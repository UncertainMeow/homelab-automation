Directory structure:
â””â”€â”€ macrimi-proxmenux/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ CHANGELOG.md
    â”œâ”€â”€ CODE_OF_CONDUCT.md
    â”œâ”€â”€ install_proxmenux.sh
    â”œâ”€â”€ LICENSE
    â”œâ”€â”€ menu
    â”œâ”€â”€ SECURITY.md
    â”œâ”€â”€ version.txt
    â”œâ”€â”€ AppImage/
    â”‚   â”œâ”€â”€ README.md
    â”‚   â”œâ”€â”€ next.config.mjs
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”œâ”€â”€ ProxMenux-Monitor.AppImage.sha256
    â”‚   â”œâ”€â”€ tailwind.config.js
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ dashboard/
    â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â””â”€â”€ hardware/
    â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ auth-setup.tsx
    â”‚   â”‚   â”œâ”€â”€ hardware-monitor.tsx
    â”‚   â”‚   â”œâ”€â”€ health-status-modal.tsx
    â”‚   â”‚   â”œâ”€â”€ login.tsx
    â”‚   â”‚   â”œâ”€â”€ metrics-dialog.tsx
    â”‚   â”‚   â”œâ”€â”€ network-card.tsx
    â”‚   â”‚   â”œâ”€â”€ network-traffic-chart.tsx
    â”‚   â”‚   â”œâ”€â”€ node-metrics-charts.tsx
    â”‚   â”‚   â”œâ”€â”€ onboarding-carousel.tsx
    â”‚   â”‚   â”œâ”€â”€ proxmox-dashboard.tsx
    â”‚   â”‚   â”œâ”€â”€ release-notes-modal.tsx
    â”‚   â”‚   â”œâ”€â”€ script-terminal-modal.tsx
    â”‚   â”‚   â”œâ”€â”€ settings.tsx
    â”‚   â”‚   â”œâ”€â”€ sidebar.tsx
    â”‚   â”‚   â”œâ”€â”€ storage-metrics.tsx
    â”‚   â”‚   â”œâ”€â”€ storage-overview.tsx
    â”‚   â”‚   â”œâ”€â”€ system-overview.tsx
    â”‚   â”‚   â”œâ”€â”€ terminal-panel.tsx
    â”‚   â”‚   â”œâ”€â”€ theme-provider.tsx
    â”‚   â”‚   â”œâ”€â”€ theme-toggle.tsx
    â”‚   â”‚   â”œâ”€â”€ two-factor-setup.tsx
    â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚       â”œâ”€â”€ badge.tsx
    â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚       â”œâ”€â”€ checkbox.tsx
    â”‚   â”‚       â”œâ”€â”€ dialog.tsx
    â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚       â”œâ”€â”€ label.tsx
    â”‚   â”‚       â”œâ”€â”€ progress.tsx
    â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚       â”œâ”€â”€ sheet.tsx
    â”‚   â”‚       â””â”€â”€ tabs.tsx
    â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â””â”€â”€ use-mobile.tsx
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â”œâ”€â”€ api-config.ts
    â”‚   â”‚   â”œâ”€â”€ format-network.ts
    â”‚   â”‚   â”œâ”€â”€ script-executor.ts
    â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â”œâ”€â”€ public/
    â”‚   â”‚   â”œâ”€â”€ manifest.json
    â”‚   â”‚   â””â”€â”€ images/
    â”‚   â”‚       â””â”€â”€ onboarding/
    â”‚   â”‚           â””â”€â”€ README.md
    â”‚   â”œâ”€â”€ scripts/
    â”‚   â”‚   â”œâ”€â”€ AppRun
    â”‚   â”‚   â”œâ”€â”€ auth_manager.py
    â”‚   â”‚   â”œâ”€â”€ build_appimage.sh
    â”‚   â”‚   â”œâ”€â”€ flask_auth_routes.py
    â”‚   â”‚   â”œâ”€â”€ flask_health_routes.py
    â”‚   â”‚   â”œâ”€â”€ flask_proxmenux_routes.py
    â”‚   â”‚   â”œâ”€â”€ flask_script_runner.py
    â”‚   â”‚   â”œâ”€â”€ flask_terminal_routes.py
    â”‚   â”‚   â”œâ”€â”€ hardware_monitor.py
    â”‚   â”‚   â”œâ”€â”€ health_persistence.py
    â”‚   â”‚   â”œâ”€â”€ jwt_middleware.py
    â”‚   â”‚   â””â”€â”€ proxmox_storage_monitor.py
    â”‚   â””â”€â”€ types/
    â”‚       â””â”€â”€ hardware.ts
    â”œâ”€â”€ assets/
    â”‚   â””â”€â”€ base-packages.txt
    â”œâ”€â”€ docs/
    â”‚   â”œâ”€â”€ 01.PROXMENUX_REVIEW.md
    â”‚   â””â”€â”€ 02.GUIA_MODIFICACION_OFFLINE.md
    â”œâ”€â”€ guides/
    â”‚   â”œâ”€â”€ backup_cloud.md
    â”‚   â”œâ”€â”€ Kodi_LXC.md
    â”‚   â”œâ”€â”€ lxc_samba.md
    â”‚   â”œâ”€â”€ nvidia.md
    â”‚   â””â”€â”€ nvidia/
    â”‚       â””â”€â”€ nvidia-docker.sh
    â”œâ”€â”€ images/
    â”‚   â””â”€â”€ logos_txt/
    â”‚       â”œâ”€â”€ Helper_Scripts.txt
    â”‚       â”œâ”€â”€ home_labsclub.txt
    â”‚       â”œâ”€â”€ logo.txt
    â”‚       â”œâ”€â”€ ProxMenux.txt
    â”‚       â””â”€â”€ proxmology.txt
    â”œâ”€â”€ lang/
    â”‚   â”œâ”€â”€ cache.json
    â”‚   â”œâ”€â”€ en.lang
    â”‚   â””â”€â”€ es.lang
    â”œâ”€â”€ scripts/
    â”‚   â”œâ”€â”€ auto_post_install.sh
    â”‚   â”œâ”€â”€ configure_igpu_lxc.sh
    â”‚   â”œâ”€â”€ disk-passthrough.sh
    â”‚   â”œâ”€â”€ disk-passthrough_ct.sh
    â”‚   â”œâ”€â”€ emergency_repair.sh
    â”‚   â”œâ”€â”€ help_info_menu.sh
    â”‚   â”œâ”€â”€ import-disk-image.sh
    â”‚   â”œâ”€â”€ install_coral_lxc.sh
    â”‚   â”œâ”€â”€ install_coral_pve.sh
    â”‚   â”œâ”€â”€ repair_network.sh
    â”‚   â”œâ”€â”€ utils.sh
    â”‚   â”œâ”€â”€ backup_restore/
    â”‚   â”‚   â”œâ”€â”€ backup_host.sh
    â”‚   â”‚   â”œâ”€â”€ backup_host2.sh
    â”‚   â”‚   â”œâ”€â”€ backup_host3.sh
    â”‚   â”‚   â”œâ”€â”€ backup_host4.sh
    â”‚   â”‚   â””â”€â”€ mount_disk_host_bk.sh
    â”‚   â”œâ”€â”€ global/
    â”‚   â”‚   â”œâ”€â”€ common-functions.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve-v3.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve-v3_.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve8.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve9.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve9_.sh
    â”‚   â”‚   â”œâ”€â”€ remove-banner-pve9_2.sh
    â”‚   â”‚   â”œâ”€â”€ share-common.func
    â”‚   â”‚   â”œâ”€â”€ update-pve.sh
    â”‚   â”‚   â”œâ”€â”€ update-pve8.sh
    â”‚   â”‚   â”œâ”€â”€ update-pve9_2.sh
    â”‚   â”‚   â””â”€â”€ update-pve9_2_.sh
    â”‚   â”œâ”€â”€ gpu_tpu/
    â”‚   â”‚   â”œâ”€â”€ install_coral_pve9.sh
    â”‚   â”‚   â”œâ”€â”€ nvidia_installer.sh
    â”‚   â”‚   â””â”€â”€ nvidia_installer_.sh
    â”‚   â”œâ”€â”€ lxc/
    â”‚   â”‚   â”œâ”€â”€ jd2.sh
    â”‚   â”‚   â”œâ”€â”€ jd2_.sh
    â”‚   â”‚   â”œâ”€â”€ jd2_2.sh
    â”‚   â”‚   â”œâ”€â”€ lxc-manual-guide.sh
    â”‚   â”‚   â”œâ”€â”€ lxc-privileged-to-unprivileged.sh
    â”‚   â”‚   â””â”€â”€ lxc-unprivileged-to-privileged.sh
    â”‚   â”œâ”€â”€ menus/
    â”‚   â”‚   â”œâ”€â”€ config_menu.sh
    â”‚   â”‚   â”œâ”€â”€ create_vm_menu.sh
    â”‚   â”‚   â”œâ”€â”€ hw_grafics_menu.sh
    â”‚   â”‚   â”œâ”€â”€ lxc_menu.sh
    â”‚   â”‚   â”œâ”€â”€ main_menu.sh
    â”‚   â”‚   â”œâ”€â”€ main_menu_.sh
    â”‚   â”‚   â”œâ”€â”€ menu_Helper_Scripts.sh
    â”‚   â”‚   â”œâ”€â”€ menu_post_install.sh
    â”‚   â”‚   â”œâ”€â”€ network_menu.sh
    â”‚   â”‚   â”œâ”€â”€ share_menu.sh
    â”‚   â”‚   â”œâ”€â”€ sm.sh
    â”‚   â”‚   â”œâ”€â”€ storage_menu.sh
    â”‚   â”‚   â””â”€â”€ utilities_menu.sh
    â”‚   â”œâ”€â”€ post_install/
    â”‚   â”‚   â”œâ”€â”€ auto_post_install.sh
    â”‚   â”‚   â””â”€â”€ uninstall-tools.sh
    â”‚   â”œâ”€â”€ share/
    â”‚   â”‚   â”œâ”€â”€ commands_share.sh
    â”‚   â”‚   â”œâ”€â”€ group_manager.sh
    â”‚   â”‚   â”œâ”€â”€ guia.md
    â”‚   â”‚   â”œâ”€â”€ local-shared-manager.sh
    â”‚   â”‚   â”œâ”€â”€ lxc-mount-manager.sh
    â”‚   â”‚   â”œâ”€â”€ lxc-mount-manager_minimal.sh
    â”‚   â”‚   â”œâ”€â”€ nfs_client.sh
    â”‚   â”‚   â”œâ”€â”€ nfs_host.sh
    â”‚   â”‚   â”œâ”€â”€ nfs_lxc_server.sh
    â”‚   â”‚   â”œâ”€â”€ samba_client.sh
    â”‚   â”‚   â””â”€â”€ samba_lxc_server.sh
    â”‚   â”œâ”€â”€ storage/
    â”‚   â”‚   â”œâ”€â”€ disk-passthrough.sh
    â”‚   â”‚   â”œâ”€â”€ disk-passthrough_ct.sh
    â”‚   â”‚   â”œâ”€â”€ format-disk.sh
    â”‚   â”‚   â”œâ”€â”€ import-disk-image.sh
    â”‚   â”‚   â”œâ”€â”€ mount-disk-on-host.sh
    â”‚   â”‚   â”œâ”€â”€ mount-point-to-ct.sh
    â”‚   â”‚   â”œâ”€â”€ mount_disk_host_bk.sh
    â”‚   â”‚   â”œâ”€â”€ notes.txt
    â”‚   â”‚   â””â”€â”€ unmount-disk-from-host.sh
    â”‚   â”œâ”€â”€ test/
    â”‚   â”‚   â”œâ”€â”€ debug_disks.sh
    â”‚   â”‚   â”œâ”€â”€ debug_disks1.sh
    â”‚   â”‚   â”œâ”€â”€ helpers-menu.sh
    â”‚   â”‚   â”œâ”€â”€ id.sh
    â”‚   â”‚   â”œâ”€â”€ Iso.sh
    â”‚   â”‚   â”œâ”€â”€ repair_network_safe.sh
    â”‚   â”‚   â”œâ”€â”€ res.sh
    â”‚   â”‚   â”œâ”€â”€ res2.sh
    â”‚   â”‚   â”œâ”€â”€ res3.sh
    â”‚   â”‚   â”œâ”€â”€ t2pbs.sh
    â”‚   â”‚   â”œâ”€â”€ tpbs.sh
    â”‚   â”‚   â””â”€â”€ vm/
    â”‚   â”‚       â”œâ”€â”€ create_vm.sh
    â”‚   â”‚       â”œâ”€â”€ disk_selector.sh
    â”‚   â”‚       â”œâ”€â”€ guest_agent_config.sh
    â”‚   â”‚       â”œâ”€â”€ select_linux_iso.sh
    â”‚   â”‚       â”œâ”€â”€ select_nas_iso.sh
    â”‚   â”‚       â”œâ”€â”€ select_windows_iso.sh
    â”‚   â”‚       â”œâ”€â”€ synology4.sh
    â”‚   â”‚       â”œâ”€â”€ synology5.sh
    â”‚   â”‚       â”œâ”€â”€ uupdump_creator.sh
    â”‚   â”‚       â”œâ”€â”€ vm_configurator.sh
    â”‚   â”‚       â””â”€â”€ vm_creator.sh
    â”‚   â”œâ”€â”€ utilities/
    â”‚   â”‚   â”œâ”€â”€ proxmox-upgrade-pve8-to-pve9-manual-guide.sh
    â”‚   â”‚   â”œâ”€â”€ proxmox_update.sh
    â”‚   â”‚   â”œâ”€â”€ pve8to9_check.sh
    â”‚   â”‚   â”œâ”€â”€ system_utils.sh
    â”‚   â”‚   â”œâ”€â”€ upgrade_pve8_to_pve9.sh
    â”‚   â”‚   â””â”€â”€ uup_dump_iso_creator.sh
    â”‚   â””â”€â”€ vm/
    â”‚       â”œâ”€â”€ create_vm.sh
    â”‚       â”œâ”€â”€ disk_selector.sh
    â”‚       â”œâ”€â”€ guest_agent_config.sh
    â”‚       â”œâ”€â”€ select_linux_iso.sh
    â”‚       â”œâ”€â”€ select_nas_iso.sh
    â”‚       â”œâ”€â”€ select_windows_iso.sh
    â”‚       â”œâ”€â”€ synology.sh
    â”‚       â”œâ”€â”€ synology_.sh
    â”‚       â”œâ”€â”€ uupdump_creator.sh
    â”‚       â”œâ”€â”€ vm_configurator.sh
    â”‚       â”œâ”€â”€ vm_creator.sh
    â”‚       â”œâ”€â”€ vm_creator_.sh
    â”‚       â””â”€â”€ zimaos.sh
    â”œâ”€â”€ web/
    â”‚   â”œâ”€â”€ components.json
    â”‚   â”œâ”€â”€ next.config.mjs
    â”‚   â”œâ”€â”€ package.json
    â”‚   â”œâ”€â”€ postcss.config.mjs
    â”‚   â”œâ”€â”€ tailwind.config.js
    â”‚   â”œâ”€â”€ tsconfig.json
    â”‚   â”œâ”€â”€ app/
    â”‚   â”‚   â”œâ”€â”€ globals.css
    â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”œâ”€â”€ metadata.ts
    â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ changelog/
    â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ docs/
    â”‚   â”‚   â”‚   â”œâ”€â”€ layout.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ about/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ code-of-conduct/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ contributors/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ faq/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ create-vm/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ synology/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-linux/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-nas/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ system-nas-others/
    â”‚   â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ system-windows/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ external-repositories/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ hardware/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ coral-tpu-lxc/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ igpu-acceleration-lxc/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ install-coral-tpu-host/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ help-info/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ backup-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ gpu-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ network-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ storage-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tools-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ update-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ vm-ct-commands/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ zfs-commands/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ installation/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ introduction/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ network/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ repair-network/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ show-ip-information/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ verify-network/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ post-install/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ basic-settings/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ customization/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ monitoring/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ network/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ optional/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ performance/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ security/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ storage/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ system/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ virtualization/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ settings/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ change-language/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ show-version-information/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ uninstall-proxmenux/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ storage/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ disk-passthrough-ct/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ disk-passthrough-vm/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ import-disk-image-vm/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ utils/
    â”‚   â”‚   â”‚       â””â”€â”€ UUp-Dump-ISO-Creator/
    â”‚   â”‚   â”‚           â””â”€â”€ page.tsx
    â”‚   â”‚   â”œâ”€â”€ guides/
    â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx
    â”‚   â”‚   â”‚   â”œâ”€â”€ [slug]/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
    â”‚   â”‚   â”‚   â””â”€â”€ linux-resources/
    â”‚   â”‚   â”‚       â””â”€â”€ page.tsx
    â”‚   â”‚   â””â”€â”€ rss.xml/
    â”‚   â”‚       â””â”€â”€ route.ts
    â”‚   â”œâ”€â”€ components/
    â”‚   â”‚   â”œâ”€â”€ CopyableCode.tsx
    â”‚   â”‚   â”œâ”€â”€ DocSidebar.tsx
    â”‚   â”‚   â”œâ”€â”€ footer.tsx
    â”‚   â”‚   â”œâ”€â”€ footer2.tsx
    â”‚   â”‚   â”œâ”€â”€ hero.tsx
    â”‚   â”‚   â”œâ”€â”€ hero2.tsx
    â”‚   â”‚   â”œâ”€â”€ mouse-move-effect.tsx
    â”‚   â”‚   â”œâ”€â”€ navbar.tsx
    â”‚   â”‚   â”œâ”€â”€ resources.tsx
    â”‚   â”‚   â”œâ”€â”€ rss-link.tsx
    â”‚   â”‚   â”œâ”€â”€ support-project.tsx
    â”‚   â”‚   â”œâ”€â”€ testimonials.tsx
    â”‚   â”‚   â”œâ”€â”€ theme-provider.tsx
    â”‚   â”‚   â””â”€â”€ ui/
    â”‚   â”‚       â”œâ”€â”€ accordion.tsx
    â”‚   â”‚       â”œâ”€â”€ alert-dialog.tsx
    â”‚   â”‚       â”œâ”€â”€ alert.tsx
    â”‚   â”‚       â”œâ”€â”€ aspect-ratio.tsx
    â”‚   â”‚       â”œâ”€â”€ avatar.tsx
    â”‚   â”‚       â”œâ”€â”€ badge.tsx
    â”‚   â”‚       â”œâ”€â”€ breadcrumb.tsx
    â”‚   â”‚       â”œâ”€â”€ button.tsx
    â”‚   â”‚       â”œâ”€â”€ calendar.tsx
    â”‚   â”‚       â”œâ”€â”€ card.tsx
    â”‚   â”‚       â”œâ”€â”€ carousel.tsx
    â”‚   â”‚       â”œâ”€â”€ chart.tsx
    â”‚   â”‚       â”œâ”€â”€ checkbox.tsx
    â”‚   â”‚       â”œâ”€â”€ collapsible.tsx
    â”‚   â”‚       â”œâ”€â”€ command.tsx
    â”‚   â”‚       â”œâ”€â”€ context-menu.tsx
    â”‚   â”‚       â”œâ”€â”€ dialog.tsx
    â”‚   â”‚       â”œâ”€â”€ doc-navigation.tsx
    â”‚   â”‚       â”œâ”€â”€ drawer.tsx
    â”‚   â”‚       â”œâ”€â”€ dropdown-menu.tsx
    â”‚   â”‚       â”œâ”€â”€ form.tsx
    â”‚   â”‚       â”œâ”€â”€ hover-card.tsx
    â”‚   â”‚       â”œâ”€â”€ image-with-caption.tsx
    â”‚   â”‚       â”œâ”€â”€ input-otp.tsx
    â”‚   â”‚       â”œâ”€â”€ input.tsx
    â”‚   â”‚       â”œâ”€â”€ label.tsx
    â”‚   â”‚       â”œâ”€â”€ menubar.tsx
    â”‚   â”‚       â”œâ”€â”€ navigation-menu.tsx
    â”‚   â”‚       â”œâ”€â”€ pagination.tsx
    â”‚   â”‚       â”œâ”€â”€ popover.tsx
    â”‚   â”‚       â”œâ”€â”€ progress.tsx
    â”‚   â”‚       â”œâ”€â”€ radio-group.tsx
    â”‚   â”‚       â”œâ”€â”€ resizable.tsx
    â”‚   â”‚       â”œâ”€â”€ scroll-area.tsx
    â”‚   â”‚       â”œâ”€â”€ select.tsx
    â”‚   â”‚       â”œâ”€â”€ separator.tsx
    â”‚   â”‚       â”œâ”€â”€ sheet.tsx
    â”‚   â”‚       â”œâ”€â”€ sidebar.tsx
    â”‚   â”‚       â”œâ”€â”€ skeleton.tsx
    â”‚   â”‚       â”œâ”€â”€ slider.tsx
    â”‚   â”‚       â”œâ”€â”€ sonner.tsx
    â”‚   â”‚       â”œâ”€â”€ steps.tsx
    â”‚   â”‚       â”œâ”€â”€ switch.tsx
    â”‚   â”‚       â”œâ”€â”€ table.tsx
    â”‚   â”‚       â”œâ”€â”€ tabs.tsx
    â”‚   â”‚       â”œâ”€â”€ textarea.tsx
    â”‚   â”‚       â”œâ”€â”€ toast.tsx
    â”‚   â”‚       â”œâ”€â”€ toaster.tsx
    â”‚   â”‚       â”œâ”€â”€ toggle-group.tsx
    â”‚   â”‚       â”œâ”€â”€ toggle.tsx
    â”‚   â”‚       â”œâ”€â”€ tooltip.tsx
    â”‚   â”‚       â”œâ”€â”€ use-mobile.tsx
    â”‚   â”‚       â””â”€â”€ use-toast.ts
    â”‚   â”œâ”€â”€ hooks/
    â”‚   â”‚   â”œâ”€â”€ use-mobile.tsx
    â”‚   â”‚   â””â”€â”€ use-toast.ts
    â”‚   â”œâ”€â”€ lib/
    â”‚   â”‚   â””â”€â”€ utils.ts
    â”‚   â””â”€â”€ styles/
    â”‚       â””â”€â”€ globals.css
    â””â”€â”€ .github/
        â”œâ”€â”€ ISSUE_TEMPLATE/
        â”‚   â”œâ”€â”€ bug_report.md
        â”‚   â”œâ”€â”€ config.yml
        â”‚   â””â”€â”€ feature_request.md
        â”œâ”€â”€ scripts/
        â”‚   â”œâ”€â”€ generate_helpers_cache.py
        â”‚   â””â”€â”€ generate_helpers_cache_.py
        â””â”€â”€ workflows/
            â”œâ”€â”€ build-appimage-manual.yml
            â”œâ”€â”€ build-appimage.yml
            â”œâ”€â”€ deploy.yml
            â””â”€â”€ update-helpers-cache.yml


Files Content:

================================================
FILE: README.md
================================================
<div align="center">
    <img src="https://github.com/MacRimi/ProxMenux/blob/main/images/main.png" 
         alt="ProxMenux Logo" 
         style="max-width: 100%; height: auto;" >
        
</div>

<br />

<div align="center" style="margin-top: 20px;">
    <a href="https://macrimi.github.io/ProxMenux/" target="_blank">
        <img src="https://img.shields.io/badge/Website-%23E64804?style=for-the-badge&logo=World-Wide-Web&logoColor=white" alt="Website" />
    </a>
    <a href="https://macrimi.github.io/ProxMenux/docs/introduction" target="_blank">
        <img src="https://img.shields.io/badge/Docs-%232A3A5D?style=for-the-badge&logo=read-the-docs&logoColor=white" alt="Docs" />
    </a>
    <a href="https://macrimi.github.io/ProxMenux/changelog" target="_blank">
        <img src="https://img.shields.io/badge/Changelog-%232A3A5D?style=for-the-badge&logo=git&logoColor=white" alt="Changelog" />
    </a>
    <a href="https://macrimi.github.io/ProxMenux/guides" target="_blank">
        <img src="https://img.shields.io/badge/Guides-%232A3A5D?style=for-the-badge&logo=bookstack&logoColor=white" alt="Guides" />
    </a>
</div>


<br />


**ProxMenux** is a management tool for **Proxmox VE** that simplifies system administration through an interactive menu, allowing you to execute commands and scripts with ease.

---

## ğŸ“Œ Installation
To install ProxMenux, simply run the following command in your Proxmox server terminal:

```bash
bash -c "$(wget -qLO - https://raw.githubusercontent.com/MacRimi/ProxMenux/main/install_proxmenux.sh)"
```

<br>

âš ï¸ Be careful when copying scripts from the internet. Always remember to check the source!

ğŸ“„ You can [review the source code](https://github.com/MacRimi/ProxMenux/blob/main/install_proxmenux.sh) before execution.

ğŸ›¡ï¸ All executable links follow our [Code of Conduct](https://github.com/MacRimi/ProxMenux?tab=coc-ov-file#-2-security--code-responsibility).

---

## ğŸ“Œ How to Use
Once installed, launch **ProxMenux** by running:

```bash
menu
```
Then, follow the on-screen options to manage your Proxmox server efficiently.

---

## ğŸ“Œ System Requirements
ğŸ–¥ **Compatible with:**
- Proxmox VE 8.x and 9.x

ğŸ“¦ **Dependencies:**
- `bash`, `curl`, `wget`, `jq`, `whiptail`, `python3-venv` (These dependencies are installed automatically during setup.)
- **Translations are handled in a Python virtual environment using `googletrans-env`.**

---

## â­ Support the Project!
If you find **ProxMenux** useful, consider giving it a â­ on GitHub to help others discover it!


## Star History

[![Star History Chart](https://api.star-history.com/svg?repos=MacRimi/ProxMenux&type=Date)](https://www.star-history.com/#MacRimi/ProxMenux&Date)


<div style="display: flex; justify-content: center; align-items: center;">
  <a href="https://ko-fi.com/G2G313ECAN" target="_blank" style="display: flex; align-items: center; text-decoration: none;">
    <img src="https://raw.githubusercontent.com/MacRimi/HWEncoderX/main/images/kofi.png" alt="Support me on Ko-fi" style="width:140px; margin-right:40px;"/>
  </a>
</div>

Support the project on Ko-fi!

## Contributors
<a href="https://github.com/MacRimi/ProxMenux/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=MacRimi/ProxMenux" />
</a>

[contrib.rocks](https://contrib.rocks).




================================================
FILE: CHANGELOG.md
================================================
## 2025-09-18

### New version v1.1.8 â€” *ProxMenux Offline Mode*

![ProxMenux Offline](https://macrimi.github.io/ProxMenux/ProxMenux_offline.png)

---

### Added

- **Offline Execution Mode (no GitHub dependency)**  
  All ProxMenux core scripts now run **entirely locally**, without requiring live requests to GitHub (`raw.githubusercontent.com`).  
  This change provides:
  - Greater stability during execution
  - No interruptions due to network timeouts or regional GitHub blocks
  - Support for **offline or isolated environments**

  âš ï¸ This update resolves recent issues where users in certain regions were unable to run scripts due to CDN or TLS filtering errors while downloading `.sh` files from GitHub raw URLs.

  **ğŸ– Special Acknowledgment: @cod378**  
  This offline conversion has been made possible thanks to the extraordinary work of **@cod378**,  
  who redesigned the entire internal logic of the installer and updater, refactored the file management system,  
  and implemented the new fully local execution workflow.  
  Without his collaboration, dedication, and technical contribution, this transformation would not have been possible.

- **ProxMenux Monitor v1.0.1**  
  This update brings a major leap in the **ProxMenux Monitor** interface.  
  New features and improvements:
  - `Proxy Support`: Access ProxMenux through reverse proxies with full functionality
  - `Authentication System`: Secure your dashboard with password protection
  - `Two-Factor Authentication (2FA)`: Optional TOTP support for enhanced security
  - `PCIe Link Speed Detection`: View NVMe connection speeds and detect performance bottlenecks
  - `Enhanced Storage Display`: Auto-formats disk sizes (GB â†’ TB when appropriate)
  - `SATA/SAS Interface Info`: Detect and show storage type (SATA, SAS, NVMe, etc.)
  - `Health Monitoring System`: Built-in system health check with dismissible alerts
  - Improved rendering across browsers and better performance

- **Helper Scripts Menu (Mirror Support)**  
  The `Helper Scripts` menu now:
  - Detects **mirror URLs** and shows alternative download options when available
  - Lists available OS versions when a helper script is version-dependent (e.g. template installers)

---

### Fixed

- Minor fixes and refinements throughout the codebase to ensure full offline compatibility and a smoother user experience.



## 2025-09-04

### New version v1.1.7

### Added

- **ProxMenux Monitor**  
  Your new monitoring tool for Proxmox. Discover all the features that will help you manage and supervise your infrastructure efficiently.

  ProxMenux Monitor is designed to support future updates where **actions can be triggered without using the terminal**, and managed through a **user-friendly interface** accessible across multiple formats and devices.

  Access it at: **http://your-server-ip:8008**

  ![ProxMenux Monitor](https://macrimi.github.io/ProxMenux/monitor/welcome.png)
- **New Banner Removal Method**  
  A new function to disable the Proxmox subscription message with improved safety:
  - Creates a full backup before modifying any files
  - Shows a clear warning that breaking changes may occur with future GUI updates
  - If the GUI fails to load, the user can revert changes via SSH from the post-install menu using the **"Uninstall Options â†’ Restore Banner"** tool

  Special thanks to **@eryonki** for providing the improved method.

---

### Improved

- **CORAL TPU Installer Updated for PVE 9**  
  The CORAL TPU driver installer now supports both **Proxmox VE 8 and VE 9**, ensuring compatibility with the latest kernels and udev rules.

- **Log2RAM Installation & Integration**  
  - Log2RAM installation is now idempotent and can be safely run multiple times.
  - Automatically adjusts `journald` configuration to align with the size and behavior of Log2RAM.
  - Ensures journaling is correctly tuned to avoid overflows or RAM exhaustion on low-memory systems.

- **Network Optimization Function (LXC + NFS)**  
  Improved to prevent â€œmartian sourceâ€ warnings in setups where **LXC containers share storage with VMs** over NFS within the same server.

- **APT Upgrade Progress**  
  When running full system upgrades via ProxMenux, a **real-time progress bar** is now displayed, giving the user clear visibility into the update process.

---

### Fixed

- Other small improvements and fixes to optimize runtime performance and eliminate minor bugs.



## 2025-01-10

### New version v1.1.6

![Shared Resources Menu](https://macrimi.github.io/ProxMenux/share/main-menu.png)


### Added

- **New Menu: Mount and Share Manager**  
  Introduced a comprehensive new menu for managing shared resources between Proxmox host and LXC containers:

  **Host Configuration Options:**
  - **Configure NFS Shared on Host** - Add, view, and remove NFS shared resources on the Proxmox server with automatic export management
  - **Configure Samba Shared on Host** - Add, view, and remove Samba/CIFS shared resources on the Proxmox server with share configuration  
  - **Configure Local Shared on Host** - Create and manage local shared directories with proper permissions on the Proxmox host

  **LXC Integration Options:**
  - **Configure LXC Mount Points (Host â†” Container)** - **Core feature** that enables mounting host directories into LXC containers with automatic permission handling. Includes the ability to **view existing mount points** for each container in a clear, organized way and **remove mount points** with proper verification that the process completed successfully. Especially optimized for **unprivileged containers** where UID/GID mapping is critical.
  - **Configure NFS Client in LXC** - Set up NFS client inside privileged containers
  - **Configure Samba Client in LXC** - Set up Samba client inside privileged containers  
  - **Configure NFS Server in LXC** - Install NFS server inside privileged containers
  - **Configure Samba Server in LXC** - Install Samba server inside privileged containers

  **Documentation & Support:**
  - **Help & Info (commands)** - Comprehensive guides with step-by-step manual instructions for all sharing scenarios

  The entire system is built around the **LXC Mount Points** functionality, which automatically detects filesystem types, handles permission mapping between host and container users, and provides seamless integration for both privileged and unprivileged containers.

---

### Improved

- **Log2RAM Auto-Detection Enhancement**  
  In the automatic post-install script, the Log2RAM installation function now prompts the user when automatic disk ssd/m2 detection fails.
  This ensures Log2RAM can still be installed on systems where automatic disk detection doesn't work properly.

---

### Fixed

- **Proxmox Update Repository Verification**  
  Fixed an issue in the Proxmox update function where empty repository source files would cause errors during conflict verification. The function now properly handles empty `/etc/apt/sources.list.d/` files without throwing false warnings.

  Thanks to **@JF_Car** for reporting this issue.

---

### Acknowledgments

Special thanks to **@JF_Car**, **@ghosthvj**, and **@jonatanc** for their testing, valuable feedback, and suggestions that helped refine the shared resources functionality and improve the overall user experience.



## 2025-08-20

### New version v1.1.5

### Added

- **New Script: Upgrade PVE 8 to PVE 9**  
  Added a full upgrade tool located under `Utilities and Tools`. It provides:
  1. **Automatic upgrade** from PVE 8 to 9
  2. **Interactive upgrade** with step-by-step confirmations
  3. **Check-only mode** using `check-pve8to9`
  4. **Manual instructions** shown in order for users who prefer to upgrade manually

- **New Tools in System Utilities**
  - [`s-tui`](https://github.com/amanusk/s-tui): Terminal-based CPU monitoring with graphs
  - [`intel-gpu-tools`](https://gitlab.freedesktop.org/drm/igt-gpu-tools): Useful for Intel GPU diagnostics

---

### Improved

- **APT Upgrade Handling**  
  The PVE upgrade function now blocks the process if any package prompts for manual confirmation. This avoids partial upgrades and ensures consistency.

- **Network Optimization (sysctl)**  
  - Obsolete kernel parameters removed (e.g., `tcp_tw_recycle`, `nf_conntrack_helper`) to prevent warnings in **Proxmox 9 / kernel 6.14**
  - Now generates only valid, up-to-date sysctl parameters

- **AMD CPU Patch Handling**  
  - Now applies correct `idle=nomwait` and KVM options (`ignore_msrs=1`, `report_ignored_msrs=0`)
  - Expected warning is now documented and safely handled for stability with Ryzen/EPYC

- **Timezone & NTP Fixes**  
  - Automatically detects timezone using public IP geolocation
  - Falls back to UTC if detection fails
  - Restarts Postfix after timezone set â†’ resolves `/var/spool/postfix/etc/localtime` mismatch warning

- **Repository & Package Installer Logic**  
  - Now verifies that working repositories exist before installing any package
  - If none are available, adds a fallback **Debian stable** repository
  - Replaces deprecated `mlocate` with `plocate` (compatible with Debian 13 and Proxmox 9)

- **Improved Logs and User Feedback**  
  - Actions that fail now provide precise messages (instead of falsely marking as success)
  - Helps users clearly understand what's been applied or skipped



## 2025-08-06

### New version v1.1.4

### Added

- **Proxmox 9 Compatibility Preparation**  
  This version prepares **ProxMenux** for the upcoming **Proxmox VE 9**:
  - The function to add the official Proxmox repositories now supports the new `.sources` format used in Proxmox 9, while maintaining backward compatibility with Proxmox 8.
  - Banner removal is now optionally supported for Proxmox 9.

- **xshok-proxmox Detection**  
  Added a check to detect if the `xshok-proxmox` post-install script has already been executed.  
  If detected, a warning is shown to avoid conflicting adjustments:

  ```
  It appears that you have already executed the xshok-proxmox post-install script on this system.

  If you continue, some adjustments may be duplicated or conflict with those already made by xshok.

  Do you want to continue anyway?
  ```

---

### Improved

- **Banner Removal (Proxmox 8.4.9+)**  
  Updated the logic for removing the subscription banner in **Proxmox 8.4.9**, due to changes in `proxmoxlib.js`.

- **LXC Disk Passthrough (Persistent UUID)**  
  The function to add a physical disk to an LXC container now uses **UUID-based persistent paths**.  
  This ensures that disks remain correctly mounted, even if the `/dev/sdX` order changes due to new hardware.

  ```bash
  PERSISTENT_DISK=$(get_persistent_path "$DISK")
  if [[ "$PERSISTENT_DISK" != "$DISK" ]] ...
  ```

- **System Utilities Installer**  
  Now checks whether APT sources are available before installing selected tools.  
  If a new Proxmox installation has no active repos, it will **automatically add the default sources** to avoid installation failure.

- **IOMMU Activation on ZFS Systems**  
  The function that enables IOMMU for passthrough now verifies existing kernel parameters to avoid duplication if the user has already configured them manually.

---

### Fixed

- Minor code cleanup and improved runtime performance across several modules.



## 2025-07-20

### Changed

- **Subscription Banner Removal (Proxmox 8.4.5+)**  
  Improved the `remove_subscription_banner` function to ensure compatibility with Proxmox 8.4.5, where the banner removal method was failing after clean installations.

- **Improved Log2RAM Detection**  
  In both the automatic and customizable post-install scripts, the logic for Log2RAM installation has been improved.  
  Now it correctly detects if Log2RAM is already configured and avoids triggering errors or reconfiguration.

- **Optimized Figurine Installation**  
  The `install_figurine` function now avoids duplicating `.bashrc` entries if the customization for the root prompt already exists.


### Added

- **New Function: Persistent Network Interface Naming**  
  Added a new function `setup_persistent_network` to create stable network interface names using `.link` files based on MAC addresses.  
  This avoids unpredictable renaming (e.g., `enp2s0` becoming `enp3s0`) when hardware changes, PCI topology shifts, or passthrough configurations are applied.

  **Why use `.link` files?**  
  Because predictable interface names in `systemd` can change with hardware reordering or replacement. Using static `.link` files bound to MAC addresses ensures consistency, especially on systems with multiple NICs or passthrough setups.

  Special thanks to [@Andres_Eduardo_Rojas_Moya] for contributing the persistent  
  network naming function and for the original idea.

```bash
[Match]
MACAddress=XX:XX:XX:XX:XX:XX

[Link]
Name=eth0
```


## 2025-07-01

### New version v1.1.3

![Installer Menu](https://macrimi.github.io/ProxMenux/install/install.png)

- **Dual Installation Modes for ProxMenux**  
  The installer now offers two distinct modes:  
  1. **Lite version (no translations):** Only installs two official Debian packages (`dialog`, `jq`) to enable menus and JSON parsing. No files are written beyond the configuration directory.  
  2. **Full version (with translations):** Uses a virtual environment and allows selecting the interface language during installation.  

  When updating, if the user switches from full to lite, the old version will be **automatically removed** for a clean transition.

### Added

- **New Script: Automated Post-Installation Setup**  
  A new minimal post-install script that performs essential setup automatically:  
  - System upgrade and sync  
  - Remove enterprise banner  
  - Optimize APT, journald, logrotate, system limits  
  - Improve kernel panic handling, memory settings, entropy, network  
  - Add `.bashrc` tweaks and **Log2RAM auto-install** (if SSD/M.2 is detected)

- **New Function: Log2RAM Configuration**  
  Now available in both the customizable and automatic post-install scripts.  
  On systems with SSD/NVMe, Log2RAM is **enabled automatically** to preserve disk life.

- **New Menus:**
  - ğŸ§° **System Utilities Menu**  
    Lets users select and install useful CLI tools with proper command validation.
  - ğŸŒ **Network Configuration & Repair**  
    A new interactive menu for analyzing and repairing network interfaces.

### Improved

- **Post-Install Menu Logic**  
  Options are now grouped more logically for better usability.

- **VM Creation Menu**  
  Enhanced with improved CPU model support and custom options.

- **UUP Dump ISO Creator Script**  
  - Added option to **customize the temporary folder location**  
  - Fixed issue where entire temp folder was deleted instead of just contents  
    ğŸ’¡ Suggested by [@igrokit](https://github.com/igrokit)  
    [#17](https://github.com/MacRimi/ProxMenux/issues/17), [#11](https://github.com/MacRimi/ProxMenux/issues/11)

- **Physical Disk to LXC Script**  
  Now handles **XFS-formatted disks** correctly.  
  Thanks to [@antroxin](https://github.com/antroxin) for reporting and testing!

- **System Utilities Installer**  
  Rewritten to **verify command availability** after installation, ensuring tools work as expected.  
  ğŸ› Fix for [#18](https://github.com/MacRimi/ProxMenux/issues/18) by [@DST73](https://github.com/DST73)

### Fixed

- **Enable IOMMU on ZFS**  
  The detection and configuration for enabling IOMMU on ZFS-based systems is now fully functional.  
  ğŸ› Fix for [#15](https://github.com/MacRimi/ProxMenux/issues/15) by [@troponaut](https://github.com/troponaut)

### Other

- Performance and code cleanup improvements across several modules.



## 2025-06-06

### Added

- **New Menu: Proxmox PVE Helper Scripts**  
  Officially introduced the new **Proxmox PVE Helper Scripts** menu, replacing the previous: Esenciales Proxmox.  
  This new menu includes:
  - Script search by name in real time
  - Category-based browsing

  Itâ€™s a cleaner, faster, and more functional way to access community scripts in Proxmox.

  ![Helper Scripts Menu](https://macrimi.github.io/ProxMenux/menu-helpers-script.png)


- **New CPU Models in VM Creation**  
  The CPU selection menu in VM creation has been greatly expanded to support advanced QEMU and x86-64 CPU profiles.  
  This allows better compatibility with modern guest systems and fine-tuning performance for specific workloads, including nested virtualization and hardware-assisted features.


  ![CPU Config](https://macrimi.github.io/ProxMenux/vm/config-cpu.png)

  Thanks to **@Nida LÃ©gÃ© (Nidouille)** for suggesting this enhancement.


- **Support for `.raw` Disk Images**  
  The disk import tool for VMs now supports `.raw` files, in addition to `.img`, `.qcow2`, and `.vmdk`.  
  This improves compatibility when working with disk exports from other hypervisors or backup tools.

  ğŸ’¡ Suggested by **@guilloking** in [GitHub Issue #5](https://github.com/MacRimi/ProxMenux/issues/5)


- **Locale Detection in Language Skipping**  
  The function that disables extra APT languages now includes:
  - Automatic locale detection (`LANG`)
  - Auto-generation of `en_US.UTF-8` if none is found
  - Prevents warnings during script execution due to undefined locale


### Improved

- **APT Language Skipping Logic**  
  Improved locale handling ensures system compatibility before disabling translations:
  ```bash
  if ! locale -a | grep -qi "^${default_locale//-/_}$"; then
      echo "$default_locale UTF-8" >> /etc/locale.gen
      locale-gen "$default_locale"
  fi
  ```

- **System Update Speed**  
  Post-install system upgrades are now faster:  
  - The upgrade process (`dist-upgrade`) is separated from container template index updates.
  - Index refresh is now an optional feature selected in the script.



## 2025-05-27

### Fixed
- **Kali Linux ISO URL Updated**  
  Fixed the incorrect download URL for Kali Linux ISO in the Linux installer module. The new correct path is:  
  ```
  https://cdimage.kali.org/kali-2025.1c/kali-linux-2025.1c-installer-amd64.iso
  ```

### Improved
- **Faster Dialog Menu Transitions**  
  Improved UI responsiveness across all interactive menus by replacing `whiptail` with `dialog`, offering faster transitions and smoother navigation.

- **Coral USB Support in LXC**  
  Improved the logic for configuring Coral USB TPU passthrough into LXC containers:
  - Refactored configuration into modular blocks with better structure and inline comments.
  - Clear separation of Coral USB (`/dev/coral`) and Coral M.2 (`/dev/apex_0`) logic.
  - Maintains backward compatibility with existing LXC configurations.
  - Introduced persistent Coral USB passthrough using a udev rule:
    ```bash
    # Create udev rule for Coral USB
    SUBSYSTEM=="usb", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="9302", MODE="0666", TAG+="uaccess", SYMLINK+="coral"
    
    # Map /dev/coral if it exists
    if [ -e /dev/coral ]; then
        echo "lxc.mount.entry: /dev/coral dev/coral none bind,optional,create=file" >> "$CONFIG_FILE"
    fi
    ```
  - Special thanks to **@Blaspt** for validating the persistent Coral USB passthrough and suggesting the use of `/dev/coral` symbolic link.


### Added
- **Persistent Coral USB Passthrough Support**  
  Added udev rule support for Coral USB devices to persistently map them as `/dev/coral`, enabling consistent passthrough across reboots. This path is automatically detected and mapped in the container configuration.

- **RSS Feed Integration**  
  Added support for generating an RSS feed for the changelog, allowing users to stay informed of updates through news clients.

- **Release Service Automation**  
  Implemented a new release management service to automate publishing and tagging of versions, starting with version **v1.1.2**.


## 2025-05-13

### Fixed

- **Startup Fix on Newer Proxmox Versions**\
  Fixed an issue where some recent Proxmox installations lacked the `/usr/local/bin` directory, causing errors when installing the execution menu. The script now creates the directory if it does not exist before downloading the main menu.\
  Thanks to **@danielmateos** for detecting and reporting this issue.

### Improved

- **Updated Lynis Installation Logic in Post-Install Settings**\
  The `install_lynis()` function was improved to always install the **latest version** of Lynis by cloning the official GitHub repository:
  ```
  https://github.com/CISOfy/lynis.git
  ```
  The installation process now ensures the latest version is always fetched and linked properly within the system path.

  Thanks to **@Kamunhas** for reporting this enhancement opportunity.

- **Balanced Memory Optimization for Low-Memory Systems**  
  Improved the default memory settings to better support systems with limited RAM. The previous configuration could prevent low-spec servers from booting. Now, a more balanced set of kernel parameters is used, and memory compaction is enabled if supported by the system.

  ```bash
  cat <<EOF | sudo tee /etc/sysctl.d/99-memory.conf
  # Balanced Memory Optimization
  vm.swappiness = 10
  vm.dirty_ratio = 15
  vm.dirty_background_ratio = 5
  vm.overcommit_memory = 1
  vm.max_map_count = 65530
  EOF

  # Enable memory compaction if supported by the system
  if [ -f /proc/sys/vm/compaction_proactiveness ]; then
    echo "vm.compaction_proactiveness = 20" | sudo tee -a /etc/sysctl.d/99-memory.conf
  fi

  # Apply settings
  sudo sysctl -p /etc/sysctl.d/99-memory.conf
  ```

  These values help maintain responsiveness and system stability even under constrained memory conditions.

  Thanks to **@chesspeto** for pointing out this issue and helping refine the optimization.


## 2025-05-04

### Added
- **Interactive Help & Info Menu**  
  Added a new script called `Help and Info`, which provides an interactive command reference menu for Proxmox VE through a dialog-based interface.  
  This tool offers users a quick way to browse and copy useful commands for managing and maintaining their Proxmox server, all in one centralized location.

  ![Help and Info Menu](https://macrimi.github.io/ProxMenux/help/help-info-menu.png)

  *Figure 1: Help and Info interactive command reference menu.*

- **Uninstaller for Post-Install Utilities**  
  A new script has been added to the **Post-Installation** menu, allowing users to uninstall utilities or packages that were previously installed through the post-install script.

### Improved
- **Utility Selection Menu in Post-Installation Script**  
  The `Install Common System Utilities` section now includes a menu where users can choose which utilities to install, instead of installing all by default. This gives more control over what gets added to the system.

- **Old PV Header Detection and Auto-Fix**  
  After updating the system, the post-update script now includes a security check for physical disks with outdated LVM PV (Physical Volume) headers.  
  This issue can occur when virtual machines have passthrough access to disks and unintentionally modify volume metadata. The script now detects and automatically updates these headers.  
  If any error occurs during the process, a warning is shown to the user.

- **Faster Translations in Menus**  
  Several post-installation menus with auto-translations have been optimized to reduce loading times and improve user experience.


## 2025-04-14

### Added
- **New Script: Disk Passthrough to a CT**
Introduced a new script that enables assigning a dedicated physical disk to a container (CT) in Proxmox VE.
This utility lists available physical disks (excluding system and mounted disks), allows the user to select a container and one disk, and then formats or reuses the disk before mounting it inside the CT at a specified path.
It supports detection of existing filesystems and ensures permissions are properly configured. Ideal for use cases such as Samba, Nextcloud, or video surveillance containers.

### Improved  
- Visual Identification of Disks for Passthrough to VMs
Enhanced the disk detection logic in the Disk Passthrough to a VM script by including visual indicators and metadata.
Disks now display tags like âš  In use, âš  RAID, âš  LVM, or âš  ZFS, making it easier to recognize their current status at a glance. This helps prevent selection mistakes and improves clarity for the user.

## 2025-03-24  
### Improved  
- Improved the logic for detecting physical disks in the **Disk Passthrough to a VM** script. Previously, the script would display disks that were already mounted in the system on some setups. This update ensures that only unmounted disks are shown in Proxmox, preventing confusion and potential conflicts.  

- This improvement ensures that disks already mounted or assigned to other VMs are excluded from the list of available disks, providing a more accurate and reliable selection process.

## [1.1.1] - 2025-03-21
### Improved
- Improved the logic of the post-install script to prevent overwriting or adding duplicate settings if similar settings are already configured by the user.
- Added a warning note to the documentation explaining that using different post-installation scripts is not recommended to avoid conflicts and duplicated settings.

### Added
- **Create Synology DSM VM**:  
  A new script that creates a VM to install Synology DSM. The script automates the process of downloading three different loaders with the option to use a custom loader provided by the user from the local storage options.  
  Additionally, it allows the use of both virtual and physical disks, which are automatically assigned by the script.  

  ![VM description](https://macrimi.github.io/ProxMenux/vm/synology/dsm_desc.png)
  
  *Figure 1: Synology DSM VM setup overview.*

- **New VM Creation Menu**:  
  A new menu has been created to enable VM creation from templates or custom scripts.

- **Main Menu Update**:  
  Added a new entry to the main menu for accessing the VM creation menu from templates or scripts.

## 2025-03-06
### Added
- Completed the web documentation section to expand information on updated scripts.

## [1.1.0] - 2025-03-04
### Added
- Created a customizable post-install script for Proxmox with 10 sections and 35 different selectable options.

## [1.0.7] - 2025-02-17
### Added
- Created a menu with essential scripts from the Proxmox VE Helper-Scripts community.

## [1.0.6] - 2025-02-10
### Added
- Added real-time translation support using Google Translate.
- Modified existing scripts to support multiple languages.
- Updated installation script to install and configure:
  - `jq` (for handling JSON data)
  - Python 3 and virtual environment (required for translations)
  - Google Translate (`googletrans`) (for multi-language support)
- Introduced support for the following languages:
  - English
  - Spanish
  - French
  - German
  - Italian
  - Portuguese
- Created a utility script for auxiliary functions that support the execution of menus and scripts.

## [1.0.5] - 2025-01-31
### Added
- Added the **Repair Network** script, which includes:
  - Verify Network
  - Show IP Information
- Created the **Network Menu** to manage network-related functions.

## [1.0.4] - 2025-01-20
### Added
- Created a script to add a passthrough disk to a VM.
- Created the **Storage Menu** to manage storage-related functions.

## [1.0.3] - 2025-01-13
### Added
- Created a script to import disk images into a VM.

## [1.0.2] - 2025-01-09
### Modified
- Updated the **Coral TPU configuration script** to:
  - Also include Intel iGPU setup.
  - Install GPU drivers for video surveillance applications to support VAAPI and QuickSync.
- Added a function to **uninstall ProxMenux**.

## [1.0.1] - 2025-01-03
### Added
- Created a script to add **Coral TPU support in an LXC** for use in video surveillance programs.

## [1.0.0] - 2024-12-18
### Added
- Initial release of **ProxMenux**.
- Created a script to add **Coral TPU drivers** to Proxmox.



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# ğŸ“ Code of Conduct & Best Practices

This document defines the **principles and guidelines** for the use of **ProxMenux**, aiming to foster **respect, collaboration, and security** in development.

## ğŸ“Œ 1. Code Attribution & Recognition

- If **scripts, code snippets, or ideas** from other repositories or developers are used, the original author will always be credited.  
- A comment will be added in the code or documentation mentioning the source and linking to the original repository if possible.  
- When using code with a specific **license**, its terms must be respected.  

### âœ… Example of proper attribution in code:

```bash
# Script based on the work of [Author] at [Repository Link]
```

## ğŸ”’ 2. Security & Code Responsibility

- All code in this repository follows secure development best practices.
- Contributions introducing intentional vulnerabilities or unsafe practices are not allowed.
- Scripts should never compromise system security or user data.
- Before implementation, contributions should be reviewed to ensure security and stability.

### âš ï¸ Responsible Disclosure of Vulnerabilities

If you discover a security vulnerability, DO NOT report it in public Issues or forums.

Instead, please report it privately via email:

ğŸ“§ proxmenux@macrimi.pro

For detailed information on security vulnerabilities and how to report them, please refer to our [Security Policy](./SECURITY.md).

## ğŸ¤ 3. Community Guidelines

To maintain a respectful and professional environment, all users must follow these guidelines:

- âœ… Be respectful and constructive in discussions.
- âŒ No harassment, hate speech, or offensive behavior will be tolerated.
- âœ… Provide feedback professionally, avoiding personal attacks.
- âŒ Violating these guidelines may result in warnings or bans, depending on severity.


##

With this document, we promote ethical code use, security awareness, and a respectful community.

ğŸ“¢ Let's build something great, together!




================================================
FILE: install_proxmenux.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven toolkit for Proxmox VE management
# ==========================================================
# Author       : MacRimi
# Contributors : cod378
# Subproject   : ProxMenux Monitor (System Health & Web Dashboard)
# Copyright    : (c) 2024-2025 MacRimi
# License      : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version      : 1.4
# Last Updated : 12/11/2025
# ==========================================================
# Description:
# This script installs and configures ProxMenux, a menu-driven
# toolkit for managing and optimizing Proxmox VE servers.
#
# - Ensures the script is run with root privileges.
# - Displays an installation confirmation prompt.
# - Installs required dependencies:
#     â€¢ whiptail (interactive terminal menus)
#     â€¢ curl (downloads and connectivity checks)
#     â€¢ jq (JSON parsing)
#     â€¢ Python 3 + venv (for translation support)
# - Creates the ProxMenux base directories and configuration files:
#     â€¢ $BASE_DIR/config.json
#     â€¢ $BASE_DIR/cache.json
# - Copies local project files into the target paths (offline mode by default):
#     â€¢ scripts/*     â†’ $BASE_DIR/scripts/
#     â€¢ utils.sh      â†’ $BASE_DIR/scripts/utils.sh
#     â€¢ menu          â†’ $INSTALL_DIR/menu (main launcher)
#     â€¢ install_proxmenux.sh â†’ $BASE_DIR/install_proxmenux.sh
# - Sets correct permissions for all executables.
# - Displays the final instruction on how to start ProxMenux ("menu").
#
# Notes:
# - This installer supports both offline and online setups.
# - ProxMenux Monitor can be installed later as an optional module
#   to provide real-time system monitoring and a web dashboard.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
INSTALL_DIR="/usr/local/bin"
BASE_DIR="/usr/local/share/proxmenux"
CONFIG_FILE="$BASE_DIR/config.json"
CACHE_FILE="$BASE_DIR/cache.json"
UTILS_FILE="$BASE_DIR/utils.sh"
LOCAL_VERSION_FILE="$BASE_DIR/version.txt"
MENU_SCRIPT="menu"
VENV_PATH="/opt/googletrans-env"

MONITOR_INSTALL_DIR="$BASE_DIR"
MONITOR_SERVICE_FILE="/etc/systemd/system/proxmenux-monitor.service"
MONITOR_PORT=8008

# Offline installer envs
REPO_URL="https://github.com/MacRimi/ProxMenux.git"
TEMP_DIR="/tmp/proxmenux-install-$$"

# Load utility functions
NEON_PURPLE_BLUE="\033[38;5;99m"
WHITE="\033[38;5;15m" 
RESET="\033[0m"  
DARK_GRAY="\033[38;5;244m"
ORANGE="\033[38;5;208m"
YW="\033[33m"
YWB="\033[1;33m"
GN="\033[1;92m"
RD="\033[01;31m"
CL="\033[m"
BL="\033[36m"
DGN="\e[32m"
BGN="\e[1;32m"
DEF="\e[1;36m"
CUS="\e[38;5;214m"
BOLD="\033[1m"
BFR="\\r\\033[K"
HOLD="-"
BOR=" | "
CM="${GN}âœ“ ${CL}"
TAB="    "   


# Create and display spinner
spinner() {
    local frames=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
    local spin_i=0
    local interval=0.1
    printf "\e[?25l"
    
    local color="${YW}"
    
    while true; do
        printf "\r ${color}%s${CL}" "${frames[spin_i]}"
        spin_i=$(( (spin_i + 1) % ${#frames[@]} ))
        sleep "$interval"
    done
}


# Function to simulate typing effect
type_text() {
    local text="$1"
    local delay=0.05
    for ((i=0; i<${#text}; i++)); do
        echo -n "${text:$i:1}"
        sleep $delay
    done
    echo
}


# Display info message with spinner
msg_info() {
    local msg="$1"
    echo -ne "${TAB}${YW}${HOLD}${msg}"
    spinner &
    SPINNER_PID=$!
}


# Display info2 message
msg_info2() {
    local msg="$1"
    echo -e "${TAB}${BOLD}${YW}${HOLD}${msg}${CL}"
}



# Display title script
msg_title() {
    local msg="$1"
    echo -e "\n"
    echo -e "${TAB}${BOLD}${HOLD}${BOR}${msg}${BOR}${HOLD}${CL}"
    echo -e "\n"
}


# Display warning or highlighted information message
msg_warn() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${CL} ${YWB}${msg}${CL}"
}


# Display success message
msg_ok() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${CM}${GN}${msg}${CL}"
}


# Display error message
msg_error() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${RD}[ERROR] ${msg}${CL}"
}
    



show_proxmenux_logo() {
clear

if [[ -z "$SSH_TTY" && -z "$(who am i | awk '{print $NF}' | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}')" ]]; then

# Logo for terminal noVNC

LOGO=$(cat << "EOF"
\e[0m\e[38;2;61;61;61mâ–†\e[38;2;60;60;60mâ–„\e[38;2;54;54;54mâ–‚\e[0m \e[38;2;0;0;0m             \e[0m \e[38;2;54;54;54mâ–‚\e[38;2;60;60;60mâ–„\e[38;2;61;61;61mâ–†\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[38;2;61;61;61;48;2;37;37;37mâ–‡\e[0m\e[38;2;60;60;60mâ–…\e[38;2;56;56;56mâ–ƒ\e[38;2;37;37;37mâ–       \e[38;2;36;36;36mâ–\e[38;2;56;56;56mâ–ƒ\e[38;2;60;60;60mâ–…\e[38;2;61;61;61;48;2;37;37;37mâ–‡\e[48;2;62;62;62m  \e[0m\e[7m\e[38;2;60;60;60mâ–\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[7m\e[38;2;61;61;61mâ–‚\e[0m\e[38;2;62;62;62;48;2;61;61;61mâ”ˆ\e[48;2;62;62;62m \e[48;2;61;61;61mâ”ˆ\e[0m\e[38;2;60;60;60mâ–†\e[38;2;57;57;57mâ–„\e[38;2;48;48;48mâ–‚\e[0m \e[38;2;47;47;47mâ–‚\e[38;2;57;57;57mâ–„\e[38;2;60;60;60mâ–†\e[38;2;62;62;62;48;2;61;61;61mâ”ˆ\e[48;2;62;62;62m \e[48;2;61;61;61mâ”ˆ\e[0m\e[7m\e[38;2;60;60;60mâ–‚\e[38;2;57;57;57mâ–„\e[38;2;47;47;47mâ–†\e[0m \e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[7m\e[38;2;39;39;39mâ–‡\e[38;2;57;57;57mâ–…\e[38;2;60;60;60mâ–ƒ\e[0m\e[38;2;40;40;40;48;2;61;61;61mâ–\e[48;2;62;62;62m  \e[38;2;54;54;54;48;2;61;61;61mâ”Š\e[48;2;62;62;62m  \e[38;2;39;39;39;48;2;61;61;61mâ–\e[0m\e[7m\e[38;2;60;60;60mâ–ƒ\e[38;2;57;57;57mâ–…\e[38;2;38;38;38mâ–‡\e[0m \e[38;2;193;60;2mâ–ƒ\e[38;2;217;67;2mâ–…\e[38;2;225;70;2mâ–‡\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[0m \e[38;2;203;63;2mâ–„\e[38;2;147;45;1mâ–‚\e[0m \e[7m\e[38;2;55;55;55mâ–†\e[38;2;60;60;60mâ–„\e[38;2;61;61;61mâ–‚\e[38;2;60;60;60mâ–„\e[38;2;55;55;55mâ–†\e[0m \e[38;2;144;44;1mâ–‚\e[38;2;202;62;2mâ–„\e[38;2;219;68;2mâ–†\e[38;2;231;72;3;48;2;226;70;2mâ”ˆ\e[48;2;231;72;3m  \e[48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[7m\e[38;2;121;37;1mâ–‰\e[0m\e[38;2;0;0;0;48;2;231;72;3m  \e[0m\e[38;2;221;68;2mâ–‡\e[38;2;208;64;2mâ–…\e[38;2;212;66;2mâ–‚\e[38;2;123;37;0mâ–\e[38;2;211;65;2mâ–‚\e[38;2;207;64;2mâ–…\e[38;2;220;68;2mâ–‡\e[48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ”ˆ\e[0m\e[7m\e[38;2;221;68;2mâ–‚\e[0m\e[38;2;44;13;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[0m \e[7m\e[38;2;190;59;2mâ–…\e[38;2;216;67;2mâ–ƒ\e[38;2;225;70;2mâ–\e[0m\e[38;2;95;29;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;230;71;2mâ”ˆ\e[48;2;231;72;3m  \e[0m\e[7m\e[38;2;225;70;2mâ–\e[38;2;216;67;2mâ–ƒ\e[38;2;191;59;2mâ–…\e[0m  \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–   \e[0m \e[7m\e[38;2;172;53;1mâ–†\e[38;2;213;66;2mâ–„\e[38;2;219;68;2mâ–‚\e[38;2;213;66;2mâ–„\e[38;2;174;54;2mâ–†\e[0m \e[38;2;0;0;0m   \e[0m \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–             \e[0m \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[7m\e[38;2;52;52;52mâ–†\e[38;2;59;59;59mâ–„\e[38;2;61;61;61mâ–‚\e[0m\e[38;2;31;31;31mâ–             \e[0m \e[7m\e[38;2;228;71;2mâ–‚\e[38;2;221;69;2mâ–„\e[38;2;196;60;2mâ–†\e[0m
EOF
)


TEXT=(
    ""
    ""
    "${BOLD}ProxMenux${RESET}"
    ""
    "${BOLD}${NEON_PURPLE_BLUE}An Interactive Menu for${RESET}"
    "${BOLD}${NEON_PURPLE_BLUE}Proxmox VE management${RESET}"
    ""
    ""
    ""
    ""
)


mapfile -t logo_lines <<< "$LOGO"

for i in {0..9}; do
    echo -e "${TAB}${logo_lines[i]}  ${WHITE}â”‚${RESET}  ${TEXT[i]}"
done
echo -e

else


# Logo for terminal SSH     
TEXT=(
    ""
    ""
    ""
    ""
    "${BOLD}ProxMenux${RESET}"
    ""
    "${BOLD}${NEON_PURPLE_BLUE}An Interactive Menu for${RESET}"
    "${BOLD}${NEON_PURPLE_BLUE}Proxmox VE management${RESET}"
    ""
    ""
    ""
    ""
    ""
    ""
)

LOGO=(
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     â–‘â–‘â–‘â–‘${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘â–‘â–‘â–‘               â–‘â–‘â–‘â–‘â–‘â–‘ ${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘       â–‘â–‘â–‘â–‘â–‘â–‘â–‘    ${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘    â–‘â–‘â–‘â–‘â–‘â–‘ â–‘â–‘â–‘â–‘â–‘â–‘      ${ORANGE}â–‘â–‘${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘       â–‘â–‘â–‘â–‘â–‘â–‘â–‘      ${ORANGE}â–‘â–‘â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘         â–‘â–‘â–‘     ${ORANGE}â–‘â–’â–’â–’â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘   ${ORANGE}â–’â–’â–’â–‘       â–‘â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘   ${ORANGE}â–‘â–’â–’â–’â–’â–’   â–’â–’â–’â–’â–’â–‘â–‘  â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘     ${ORANGE}â–‘â–‘â–’â–’â–’â–’â–’â–’â–’â–‘â–‘     â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘         ${ORANGE}â–‘â–‘â–‘         â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     ${ORANGE}â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     ${ORANGE}â–’â–’â–’â–‘${RESET}"
    "${DARK_GRAY}  â–‘â–‘                     ${ORANGE}â–‘â–‘  ${RESET}"
)

for i in {0..12}; do
    echo -e "${TAB}${LOGO[i]}  â”‚${RESET}  ${TEXT[i]}"
done
echo -e
fi

}

# ==========================================================





cleanup_corrupted_files() {
    if [ -f "$CONFIG_FILE" ] && ! jq empty "$CONFIG_FILE" >/dev/null 2>&1; then
        echo "Cleaning up corrupted configuration file..."
        rm -f "$CONFIG_FILE"
    fi
    if [ -f "$CACHE_FILE" ] && ! jq empty "$CACHE_FILE" >/dev/null 2>&1; then
        echo "Cleaning up corrupted cache file..."
        rm -f "$CACHE_FILE"
    fi
}

# Cleanup function
cleanup() {
    if [ -d "$TEMP_DIR" ]; then
        rm -rf "$TEMP_DIR"
    fi
}

# Set trap to ensure cleanup on exit
trap cleanup EXIT


# ==========================================================
check_existing_installation() {
    local has_venv=false
    local has_config=false
    local has_language=false
    local has_menu=false
    
    if [ -f "$INSTALL_DIR/$MENU_SCRIPT" ]; then
        has_menu=true
    fi
    
    if [ -d "$VENV_PATH" ] && [ -f "$VENV_PATH/bin/activate" ]; then
        has_venv=true
    fi
    
    if [ -f "$CONFIG_FILE" ]; then
        if jq empty "$CONFIG_FILE" >/dev/null 2>&1; then
            has_config=true
            local current_language=$(jq -r '.language // empty' "$CONFIG_FILE" 2>/dev/null)
            if [[ -n "$current_language" && "$current_language" != "null" && "$current_language" != "empty" ]]; then
                has_language=true
            fi
        else
            echo "Warning: Corrupted config file detected, removing..."
            rm -f "$CONFIG_FILE"
        fi
    fi
    
    if [ "$has_venv" = true ] && [ "$has_language" = true ]; then
        echo "translation"
    elif [ "$has_menu" = true ] && [ "$has_venv" = false ]; then
        echo "normal"
    elif [ "$has_menu" = true ]; then
        echo "unknown"
    else
        echo "none"
    fi
}

uninstall_proxmenux() {
    local install_type="$1"
    local force_clean="$2"
    
    if [ "$force_clean" != "force" ]; then
        if ! whiptail --title "Uninstall ProxMenux" --yesno "Are you sure you want to uninstall ProxMenux?" 10 60; then
            return 1
        fi
    fi
    
    echo "Uninstalling ProxMenux..."
    
    if systemctl is-active --quiet proxmenux-monitor.service; then
        echo "Stopping ProxMenux Monitor service..."
        systemctl stop proxmenux-monitor.service
    fi
    
    if systemctl is-enabled --quiet proxmenux-monitor.service 2>/dev/null; then
        echo "Disabling ProxMenux Monitor service..."
        systemctl disable proxmenux-monitor.service
    fi
    
    if [ -f "$MONITOR_SERVICE_FILE" ]; then
        echo "Removing ProxMenux Monitor service file..."
        rm -f "$MONITOR_SERVICE_FILE"
        systemctl daemon-reload
    fi
    
    if [ -d "$MONITOR_INSTALL_DIR" ]; then
        echo "Removing ProxMenux Monitor directory..."
        rm -rf "$MONITOR_INSTALL_DIR"
    fi
    
    if [ -f "$VENV_PATH/bin/activate" ]; then
        echo "Removing googletrans and virtual environment..."
        source "$VENV_PATH/bin/activate"
        pip uninstall -y googletrans >/dev/null 2>&1
        deactivate
        rm -rf "$VENV_PATH"
    fi
    
    if [ "$install_type" = "translation" ] && [ "$force_clean" != "force" ]; then
        DEPS_TO_REMOVE=$(whiptail --title "Remove Translation Dependencies" --checklist \
            "Select translation-specific dependencies to remove:" 15 60 3 \
            "python3-venv" "Python virtual environment" OFF \
            "python3-pip" "Python package installer" OFF \
            "python3" "Python interpreter" OFF \
            3>&1 1>&2 2>&3)
        
        if [ -n "$DEPS_TO_REMOVE" ]; then
            echo "Removing selected dependencies..."
            read -r -a DEPS_ARRAY <<< "$(echo "$DEPS_TO_REMOVE" | tr -d '"')"
            for dep in "${DEPS_ARRAY[@]}"; do
                echo "Removing $dep..."
                apt-mark auto "$dep" >/dev/null 2>&1
                apt-get -y --purge autoremove "$dep" >/dev/null 2>&1
            done
            apt-get autoremove -y --purge >/dev/null 2>&1
        fi
    fi
    
    rm -f "$INSTALL_DIR/$MENU_SCRIPT"
    rm -rf "$BASE_DIR"
    
    [ -f /root/.bashrc.bak ] && mv /root/.bashrc.bak /root/.bashrc
    if [ -f /etc/motd.bak ]; then
        mv /etc/motd.bak /etc/motd
    else
        sed -i '/This system is optimised by: ProxMenux/d' /etc/motd
    fi
    
    echo "ProxMenux has been uninstalled."
    return 0
}

handle_installation_change() {
    local current_type="$1"
    local new_type="$2"
    
    if [ "$current_type" = "$new_type" ]; then
        return 0
    fi
    
    case "$current_type-$new_type" in
        "translation-1"|"translation-normal")
            if whiptail --title "Installation Type Change" \
                --yesno "Switch from Translation to Normal Version?\n\nThis will remove translation components." 10 60; then
                echo "Preparing for installation type change..."
                uninstall_proxmenux "translation" "force" >/dev/null 2>&1
                return 0
            else
                return 1
            fi
            ;;
        "normal-2"|"normal-translation")
            if whiptail --title "Installation Type Change" \
                --yesno "Switch from Normal to Translation Version?\n\nThis will add translation components." 10 60; then
                return 0
            else
                return 1
            fi
            ;;
        *)
            return 0
            ;;
    esac
}

update_config() {
    local component="$1"
    local status="$2"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    local tracked_components=("dialog" "curl" "jq" "git" "python3" "python3-venv" "python3-pip" "virtual_environment" "pip" "googletrans" "proxmenux_monitor")
    
    if [[ " ${tracked_components[@]} " =~ " ${component} " ]]; then
        mkdir -p "$(dirname "$CONFIG_FILE")"
        
        if [ ! -f "$CONFIG_FILE" ] || ! jq empty "$CONFIG_FILE" >/dev/null 2>&1; then
            echo '{}' > "$CONFIG_FILE"
        fi
        
        local tmp_file=$(mktemp)
        if jq --arg comp "$component" --arg stat "$status" --arg time "$timestamp" \
           '.[$comp] = {status: $stat, timestamp: $time}' "$CONFIG_FILE" > "$tmp_file" 2>/dev/null; then
            mv "$tmp_file" "$CONFIG_FILE"
        else
            echo '{}' > "$CONFIG_FILE"
            jq --arg comp "$component" --arg stat "$status" --arg time "$timestamp" \
               '.[$comp] = {status: $stat, timestamp: $time}' "$CONFIG_FILE" > "$tmp_file" && mv "$tmp_file" "$CONFIG_FILE"
        fi
        
        [ -f "$tmp_file" ] && rm -f "$tmp_file"
    fi
}

show_progress() {
    local step="$1"
    local total="$2"
    local message="$3"
    
    echo -e "\n${BOLD}${BL}${TAB}Installing ProxMenux: Step $step of $total${CL}"
    echo
    msg_info2 "$message"
}

select_language() {
    if [ -f "$CONFIG_FILE" ] && jq empty "$CONFIG_FILE" >/dev/null 2>&1; then
        local existing_language=$(jq -r '.language // empty' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$existing_language" && "$existing_language" != "null" && "$existing_language" != "empty" ]]; then
            LANGUAGE="$existing_language"
            msg_ok "Using existing language configuration: $LANGUAGE"
            return 0
        fi
    fi
    
    LANGUAGE=$(whiptail --title "Select Language" --menu "Choose a language for the menu:" 20 60 12 \
        "en" "English (Recommended)" \
        "es" "Spanish" \
        "fr" "French" \
        "de" "German" \
        "it" "Italian" \
        "pt" "Portuguese" 3>&1 1>&2 2>&3)
    
    if [ -z "$LANGUAGE" ]; then
        msg_error "No language selected. Exiting."
        exit 1
    fi
    
    mkdir -p "$(dirname "$CONFIG_FILE")"
    
    if [ ! -f "$CONFIG_FILE" ] || ! jq empty "$CONFIG_FILE" >/dev/null 2>&1; then
        echo '{}' > "$CONFIG_FILE"
    fi
    
    local tmp_file=$(mktemp)
    if jq --arg lang "$LANGUAGE" '. + {language: $lang}' "$CONFIG_FILE" > "$tmp_file" 2>/dev/null; then
        mv "$tmp_file" "$CONFIG_FILE"
    else
        echo "{\"language\": \"$LANGUAGE\"}" > "$CONFIG_FILE"
    fi
    
    [ -f "$tmp_file" ] && rm -f "$tmp_file"
    
    msg_ok "Language set to: $LANGUAGE"
}

# Show installation confirmation for new installations
show_installation_confirmation() {
    local install_type="$1"
    
    case "$install_type" in
        "1")
            if whiptail --title "ProxMenux - Normal Version Installation" \
                --yesno "ProxMenux Normal Version will install:\n\nâ€¢ dialog  (interactive menus) - Official Debian package\nâ€¢ curl       (file downloads) - Official Debian package\nâ€¢ jq        (JSON processing) - Official Debian package\nâ€¢ ProxMenux core files     (/usr/local/share/proxmenux)\nâ€¢ ProxMenux Monitor        (Web dashboard on port 8008)\n\nThis is a lightweight installation with minimal dependencies.\n\nProceed with installation?" 20 70; then
                return 0
            else
                return 1
            fi
            ;;
        "2")
            if whiptail --title "ProxMenux - Translation Version Installation" \
                --yesno "ProxMenux Translation Version will install:\n\nâ€¢ dialog (interactive menus)\nâ€¢ curl (file downloads)\nâ€¢ jq (JSON processing)\nâ€¢ python3 + python3-venv + python3-pip\nâ€¢ Google Translate library (googletrans)\nâ€¢ Virtual environment (/opt/googletrans-env)\nâ€¢ Translation cache system\nâ€¢ ProxMenux core files\nâ€¢ ProxMenux Monitor        (Web dashboard on port 8008)\n\nThis version requires more dependencies for translation support.\n\nProceed with installation?" 20 70; then
                return 0
            else
                return 1
            fi
            ;;
    esac
}

get_server_ip() {
    local ip
    # Try to get the primary IP address
    ip=$(ip route get 1.1.1.1 2>/dev/null | grep -oP 'src \K\S+')
    
    if [ -z "$ip" ]; then
        # Fallback: get first non-loopback IP
        ip=$(hostname -I | awk '{print $1}')
    fi
    
    if [ -z "$ip" ]; then
        # Last resort: use localhost
        ip="localhost"
    fi
    
    echo "$ip"
}

detect_latest_appimage() {
    local appimage_dir="$TEMP_DIR/AppImage"
    
    if [ ! -d "$appimage_dir" ]; then
        return 1
    fi
    
    local latest_appimage=$(find "$appimage_dir" -name "ProxMenux-*.AppImage" -type f | sort -V | tail -1)
    
    if [ -z "$latest_appimage" ]; then
        return 1
    fi
    
    echo "$latest_appimage"
    return 0
}

get_appimage_version() {
    local appimage_path="$1"
    local filename=$(basename "$appimage_path")
    
    local version=$(echo "$filename" | grep -oP 'ProxMenux-\K[0-9]+\.[0-9]+\.[0-9]+')
    
    echo "$version"
}

install_proxmenux_monitor() {
    local appimage_source=$(detect_latest_appimage)
    
    if [ -z "$appimage_source" ] || [ ! -f "$appimage_source" ]; then
        msg_error "ProxMenux Monitor AppImage not found in $TEMP_DIR/AppImage/"
        msg_warn "Please ensure the AppImage directory exists with ProxMenux-*.AppImage files."
        update_config "proxmenux_monitor" "appimage_not_found"
        return 1
    fi
    
    local appimage_version=$(get_appimage_version "$appimage_source")
    
    if systemctl is-active --quiet proxmenux-monitor.service; then
        systemctl stop proxmenux-monitor.service
    fi
    
    local service_exists=false
    if [ -f "$MONITOR_SERVICE_FILE" ]; then
        service_exists=true
    fi
    
    local sha256_file="$TEMP_DIR/AppImage/ProxMenux-Monitor.AppImage.sha256"
    
    if [ -f "$sha256_file" ]; then
        msg_info "Verifying AppImage integrity..."
        local expected_hash=$(cat "$sha256_file" | grep -Eo '^[a-f0-9]+' | tr -d '\n')
        local actual_hash=$(sha256sum "$appimage_source" | awk '{print $1}')
        
        if [ "$expected_hash" != "$actual_hash" ]; then
            msg_error "SHA256 verification failed! AppImage may be corrupted."
            return 1
        fi
        msg_ok "SHA256 verification passed."
    else
        msg_warn "SHA256 checksum not available. Skipping verification."
    fi
    
    msg_info "Installing ProxMenux Monitor..."
    mkdir -p "$MONITOR_INSTALL_DIR"
    
    local target_path="$MONITOR_INSTALL_DIR/ProxMenux-Monitor.AppImage"
    cp "$appimage_source" "$target_path"
    chmod +x "$target_path"
    
    msg_ok "ProxMenux Monitor v$appimage_version installed."
    
    if [ "$service_exists" = false ]; then
        return 0  # New installation - service needs to be created
    else

        systemctl start proxmenux-monitor.service
        sleep 2
        
        if systemctl is-active --quiet proxmenux-monitor.service; then

            update_config "proxmenux_monitor" "updated"
            return 2  # Update successful
        else
            msg_warn "Service failed to restart. Check: journalctl -u proxmenux-monitor"
            update_config "proxmenux_monitor" "failed"
            return 1
        fi
    fi
}

create_monitor_service() {
    msg_info "Creating ProxMenux Monitor service..."
    
    local exec_path="$MONITOR_INSTALL_DIR/ProxMenux-Monitor.AppImage"
    
    if [ -f "$TEMP_DIR/systemd/proxmenux-monitor.service" ]; then
        sed "s|ExecStart=.*|ExecStart=$exec_path|g" \
            "$TEMP_DIR/systemd/proxmenux-monitor.service" > "$MONITOR_SERVICE_FILE"
        msg_ok "Using service file from repository."
    else
        cat > "$MONITOR_SERVICE_FILE" << EOF
[Unit]
Description=ProxMenux Monitor - Web Dashboard
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=$MONITOR_INSTALL_DIR
ExecStart=$exec_path
Restart=on-failure
RestartSec=10
Environment="PORT=$MONITOR_PORT"

[Install]
WantedBy=multi-user.target
EOF
        msg_ok "Created default service file."
    fi

    systemctl daemon-reload
    systemctl enable proxmenux-monitor.service > /dev/null 2>&1
    systemctl start proxmenux-monitor.service > /dev/null 2>&1
    
    sleep 3
    
    if systemctl is-active --quiet proxmenux-monitor.service; then
        msg_ok "ProxMenux Monitor service started successfully."
        update_config "proxmenux_monitor" "installed"
        return 0
    else
        msg_warn "ProxMenux Monitor service failed to start."
        msg_info "Check logs with: journalctl -u proxmenux-monitor -n 20"
        msg_info "Check status with: systemctl status proxmenux-monitor"
        update_config "proxmenux_monitor" "failed"
        return 1
    fi
}

install_normal_version() {
    local total_steps=5
    local current_step=1
    
    show_progress $current_step $total_steps "Installing basic dependencies."
    
    if ! command -v jq > /dev/null 2>&1; then
        apt-get update > /dev/null 2>&1
        
        if apt-get install -y jq > /dev/null 2>&1 && command -v jq > /dev/null 2>&1; then
            update_config "jq" "installed"
        else
            local jq_url="https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64"
            if wget -q -O /usr/local/bin/jq "$jq_url" 2>/dev/null && chmod +x /usr/local/bin/jq; then
                if command -v jq > /dev/null 2>&1; then
                    update_config "jq" "installed_from_github"
                else
                    msg_error "Failed to install jq. Please install it manually."
                    update_config "jq" "failed"
                    return 1
                fi
            else
                msg_error "Failed to install jq from both APT and GitHub. Please install it manually."
                update_config "jq" "failed"
                return 1
            fi
        fi
    else
        update_config "jq" "already_installed"
    fi
    




    BASIC_DEPS=("dialog" "curl" "git")

    if [ -z "${APT_UPDATED:-}" ]; then
        apt-get update -y > /dev/null 2>&1 || true
        APT_UPDATED=1
    fi

    for pkg in "${BASIC_DEPS[@]}"; do
        if ! dpkg -l | grep -qw "$pkg"; then
            if apt-get install -y "$pkg" > /dev/null 2>&1; then
                update_config "$pkg" "installed"
            else
                msg_error "Failed to install $pkg. Please install it manually."
                update_config "$pkg" "failed"
                return 1
            fi
        else
            update_config "$pkg" "already_installed"
        fi
    done


    if ! command -v git > /dev/null 2>&1; then
        msg_info "Installing git (required to clone the ProxMenux repository)."


        if [ -z "${APT_UPDATED:-}" ]; then
            apt-get update -y > /dev/null 2>&1 || true
            APT_UPDATED=1
        fi

        if ! apt-get install -y git > /dev/null 2>&1; then
            msg_error "Failed to install git. Please run 'apt-get install git' manually and rerun the installer."
            update_config "git" "failed"
            return 1
        fi


        if ! command -v git > /dev/null 2>&1; then
            msg_error "Git is still not available after installation. Aborting to avoid a broken setup."
            update_config "git" "failed"
            return 1
        fi

        update_config "git" "installed"
    else
        update_config "git" "already_installed"
    fi

    msg_ok "jq, dialog, curl and git installed successfully."






    ((current_step++))

    show_progress $current_step $total_steps "Install ProxMenux repository"
    msg_info "Cloning ProxMenux repositoryy."
    if ! git clone --depth 1 "$REPO_URL" "$TEMP_DIR" 2>/dev/null; then
        msg_error "Failed to clone repository from $REPO_URL"
        exit 1
    fi

    msg_ok "Repository cloned successfully."

    cd "$TEMP_DIR"

    ((current_step++))
    
    show_progress $current_step $total_steps "Creating directories and configuration"
    
    mkdir -p "$BASE_DIR"
    mkdir -p "$INSTALL_DIR"
    
    if [ ! -f "$CONFIG_FILE" ]; then
        echo '{}' > "$CONFIG_FILE"
    fi
    
    msg_ok "Directories and configuration created."
    ((current_step++))
    
    show_progress $current_step $total_steps "Copying necessary files"
    
    cp "./scripts/utils.sh" "$UTILS_FILE"
    cp "./menu" "$INSTALL_DIR/$MENU_SCRIPT"
    cp "./version.txt" "$LOCAL_VERSION_FILE"
    cp "./install_proxmenux.sh" "$BASE_DIR/install_proxmenux.sh"

    mkdir -p "$BASE_DIR/scripts"
    cp -r "./scripts/"* "$BASE_DIR/scripts/"
    chmod -R +x "$BASE_DIR/scripts/"
    chmod +x "$BASE_DIR/install_proxmenux.sh"
    msg_ok "Necessary files created."

    chmod +x "$INSTALL_DIR/$MENU_SCRIPT"
    
    ((current_step++))
    show_progress $current_step $total_steps "Installing ProxMenux Monitor"
    
    install_proxmenux_monitor
    local monitor_status=$?
    
    if [ $monitor_status -eq 0 ]; then
        create_monitor_service
    fi
    
    msg_ok "ProxMenux Normal Version installation completed successfully."
}

install_translation_version() {
    local total_steps=5
    local current_step=1
    
    show_progress $current_step $total_steps "Language selection"
    select_language
    ((current_step++))
    
    show_progress $current_step $total_steps "Installing system dependencies"
    
    if ! command -v jq > /dev/null 2>&1; then
        apt-get update > /dev/null 2>&1
        
        if apt-get install -y jq > /dev/null 2>&1 && command -v jq > /dev/null 2>&1; then
            update_config "jq" "installed"
        else
            local jq_url="https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64"
            if wget -q -O /usr/local/bin/jq "$jq_url" 2>/dev/null && chmod +x /usr/local/bin/jq; then
                if command -v jq > /dev/null 2>&1; then
                    update_config "jq" "installed_from_github"
                else
                    msg_error "Failed to install jq. Please install it manually."
                    update_config "jq" "failed"
                    return 1
                fi
            else
                msg_error "Failed to install jq from both APT and GitHub. Please install it manually."
                update_config "jq" "failed"
                return 1
            fi
        fi
    else
        update_config "jq" "already_installed"
    fi
    
    DEPS=("dialog" "curl" "git" "python3" "python3-venv" "python3-pip")
    for pkg in "${DEPS[@]}"; do
        if ! dpkg -l | grep -qw "$pkg"; then
            if apt-get install -y "$pkg" > /dev/null 2>&1; then
                update_config "$pkg" "installed"
            else
                msg_error "Failed to install $pkg. Please install it manually."
                update_config "$pkg" "failed"
                return 1
            fi
        else
            update_config "$pkg" "already_installed"
        fi
    done
    
    msg_ok "jq, dialog, curl, git, python3, python3-venv and python3-pip installed successfully."
    
    ((current_step++))
    
    show_progress $current_step $total_steps "Setting up translation environment"
    
    if [ ! -d "$VENV_PATH" ] || [ ! -f "$VENV_PATH/bin/activate" ]; then
        python3 -m venv --system-site-packages "$VENV_PATH" > /dev/null 2>&1
        if [ ! -f "$VENV_PATH/bin/activate" ]; then
            msg_error "Failed to create virtual environment. Please check your Python installation."
            update_config "virtual_environment" "failed"
            return 1
        else
            update_config "virtual_environment" "created"
        fi
    else
        update_config "virtual_environment" "already_exists"
    fi
    
    source "$VENV_PATH/bin/activate"
    
    if pip install --upgrade pip > /dev/null 2>&1; then
        update_config "pip" "upgraded"
    else
        msg_error "Failed to upgrade pip."
        update_config "pip" "upgrade_failed"
        return 1
    fi
    
    if pip install --break-system-packages --no-cache-dir googletrans==4.0.0-rc1 > /dev/null 2>&1; then
        update_config "googletrans" "installed"
    else
        msg_error "Failed to install googletrans. Please check your internet connection."
        update_config "googletrans" "failed"
        deactivate
        return 1
    fi
    
    deactivate
    
    show_progress $current_step $total_steps "Cloning ProxMenux repository"
    if ! git clone --depth 1 "$REPO_URL" "$TEMP_DIR" 2>/dev/null; then
        msg_error "Failed to clone repository from $REPO_URL"
        exit 1
    fi
    msg_ok "Repository cloned successfully."
    
    cd "$TEMP_DIR"
    
    ((current_step++))
    
    show_progress $current_step $total_steps "Copying necessary files"
    
    mkdir -p "$BASE_DIR"
    mkdir -p "$INSTALL_DIR"
    
    cp "./json/cache.json" "$CACHE_FILE"
    msg_ok "Cache file copied with translations."
    
    cp "./scripts/utils.sh" "$UTILS_FILE"
    cp "./menu" "$INSTALL_DIR/$MENU_SCRIPT"
    cp "./version.txt" "$LOCAL_VERSION_FILE"
    cp "./install_proxmenux.sh" "$BASE_DIR/install_proxmenux.sh"
    
    mkdir -p "$BASE_DIR/scripts"
    cp -r "./scripts/"* "$BASE_DIR/scripts/"
    chmod -R +x "$BASE_DIR/scripts/"
    chmod +x "$BASE_DIR/install_proxmenux.sh"
    msg_ok "Necessary files created."
    
    chmod +x "$INSTALL_DIR/$MENU_SCRIPT"
    
    ((current_step++))
    show_progress $current_step $total_steps "Installing ProxMenux Monitor"
    
    install_proxmenux_monitor
    local monitor_status=$?
    
    if [ $monitor_status -eq 0 ]; then
        create_monitor_service
    elif [ $monitor_status -eq 2 ]; then
        msg_ok "ProxMenux Monitor updated successfully."
    fi
    
    msg_ok "ProxMenux Translation Version installation completed successfully."
}

show_installation_options() {
    local current_install_type
    current_install_type=$(check_existing_installation)
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)
    
    local menu_title="ProxMenux Installation"
    local menu_text="Choose installation type:"
    
    if [ "$current_install_type" != "none" ]; then
        case "$current_install_type" in
            "translation")
                menu_title="ProxMenux Update - Translation Version Detected"
                ;;
            "normal")
                menu_title="ProxMenux Update - Normal Version Detected"
                ;;
            "unknown")
                menu_title="ProxMenux Update - Existing Installation Detected"
                ;;
        esac
    fi
    
    if [[ "$pve_version" -ge 9 ]]; then
        INSTALL_TYPE=$(whiptail --backtitle "ProxMenux" --title "$menu_title" --menu "\n$menu_text" 14 70 2 \
            "1" "Normal Version      (English only)" 3>&1 1>&2 2>&3)
        
        if [ -z "$INSTALL_TYPE" ]; then
            show_proxmenux_logo
            msg_warn "Installation cancelled."
            exit 1
        fi
    else
        INSTALL_TYPE=$(whiptail --backtitle "ProxMenux" --title "$menu_title" --menu "\n$menu_text" 14 70 2 \
            "1" "Normal Version      (English only)" \
            "2" "Translation Version (Multi-language support)" 3>&1 1>&2 2>&3)
        
        if [ -z "$INSTALL_TYPE" ]; then
            show_proxmenux_logo
            msg_warn "Installation cancelled."
            exit 1
        fi
    fi
    
    if [ -z "$INSTALL_TYPE" ]; then
        show_proxmenux_logo
        msg_warn "Installation cancelled."
        exit 1
    fi
    
    if [ "$current_install_type" = "none" ]; then
        if ! show_installation_confirmation "$INSTALL_TYPE"; then
            show_proxmenux_logo
            msg_warn "Installation cancelled."
            exit 1
        fi
    fi
    
    if ! handle_installation_change "$current_install_type" "$INSTALL_TYPE"; then
        show_proxmenux_logo
        msg_warn "Installation cancelled."
        exit 1
    fi
}

install_proxmenux() {
    show_installation_options
    
    case "$INSTALL_TYPE" in
        "1")
            show_proxmenux_logo
            msg_title "Installing ProxMenux - Normal Version"
            install_normal_version
            ;;
        "2")
            show_proxmenux_logo
            msg_title "Installing ProxMenux - Translation Version"
            install_translation_version
            ;;
        *)
            msg_error "Invalid option selected."
            exit 1
            ;;
    esac

    if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
    fi
    
    msg_title "ProxMenux has been installed successfully"
    
    if systemctl is-active --quiet proxmenux-monitor.service; then
        local server_ip=$(get_server_ip)
        echo -e "${GN}ğŸŒ  ProxMenux Monitor activated${CL}: ${BL}http://${server_ip}:${MONITOR_PORT}${CL}"
        echo
    fi
    
    echo -ne "${GN}"
    type_text "To run ProxMenux, simply execute this command in the console or terminal:"
    echo -e "${YWB}    menu${CL}"
    echo
    # -------
    exit 0
}

if [ "$(id -u)" -ne 0 ]; then
    msg_error "This script must be run as root."
    exit 1
fi

cleanup_corrupted_files
install_proxmenux



================================================
FILE: LICENSE
================================================
ProxMenux An Interactive Menu for Proxmox VE Management
Copyright (c) 2025 MacRimi

This project is licensed under the Creative Commons Attribution-NonCommercial 4.0 International License.
See the full license terms below.

======================================================================

Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)

This is a human-readable summary of (and not a substitute for) the license.
You may obtain a copy of the full license at:

    https://creativecommons.org/licenses/by-nc/4.0/

You are free to:
- Share â€” copy and redistribute the material in any medium or format.
- Adapt â€” remix, transform, and build upon the material.

Under the following terms:
- Attribution â€” You must give appropriate credit, provide a link to the license,
  and indicate if changes were made.
- NonCommercial â€” You may not use the material for commercial purposes.

No additional restrictions â€” You may not apply legal terms or technological
measures that legally restrict others from doing anything the license permits.

Disclaimer:
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT, OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE. 



================================================
FILE: menu
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 04/07/2025
# ==========================================================
# Description:
# This script serves as the main entry point for ProxMenux,
# a menu-driven tool designed for Proxmox VE management.
# - Displays the ProxMenux logo on startup.
# - Loads necessary configurations and language settings.
# - Checks for available updates and installs them if confirmed.
# - Downloads and executes the latest main menu script.
#
# Key Features:
# - Ensures ProxMenux is always up-to-date by fetching the latest version.
# - Uses whiptail for interactive menus and language selection.
# - Loads utility functions and translation support.
# - Maintains a cache system to improve performance.
# - Executes the ProxMenux main menu dynamically from the repository.
#
# This script ensures a streamlined and automated experience
# for managing Proxmox VE using ProxMenux.
# ==========================================================

# Configuration ============================================
REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"
BASE_DIR="/usr/local/share/proxmenux"
LOCAL_SCRIPTS="$BASE_DIR/scripts"
CONFIG_FILE="$BASE_DIR/config.json"
CACHE_FILE="$BASE_DIR/cache.json"
UTILS_FILE="$BASE_DIR/utils.sh"
LOCAL_VERSION_FILE="$BASE_DIR/version.txt"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then

    source "$UTILS_FILE"
fi

: "${LOCAL_SCRIPTS:=/usr/local/share/proxmenux/scripts}"

# =========================================================

check_updates() {
    local VERSION_URL INSTALL_URL INSTALL_SCRIPT
    local REMOTE_VERSION LOCAL_VERSION

    VERSION_URL="$REPO_URL/version.txt"
    INSTALL_URL="$REPO_URL/install_proxmenux.sh"
    INSTALL_SCRIPT="$BASE_DIR/install_proxmenux.sh"


    [[ ! -f "$LOCAL_VERSION_FILE" ]] && return 0

    REMOTE_VERSION="$(curl -fsSL "$VERSION_URL" 2>/dev/null | head -n 1)"
    [[ -z "$REMOTE_VERSION" ]] && return 0


    LOCAL_VERSION="$(head -n 1 "$LOCAL_VERSION_FILE" 2>/dev/null)"
    [[ -z "$LOCAL_VERSION" ]] && return 0


    [[ "$LOCAL_VERSION" = "$REMOTE_VERSION" ]] && return 0


    if whiptail --title "$(translate 'Update Available')" \
                --yesno "$(translate 'New version available') ($REMOTE_VERSION)\n\n$(translate 'Do you want to update now?')" \
                10 60 --defaultno; then

        msg_warn "$(translate 'Starting ProxMenux update...')"


        if curl -fsSL "$INSTALL_URL" -o "$INSTALL_SCRIPT"; then
            chmod +x "$INSTALL_SCRIPT"


            bash "$INSTALL_SCRIPT" --update

            return 0

        fi

    fi
}





main_menu() {
    local MAIN_MENU="$LOCAL_SCRIPTS/menus/main_menu.sh"

    exec bash "$MAIN_MENU"
}

load_language
initialize_cache
check_updates
main_menu



================================================
FILE: SECURITY.md
================================================
# ğŸ”’ Security Policy

## ğŸ“… Supported Versions

We actively maintain the latest release of ProxMenux. Only the most recent version receives security updates.

| Version | Supported |
| ------- | --------- |
| Latest  | âœ…        |
| Older versions | âŒ     |

## ğŸ“¢ Reporting a Vulnerability

If you discover a **security vulnerability**, please help us keep the community safe by reporting it **privately**.

**Do not report vulnerabilities in public GitHub Issues or Discussions.**

### ğŸ“¬ Contact

To report a vulnerability, email:

**ğŸ“§ proxmenux@macrimi.pro**

Please include as much detail as possible, including:

- Steps to reproduce the issue
- A description of the impact
- Any known mitigations

We aim to respond as soon as possible, typically within **48 hours**.

## âš ï¸ Coordinated Disclosure

We follow responsible disclosure principles. If a vulnerability is confirmed, we will:

1. Work on a fix immediately.
2. Inform you of the resolution status.

---

ğŸ” Thank you for helping make ProxMenux a safer project for everyone!



================================================
FILE: version.txt
================================================
1.1.8


================================================
FILE: AppImage/README.md
================================================
# ProxMenux Monitor

A modern, responsive dashboard for monitoring Proxmox VE systems built with Next.js and React.

---

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Technology Stack](#technology-stack)
- [Installation](#installation)
- [Authentication & Security](#authentication--security)
  - [Setup Authentication](#setup-authentication)
  - [Two-Factor Authentication (2FA)](#two-factor-authentication-2fa)
  - [Security Best Practices for API Tokens](#security-best-practices-for-api-tokens)
- [API Documentation](#api-documentation)
  - [API Authentication](#api-authentication)
  - [Generating API Tokens](#generating-api-tokens)
  - [Available Endpoints](#available-endpoints)
- [Integration Examples](#integration-examples)
  - [Homepage Integration](#homepage-integration)
  - [Home Assistant Integration](#home-assistant-integration)
- [License](#license)

---

## Overview

**ProxMenux Monitor** is a comprehensive, real-time monitoring dashboard for Proxmox VE environments. Built with modern web technologies, it provides an intuitive interface to monitor system resources, virtual machines, containers, storage, network traffic, and system logs.

The application runs as a standalone AppImage on your Proxmox server and serves a web interface accessible from any device on your network.


## Screenshots

Get a quick overview of ProxMenux Monitor's main features:

<p align="center">
  <img src="public/images/onboarding/imagen1.png" alt="Overview Dashboard" width="800"/>
  <br/>
  <em>System Overview - Monitor CPU, memory, temperature, and uptime in real-time</em>
</p>


---

## Features

- **System Overview**: Real-time monitoring of CPU, memory, temperature, and system uptime
- **Storage Management**: Visual representation of storage distribution, disk health, and SMART data
- **Network Monitoring**: Network interface statistics, real-time traffic graphs, and bandwidth usage
- **Virtual Machines & LXC**: Comprehensive view of all VMs and containers with resource usage and controls
- **Hardware Information**: Detailed hardware specifications including CPU, GPU, PCIe devices, and disks
- **System Logs**: Real-time system log monitoring with filtering and search capabilities
- **Health Monitoring**: Proactive system health checks with persistent error tracking
- **Authentication & 2FA**: Optional password protection with TOTP-based two-factor authentication
- **RESTful API**: Complete API access for integrations with Homepage, Home Assistant, and custom dashboards
- **Dark/Light Theme**: Toggle between themes with Proxmox-inspired design
- **Responsive Design**: Works seamlessly on desktop, tablet, and mobile devices
- **Release Notes**: Automatic notifications of new features and improvements

## Technology Stack

- **Frontend**: Next.js 15, React 19, TypeScript
- **Styling**: Tailwind CSS v4 with custom Proxmox-inspired theme
- **Charts**: Recharts for data visualization
- **UI Components**: Radix UI primitives with shadcn/ui
- **Backend**: Flask (Python) server for system data collection
- **Packaging**: AppImage for easy distribution and deployment

## Installation

**ProxMenux Monitor is integrated into [ProxMenux](https://proxmenux.com) and comes enabled by default.** No manual installation is required if you're using ProxMenux.

The monitor automatically starts when ProxMenux is installed and runs as a systemd service on your Proxmox server.

### Accessing the Dashboard

You can access ProxMenux Monitor in two ways:

1. **Direct Access**: `http://your-proxmox-ip:8008`
2. **Via Proxy** (Recommended): `https://your-domain.com/proxmenux-monitor/`

**Note**: All API endpoints work seamlessly with both direct access and proxy configurations. When using a reverse proxy, the application automatically detects and adapts to the proxied environment.

### Proxy Configuration

ProxMenux Monitor includes built-in support for reverse proxy configurations. If you're using Nginx, Caddy, or Traefik, the application will automatically:

- Detect the proxy headers (`X-Forwarded-For`, `X-Forwarded-Proto`, `X-Forwarded-Host`)
- Adjust API endpoints to work correctly through the proxy
- Maintain full functionality for all features including authentication and API access



## Authentication & Security

ProxMenux Monitor includes an optional authentication system to protect your dashboard with a password and two-factor authentication.

### Setup Authentication

On first launch, you'll be presented with three options:

1. **Set up authentication** - Create a username and password to protect your dashboard
2. **Enable 2FA** - Add TOTP-based two-factor authentication for enhanced security
3. **Skip** - Continue without authentication (not recommended for production environments)

![Authentication Setup](AppImage/public/images/docs/auth-setup.png)

### Two-Factor Authentication (2FA)

After setting up your password, you can enable 2FA using any TOTP authenticator app (Google Authenticator, Authy, 1Password, etc.):

1. Navigate to **Settings > Authentication**
2. Click **Enable 2FA**
3. Scan the QR code with your authenticator app
4. Enter the 6-digit code to verify
5. Save your backup codes in a secure location

![2FA Setup](AppImage/public/images/docs/2fa-setup.png)

### Security Best Practices for API Tokens

**IMPORTANT**: Never hardcode your API tokens directly in configuration files or scripts. Instead, use environment variables or secrets management.

**Option 1: Environment Variables**

Store your token in an environment variable:

```bash
# Linux/macOS - Add to ~/.bashrc or ~/.zshrc
export PROXMENUX_API_TOKEN="your_actual_token_here"

# Windows PowerShell - Add to profile
$env:PROXMENUX_API_TOKEN = "your_actual_token_here"
```

Then reference it in your scripts:

```bash
# Linux/macOS
curl -H "Authorization: Bearer $PROXMENUX_API_TOKEN" \
  http://your-proxmox-ip:8008/api/system

# Windows PowerShell
curl -H "Authorization: Bearer $env:PROXMENUX_API_TOKEN" `
  http://your-proxmox-ip:8008/api/system
```

**Option 2: Secrets File**

Create a dedicated secrets file (make sure to add it to `.gitignore`):

```bash
# Create secrets file
echo "PROXMENUX_API_TOKEN=your_actual_token_here" > ~/.proxmenux_secrets

# Secure the file (Linux/macOS only)
chmod 600 ~/.proxmenux_secrets

# Load in your script
source ~/.proxmenux_secrets
```

**Option 3: Homepage Secrets (Recommended)**

Homepage supports secrets management. Create a `secrets.yaml` file:

```yaml
# secrets.yaml (add to .gitignore!)
proxmenux_token: "your_actual_token_here"
```

Then reference it in your `services.yaml`:

```yaml
- ProxMenux Monitor:
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/system
      headers:
        Authorization: Bearer {{HOMEPAGE_VAR_PROXMENUX_TOKEN}}
```

**Option 4: Home Assistant Secrets**

Home Assistant has built-in secrets support. Edit `secrets.yaml`:

```yaml
# secrets.yaml
proxmenux_api_token: "your_actual_token_here"
```

Then reference it in `configuration.yaml`:

```yaml
sensor:
  - platform: rest
    name: ProxMenux CPU
    resource: http://proxmox.example.tld:8008/api/system
    headers:
      Authorization: !secret proxmenux_api_token
```

**Token Security Checklist:**
- âœ… Store tokens in environment variables or secrets files
- âœ… Add secrets files to `.gitignore`
- âœ… Set proper file permissions (chmod 600 on Linux/macOS)
- âœ… Rotate tokens periodically (every 3-6 months)
- âœ… Use different tokens for different integrations
- âœ… Delete tokens you no longer use
- âŒ Never commit tokens to version control
- âŒ Never share tokens in screenshots or logs
- âŒ Never hardcode tokens in configuration files

---

## API Documentation

ProxMenux Monitor provides a comprehensive RESTful API for integrating with external services like Homepage, Home Assistant, or custom dashboards.

### API Authentication

When authentication is enabled on ProxMenux Monitor, all API endpoints (except `/api/health` and `/api/auth/*`) require a valid JWT token in the `Authorization` header.

### API Endpoint Base URL

**Direct Access:**
```
http://your-proxmox-ip:8008/api/
```

**Via Proxy:**
```
https://your-domain.com/proxmenux-monitor/api/
```

**Note**: All API examples in this documentation work with both direct and proxied URLs. Simply replace the base URL with your preferred access method.

### Generating API Tokens

To use the API with authentication enabled, you need to generate a long-lived API token.

#### Option 1: Generate via Web Panel (Recommended)

The easiest way to generate an API token is through the ProxMenux Monitor web interface:

1. Navigate to **Settings** tab in the dashboard
2. Scroll to the **API Access Tokens** section
3. Enter your password
4. If 2FA is enabled, enter your 6-digit code
5. Provide a name for the token (e.g., "Homepage Integration")
6. Click **Generate Token**
7. Copy the token immediately - it will not be shown again

![Generate API Token](AppImage/public/images/docs/generate-api-token.png)

The token will be valid for **365 days** (1 year) and can be used for integrations with Homepage, Home Assistant, or any custom application.

#### Option 2: Generate via API Call

For advanced users or automation, you can generate tokens programmatically:

```bash
curl -X POST http://your-proxmox-ip:8008/api/auth/generate-api-token \
  -H "Content-Type: application/json" \
  -d '{
    "username": "your-username",
    "password": "your-password",
    "totp_token": "123456",
    "token_name": "Homepage Integration"
  }'
```

**Response:**
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_name": "Homepage Integration",
  "expires_in": "365 days",
  "message": "API token generated successfully. Store this token securely, it will not be shown again."
}
```

**Notes:**
- If 2FA is enabled, include the `totp_token` field with your 6-digit code
- If 2FA is not enabled, omit the `totp_token` field
- The token is valid for **365 days** (1 year)
- Store the token securely - it cannot be retrieved again

#### Option 3: Generate via cURL (without 2FA)

```bash
# Without 2FA
curl -X POST http://your-proxmox-ip:8008/api/auth/generate-api-token \
  -H "Content-Type: application/json" \
  -d '{"username":"pedro","password":"your-password","token_name":"Homepage"}'
```

### Using API Tokens

Once you have your API token, include it in the `Authorization` header of all API requests:

```bash
curl -H "Authorization: Bearer YOUR_API_TOKEN_HERE" \
  http://your-proxmox-ip:8008/api/system
```

---

### Available Endpoints

Below is a complete list of all API endpoints with descriptions and example responses.

#### System & Metrics

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/system` | GET | Yes | Complete system information (CPU, memory, temperature, uptime) |
| `/api/system-info` | GET | No | Lightweight system info for header (hostname, uptime, health) |
| `/api/node/metrics` | GET | Yes | Historical metrics data (RRD) for CPU, memory, disk I/O |
| `/api/prometheus` | GET | Yes | Export metrics in Prometheus format |

**Example `/api/system` Response:**
```json
{
  "hostname": "pve",
  "cpu_usage": 15.2,
  "memory_usage": 45.8,
  "temperature": 42.5,
  "uptime": 345600,
  "kernel": "6.2.16-3-pve",
  "pve_version": "8.0.3"
}
```

#### Storage

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/storage` | GET | Yes | Complete storage information with SMART data |
| `/api/storage/summary` | GET | Yes | Optimized storage summary (without SMART) |
| `/api/proxmox-storage` | GET | Yes | Proxmox storage pools information |
| `/api/backups` | GET | Yes | List of all backup files |

**Example `/api/storage/summary` Response:**
```json
{
  "total_capacity": 1431894917120,
  "used_space": 197414092800,
  "free_space": 1234480824320,
  "usage_percentage": 13.8,
  "disks": [
    {
      "device": "/dev/sda",
      "model": "Samsung SSD 970",
      "size": "476.94 GB",
      "type": "SSD"
    }
  ]
}
```

#### Network

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/network` | GET | Yes | Complete network information for all interfaces |
| `/api/network/summary` | GET | Yes | Optimized network summary |
| `/api/network/<interface>/metrics` | GET | Yes | Historical metrics (RRD) for specific interface |

**Example `/api/network/summary` Response:**
```json
{
  "interfaces": [
    {
      "name": "vmbr0",
      "ip": "192.168.1.100",
      "state": "up",
      "rx_bytes": 1234567890,
      "tx_bytes": 987654321
    }
  ]
}
```

#### Virtual Machines & Containers

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/vms` | GET | Yes | List of all VMs and LXC containers |
| `/api/vms/<vmid>` | GET | Yes | Detailed configuration for specific VM/LXC |
| `/api/vms/<vmid>/metrics` | GET | Yes | Historical metrics (RRD) for specific VM/LXC |
| `/api/vms/<vmid>/logs` | GET | Yes | Download real logs for specific VM/LXC |
| `/api/vms/<vmid>/control` | POST | Yes | Control VM/LXC (start, stop, shutdown, reboot) |
| `/api/vms/<vmid>/config` | PUT | Yes | Update VM/LXC configuration (description/notes) |

**Example `/api/vms` Response:**
```json
{
  "vms": [
    {
      "vmid": "100",
      "name": "ubuntu-server",
      "type": "qemu",
      "status": "running",
      "cpu": 2,
      "maxcpu": 4,
      "mem": 2147483648,
      "maxmem": 4294967296,
      "uptime": 86400
    }
  ]
}
```

#### Hardware

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/hardware` | GET | Yes | Complete hardware information (CPU, GPU, PCIe, disks) |
| `/api/gpu/<slot>/realtime` | GET | Yes | Real-time monitoring for specific GPU |

**Example `/api/hardware` Response:**
```json
{
  "cpu": {
    "model": "AMD Ryzen 9 5950X",
    "cores": 16,
    "threads": 32,
    "frequency": "3.4 GHz"
  },
  "gpus": [
    {
      "slot": "0000:01:00.0",
      "vendor": "NVIDIA",
      "model": "GeForce RTX 3080",
      "driver": "nvidia"
    }
  ]
}
```

#### Logs, Events & Notifications

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/logs` | GET | Yes | System logs (journalctl) with filters |
| `/api/logs/download` | GET | Yes | Download logs as text file |
| `/api/notifications` | GET | Yes | Proxmox notification history |
| `/api/notifications/download` | GET | Yes | Download full notification log |
| `/api/events` | GET | Yes | Recent Proxmox tasks and events |
| `/api/task-log/<upid>` | GET | Yes | Full log for specific task using UPID |

**Example `/api/logs` Query Parameters:**
```
/api/logs?severity=error&since=1h&search=failed
```

#### Health Monitoring

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/health` | GET | No | Basic health check (for external monitoring) |
| `/api/health/status` | GET | Yes | Summary of system health status |
| `/api/health/details` | GET | Yes | Detailed health check results |
| `/api/health/acknowledge` | POST | Yes | Dismiss/acknowledge health warnings |
| `/api/health/active-errors` | GET | Yes | Get active persistent errors |

#### ProxMenux Optimizations

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/proxmenux/installed-tools` | GET | Yes | List of installed ProxMenux optimizations |

#### Authentication

| Endpoint | Method | Auth Required | Description |
|----------|--------|---------------|-------------|
| `/api/auth/status` | GET | No | Current authentication status |
| `/api/auth/login` | POST | No | Authenticate and receive JWT token |
| `/api/auth/generate-api-token` | POST | No | Generate long-lived API token (365 days) |
| `/api/auth/setup` | POST | No | Initial setup of username/password |
| `/api/auth/enable` | POST | No | Enable authentication |
| `/api/auth/disable` | POST | Yes | Disable authentication |
| `/api/auth/change-password` | POST | No | Change password |
| `/api/auth/totp/setup` | POST | Yes | Initialize 2FA setup |
| `/api/auth/totp/enable` | POST | Yes | Enable 2FA after verification |
| `/api/auth/totp/disable` | POST | Yes | Disable 2FA |

---

## Integration Examples

### Homepage Integration

[Homepage](https://gethomepage.dev/) is a modern, fully static, fast, secure fully proxied, highly customizable application dashboard.

#### Basic Configuration (No Authentication)

```yaml
- ProxMenux Monitor:
    href: http://proxmox.example.tld:8008/
    icon: lucide:flask-round
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/system
      refreshInterval: 10000
      mappings:
        - field: uptime
          label: Uptime
          icon: lucide:clock-4
          format: text
        - field: cpu_usage
          label: CPU
          icon: lucide:cpu
          format: percent
        - field: memory_usage
          label: RAM
          icon: lucide:memory-stick
          format: percent
        - field: temperature
          label: Temp
          icon: lucide:thermometer-sun
          format: number
          suffix: Â°C
```

#### With Authentication Enabled (Using Secrets)

First, generate an API token via the web interface (Settings > API Access Tokens) or via API.

Then, store your token securely in Homepage's `secrets.yaml`:

```yaml
# secrets.yaml (add to .gitignore!)
proxmenux_token: "your_actual_api_token_here"
```

Finally, reference the secret in your `services.yaml`:

```yaml
- ProxMenux Monitor:
    href: http://proxmox.example.tld:8008/
    icon: lucide:flask-round
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/system
      headers:
        Authorization: Bearer {{HOMEPAGE_VAR_PROXMENUX_TOKEN}}
      refreshInterval: 10000
      mappings:
        - field: uptime
          label: Uptime
          icon: lucide:clock-4
          format: text
        - field: cpu_usage
          label: CPU
          icon: lucide:cpu
          format: percent
        - field: memory_usage
          label: RAM
          icon: lucide:memory-stick
          format: percent
        - field: temperature
          label: Temp
          icon: lucide:thermometer-sun
          format: number
          suffix: Â°C
```

#### Advanced Multi-Widget Configuration

```yaml
# Store token in secrets.yaml
# proxmenux_token: "your_actual_api_token_here"

- ProxMenux System:
    href: http://proxmox.example.tld:8008/
    icon: lucide:server
    description: Proxmox VE Host
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/system
      headers:
        Authorization: Bearer {{HOMEPAGE_VAR_PROXMENUX_TOKEN}}
      refreshInterval: 5000
      mappings:
        - field: cpu_usage
          label: CPU
          icon: lucide:cpu
          format: percent
        - field: memory_usage
          label: RAM
          icon: lucide:memory-stick
          format: percent
        - field: temperature
          label: Temp
          icon: lucide:thermometer-sun
          format: number
          suffix: Â°C

- ProxMenux Storage:
    href: http://proxmox.example.tld:8008/#/storage
    icon: lucide:hard-drive
    description: Storage Overview
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/storage/summary
      headers:
        Authorization: Bearer {{HOMEPAGE_VAR_PROXMENUX_TOKEN}}
      refreshInterval: 30000
      mappings:
        - field: usage_percentage
          label: Used
          icon: lucide:database
          format: percent
        - field: used_space
          label: Space
          icon: lucide:folder
          format: bytes

- ProxMenux Network:
    href: http://proxmox.example.tld:8008/#/network
    icon: lucide:network
    description: Network Stats
    widget:
      type: customapi
      url: http://proxmox.example.tld:8008/api/network/summary
      headers:
        Authorization: Bearer {{HOMEPAGE_VAR_PROXMENUX_TOKEN}}
      refreshInterval: 5000
      mappings:
        - field: interfaces[0].rx_bytes
          label: Received
          icon: lucide:download
          format: bytes
        - field: interfaces[0].tx_bytes
          label: Sent
          icon: lucide:upload
          format: bytes
```

![Homepage Integration Example](AppImage/public/images/docs/homepage-integration.png)

### Home Assistant Integration

[Home Assistant](https://www.home-assistant.io/) is an open-source home automation platform.

#### Store Token Securely

First, add your API token to Home Assistant's `secrets.yaml`:

```yaml
# secrets.yaml
proxmenux_api_token: "Bearer your_actual_api_token_here"
```

**Note**: Include "Bearer " prefix in the secrets file for Home Assistant.

#### Configuration.yaml

```yaml
# ProxMenux Monitor Sensors
sensor:
  - platform: rest
    name: ProxMenux CPU
    resource: http://proxmox.example.tld:8008/api/system
    headers:
      Authorization: !secret proxmenux_api_token
    value_template: "{{ value_json.cpu_usage }}"
    unit_of_measurement: "%"
    scan_interval: 30

  - platform: rest
    name: ProxMenux Memory
    resource: http://proxmox.example.tld:8008/api/system
    headers:
      Authorization: !secret proxmenux_api_token
    value_template: "{{ value_json.memory_usage }}"
    unit_of_measurement: "%"
    scan_interval: 30

  - platform: rest
    name: ProxMenux Temperature
    resource: http://proxmox.example.tld:8008/api/system
    headers:
      Authorization: !secret proxmenux_api_token
    value_template: "{{ value_json.temperature }}"
    unit_of_measurement: "Â°C"
    device_class: temperature
    scan_interval: 30

  - platform: rest
    name: ProxMenux Uptime
    resource: http://proxmox.example.tld:8008/api/system
    headers:
      Authorization: !secret proxmenux_api_token
    value_template: >
      {% set uptime_seconds = value_json.uptime | int %}
      {% set days = (uptime_seconds / 86400) | int %}
      {% set hours = ((uptime_seconds % 86400) / 3600) | int %}
      {% set minutes = ((uptime_seconds % 3600) / 60) | int %}
      {{ days }}d {{ hours }}h {{ minutes }}m
    scan_interval: 60
```

#### Lovelace Card Example

```yaml
type: entities
title: Proxmox Monitor
entities:
  - entity: sensor.proxmenux_cpu
    name: CPU Usage
    icon: mdi:cpu-64-bit
  - entity: sensor.proxmenux_memory
    name: Memory Usage
    icon: mdi:memory
  - entity: sensor.proxmenux_temperature
    name: Temperature
    icon: mdi:thermometer
  - entity: sensor.proxmenux_uptime
    name: Uptime
    icon: mdi:clock-outline
```

![Home Assistant Integration Example](AppImage/public/images/docs/homeassistant-integration.png)


---

## License

This project is licensed under the **Creative Commons Attribution-NonCommercial 4.0 International License (CC BY-NC 4.0)**.

You are free to:
- Share â€” copy and redistribute the material in any medium or format
- Adapt â€” remix, transform, and build upon the material

Under the following terms:
- Attribution â€” You must give appropriate credit, provide a link to the license, and indicate if changes were made
- NonCommercial â€” You may not use the material for commercial purposes

For more details, see the [full license](https://creativecommons.org/licenses/by-nc/4.0/).



---

**ProxMenux Monitor** - Made with â¤ï¸ for the Proxmox community



================================================
FILE: AppImage/next.config.mjs
================================================
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'export',
  trailingSlash: true,
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  images: {
    unoptimized: true,
  },
  experimental: {
    esmExternals: 'loose',
  },
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
      };
    }
    return config;
  },
};

export default nextConfig;



================================================
FILE: AppImage/package.json
================================================
{
  "name": "ProxMenux-Monitor",
  "version": "1.0.2",
  "description": "Proxmox System Monitoring Dashboard",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "export": "next build"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@radix-ui/react-accordion": "1.2.2",
    "@radix-ui/react-alert-dialog": "1.1.4",
    "@radix-ui/react-aspect-ratio": "1.1.1",
    "@radix-ui/react-avatar": "1.1.2",
    "@radix-ui/react-checkbox": "1.1.3",
    "@radix-ui/react-collapsible": "1.1.2",
    "@radix-ui/react-context-menu": "2.2.4",
    "@radix-ui/react-dialog": "1.1.4",
    "@radix-ui/react-dropdown-menu": "2.1.4",
    "@radix-ui/react-hover-card": "1.1.4",
    "@radix-ui/react-label": "2.1.1",
    "@radix-ui/react-menubar": "1.1.4",
    "@radix-ui/react-navigation-menu": "1.2.3",
    "@radix-ui/react-popover": "1.1.4",
    "@radix-ui/react-progress": "1.1.1",
    "@radix-ui/react-radio-group": "1.2.2",
    "@radix-ui/react-scroll-area": "1.2.2",
    "@radix-ui/react-select": "2.1.4",
    "@radix-ui/react-separator": "1.1.1",
    "@radix-ui/react-slider": "1.2.2",
    "@radix-ui/react-slot": "1.1.1",
    "@radix-ui/react-switch": "1.1.2",
    "@radix-ui/react-tabs": "1.1.2",
    "@radix-ui/react-toast": "1.2.4",
    "@radix-ui/react-toggle": "1.1.1",
    "@radix-ui/react-toggle-group": "1.1.1",
    "@radix-ui/react-tooltip": "1.1.6",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "1.0.4",
    "date-fns": "4.1.0",
    "embla-carousel-react": "8.5.1",
    "geist": "^1.3.1",
    "input-otp": "1.4.1",
    "lucide-react": "^0.454.0",
    "next": "15.1.6",
    "next-themes": "^0.4.6",
    "react": "^19",
    "react-day-picker": "9.8.0",
    "react-dom": "^19",
    "react-hook-form": "^7.60.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "2.15.4",
    "socket.io-client": "^4.8.1",
    "sonner": "^1.7.4",
    "swr": "^2.2.5",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.9",
    "xterm": "^5.3.0",
    "xterm-addon-fit": "^0.8.0",
    "zod": "3.25.67"
  },
  "devDependencies": {
    "@types/node": "^22",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.20",
    "postcss": "^8.5",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}



================================================
FILE: AppImage/postcss.config.mjs
================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;



================================================
FILE: AppImage/ProxMenux-Monitor.AppImage.sha256
================================================
f35de512c1a19843d15a9a3263a5104759d041ffc9d01249450babe0b0c3f889  ProxMenux-1.0.1.AppImage



================================================
FILE: AppImage/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./app/**/*.{ts,tsx,js,jsx}",
    "./components/**/*.{ts,tsx,js,jsx}",
    "./pages/**/*.{ts,tsx,js,jsx}",
    "./src/**/*.{ts,tsx,js,jsx}",
  ],
  darkMode: "class",
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",

        card: "var(--card)",
        "card-foreground": "var(--card-foreground)",

        popover: "var(--popover)",
        "popover-foreground": "var(--popover-foreground)",

        primary: "var(--primary)",
        "primary-foreground": "var(--primary-foreground)",

        secondary: "var(--secondary)",
        "secondary-foreground": "var(--secondary-foreground)",

        muted: "var(--muted)",
        "muted-foreground": "var(--muted-foreground)",

        accent: "var(--accent)",
        "accent-foreground": "var(--accent-foreground)",

        destructive: "var(--destructive)",
        "destructive-foreground": "var(--destructive-foreground)",

        border: "var(--border)",
        input: "var(--input)",
        ring: "var(--ring)",

        "chart-1": "var(--chart-1)",
        "chart-2": "var(--chart-2)",
        "chart-3": "var(--chart-3)",
        "chart-4": "var(--chart-4)",
        "chart-5": "var(--chart-5)",

        sidebar: "var(--sidebar)",
        "sidebar-foreground": "var(--sidebar-foreground)",
        "sidebar-primary": "var(--sidebar-primary)",
        "sidebar-primary-foreground": "var(--sidebar-primary-foreground)",
        "sidebar-accent": "var(--sidebar-accent)",
        "sidebar-accent-foreground": "var(--sidebar-accent-foreground)",
        "sidebar-border": "var(--sidebar-border)",
        "sidebar-ring": "var(--sidebar-ring)",
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
        xl: "calc(var(--radius) + 4px)",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
};



================================================
FILE: AppImage/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: AppImage/app/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* ===================== */
/* Light Mode (default)  */
/* ===================== */
:root {
  --background: oklch(1 0 0);              /* blanco */
  --foreground: oklch(0.145 0 0);          /* casi negro */

  --card: oklch(1 0 0);
  --card-foreground: var(--foreground);

  --popover: var(--card);
  --popover-foreground: var(--foreground);

  --primary: oklch(0.205 0 0);             /* gris oscuro */
  --primary-foreground: oklch(0.985 0 0);  /* blanco */

  --secondary: oklch(0.97 0 0);
  --secondary-foreground: var(--primary);

  --muted: oklch(0.97 0 0);
  --muted-foreground: oklch(0.556 0 0);    /* gris medio */

  --accent: oklch(0.97 0 0);
  --accent-foreground: var(--primary);

  --destructive: oklch(0.577 0.245 27.325);
  --destructive-foreground: oklch(0.145 0 0);

  --border: oklch(0.922 0 0);
  --input: var(--border);
  --ring: oklch(0.708 0 0);

  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);

  --radius: 0.625rem;

  --sidebar: oklch(0.985 0 0);
  --sidebar-foreground: var(--foreground);
  --sidebar-primary: var(--primary);
  --sidebar-primary-foreground: oklch(0.985 0 0);
  --sidebar-accent: oklch(0.97 0 0);
  --sidebar-accent-foreground: var(--primary);
  --sidebar-border: var(--border);
  --sidebar-ring: var(--ring);
}

/* ===================== */
/* Dark Mode (gris)      */
/* ===================== */
.dark {
  --background: oklch(0.22 0 0);           /* gris oscuro */
  --foreground: oklch(0.97 0 0);           /* blanco/gris claro */

  --card: oklch(0.24 0 0);
  --card-foreground: var(--foreground);

  --popover: var(--card);
  --popover-foreground: var(--foreground);

  --primary: oklch(0.83 0 0);              /* casi blanco */
  --primary-foreground: var(--background);

  --secondary: oklch(0.28 0 0);
  --secondary-foreground: oklch(0.92 0 0);

  --muted: oklch(0.26 0 0);
  --muted-foreground: oklch(0.72 0 0);

  --accent: oklch(0.28 0 0);
  --accent-foreground: var(--primary);

  --destructive: oklch(0.53 0.25 27);
  --destructive-foreground: oklch(0.9 0 0);

  --border: oklch(0.34 0 0);
  --input: var(--border);
  --ring: oklch(0.55 0 0);

  --chart-1: oklch(0.60 0.20 255);
  --chart-2: oklch(0.70 0.16 165);
  --chart-3: oklch(0.76 0.19 70);
  --chart-4: oklch(0.63 0.25 305);
  --chart-5: oklch(0.66 0.24 20);

  --sidebar: oklch(0.24 0 0);
  --sidebar-foreground: var(--foreground);
  --sidebar-primary: var(--chart-1);
  --sidebar-primary-foreground: var(--foreground);
  --sidebar-accent: oklch(0.28 0 0);
  --sidebar-accent-foreground: var(--foreground);
  --sidebar-border: var(--border);
  --sidebar-ring: var(--ring);
}

/* ===================== */
/* Base layer            */
/* ===================== */
@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply bg-background text-foreground;
  }

  /* Foco accesible */
  :is(button,[role="button"],a,input,select,textarea,[tabindex]:not([tabindex="-1"])):focus {
    @apply outline-none;
  }
  :is(button,[role="button"],a,input,select,textarea,[tabindex]:not([tabindex="-1"])):focus-visible {
    @apply ring-2;
    --tw-ring-color: var(--ring);
    --tw-ring-opacity: 0.5; /* equivalente al /50 */
  }
}

/* ===================== */
/* Ajustes para Charts   */
/* ===================== */
@layer components {
  /* Recharts axis */
  .recharts-cartesian-axis-tick tspan {
    fill: var(--muted-foreground);
  }
  .recharts-cartesian-axis-line,
  .recharts-cartesian-grid line {
    stroke: var(--border);
  }

  /* Chart.js axis */
  .chartjs-render-monitor text {
    fill: var(--muted-foreground);
  }
  .chartjs-render-monitor line {
    stroke: var(--border);
  }
}

/* ===================== */
/* Ajustes para xterm.js */
/* ===================== */

/* Quitar padding para que la terminal ocupe el 100% del ancho */
.xterm {
  padding: 0 !important;
}

/* Por si acaso el viewport aÃ±ade padding extra */
.xterm .xterm-viewport {
  padding: 0 !important;
}

/* Opcional: asegurar que no haya margen raro */
.xterm-rows {
  margin: 0 !important;
}



================================================
FILE: AppImage/app/layout.tsx
================================================
import type React from "react"
import type { Metadata } from "next"
import { GeistSans } from "geist/font/sans"
import { GeistMono } from "geist/font/mono"
import { ThemeProvider } from "../components/theme-provider"
import { Suspense } from "react"
import "./globals.css"

export const metadata: Metadata = {
  title: "ProxMenux Monitor",
  description: "Proxmox System Dashboard and Monitor",
  generator: "v0.app",
  manifest: "/manifest.json",
  icons: {
    icon: [
      { url: "/favicon.ico", sizes: "any" },
      { url: "/icon.svg", type: "image/svg+xml" },
      { url: "/icon.png", type: "image/png", sizes: "32x32" },
    ],
    shortcut: "/favicon.ico",
    apple: [{ url: "/apple-touch-icon.png", sizes: "180x180", type: "image/png" }],
  },
  viewport: "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no",
  themeColor: [
    { media: "(prefers-color-scheme: light)", color: "#ffffff" },
    { media: "(prefers-color-scheme: dark)", color: "#2b2f36" },
  ],
}

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${GeistSans.variable} ${GeistMono.variable} antialiased bg-background text-foreground`}>
        <Suspense fallback={<div>Loading...</div>}>
          <ThemeProvider attribute="class" defaultTheme="dark" enableSystem disableTransitionOnChange>
            {children}
          </ThemeProvider>
        </Suspense>
      </body>
    </html>
  )
}



================================================
FILE: AppImage/app/page.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { ProxmoxDashboard } from "../components/proxmox-dashboard"
import { Login } from "../components/login"
import { AuthSetup } from "../components/auth-setup"
import { getApiUrl } from "../lib/api-config"

export default function Home() {
  const [authStatus, setAuthStatus] = useState<{
    loading: boolean
    authEnabled: boolean
    authConfigured: boolean
    authenticated: boolean
  }>({
    loading: true,
    authEnabled: false,
    authConfigured: false,
    authenticated: false,
  })

  useEffect(() => {
    checkAuthStatus()
  }, [])

  const checkAuthStatus = async () => {
    try {
      const token = localStorage.getItem("proxmenux-auth-token")
      const response = await fetch(getApiUrl("/api/auth/status"), {
        headers: token ? { Authorization: `Bearer ${token}` } : {},
      })
      const data = await response.json()

      console.log("[v0] Auth status:", data)

      const authenticated = data.auth_enabled ? data.authenticated : true

      setAuthStatus({
        loading: false,
        authEnabled: data.auth_enabled,
        authConfigured: data.auth_configured,
        authenticated,
      })
    } catch (error) {
      console.error("[v0] Failed to check auth status:", error)
      setAuthStatus({
        loading: false,
        authEnabled: false,
        authConfigured: false,
        authenticated: true,
      })
    }
  }

  const handleAuthComplete = () => {
    checkAuthStatus()
  }

  const handleLoginSuccess = () => {
    checkAuthStatus()
  }

  if (authStatus.loading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center space-y-4">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    )
  }

  if (authStatus.authEnabled && !authStatus.authenticated) {
    return <Login onLogin={handleLoginSuccess} />
  }

  // Show dashboard in all other cases
  return (
    <>
      {!authStatus.authConfigured && <AuthSetup onComplete={handleAuthComplete} />}
      <ProxmoxDashboard />
    </>
  )
}



================================================
FILE: AppImage/app/dashboard/page.tsx
================================================
import { ProxmoxDashboard } from "../../components/proxmox-dashboard"

export default function DashboardPage() {
  return (
    <main className="min-h-screen bg-background">
      <ProxmoxDashboard />
    </main>
  )
}



================================================
FILE: AppImage/app/hardware/page.tsx
================================================
import Hardware from "@/components/hardware"

export default function HardwarePage() {
  return <Hardware />
}



================================================
FILE: AppImage/components/auth-setup.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Button } from "./ui/button"
import { Dialog, DialogContent, DialogTitle } from "./ui/dialog"
import { Input } from "./ui/input"
import { Label } from "./ui/label"
import { Shield, Lock, User, AlertCircle, Eye, EyeOff } from "lucide-react"
import { getApiUrl } from "../lib/api-config"

interface AuthSetupProps {
  onComplete: () => void
}

export function AuthSetup({ onComplete }: AuthSetupProps) {
  const [open, setOpen] = useState(false)
  const [step, setStep] = useState<"choice" | "setup">("choice")
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [confirmPassword, setConfirmPassword] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [showPassword, setShowPassword] = useState(false)
  const [showConfirmPassword, setShowConfirmPassword] = useState(false)

  useEffect(() => {
    const checkOnboardingStatus = async () => {
      try {
        const response = await fetch(getApiUrl("/api/auth/status"))
        const data = await response.json()

        console.log("[v0] Auth status for modal check:", data)

        // Show modal if auth is not configured and not declined
        if (!data.auth_configured) {
          setTimeout(() => setOpen(true), 500)
        }
      } catch (error) {
        console.error("[v0] Failed to check auth status:", error)
        // Fail-safe: show modal if we can't check status
        setTimeout(() => setOpen(true), 500)
      }
    }

    checkOnboardingStatus()
  }, [])

  const handleSkipAuth = async () => {
    setLoading(true)
    setError("")

    try {
      console.log("[v0] Skipping authentication setup...")
      const response = await fetch(getApiUrl("/api/auth/skip"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
      })

      const data = await response.json()
      console.log("[v0] Auth skip response:", data)

      if (!response.ok) {
        throw new Error(data.error || "Failed to skip authentication")
      }

      if (data.auth_declined) {
        console.log("[v0] Authentication skipped successfully - APIs should be accessible without token")
      }

      console.log("[v0] Authentication skipped successfully")
      localStorage.setItem("proxmenux-auth-declined", "true")
      localStorage.removeItem("proxmenux-auth-token") // Remove any old token
      setOpen(false)
      onComplete()
    } catch (err) {
      console.error("[v0] Auth skip error:", err)
      setError(err instanceof Error ? err.message : "Failed to save preference")
    } finally {
      setLoading(false)
    }
  }

  const handleSetupAuth = async () => {
    setError("")

    if (!username || !password) {
      setError("Please fill in all fields")
      return
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match")
      return
    }

    if (password.length < 6) {
      setError("Password must be at least 6 characters")
      return
    }

    setLoading(true)

    try {
      console.log("[v0] Setting up authentication...")
      const response = await fetch(getApiUrl("/api/auth/setup"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          username,
          password,
        }),
      })

      const data = await response.json()
      console.log("[v0] Auth setup response:", data)

      if (!response.ok) {
        throw new Error(data.error || "Failed to setup authentication")
      }

      if (data.token) {
        localStorage.setItem("proxmenux-auth-token", data.token)
        localStorage.removeItem("proxmenux-auth-declined")
        console.log("[v0] Authentication setup successful")
      }

      setOpen(false)
      onComplete()
    } catch (err) {
      console.error("[v0] Auth setup error:", err)
      setError(err instanceof Error ? err.message : "Failed to setup authentication")
    } finally {
      setLoading(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogContent className="max-w-md max-h-[90vh] overflow-y-auto">
        <DialogTitle className="sr-only">
          {step === "choice" ? "Setup Dashboard Protection" : "Create Password"}
        </DialogTitle>
        {step === "choice" ? (
          <div className="space-y-6 py-2">
            <div className="text-center space-y-2">
              <div className="mx-auto w-16 h-16 bg-blue-500/10 rounded-full flex items-center justify-center">
                <Shield className="h-8 w-8 text-blue-500" />
              </div>
              <h2 className="text-2xl font-bold">Protect Your Dashboard?</h2>
              <p className="text-muted-foreground text-sm">
                Add an extra layer of security to protect your Proxmox data when accessing from non-private networks.
              </p>
            </div>

            <div className="space-y-3">
              <Button onClick={() => setStep("setup")} className="w-full bg-blue-500 hover:bg-blue-600" size="lg">
                <Lock className="h-4 w-4 mr-2" />
                Yes, Setup Password
              </Button>
              <Button
                onClick={handleSkipAuth}
                variant="outline"
                className="w-full bg-transparent"
                size="lg"
                disabled={loading}
              >
                No, Continue Without Protection
              </Button>
            </div>

            <p className="text-xs text-center text-muted-foreground">You can always enable this later in Settings</p>
          </div>
        ) : (
          <div className="space-y-6 py-2">
            <div className="text-center space-y-2">
              <div className="mx-auto w-16 h-16 bg-blue-500/10 rounded-full flex items-center justify-center">
                <Lock className="h-8 w-8 text-blue-500" />
              </div>
              <h2 className="text-2xl font-bold">Setup Authentication</h2>
              <p className="text-muted-foreground text-sm">Create a username and password to protect your dashboard</p>
            </div>

            {error && (
              <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3 flex items-start gap-2">
                <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-red-500">{error}</p>
              </div>
            )}

            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="username" className="text-sm">
                  Username
                </Label>
                <div className="relative">
                  <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="username"
                    type="text"
                    placeholder="Enter username"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    className="pl-10 text-base"
                    disabled={loading}
                    autoComplete="username"
                  />
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="password" className="text-sm">
                  Password
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="password"
                    type={showPassword ? "text" : "password"}
                    placeholder="Enter password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="pl-10 text-base"
                    disabled={loading}
                    autoComplete="new-password"
                  />
                  <Button
                    variant="ghost"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute right-3 top-1/2 -translate-y-1/2"
                    disabled={loading}
                  >
                    {showPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </Button>
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="confirm-password" className="text-sm">
                  Confirm Password
                </Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="confirm-password"
                    type={showConfirmPassword ? "text" : "password"}
                    placeholder="Confirm password"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="pl-10 text-base"
                    disabled={loading}
                    autoComplete="new-password"
                  />
                  <Button
                    variant="ghost"
                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    className="absolute right-3 top-1/2 -translate-y-1/2"
                    disabled={loading}
                  >
                    {showConfirmPassword ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                  </Button>
                </div>
              </div>
            </div>

            <div className="space-y-2">
              <Button onClick={handleSetupAuth} className="w-full bg-blue-500 hover:bg-blue-600" disabled={loading}>
                {loading ? "Setting up..." : "Setup Authentication"}
              </Button>
              <Button onClick={() => setStep("choice")} variant="ghost" className="w-full" disabled={loading}>
                Back
              </Button>
            </div>
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: AppImage/components/hardware-monitor.tsx
================================================
import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card"
import { Cpu } from "@/components/icons/cpu" // Added import for Cpu
import type { PCIDevice } from "../types/hardware" // Fixed import to use relative path instead of alias
import { Progress } from "@/components/ui/progress"

function GPUCard({ device }: { device: PCIDevice }) {
  const hasMonitoring = device.gpu_temperature !== undefined || device.gpu_utilization !== undefined

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Cpu className="h-5 w-5" />
          {device.device}
        </CardTitle>
        <CardDescription>{device.vendor}</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="grid grid-cols-2 gap-4 text-sm">
          <div>
            <div className="text-muted-foreground">Slot</div>
            <div className="font-medium">{device.slot}</div>
          </div>
          {device.driver && (
            <div>
              <div className="text-muted-foreground">Driver</div>
              <div className="font-medium">{device.driver}</div>
            </div>
          )}
          {device.gpu_driver_version && (
            <div>
              <div className="text-muted-foreground">Driver Version</div>
              <div className="font-medium">{device.gpu_driver_version}</div>
            </div>
          )}
          {device.gpu_memory && (
            <div>
              <div className="text-muted-foreground">Memory</div>
              <div className="font-medium">{device.gpu_memory}</div>
            </div>
          )}
          {device.gpu_compute_capability && (
            <div>
              <div className="text-muted-foreground">Compute Capability</div>
              <div className="font-medium">{device.gpu_compute_capability}</div>
            </div>
          )}
        </div>

        {hasMonitoring && (
          <div className="space-y-3 pt-4 border-t">
            <h4 className="text-sm font-semibold">Real-time Monitoring</h4>

            {device.gpu_temperature !== undefined && (
              <div className="space-y-1">
                <div className="flex justify-between text-sm">
                  <span className="text-muted-foreground">Temperature</span>
                  <span className="font-medium">{device.gpu_temperature}Â°C</span>
                </div>
                <Progress value={(device.gpu_temperature / 100) * 100} className="h-2" />
              </div>
            )}

            {device.gpu_utilization !== undefined && (
              <div className="space-y-1">
                <div className="flex justify-between text-sm">
                  <span className="text-muted-foreground">GPU Utilization</span>
                  <span className="font-medium">{device.gpu_utilization}%</span>
                </div>
                <Progress value={device.gpu_utilization} className="h-2" />
              </div>
            )}

            {device.gpu_memory_used && device.gpu_memory_total && (
              <div className="space-y-1">
                <div className="flex justify-between text-sm">
                  <span className="text-muted-foreground">Memory Usage</span>
                  <span className="font-medium">
                    {device.gpu_memory_used} / {device.gpu_memory_total}
                  </span>
                </div>
                <Progress
                  value={(Number.parseInt(device.gpu_memory_used) / Number.parseInt(device.gpu_memory_total)) * 100}
                  className="h-2"
                />
              </div>
            )}

            {device.gpu_power_draw && (
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">Power Draw</span>
                <span className="font-medium">{device.gpu_power_draw}</span>
              </div>
            )}

            {device.gpu_clock_speed && (
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">GPU Clock</span>
                <span className="font-medium">{device.gpu_clock_speed}</span>
              </div>
            )}

            {device.gpu_memory_clock && (
              <div className="flex justify-between text-sm">
                <span className="text-muted-foreground">Memory Clock</span>
                <span className="font-medium">{device.gpu_memory_clock}</span>
              </div>
            )}
          </div>
        )}
      </CardContent>
    </Card>
  )
}



================================================
FILE: AppImage/components/health-status-modal.tsx
================================================
"use client"

import type React from "react"

import { useState, useEffect } from "react"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { Badge } from "@/components/ui/badge"
import { Button } from "@/components/ui/button"
import {
  Loader2,
  CheckCircle2,
  AlertTriangle,
  XCircle,
  Activity,
  Cpu,
  MemoryStick,
  HardDrive,
  Disc,
  Network,
  Box,
  Settings,
  FileText,
  RefreshCw,
  Shield,
  X,
} from "lucide-react"

interface CategoryCheck {
  status: string
  reason?: string
  details?: any
  dismissable?: boolean
  [key: string]: any
}

interface HealthDetails {
  overall: string
  summary: string
  details: {
    cpu: CategoryCheck
    memory: CategoryCheck
    storage: CategoryCheck
    disks: CategoryCheck
    network: CategoryCheck
    vms: CategoryCheck
    services: CategoryCheck
    logs: CategoryCheck
    updates: CategoryCheck
    security: CategoryCheck
  }
  timestamp: string
}

interface HealthStatusModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  getApiUrl: (path: string) => string
}

const CATEGORIES = [
  { key: "cpu", label: "CPU Usage & Temperature", Icon: Cpu },
  { key: "memory", label: "Memory & Swap", Icon: MemoryStick },
  { key: "storage", label: "Storage Mounts & Space", Icon: HardDrive },
  { key: "disks", label: "Disk I/O & Errors", Icon: Disc },
  { key: "network", label: "Network Interfaces", Icon: Network },
  { key: "vms", label: "VMs & Containers", Icon: Box },
  { key: "services", label: "PVE Services", Icon: Settings },
  { key: "logs", label: "System Logs", Icon: FileText },
  { key: "updates", label: "System Updates", Icon: RefreshCw },
  { key: "security", label: "Security & Certificates", Icon: Shield },
]

export function HealthStatusModal({ open, onOpenChange, getApiUrl }: HealthStatusModalProps) {
  const [loading, setLoading] = useState(true)
  const [healthData, setHealthData] = useState<HealthDetails | null>(null)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    if (open) {
      fetchHealthDetails()
    }
  }, [open])

  const fetchHealthDetails = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(getApiUrl("/api/health/details"))
      if (!response.ok) {
        throw new Error("Failed to fetch health details")
      }
      const data = await response.json()
      console.log("[v0] Health data received:", data)
      setHealthData(data)

      const event = new CustomEvent("healthStatusUpdated", {
        detail: { status: data.overall },
      })
      window.dispatchEvent(event)
    } catch (err) {
      console.error("[v0] Error fetching health data:", err)
      setError(err instanceof Error ? err.message : "Unknown error")
    } finally {
      setLoading(false)
    }
  }

  const getStatusIcon = (status: string) => {
    const statusUpper = status?.toUpperCase()
    switch (statusUpper) {
      case "OK":
        return <CheckCircle2 className="h-5 w-5 text-green-500" />
      case "WARNING":
        return <AlertTriangle className="h-5 w-5 text-yellow-500" />
      case "CRITICAL":
        return <XCircle className="h-5 w-5 text-red-500" />
      default:
        return <Activity className="h-5 w-5 text-gray-500" />
    }
  }

  const getStatusBadge = (status: string) => {
    const statusUpper = status?.toUpperCase()
    switch (statusUpper) {
      case "OK":
        return <Badge className="bg-green-500 text-white hover:bg-green-500">OK</Badge>
      case "WARNING":
        return <Badge className="bg-yellow-500 text-white hover:bg-yellow-500">Warning</Badge>
      case "CRITICAL":
        return <Badge className="bg-red-500 text-white hover:bg-red-500">Critical</Badge>
      default:
        return <Badge>Unknown</Badge>
    }
  }

  const getHealthStats = () => {
    if (!healthData?.details) {
      return { total: 0, healthy: 0, warnings: 0, critical: 0 }
    }

    let healthy = 0
    let warnings = 0
    let critical = 0

    CATEGORIES.forEach(({ key }) => {
      const categoryData = healthData.details[key as keyof typeof healthData.details]
      if (categoryData) {
        const status = categoryData.status?.toUpperCase()
        if (status === "OK") healthy++
        else if (status === "WARNING") warnings++
        else if (status === "CRITICAL") critical++
      }
    })

    return { total: CATEGORIES.length, healthy, warnings, critical }
  }

  const stats = getHealthStats()

  const handleCategoryClick = (categoryKey: string, status: string) => {
    if (status === "OK") return // No navegar si estÃ¡ OK

    onOpenChange(false) // Cerrar el modal

    // Mapear categorÃ­as a tabs
    const categoryToTab: Record<string, string> = {
      storage: "storage",
      disks: "storage",
      network: "network",
      vms: "vms",
      logs: "logs",
      hardware: "hardware",
      services: "hardware",
    }

    const targetTab = categoryToTab[categoryKey]
    if (targetTab) {
      // Disparar evento para cambiar tab
      const event = new CustomEvent("changeTab", { detail: { tab: targetTab } })
      window.dispatchEvent(event)
    }
  }

  const handleAcknowledge = async (errorKey: string, e: React.MouseEvent) => {
    e.stopPropagation() // Prevent navigation

    console.log("[v0] Dismissing error:", errorKey)

    try {
      const response = await fetch(getApiUrl("/api/health/acknowledge"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ error_key: errorKey }),
      })

      if (!response.ok) {
        const errorData = await response.json()
        console.error("[v0] Acknowledge failed:", errorData)
        throw new Error(errorData.error || "Failed to acknowledge error")
      }

      const result = await response.json()
      console.log("[v0] Acknowledge success:", result)

      // Refresh health data
      await fetchHealthDetails()
    } catch (err) {
      console.error("[v0] Error acknowledging:", err)
      alert("Failed to dismiss error. Please try again.")
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-3xl max-h-[85vh] overflow-y-auto">
        <DialogHeader>
          <div className="flex items-center justify-between gap-3">
            <DialogTitle className="flex items-center gap-2 flex-1">
              <Activity className="h-6 w-6" />
              System Health Status
              {healthData && <div className="ml-2">{getStatusBadge(healthData.overall)}</div>}
            </DialogTitle>
          </div>
          <DialogDescription>Detailed health checks for all system components</DialogDescription>
        </DialogHeader>

        {loading && (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
          </div>
        )}

        {error && (
          <div className="rounded-lg border border-red-200 bg-red-50 p-4 text-red-800 dark:bg-red-950 dark:border-red-800 dark:text-red-200">
            <p className="font-medium">Error loading health status</p>
            <p className="text-sm">{error}</p>
          </div>
        )}

        {healthData && !loading && (
          <div className="space-y-4">
            {/* Overall Stats Summary */}
            <div className="grid grid-cols-4 gap-3 p-4 rounded-lg bg-muted/30 border">
              <div className="text-center">
                <div className="text-2xl font-bold">{stats.total}</div>
                <div className="text-xs text-muted-foreground">Total Checks</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-green-500">{stats.healthy}</div>
                <div className="text-xs text-muted-foreground">Healthy</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-yellow-500">{stats.warnings}</div>
                <div className="text-xs text-muted-foreground">Warnings</div>
              </div>
              <div className="text-center">
                <div className="text-2xl font-bold text-red-500">{stats.critical}</div>
                <div className="text-xs text-muted-foreground">Critical</div>
              </div>
            </div>

            {healthData.summary && healthData.summary !== "All systems operational" && (
              <div className="text-sm p-3 rounded-lg bg-muted/20 border">
                <span className="font-medium text-foreground">{healthData.summary}</span>
              </div>
            )}

            <div className="space-y-2">
              {CATEGORIES.map(({ key, label, Icon }) => {
                const categoryData = healthData.details[key as keyof typeof healthData.details]
                const status = categoryData?.status || "UNKNOWN"
                const reason = categoryData?.reason
                const details = categoryData?.details

                return (
                  <div
                    key={key}
                    onClick={() => handleCategoryClick(key, status)}
                    className={`flex items-start gap-3 p-3 rounded-lg border transition-colors ${
                      status === "OK"
                        ? "bg-card border-border hover:bg-muted/30"
                        : status === "WARNING"
                          ? "bg-yellow-500/5 border-yellow-500/20 hover:bg-yellow-500/10 cursor-pointer"
                          : status === "CRITICAL"
                            ? "bg-red-500/5 border-red-500/20 hover:bg-red-500/10 cursor-pointer"
                            : "bg-muted/30 hover:bg-muted/50"
                    }`}
                  >
                    <div className="mt-0.5 flex-shrink-0 flex items-center gap-2">
                      <Icon className="h-4 w-4 text-blue-500" />
                      {getStatusIcon(status)}
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center justify-between gap-2 mb-1">
                        <p className="font-medium text-sm">{label}</p>
                        <Badge
                          variant="outline"
                          className={`shrink-0 text-xs ${
                            status === "OK"
                              ? "border-green-500 text-green-500 bg-transparent"
                              : status === "WARNING"
                                ? "border-yellow-500 text-yellow-500 bg-yellow-500/5"
                                : status === "CRITICAL"
                                  ? "border-red-500 text-red-500 bg-red-500/5"
                                  : ""
                          }`}
                        >
                          {status}
                        </Badge>
                      </div>
                      {reason && <p className="text-xs text-muted-foreground mt-1">{reason}</p>}
                      {details && typeof details === "object" && (
                        <div className="mt-2 space-y-1">
                          {Object.entries(details).map(([detailKey, detailValue]: [string, any]) => {
                            if (typeof detailValue === "object" && detailValue !== null) {
                              const isDismissable = detailValue.dismissable !== false

                              return (
                                <div
                                  key={detailKey}
                                  className="flex items-start justify-between gap-2 text-xs pl-3 border-l-2 border-muted py-1"
                                >
                                  <div className="flex-1">
                                    <span className="font-medium">{detailKey}:</span>
                                    {detailValue.reason && (
                                      <span className="ml-1 text-muted-foreground">{detailValue.reason}</span>
                                    )}
                                  </div>
                                  {(status === "WARNING" || status === "CRITICAL") && isDismissable && (
                                    <Button
                                      size="sm"
                                      variant="outline"
                                      className="h-6 px-2 shrink-0 hover:bg-red-500/10 hover:border-red-500/50 bg-transparent"
                                      onClick={(e) => handleAcknowledge(detailKey, e)}
                                    >
                                      <X className="h-3 w-3 mr-1" />
                                      <span className="text-xs">Dismiss</span>
                                    </Button>
                                  )}
                                </div>
                              )
                            }
                            return null
                          })}
                        </div>
                      )}
                    </div>
                  </div>
                )
              })}
            </div>

            {healthData.timestamp && (
              <div className="text-xs text-muted-foreground text-center pt-2">
                Last updated: {new Date(healthData.timestamp).toLocaleString()}
              </div>
            )}
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: AppImage/components/login.tsx
================================================
"use client"

import type React from "react"

import { useState, useEffect } from "react"
import { Button } from "./ui/button"
import { Input } from "./ui/input"
import { Label } from "./ui/label"
import { Checkbox } from "./ui/checkbox"
import { Lock, User, AlertCircle, Server, Shield } from "lucide-react"
import { getApiUrl } from "../lib/api-config"
import Image from "next/image"

interface LoginProps {
  onLogin: () => void
}

export function Login({ onLogin }: LoginProps) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [totpCode, setTotpCode] = useState("")
  const [requiresTotp, setRequiresTotp] = useState(false)
  const [rememberMe, setRememberMe] = useState(false)
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)

  useEffect(() => {
    const savedUsername = localStorage.getItem("proxmenux-saved-username")
    const savedPassword = localStorage.getItem("proxmenux-saved-password")

    if (savedUsername && savedPassword) {
      setUsername(savedUsername)
      setPassword(savedPassword)
      setRememberMe(true)
    }
  }, [])

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault()
    setError("")

    if (!username || !password) {
      setError("Please enter username and password")
      return
    }

    if (requiresTotp && !totpCode) {
      setError("Please enter your 2FA code")
      return
    }

    setLoading(true)

    try {
      const response = await fetch(getApiUrl("/api/auth/login"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          username,
          password,
          totp_token: totpCode || undefined, // Include 2FA code if provided
        }),
      })

      const data = await response.json()

      if (data.requires_totp) {
        setRequiresTotp(true)
        setLoading(false)
        return
      }

      if (!response.ok) {
        throw new Error(data.message || "Login failed")
      }

      localStorage.setItem("proxmenux-auth-token", data.token)

      if (rememberMe) {
        localStorage.setItem("proxmenux-saved-username", username)
        localStorage.setItem("proxmenux-saved-password", password)
      } else {
        localStorage.removeItem("proxmenux-saved-username")
        localStorage.removeItem("proxmenux-saved-password")
      }

      onLogin()
    } catch (err) {
      setError(err instanceof Error ? err.message : "Login failed")
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-background flex items-center justify-center p-4">
      <div className="w-full max-w-md space-y-8">
        <div className="text-center space-y-4">
          <div className="flex justify-center">
            <div className="w-20 h-20 relative flex items-center justify-center bg-primary/10 rounded-lg">
              <Image
                src="/images/proxmenux-logo.png"
                alt="ProxMenux Logo"
                width={80}
                height={80}
                className="object-contain"
                priority
                onError={(e) => {
                  const target = e.target as HTMLImageElement
                  target.style.display = "none"
                  const fallback = target.parentElement?.querySelector(".fallback-icon")
                  if (fallback) {
                    fallback.classList.remove("hidden")
                  }
                }}
              />
              <Server className="h-12 w-12 text-primary absolute fallback-icon hidden" />
            </div>
          </div>
          <div>
            <h1 className="text-3xl font-bold">ProxMenux Monitor</h1>
            <p className="text-muted-foreground mt-2">Sign in to access your dashboard</p>
          </div>
        </div>

        <div className="bg-card border border-border rounded-lg p-6 shadow-lg">
          <form onSubmit={handleLogin} className="space-y-4">
            {error && (
              <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3 flex items-start gap-2">
                <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-red-500">{error}</p>
              </div>
            )}

            {!requiresTotp ? (
              <>
                <div className="space-y-2">
                  <Label htmlFor="login-username" className="text-sm">
                    Username
                  </Label>
                  <div className="relative">
                    <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      id="login-username"
                      type="text"
                      placeholder="Enter your username"
                      value={username}
                      onChange={(e) => setUsername(e.target.value)}
                      className="pl-10 text-base"
                      disabled={loading}
                      autoComplete="username"
                    />
                  </div>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="login-password" className="text-sm">
                    Password
                  </Label>
                  <div className="relative">
                    <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      id="login-password"
                      type="password"
                      placeholder="Enter your password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      className="pl-10 text-base"
                      disabled={loading}
                      autoComplete="current-password"
                    />
                  </div>
                </div>

                <div className="flex items-center space-x-2">
                  <Checkbox
                    id="remember-me"
                    checked={rememberMe}
                    onCheckedChange={(checked) => setRememberMe(checked as boolean)}
                    disabled={loading}
                  />
                  <Label htmlFor="remember-me" className="text-sm font-normal cursor-pointer select-none">
                    Remember me
                  </Label>
                </div>
              </>
            ) : (
              <div className="space-y-4">
                <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 flex items-start gap-2">
                  <Shield className="h-5 w-5 text-blue-500 flex-shrink-0 mt-0.5" />
                  <div>
                    <p className="text-sm font-medium text-blue-500">Two-Factor Authentication</p>
                    <p className="text-xs text-blue-500 mt-1">Enter the 6-digit code from your authentication app</p>
                  </div>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="totp-code" className="text-sm">
                    Authentication Code
                  </Label>
                  <Input
                    id="totp-code"
                    type="text"
                    placeholder="000000"
                    value={totpCode}
                    onChange={(e) => setTotpCode(e.target.value.replace(/\D/g, "").slice(0, 6))}
                    className="text-center text-lg tracking-widest font-mono text-base"
                    maxLength={6}
                    disabled={loading}
                    autoComplete="one-time-code"
                    autoFocus
                  />
                  <p className="text-xs text-muted-foreground text-center">
                    You can also use a backup code (format: XXXX-XXXX)
                  </p>
                </div>

                <Button
                  type="button"
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    setRequiresTotp(false)
                    setTotpCode("")
                    setError("")
                  }}
                  className="w-full"
                >
                  Back to login
                </Button>
              </div>
            )}

            <Button type="submit" className="w-full bg-blue-500 hover:bg-blue-600" disabled={loading}>
              {loading ? "Signing in..." : requiresTotp ? "Verify Code" : "Sign In"}
            </Button>
          </form>
        </div>

        <p className="text-center text-sm text-muted-foreground">ProxMenux Monitor v1.0.2</p>
      </div>
    </div>
  )
}



================================================
FILE: AppImage/components/metrics-dialog.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { ArrowLeft, Loader2 } from "lucide-react"
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from "recharts"
import { fetchApi } from "@/lib/api-config"

interface MetricsViewProps {
  vmid: number
  vmName: string
  vmType: "qemu" | "lxc"
  onBack: () => void
}

const TIMEFRAME_OPTIONS = [
  { value: "hour", label: "1 Hour" },
  { value: "day", label: "24 Hours" },
  { value: "week", label: "7 Days" },
  { value: "month", label: "30 Days" },
  { value: "year", label: "1 Year" },
]

const CustomCPUTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value}</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

const CustomMemoryTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value} GB</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

const CustomDiskTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value} MB</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

const CustomNetworkTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value} MB</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

export function MetricsView({ vmid, vmName, vmType, onBack }: MetricsViewProps) {
  const [timeframe, setTimeframe] = useState("week")
  const [data, setData] = useState<any[]>([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [hiddenDiskLines, setHiddenDiskLines] = useState<string[]>([])
  const [hiddenNetworkLines, setHiddenNetworkLines] = useState<string[]>([])

  useEffect(() => {
    fetchMetrics()
  }, [vmid, timeframe])

  const fetchMetrics = async () => {
    setLoading(true)
    setError(null)

    try {
      const result = await fetchApi<any>(`/api/vms/${vmid}/metrics?timeframe=${timeframe}`)

      const transformedData = result.data.map((item: any) => {
        const date = new Date(item.time * 1000)
        let timeLabel = ""

        if (timeframe === "hour") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "day") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "week") {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "month") {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
          })
        } else {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            year: "numeric",
          })
        }

        return {
          time: timeLabel,
          timestamp: item.time,
          cpu: item.cpu ? Number((item.cpu * 100).toFixed(2)) : 0,
          memory: item.mem ? Number(((item.mem / item.maxmem) * 100).toFixed(2)) : 0,
          memoryGB: item.mem ? Number((item.mem / 1024 / 1024 / 1024).toFixed(2)) : 0,
          maxMemoryGB: item.maxmem ? Number((item.maxmem / 1024 / 1024 / 1024).toFixed(2)) : 0,
          netin: item.netin ? Number((item.netin / 1024 / 1024).toFixed(2)) : 0,
          netout: item.netout ? Number((item.netout / 1024 / 1024).toFixed(2)) : 0,
          diskread: item.diskread ? Number((item.diskread / 1024 / 1024).toFixed(2)) : 0,
          diskwrite: item.diskwrite ? Number((item.diskwrite / 1024 / 1024).toFixed(2)) : 0,
        }
      })

      setData(transformedData)
    } catch (err: any) {
      setError(err.message || "Error loading metrics")
    } finally {
      setLoading(false)
    }
  }

  const formatXAxisTick = (tick: any) => {
    return tick
  }

  const renderAllCharts = () => {
    if (loading) {
      return (
        <div className="flex items-center justify-center h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      )
    }

    if (error) {
      return (
        <div className="flex items-center justify-center h-[400px]">
          <p className="text-red-500">{error}</p>
        </div>
      )
    }

    if (data.length === 0) {
      return (
        <div className="flex items-center justify-center h-[400px]">
          <p className="text-muted-foreground">No data available</p>
        </div>
      )
    }

    const tickInterval = Math.ceil(data.length / 8)

    return (
      <div className="space-y-8">
        {/* CPU Chart */}
        <div>
          <h3 className="text-lg font-semibold mb-4">CPU Usage</h3>
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={data} margin={{ bottom: 80 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
              <XAxis
                dataKey="time"
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                angle={-45}
                textAnchor="end"
                height={60}
                interval={tickInterval}
                tickFormatter={formatXAxisTick}
              />
              <YAxis
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                label={{ value: "%", angle: -90, position: "insideLeft", fill: "currentColor" }}
                domain={[0, "dataMax"]}
              />
              <Tooltip content={<CustomCPUTooltip />} />
              <Area
                type="monotone"
                dataKey="cpu"
                stroke="#3b82f6"
                strokeWidth={2}
                fill="#3b82f6"
                fillOpacity={0.3}
                name="CPU %"
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>

        {/* Memory Chart */}
        <div>
          <h3 className="text-lg font-semibold mb-4">Memory Usage</h3>
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={data} margin={{ bottom: 80 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
              <XAxis
                dataKey="time"
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                angle={-45}
                textAnchor="end"
                height={60}
                interval={tickInterval}
                tickFormatter={formatXAxisTick}
              />
              <YAxis
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                label={{ value: "GB", angle: -90, position: "insideLeft", fill: "currentColor" }}
                domain={[0, "dataMax"]}
              />
              <Tooltip content={<CustomMemoryTooltip />} />
              <Area
                type="monotone"
                dataKey="memoryGB"
                stroke="#10b981"
                fill="#10b981"
                fillOpacity={0.3}
                strokeWidth={2}
                name="Memory GB"
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>

        {/* Disk I/O Chart */}
        <div>
          <h3 className="text-lg font-semibold mb-4">Disk I/O</h3>
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={data} margin={{ bottom: 80 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
              <XAxis
                dataKey="time"
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                angle={-45}
                textAnchor="end"
                height={60}
                interval={tickInterval}
                tickFormatter={formatXAxisTick}
              />
              <YAxis
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                label={{ value: "MB", angle: -90, position: "insideLeft", fill: "currentColor" }}
                domain={[0, "dataMax"]}
              />
              <Tooltip content={<CustomDiskTooltip />} />
              <Legend content={renderDiskLegend} verticalAlign="top" />
              <Area
                type="monotone"
                dataKey="diskread"
                stroke="#10b981"
                fill="#10b981"
                fillOpacity={0.3}
                strokeWidth={2}
                name="Read"
                hide={hiddenDiskLines.includes("diskread")}
              />
              <Area
                type="monotone"
                dataKey="diskwrite"
                stroke="#3b82f6"
                fill="#3b82f6"
                fillOpacity={0.3}
                strokeWidth={2}
                name="Write"
                hide={hiddenDiskLines.includes("diskwrite")}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>

        {/* Network I/O Chart */}
        <div>
          <h3 className="text-lg font-semibold mb-4">Network I/O</h3>
          <ResponsiveContainer width="100%" height={300}>
            <AreaChart data={data} margin={{ bottom: 80 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
              <XAxis
                dataKey="time"
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                angle={-45}
                textAnchor="end"
                height={60}
                interval={tickInterval}
                tickFormatter={formatXAxisTick}
              />
              <YAxis
                stroke="currentColor"
                className="text-foreground"
                tick={{ fill: "currentColor" }}
                label={{ value: "MB", angle: -90, position: "insideLeft", fill: "currentColor" }}
                domain={[0, "dataMax"]}
              />
              <Tooltip content={<CustomNetworkTooltip />} />
              <Legend content={renderNetworkLegend} verticalAlign="top" />
              <Area
                type="monotone"
                dataKey="netin"
                stroke="#10b981"
                fill="#10b981"
                fillOpacity={0.3}
                strokeWidth={2}
                name="Download"
                hide={hiddenNetworkLines.includes("netin")}
              />
              <Area
                type="monotone"
                dataKey="netout"
                stroke="#3b82f6"
                fill="#3b82f6"
                fillOpacity={0.3}
                strokeWidth={2}
                name="Upload"
                hide={hiddenNetworkLines.includes("netout")}
              />
            </AreaChart>
          </ResponsiveContainer>
        </div>
      </div>
    )
  }

  const handleDiskLegendClick = (dataKey: string) => {
    setHiddenDiskLines((prev) => {
      if (prev.includes(dataKey)) {
        return prev.filter((key) => key !== dataKey)
      } else {
        return [...prev, dataKey]
      }
    })
  }

  const handleNetworkLegendClick = (dataKey: string) => {
    setHiddenNetworkLines((prev) => {
      if (prev.includes(dataKey)) {
        return prev.filter((key) => key !== dataKey)
      } else {
        return [...prev, dataKey]
      }
    })
  }

  const renderDiskLegend = (props: any) => {
    const { payload } = props
    return (
      <div className="flex justify-center gap-6 pb-2">
        {payload.map((entry: any) => (
          <button
            key={entry.dataKey}
            onClick={() => handleDiskLegendClick(entry.dataKey)}
            className={`flex items-center gap-2 cursor-pointer transition-opacity hover:opacity-100 ${
              hiddenDiskLines.includes(entry.dataKey) ? "opacity-40" : "opacity-100"
            }`}
          >
            <span className="w-3 h-3 rounded-full" style={{ backgroundColor: entry.color }} />
            <span className="text-sm">{entry.value}</span>
          </button>
        ))}
      </div>
    )
  }

  const renderNetworkLegend = (props: any) => {
    const { payload } = props
    return (
      <div className="flex justify-center gap-6 pb-2">
        {payload.map((entry: any) => (
          <button
            key={entry.dataKey}
            onClick={() => handleNetworkLegendClick(entry.dataKey)}
            className={`flex items-center gap-2 cursor-pointer transition-opacity hover:opacity-100 ${
              hiddenNetworkLines.includes(entry.dataKey) ? "opacity-40" : "opacity-100"
            }`}
          >
            <span className="w-3 h-3 rounded-full" style={{ backgroundColor: entry.color }} />
            <span className="text-sm">{entry.value}</span>
          </button>
        ))}
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full max-h-[90vh]">
      {/* Fixed Header */}
      <div className="p-6 pb-4 border-b shrink-0">
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Button variant="ghost" size="icon" onClick={onBack}>
              <ArrowLeft className="h-5 w-5" />
            </Button>
            <div>
              <h2 className="text-xl font-semibold">Metrics - {vmName}</h2>
              <p className="text-sm text-muted-foreground mt-1">
                VMID: {vmid} â€¢ Type: {vmType.toUpperCase()}
              </p>
            </div>
          </div>
          <Select value={timeframe} onValueChange={setTimeframe}>
            <SelectTrigger className="w-32">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              {TIMEFRAME_OPTIONS.map((option) => (
                <SelectItem key={option.value} value={option.value}>
                  {option.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        </div>
      </div>

      {/* Scrollable Content with all charts */}
      <div className="flex-1 overflow-y-auto p-6 min-h-0">{renderAllCharts()}</div>
    </div>
  )
}



================================================
FILE: AppImage/components/network-card.tsx
================================================
"use client"

import { Card, CardContent } from "./ui/card"
import { Badge } from "./ui/badge"
import { Wifi, Zap } from 'lucide-react'
import { useState, useEffect } from "react"
import { fetchApi } from "../lib/api-config"
import { formatNetworkTraffic, getNetworkUnit } from "../lib/format-network"

interface NetworkCardProps {
  interface_: {
    name: string
    type: string
    status: string
    speed: number
    duplex?: string
    mtu?: number
    mac_address: string | null
    addresses: Array<{
      ip: string
      netmask: string
    }>
    bytes_sent?: number
    bytes_recv?: number
    bridge_physical_interface?: string
    bridge_bond_slaves?: string[]
    vmid?: number
    vm_name?: string
    vm_type?: string
  }
  timeframe: "hour" | "day" | "week" | "month" | "year"
  onClick?: () => void
}

const getInterfaceTypeBadge = (type: string) => {
  switch (type) {
    case "physical":
      return { color: "bg-blue-500/10 text-blue-500 border-blue-500/20", label: "Physical" }
    case "bridge":
      return { color: "bg-green-500/10 text-green-500 border-green-500/20", label: "Bridge" }
    case "bond":
      return { color: "bg-purple-500/10 text-purple-500 border-purple-500/20", label: "Bond" }
    case "vlan":
      return { color: "bg-cyan-500/10 text-cyan-500 border-cyan-500/20", label: "VLAN" }
    case "vm_lxc":
      return { color: "bg-orange-500/10 text-orange-500 border-orange-500/20", label: "Virtual" }
    case "virtual":
      return { color: "bg-orange-500/10 text-orange-500 border-orange-500/20", label: "Virtual" }
    default:
      return { color: "bg-gray-500/10 text-gray-500 border-gray-500/20", label: "Unknown" }
  }
}

const getVMTypeBadge = (vmType: string | undefined) => {
  if (vmType === "lxc") {
    return { color: "bg-cyan-500/10 text-cyan-500 border-cyan-500/20", label: "LXC" }
  } else if (vmType === "vm") {
    return { color: "bg-purple-500/10 text-purple-500 border-purple-500/20", label: "VM" }
  }
  return { color: "bg-gray-500/10 text-gray-500 border-gray-500/20", label: "Unknown" }
}

const formatSpeed = (speed: number): string => {
  if (speed === 0) return "N/A"
  if (speed >= 1000) return `${(speed / 1000).toFixed(1)} Gbps`
  return `${speed} Mbps`
}

export function NetworkCard({ interface_, timeframe, onClick }: NetworkCardProps) {
  const typeBadge = getInterfaceTypeBadge(interface_.type)
  const vmTypeBadge = interface_.vm_type ? getVMTypeBadge(interface_.vm_type) : null

  const [networkUnit, setNetworkUnit] = useState<"Bytes" | "Bits">(getNetworkUnit())

  const [trafficData, setTrafficData] = useState<{ received: number; sent: number }>({
    received: 0,
    sent: 0,
  })

  useEffect(() => {
    const handleUnitChange = () => {
      setNetworkUnit(getNetworkUnit())
    }

    window.addEventListener("networkUnitChanged", handleUnitChange)
    window.addEventListener("storage", handleUnitChange)

    return () => {
      window.removeEventListener("networkUnitChanged", handleUnitChange)
      window.removeEventListener("storage", handleUnitChange)
    }
  }, [])

  useEffect(() => {
    const fetchTrafficData = async () => {
      try {
        const data = await fetchApi(`/api/network/${interface_.name}/metrics?timeframe=${timeframe}`)

        if (data.data && data.data.length > 0) {
          const lastPoint = data.data[data.data.length - 1]
          const firstPoint = data.data[0]

          const receivedGB = Math.max(0, (lastPoint.netin || 0) - (firstPoint.netin || 0))
          const sentGB = Math.max(0, (lastPoint.netout || 0) - (firstPoint.netout || 0))

          setTrafficData({
            received: receivedGB,
            sent: sentGB,
          })
        }
      } catch (error) {
        console.error("[v0] Failed to fetch traffic data for card:", error)
        setTrafficData({ received: 0, sent: 0 })
      }
    }

    if (interface_.status.toLowerCase() === "up" && interface_.vm_type !== "vm") {
      fetchTrafficData()

      const interval = setInterval(fetchTrafficData, 60000)
      return () => clearInterval(interval)
    }
  }, [interface_.name, interface_.status, interface_.vm_type, timeframe])

  const getTimeframeLabel = () => {
    switch (timeframe) {
      case "hour":
        return "Last Hour"
      case "day":
        return "Last 24 Hours"
      case "week":
        return "Last 7 Days"
      case "month":
        return "Last 30 Days"
      case "year":
        return "Last Year"
      default:
        return "Last 24 Hours"
    }
  }

  return (
    <Card className="bg-card border-border hover:bg-white/5 transition-colors cursor-pointer" onClick={onClick}>
      <CardContent className="p-4">
        <div className="flex flex-col gap-3">
          {/* First row: Icon, Name, Type Badge, Status */}
          <div className="flex items-center gap-3 flex-wrap">
            <Wifi className="h-5 w-5 text-muted-foreground flex-shrink-0" />
            <div className="flex items-center gap-2 min-w-0 flex-1 flex-wrap">
              <div className="font-medium text-foreground">{interface_.name}</div>
              {vmTypeBadge ? (
                <Badge variant="outline" className={vmTypeBadge.color}>
                  {vmTypeBadge.label}
                </Badge>
              ) : (
                <Badge variant="outline" className={typeBadge.color}>
                  {typeBadge.label}
                </Badge>
              )}
              {interface_.vm_name && (
                <div className="text-sm text-muted-foreground truncate">â†’ {interface_.vm_name}</div>
              )}
              {interface_.type === "bridge" && interface_.bridge_physical_interface && (
                <div className="text-sm text-blue-500 font-medium flex items-center gap-1 flex-wrap break-all">
                  â†’ {interface_.bridge_physical_interface}
                </div>
              )}
            </div>
            <Badge
              variant="outline"
              className={
                interface_.status === "up"
                  ? "bg-green-500/10 text-green-500 border-green-500/20"
                  : "bg-red-500/10 text-red-500 border-red-500/20"
              }
            >
              {interface_.status.toUpperCase()}
            </Badge>
          </div>

          {/* Second row: Details - Responsive layout */}
          <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            <div>
              <div className="text-muted-foreground text-xs">
                {interface_.type === "vm_lxc" ? "VMID" : "IP Address"}
              </div>
              <div className="font-medium text-foreground font-mono text-sm truncate">
                {interface_.type === "vm_lxc"
                  ? (interface_.vmid ?? "N/A")
                  : interface_.addresses.length > 0
                    ? interface_.addresses[0].ip
                    : "N/A"}
              </div>
            </div>

            <div>
              <div className="text-muted-foreground text-xs">Speed</div>
              <div className="font-medium text-foreground flex items-center gap-1 text-xs">
                <Zap className="h-3 w-3" />
                {formatSpeed(interface_.speed)}
              </div>
            </div>

            <div className="col-span-2 md:col-span-1">
              <div className="text-muted-foreground text-xs">{getTimeframeLabel()}</div>
              <div className="font-medium text-foreground text-xs">
                {interface_.status.toLowerCase() === "up" && interface_.vm_type !== "vm" ? (
                  <>
                    <span className="text-green-500">â†“ {formatNetworkTraffic(trafficData.received * 1024 * 1024 * 1024, networkUnit)}</span>
                    {" / "}
                    <span className="text-blue-500">â†‘ {formatNetworkTraffic(trafficData.sent * 1024 * 1024 * 1024, networkUnit)}</span>
                  </>
                ) : (
                  <>
                    <span className="text-green-500">â†“ {formatNetworkTraffic(interface_.bytes_recv || 0, networkUnit)}</span>
                    {" / "}
                    <span className="text-blue-500">â†‘ {formatNetworkTraffic(interface_.bytes_sent || 0, networkUnit)}</span>
                  </>
                )}
              </div>
            </div>

            {interface_.mac_address && (
              <div className="col-span-2 md:col-span-1">
                <div className="text-muted-foreground text-xs">MAC</div>
                <div className="font-medium text-foreground font-mono text-xs truncate">{interface_.mac_address}</div>
              </div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  )
}



================================================
FILE: AppImage/components/network-traffic-chart.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from "recharts"
import { Loader2 } from 'lucide-react'
import { fetchApi } from "../lib/api-config"
import { getNetworkUnit } from "../lib/format-network"

interface NetworkMetricsData {
  time: string
  timestamp: number
  netIn: number
  netOut: number
}

interface NetworkTrafficChartProps {
  timeframe: string
  interfaceName?: string
  onTotalsCalculated?: (totals: { received: number; sent: number }) => void
  refreshInterval?: number // En milisegundos, por defecto 60000 (60 segundos)
  networkUnit?: "Bytes" | "Bits" // Added networkUnit prop
}

const CustomNetworkTooltip = ({ active, payload, label, networkUnit }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">
                {entry.value.toFixed(3)} {networkUnit === "Bits" ? "Gb" : "GB"}
              </span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

export function NetworkTrafficChart({
  timeframe,
  interfaceName,
  onTotalsCalculated,
  refreshInterval = 60000,
  networkUnit: networkUnitProp, // Rename prop to avoid conflict
}: NetworkTrafficChartProps) {
  const [data, setData] = useState<NetworkMetricsData[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [isInitialLoad, setIsInitialLoad] = useState(true)
  const [visibleLines, setVisibleLines] = useState({
    netIn: true,
    netOut: true,
  })
  
  const [networkUnit, setNetworkUnit] = useState<"Bytes" | "Bits">(
    networkUnitProp || getNetworkUnit()
  )

  useEffect(() => {
    const handleUnitChange = () => {
      const newUnit = getNetworkUnit()
      setNetworkUnit(newUnit)
    }

    window.addEventListener("networkUnitChanged", handleUnitChange)
    window.addEventListener("storage", handleUnitChange)

    return () => {
      window.removeEventListener("networkUnitChanged", handleUnitChange)
      window.removeEventListener("storage", handleUnitChange)
    }
  }, [])

  useEffect(() => {
    if (networkUnitProp) {
      setNetworkUnit(networkUnitProp)
    }
  }, [networkUnitProp])

  useEffect(() => {
    setIsInitialLoad(true)
    fetchMetrics()
  }, [timeframe, interfaceName, networkUnit])

  useEffect(() => {
    if (refreshInterval > 0) {
      const interval = setInterval(() => {
        fetchMetrics()
      }, refreshInterval)

      return () => clearInterval(interval)
    }
  }, [timeframe, interfaceName, refreshInterval, networkUnit]) // Added networkUnit to dependencies

  const fetchMetrics = async () => {
    if (isInitialLoad) {
      setLoading(true)
    }
    setError(null)

    try {
      const apiPath = interfaceName
        ? `/api/network/${interfaceName}/metrics?timeframe=${timeframe}`
        : `/api/node/metrics?timeframe=${timeframe}`

      console.log("[v0] Fetching network metrics from:", apiPath)

      const result = await fetchApi<any>(apiPath)

      if (!result.data || !Array.isArray(result.data)) {
        throw new Error("Invalid data format received from server")
      }

      if (result.data.length === 0) {
        setData([])
        setLoading(false)
        return
      }

      const transformedData = result.data.map((item: any, index: number) => {
        const date = new Date(item.time * 1000)
        let timeLabel = ""

        if (timeframe === "hour") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "day") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "week") {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            hour: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "year") {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          })
        } else {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
          })
        }

        let intervalSeconds = 60
        if (index > 0) {
          intervalSeconds = item.time - result.data[index - 1].time
        }

        const netInBytes = (item.netin || 0) * intervalSeconds
        const netOutBytes = (item.netout || 0) * intervalSeconds

        if (networkUnit === "Bits") {
          return {
            time: timeLabel,
            timestamp: item.time,
            netIn: Number(((netInBytes * 8) / 1024 / 1024 / 1024).toFixed(4)),
            netOut: Number(((netOutBytes * 8) / 1024 / 1024 / 1024).toFixed(4)),
          }
        }

        return {
          time: timeLabel,
          timestamp: item.time,
          netIn: Number((netInBytes / 1024 / 1024 / 1024).toFixed(4)),
          netOut: Number((netOutBytes / 1024 / 1024 / 1024).toFixed(4)),
        }
      })

      setData(transformedData)

      const totalReceivedGB = result.data.reduce((sum: number, item: any, index: number) => {
        const intervalSeconds = index > 0 ? item.time - result.data[index - 1].time : 60
        const netInBytes = (item.netin || 0) * intervalSeconds
        return sum + (netInBytes / 1024 / 1024 / 1024)
      }, 0)
      
      const totalSentGB = result.data.reduce((sum: number, item: any, index: number) => {
        const intervalSeconds = index > 0 ? item.time - result.data[index - 1].time : 60
        const netOutBytes = (item.netout || 0) * intervalSeconds
        return sum + (netOutBytes / 1024 / 1024 / 1024)
      }, 0)

      if (onTotalsCalculated) {
        onTotalsCalculated({ received: totalReceivedGB, sent: totalSentGB })
      }

      if (isInitialLoad) {
        setIsInitialLoad(false)
      }
    } catch (err: any) {
      console.error("[v0] Error fetching network metrics:", err)
      setError(err.message || "Error loading metrics")
    } finally {
      setLoading(false)
    }
  }

  const tickInterval = Math.ceil(data.length / 8)

  const handleLegendClick = (dataKey: string) => {
    setVisibleLines((prev) => ({
      ...prev,
      [dataKey as keyof typeof prev]: !prev[dataKey as keyof typeof prev],
    }))
  }

  const renderLegend = (props: any) => {
    const { payload } = props
    return (
      <div className="flex justify-center gap-4 pb-2 flex-wrap">
        {payload.map((entry: any, index: number) => {
          const isVisible = visibleLines[entry.dataKey as keyof typeof visibleLines]
          return (
            <div
              key={`legend-${index}`}
              className="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity"
              onClick={() => handleLegendClick(entry.dataKey)}
              style={{ opacity: isVisible ? 1 : 0.4 }}
            >
              <div className="w-3 h-3 rounded-sm" style={{ backgroundColor: entry.color }} />
              <span className="text-sm text-foreground">{entry.value}</span>
            </div>
          )
        })}
      </div>
    )
  }

  if (loading && isInitialLoad) {
    return (
      <div className="flex items-center justify-center h-[300px]">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex flex-col items-center justify-center h-[300px] gap-2">
        <p className="text-muted-foreground text-sm">Network metrics not available yet</p>
        <p className="text-xs text-red-500">{error}</p>
      </div>
    )
  }

  if (data.length === 0) {
    return (
      <div className="flex items-center justify-center h-[300px]">
        <p className="text-muted-foreground text-sm">No network metrics available</p>
      </div>
    )
  }

  return (
    <ResponsiveContainer width="100%" height={300}>
      <AreaChart data={data} margin={{ bottom: 80 }}>
        <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
        <XAxis
          dataKey="time"
          stroke="currentColor"
          className="text-foreground"
          tick={{ fill: "currentColor", fontSize: 12 }}
          angle={-45}
          textAnchor="end"
          height={60}
          interval={tickInterval}
        />
        <YAxis
          stroke="currentColor"
          className="text-foreground"
          tick={{ fill: "currentColor", fontSize: 12 }}
          label={{
            value: networkUnit === "Bits" ? "Gb" : "GB", // Dynamic label based on unit
            angle: -90,
            position: "insideLeft",
            fill: "currentColor",
          }}
          domain={[0, "auto"]}
        />
        <Tooltip content={<CustomNetworkTooltip networkUnit={networkUnit} />} /> // Pass networkUnit to tooltip
        <Legend verticalAlign="top" height={36} content={renderLegend} />
        <Area
          type="monotone"
          dataKey="netIn"
          stroke="#10b981"
          strokeWidth={2}
          fill="#10b981"
          fillOpacity={0.3}
          name="Received"
          hide={!visibleLines.netIn}
          isAnimationActive={true}
          animationDuration={300}
          animationEasing="ease-in-out"
        />
        <Area
          type="monotone"
          dataKey="netOut"
          stroke="#3b82f6"
          strokeWidth={2}
          fill="#3b82f6"
          fillOpacity={0.3}
          name="Sent"
          hide={!visibleLines.netOut}
          isAnimationActive={true}
          animationDuration={300}
          animationEasing="ease-in-out"
        />
      </AreaChart>
    </ResponsiveContainer>
  )
}



================================================
FILE: AppImage/components/node-metrics-charts.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select"
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Legend } from "recharts"
import { Loader2, TrendingUp, MemoryStick } from "lucide-react"
import { useIsMobile } from "../hooks/use-mobile"
import { fetchApi } from "@/lib/api-config"

const TIMEFRAME_OPTIONS = [
  { value: "hour", label: "1 Hour" },
  { value: "day", label: "24 Hours" },
  { value: "week", label: "7 Days" },
  { value: "month", label: "30 Days" },
]

interface NodeMetricsData {
  time: string
  timestamp: number
  cpu: number
  load: number
  memoryTotal: number
  memoryUsed: number
  memoryFree: number
  memoryZfsArc: number
}

const CustomCpuTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value}</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

const CustomMemoryTooltip = ({ active, payload, label }: any) => {
  if (active && payload && payload.length) {
    return (
      <div className="bg-gray-900/95 backdrop-blur-sm border border-gray-700 rounded-lg p-3 shadow-xl">
        <p className="text-sm font-semibold text-white mb-2">{label}</p>
        <div className="space-y-1.5">
          {payload.map((entry: any, index: number) => (
            <div key={index} className="flex items-center gap-2">
              <div className="w-2.5 h-2.5 rounded-full flex-shrink-0" style={{ backgroundColor: entry.color }} />
              <span className="text-xs text-gray-300 min-w-[60px]">{entry.name}:</span>
              <span className="text-sm font-semibold text-white">{entry.value} GB</span>
            </div>
          ))}
        </div>
      </div>
    )
  }
  return null
}

export function NodeMetricsCharts() {
  const [timeframe, setTimeframe] = useState("day")
  const [data, setData] = useState<NodeMetricsData[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const isMobile = useIsMobile()

  const [visibleLines, setVisibleLines] = useState({
    cpu: { cpu: true, load: true },
    memory: { memoryTotal: true, memoryUsed: true, memoryZfsArc: true, memoryFree: true },
  })

  useEffect(() => {
    console.log("[v0] NodeMetricsCharts component mounted")
    fetchMetrics()
  }, [timeframe])

  const fetchMetrics = async () => {
    console.log("[v0] fetchMetrics called with timeframe:", timeframe)
    setLoading(true)
    setError(null)

    try {
      const result = await fetchApi<any>(`/api/node/metrics?timeframe=${timeframe}`)

      console.log("[v0] Node metrics result:", result)
      console.log("[v0] Result keys:", Object.keys(result))
      console.log("[v0] Data array length:", result.data?.length || 0)

      if (!result.data || !Array.isArray(result.data)) {
        console.error("[v0] Invalid data format - data is not an array:", result)
        throw new Error("Invalid data format received from server")
      }

      if (result.data.length === 0) {
        console.warn("[v0] No data points received")
        setData([])
        setLoading(false)
        return
      }

      console.log("[v0] First data point sample:", result.data[0])
      console.log("[v0] First data point loadavg field:", result.data[0]?.loadavg)
      console.log("[v0] loadavg type:", typeof result.data[0]?.loadavg)
      console.log("[v0] loadavg is array:", Array.isArray(result.data[0]?.loadavg))
      if (result.data[0]?.loadavg) {
        console.log("[v0] loadavg length:", result.data[0].loadavg.length)
        console.log("[v0] loadavg[0]:", result.data[0].loadavg[0])
      }

      const transformedData = result.data.map((item: any) => {
        const date = new Date(item.time * 1000)
        let timeLabel = ""

        if (timeframe === "hour") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "day") {
          timeLabel = date.toLocaleString("en-US", {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false,
          })
        } else if (timeframe === "week") {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
            hour: "2-digit",
            hour12: false,
          })
        } else {
          timeLabel = date.toLocaleString("en-US", {
            month: "short",
            day: "numeric",
          })
        }

        return {
          time: timeLabel,
          timestamp: item.time,
          cpu: item.cpu ? Number((item.cpu * 100).toFixed(2)) : 0,
          load: item.loadavg
            ? typeof item.loadavg === "number"
              ? Number(item.loadavg.toFixed(2))
              : Array.isArray(item.loadavg) && item.loadavg.length > 0
                ? Number(item.loadavg[0].toFixed(2))
                : 0
            : 0,
          memoryTotal: item.memtotal ? Number((item.memtotal / 1024 / 1024 / 1024).toFixed(2)) : 0,
          memoryUsed: item.memused ? Number((item.memused / 1024 / 1024 / 1024).toFixed(2)) : 0,
          memoryFree: item.memfree ? Number((item.memfree / 1024 / 1024 / 1024).toFixed(2)) : 0,
          memoryZfsArc: item.zfsarc ? Number((item.zfsarc / 1024 / 1024 / 1024).toFixed(2)) : 0,
        }
      })

      setData(transformedData)
    } catch (err: any) {
      console.error("[v0] Error fetching node metrics:", err)
      console.error("[v0] Error message:", err.message)
      console.error("[v0] Error stack:", err.stack)
      setError(err.message || "Error loading metrics")
    } finally {
      console.log("[v0] fetchMetrics finally block - setting loading to false")
      setLoading(false)
    }
  }

  const tickInterval = Math.ceil(data.length / 8)

  const handleLegendClick = (chartType: "cpu" | "memory", dataKey: string) => {
    setVisibleLines((prev) => ({
      ...prev,
      [chartType]: {
        ...prev[chartType],
        [dataKey as keyof (typeof prev)[typeof chartType]]:
          !prev[chartType][dataKey as keyof (typeof prev)[typeof chartType]],
      },
    }))
  }

  const renderLegend = (chartType: "cpu" | "memory") => (props: any) => {
    const { payload } = props
    return (
      <div className="flex justify-center gap-4 pb-2 flex-wrap">
        {payload.map((entry: any, index: number) => {
          const isVisible = visibleLines[chartType][entry.dataKey as keyof (typeof visibleLines)[typeof chartType]]
          return (
            <div
              key={`legend-${index}`}
              className="flex items-center gap-2 cursor-pointer hover:opacity-80 transition-opacity"
              onClick={() => handleLegendClick(chartType, entry.dataKey)}
              style={{ opacity: isVisible ? 1 : 0.4 }}
            >
              <div className="w-3 h-3 rounded-sm" style={{ backgroundColor: entry.color }} />
              <span className="text-sm text-foreground">{entry.value}</span>
            </div>
          )
        })}
      </div>
    )
  }

  console.log("[v0] Render state - loading:", loading, "error:", error, "data length:", data.length)

  if (loading) {
    console.log("[v0] Rendering loading state")
    return (
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex items-center justify-center h-[300px]">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          </CardContent>
        </Card>
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex items-center justify-center h-[300px]">
              <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
            </div>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (error) {
    console.log("[v0] Rendering error state:", error)
    return (
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex flex-col items-center justify-center h-[300px] gap-2">
              <p className="text-muted-foreground text-sm">Metrics data not available yet</p>
              <p className="text-xs text-red-500">{error}</p>
            </div>
          </CardContent>
        </Card>
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex flex-col items-center justify-center h-[300px] gap-2">
              <p className="text-muted-foreground text-sm">Metrics data not available yet</p>
              <p className="text-xs text-red-500">{error}</p>
            </div>
          </CardContent>
        </Card>
      </div>
    )
  }

  if (data.length === 0) {
    console.log("[v0] Rendering no data state")
    return (
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex items-center justify-center h-[300px]">
              <p className="text-muted-foreground text-sm">No metrics data available</p>
            </div>
          </CardContent>
        </Card>
        <Card className="bg-card border-border">
          <CardContent className="p-6">
            <div className="flex items-center justify-center h-[300px]">
              <p className="text-muted-foreground text-sm">No metrics data available</p>
            </div>
          </CardContent>
        </Card>
      </div>
    )
  }

  console.log("[v0] Rendering charts with", data.length, "data points")

  return (
    <div className="space-y-6">
      {/* Timeframe Selector */}
      <div className="flex justify-end">
        <Select value={timeframe} onValueChange={setTimeframe}>
          <SelectTrigger className="w-32">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            {TIMEFRAME_OPTIONS.map((option) => (
              <SelectItem key={option.value} value={option.value}>
                {option.label}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Charts Grid */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* CPU Usage + Load Average Chart */}
        <Card className="bg-card border-border">
          <CardHeader className="px-4 md:px-6">
            <CardTitle className="text-foreground flex items-center">
              <TrendingUp className="h-5 w-5 mr-2" />
              CPU Usage & Load Average
            </CardTitle>
          </CardHeader>
          <CardContent className="px-0 md:px-6">
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={data} margin={{ bottom: 60, left: 0, right: 0 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
                <XAxis
                  dataKey="time"
                  stroke="currentColor"
                  className="text-foreground"
                  tick={{ fill: "currentColor", fontSize: 12 }}
                  angle={-45}
                  textAnchor="end"
                  height={60}
                  interval={tickInterval}
                />
                <YAxis
                  yAxisId="left"
                  stroke="currentColor"
                  className="text-foreground"
                  tick={{ fill: "currentColor", fontSize: 12 }}
                  label={
                    isMobile ? undefined : { value: "CPU %", angle: -90, position: "insideLeft", fill: "currentColor" }
                  }
                  domain={[0, "dataMax"]}
                />
                <YAxis
                  yAxisId="right"
                  orientation="right"
                  stroke="currentColor"
                  className="text-foreground"
                  tick={{ fill: "currentColor", fontSize: 12 }}
                  label={
                    isMobile ? undefined : { value: "Load", angle: 90, position: "insideRight", fill: "currentColor" }
                  }
                  domain={[0, "dataMax"]}
                />
                <Tooltip content={<CustomCpuTooltip />} />
                <Legend verticalAlign="top" height={36} content={renderLegend("cpu")} />
                <Area
                  yAxisId="left"
                  type="monotone"
                  dataKey="cpu"
                  stroke="#3b82f6"
                  strokeWidth={2}
                  fill="#3b82f6"
                  fillOpacity={0.3}
                  name="CPU %"
                  hide={!visibleLines.cpu.cpu}
                />
                <Area
                  yAxisId="right"
                  type="monotone"
                  dataKey="load"
                  stroke="#10b981"
                  strokeWidth={2}
                  fill="#10b981"
                  fillOpacity={0.3}
                  name="Load Avg"
                  hide={!visibleLines.cpu.load}
                />
              </AreaChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>

        {/* Memory Usage Chart */}
        <Card className="bg-card border-border">
          <CardHeader className="px-4 md:px-6">
            <CardTitle className="text-foreground flex items-center">
              <MemoryStick className="h-5 w-5 mr-2" />
              Memory Usage
            </CardTitle>
          </CardHeader>
          <CardContent className="px-0 pr-2 md:px-6">
            <ResponsiveContainer width="100%" height={300}>
              <AreaChart data={data} margin={{ bottom: 60, left: 0, right: 0 }}>
                <CartesianGrid strokeDasharray="3 3" stroke="currentColor" className="text-border" />
                <XAxis
                  dataKey="time"
                  stroke="currentColor"
                  className="text-foreground"
                  tick={{ fill: "currentColor", fontSize: 12 }}
                  angle={-45}
                  textAnchor="end"
                  height={60}
                  interval={tickInterval}
                />
                <YAxis
                  stroke="currentColor"
                  className="text-foreground"
                  tick={{ fill: "currentColor", fontSize: 12 }}
                  label={
                    isMobile ? undefined : { value: "GB", angle: -90, position: "insideLeft", fill: "currentColor" }
                  }
                  domain={[0, "dataMax"]}
                />
                <Tooltip content={<CustomMemoryTooltip />} />
                <Legend verticalAlign="top" height={36} content={renderLegend("memory")} />
                <Area
                  type="monotone"
                  dataKey="memoryTotal"
                  stroke="#3b82f6"
                  strokeWidth={2}
                  fill="#3b82f6"
                  fillOpacity={0.1}
                  name="Total"
                  hide={!visibleLines.memory.memoryTotal}
                />
                <Area
                  type="monotone"
                  dataKey="memoryUsed"
                  stroke="#10b981"
                  strokeWidth={2}
                  fill="#10b981"
                  fillOpacity={0.3}
                  name="Used"
                  hide={!visibleLines.memory.memoryUsed}
                />
                <Area
                  type="monotone"
                  dataKey="memoryZfsArc"
                  stroke="#f59e0b"
                  strokeWidth={2}
                  fill="#f59e0b"
                  fillOpacity={0.3}
                  name="ZFS ARC"
                  hide={!visibleLines.memory.memoryZfsArc}
                />
                <Area
                  type="monotone"
                  dataKey="memoryFree"
                  stroke="#06b6d4"
                  strokeWidth={2}
                  fill="#06b6d4"
                  fillOpacity={0.3}
                  name="Available"
                  hide={!visibleLines.memory.memoryFree}
                />
              </AreaChart>
            </ResponsiveContainer>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}



================================================
FILE: AppImage/components/onboarding-carousel.tsx
================================================
"use client"

import type React from "react"

import { useState, useEffect } from "react"
import { Button } from "./ui/button"
import { Dialog, DialogContent, DialogTitle } from "./ui/dialog"
import {
  ChevronLeft,
  ChevronRight,
  X,
  Sparkles,
  LayoutDashboard,
  HardDrive,
  Network,
  Box,
  Cpu,
  FileText,
  Rocket,
} from "lucide-react"
import Image from "next/image"
import { Checkbox } from "./ui/checkbox"

interface OnboardingSlide {
  id: number
  title: string
  description: string
  image?: string
  icon: React.ReactNode
  gradient: string
}

const slides: OnboardingSlide[] = [
  {
    id: 0,
    title: "Welcome to ProxMenux Monitor!",
    description:
      "Your new monitoring tool for Proxmox. Discover all the features that will help you manage and supervise your infrastructure efficiently.",
    icon: <Sparkles className="h-16 w-16" />,
    gradient: "from-blue-500 via-purple-500 to-pink-500",
  },
  {
    id: 1,
    title: "System Overview",
    description:
      "Monitor your server's status in real-time: CPU, memory, temperature, system load and more. Everything in an intuitive and easy-to-understand dashboard.",
    image: "/images/onboarding/imagen1.png",
    icon: <LayoutDashboard className="h-12 w-12" />,
    gradient: "from-blue-500 to-cyan-500",
  },
  {
    id: 2,
    title: "Storage Management",
    description:
      "Visualize the status of all your disks and volumes. Detailed information on capacity, usage, SMART health, temperature and performance of each storage device.",
    image: "/images/onboarding/imagen2.png",
    icon: <HardDrive className="h-12 w-12" />,
    gradient: "from-cyan-500 to-teal-500",
  },
  {
    id: 3,
    title: "Network Metrics",
    description:
      "Monitor network traffic in real-time. Bandwidth statistics, active interfaces, transfer speeds and historical usage graphs.",
    image: "/images/onboarding/imagen3.png",
    icon: <Network className="h-12 w-12" />,
    gradient: "from-teal-500 to-green-500",
  },
  {
    id: 4,
    title: "Virtual Machines & Containers",
    description:
      "Manage all your VMs and LXC containers from one place. Status, allocated resources, current usage and quick controls for each virtual machine.",
    image: "/images/onboarding/imagen4.png",
    icon: <Box className="h-12 w-12" />,
    gradient: "from-green-500 to-emerald-500",
  },
  {
    id: 5,
    title: "Hardware Information",
    description:
      "Complete details of your server hardware: CPU, RAM, GPU, disks, network, UPS and more. Technical specifications, models, serial numbers and status of each component.",
    image: "/images/onboarding/imagen5.png",
    icon: <Cpu className="h-12 w-12" />,
    gradient: "from-emerald-500 to-blue-500",
  },
  {
    id: 6,
    title: "System Logs",
    description:
      "Access system logs in real-time. Filter by event type, search for specific errors and keep complete track of your server activity. Download the displayed logs for further analysis.",
    image: "/images/onboarding/imagen6.png",
    icon: <FileText className="h-12 w-12" />,
    gradient: "from-blue-500 to-indigo-500",
  },
  {
    id: 7,
    title: "Ready for the Future!",
    description:
      "ProxMenux Monitor is prepared to receive updates and improvements that will be added gradually, improving the user experience and being able to execute ProxMenux functions from the web panel.",
    icon: <Rocket className="h-16 w-16" />,
    gradient: "from-indigo-500 via-purple-500 to-pink-500",
  },
]

export function OnboardingCarousel() {
  const [open, setOpen] = useState(false)
  const [currentSlide, setCurrentSlide] = useState(0)
  const [direction, setDirection] = useState<"next" | "prev">("next")
  const [dontShowAgain, setDontShowAgain] = useState(false)

  useEffect(() => {
    const hasSeenOnboarding = localStorage.getItem("proxmenux-onboarding-seen")
    if (!hasSeenOnboarding) {
      setOpen(true)
    }
  }, [])

  const handleNext = () => {
    if (currentSlide < slides.length - 1) {
      setDirection("next")
      setCurrentSlide(currentSlide + 1)
    } else {
      if (dontShowAgain) {
        localStorage.setItem("proxmenux-onboarding-seen", "true")
      }
      setOpen(false)
    }
  }

  const handlePrev = () => {
    if (currentSlide > 0) {
      setDirection("prev")
      setCurrentSlide(currentSlide - 1)
    }
  }

  const handleSkip = () => {
    if (dontShowAgain) {
      localStorage.setItem("proxmenux-onboarding-seen", "true")
    }
    setOpen(false)
  }

  const handleClose = () => {
    if (dontShowAgain) {
      localStorage.setItem("proxmenux-onboarding-seen", "true")
    }
    setOpen(false)
  }

  const handleDotClick = (index: number) => {
    setDirection(index > currentSlide ? "next" : "prev")
    setCurrentSlide(index)
  }

  const slide = slides[currentSlide]

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-4xl p-0 gap-0 overflow-hidden border-0 bg-transparent">
        <DialogTitle className="sr-only">ProxMenux Onboarding</DialogTitle>
        <div className="relative bg-card rounded-lg overflow-hidden shadow-2xl">
          <Button
            variant="ghost"
            size="icon"
            className="absolute top-4 right-4 z-50 h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm hover:bg-background"
            onClick={handleClose}
          >
            <X className="h-4 w-4" />
          </Button>

          <div
            className={`relative h-48 md:h-64 bg-gradient-to-br ${slide.gradient} flex items-center justify-center overflow-hidden`}
          >
            <div className="absolute inset-0 bg-black/10" />
            <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(255,255,255,0.1),transparent)]" />

            <div className="relative z-10 text-white">
              {slide.image ? (
                <div className="relative w-full h-36 md:h-48 flex items-center justify-center px-4">
                  <Image
                    src={slide.image || "/placeholder.svg"}
                    alt={slide.title}
                    width={600}
                    height={400}
                    className="rounded-lg shadow-2xl object-cover max-h-36 md:max-h-48"
                    onError={(e) => {
                      const target = e.target as HTMLImageElement
                      target.style.display = "none"
                      const fallback = target.parentElement?.querySelector(".fallback-icon")
                      if (fallback) {
                        fallback.classList.remove("hidden")
                      }
                    }}
                  />
                  <div className="fallback-icon hidden">{slide.icon}</div>
                </div>
              ) : (
                <div className="animate-pulse">{slide.icon}</div>
              )}
            </div>

            <div className="absolute top-10 left-10 w-20 h-20 bg-white/10 rounded-full blur-2xl" />
            <div className="absolute bottom-10 right-10 w-32 h-32 bg-white/10 rounded-full blur-3xl" />
          </div>

          <div className="p-4 md:p-8 space-y-3 md:space-y-6 max-h-[60vh] md:max-h-none overflow-y-auto">
            <div className="space-y-2 md:space-y-3">
              <h2 className="text-xl md:text-3xl font-bold text-foreground text-balance">{slide.title}</h2>
              <p className="text-sm md:text-lg text-muted-foreground leading-relaxed text-pretty">
                {slide.description}
              </p>
            </div>

            <div className="flex items-center justify-center gap-2 py-2 md:py-4">
              {slides.map((_, index) => (
                <button
                  key={index}
                  onClick={() => handleDotClick(index)}
                  className={`transition-all duration-300 rounded-full ${
                    index === currentSlide
                      ? "w-8 h-2.5 bg-blue-500 shadow-lg shadow-blue-500/50"
                      : "w-2.5 h-2.5 bg-muted-foreground/60 hover:bg-muted-foreground/80 border border-muted-foreground/40"
                  }`}
                  aria-label={`Go to slide ${index + 1}`}
                />
              ))}
            </div>

            <div className="flex flex-col sm:flex-row items-center justify-between gap-2 md:gap-4">
              <Button
                variant="ghost"
                onClick={handlePrev}
                disabled={currentSlide === 0}
                className="gap-2 w-full sm:w-auto text-sm"
              >
                <ChevronLeft className="h-4 w-4" />
                Previous
              </Button>

              <div className="flex gap-2 w-full sm:w-auto">
                {currentSlide < slides.length - 1 ? (
                  <>
                    <Button
                      variant="outline"
                      onClick={handleSkip}
                      className="flex-1 sm:flex-none bg-transparent text-sm"
                    >
                      Skip
                    </Button>
                    <Button
                      onClick={handleNext}
                      className="gap-2 bg-blue-500 hover:bg-blue-600 flex-1 sm:flex-none text-sm"
                    >
                      Next
                      <ChevronRight className="h-4 w-4" />
                    </Button>
                  </>
                ) : (
                  <Button
                    onClick={handleNext}
                    className="gap-2 bg-gradient-to-r from-blue-500 to-purple-500 hover:from-blue-600 hover:to-purple-600 w-full sm:w-auto text-sm"
                  >
                    Get Started!
                    <Sparkles className="h-4 w-4" />
                  </Button>
                )}
              </div>
            </div>

            <div className="flex items-center justify-center gap-2 pt-2 pb-1">
              <Checkbox
                id="dont-show-again"
                checked={dontShowAgain}
                onCheckedChange={(checked) => setDontShowAgain(checked as boolean)}
              />
              <label
                htmlFor="dont-show-again"
                className="text-xs md:text-sm text-muted-foreground hover:text-foreground transition-colors cursor-pointer select-none"
              >
                Don't show this again
              </label>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: AppImage/components/proxmox-dashboard.tsx
================================================
"use client"

import { useState, useEffect, useMemo, useCallback } from "react"
import { Badge } from "./ui/badge"
import { Button } from "./ui/button"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "./ui/tabs"
import { SystemOverview } from "./system-overview"
import { StorageOverview } from "./storage-overview"
import { NetworkMetrics } from "./network-metrics"
import { VirtualMachines } from "./virtual-machines"
import Hardware from "./hardware"
import { SystemLogs } from "./system-logs"
import { Settings } from "./settings"
import { OnboardingCarousel } from "./onboarding-carousel"
import { HealthStatusModal } from "./health-status-modal"
import { ReleaseNotesModal, useVersionCheck } from "./release-notes-modal"
import { getApiUrl, fetchApi } from "../lib/api-config"
import { TerminalPanel } from "./terminal-panel"
import {
  RefreshCw,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Server,
  Menu,
  LayoutDashboard,
  HardDrive,
  NetworkIcon,
  Box,
  Cpu,
  FileText,
  SettingsIcon,
  Terminal,
} from "lucide-react"
import Image from "next/image"
import { ThemeToggle } from "./theme-toggle"
import { Sheet, SheetContent, SheetTrigger } from "./ui/sheet"

interface SystemStatus {
  status: "healthy" | "warning" | "critical"
  uptime: string
  lastUpdate: string
  serverName: string
  nodeId: string
}

interface FlaskSystemData {
  hostname: string
  node_id: string
  uptime: string
  cpu_usage: number
  memory_usage: number
  temperature: number
  load_average: number[]
}

interface FlaskSystemInfo {
  hostname: string
  node_id: string
  uptime: string
  health: {
    status: "healthy" | "warning" | "critical"
  }
}

export function ProxmoxDashboard() {
  const [systemStatus, setSystemStatus] = useState<SystemStatus>({
    status: "healthy",
    uptime: "Loading...",
    lastUpdate: new Date().toLocaleTimeString("en-US", { hour12: false }),
    serverName: "Loading...",
    nodeId: "Loading...",
  })
  const [isRefreshing, setIsRefreshing] = useState(false)
  const [isServerConnected, setIsServerConnected] = useState(true)
  const [componentKey, setComponentKey] = useState(0)
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const [activeTab, setActiveTab] = useState("overview")
  const [showNavigation, setShowNavigation] = useState(true)
  const [lastScrollY, setLastScrollY] = useState(0)
  const [showHealthModal, setShowHealthModal] = useState(false)
  const { showReleaseNotes, setShowReleaseNotes } = useVersionCheck()

  const fetchSystemData = useCallback(async () => {
    try {
      const data: FlaskSystemInfo = await fetchApi("/api/system-info")

      const uptimeValue =
        data.uptime && typeof data.uptime === "string" && data.uptime.trim() !== "" ? data.uptime : "N/A"

      const backendStatus = data.health?.status?.toUpperCase() || "OK"
      let healthStatus: "healthy" | "warning" | "critical"

      if (backendStatus === "CRITICAL") {
        healthStatus = "critical"
      } else if (backendStatus === "WARNING") {
        healthStatus = "warning"
      } else {
        healthStatus = "healthy"
      }

      setSystemStatus({
        status: healthStatus,
        uptime: uptimeValue,
        lastUpdate: new Date().toLocaleTimeString("en-US", { hour12: false }),
        serverName: data.hostname || "Unknown",
        nodeId: data.node_id || "Unknown",
      })
      setIsServerConnected(true)
    } catch (error) {
      console.error("[v0] Failed to fetch system data from Flask server:", error)

      setIsServerConnected(false)
      setSystemStatus((prev) => ({
        ...prev,
        status: "critical",
        serverName: "Server Offline",
        nodeId: "Server Offline",
        uptime: "N/A",
        lastUpdate: new Date().toLocaleTimeString("en-US", { hour12: false }),
      }))
    }
  }, [])

  useEffect(() => {
    // Siempre fetch inicial
    fetchSystemData()

    // En overview: cada 30 segundos para actualizaciÃ³n frecuente del estado de salud
    // En otras tabs: cada 60 segundos para reducir carga
    let interval: ReturnType<typeof setInterval> | null = null
    if (activeTab === "overview") {
      interval = setInterval(fetchSystemData, 30000) // 30 segundos
    } else {
      interval = setInterval(fetchSystemData, 60000) // 60 segundos
    }

    return () => {
      if (interval) clearInterval(interval)
    }
  }, [fetchSystemData, activeTab])

  useEffect(() => {
    const handleChangeTab = (event: CustomEvent) => {
      const { tab } = event.detail
      if (tab) {
        setActiveTab(tab)
      }
    }

    window.addEventListener("changeTab", handleChangeTab as EventListener)
    return () => {
      window.removeEventListener("changeTab", handleChangeTab as EventListener)
    }
  }, [])

  useEffect(() => {
    const handleHealthStatusUpdate = (event: CustomEvent) => {
      const { status } = event.detail
      let healthStatus: "healthy" | "warning" | "critical"

      if (status === "CRITICAL") {
        healthStatus = "critical"
      } else if (status === "WARNING") {
        healthStatus = "warning"
      } else {
        healthStatus = "healthy"
      }

      setSystemStatus((prev) => ({
        ...prev,
        status: healthStatus,
      }))
    }

    window.addEventListener("healthStatusUpdated", handleHealthStatusUpdate as EventListener)
    return () => {
      window.removeEventListener("healthStatusUpdated", handleHealthStatusUpdate as EventListener)
    }
  }, [])

  useEffect(() => {
    if (
      systemStatus.serverName &&
      systemStatus.serverName !== "Loading..." &&
      systemStatus.serverName !== "Server Offline"
    ) {
      document.title = `${systemStatus.serverName} - ProxMenux Monitor`
    } else {
      document.title = "ProxMenux Monitor"
    }
  }, [systemStatus.serverName])

  useEffect(() => {
    let hideTimeout: ReturnType<typeof setTimeout> | null = null
    let lastPosition = window.scrollY

    const handleScroll = () => {
      const currentScrollY = window.scrollY
      const delta = currentScrollY - lastPosition

      if (currentScrollY < 50) {
        setShowNavigation(true)
      } else if (delta > 2) {
        if (hideTimeout) clearTimeout(hideTimeout)
        hideTimeout = setTimeout(() => setShowNavigation(false), 20)
      } else if (delta < -2) {
        if (hideTimeout) clearTimeout(hideTimeout)
        setShowNavigation(true)
      }

      lastPosition = currentScrollY
    }

    window.addEventListener("scroll", handleScroll, { passive: true })
    return () => {
      window.removeEventListener("scroll", handleScroll)
      if (hideTimeout) clearTimeout(hideTimeout)
    }
  }, [])

  const refreshData = async () => {
    setIsRefreshing(true)
    await fetchSystemData()
    setComponentKey((prev) => prev + 1)
    await new Promise((resolve) => setTimeout(resolve, 500))
    setIsRefreshing(false)
  }

  const statusIcon = useMemo(() => {
    switch (systemStatus.status) {
      case "healthy":
        return <CheckCircle className="h-4 w-4 text-green-500" />
      case "warning":
        return <AlertTriangle className="h-4 w-4 text-yellow-500" />
      case "critical":
        return <XCircle className="h-4 w-4 text-red-500" />
    }
  }, [systemStatus.status])

  const statusColor = useMemo(() => {
    switch (systemStatus.status) {
      case "healthy":
        return "bg-green-500/10 text-green-500 border-green-500/20"
      case "warning":
        return "bg-yellow-500/10 text-yellow-500 border-yellow-500/20"
      case "critical":
        return "bg-red-500/10 text-red-500 border-red-500/20"
    }
  }, [systemStatus.status])

  const getActiveTabLabel = () => {
    switch (activeTab) {
      case "overview":
        return "Overview"
      case "storage":
        return "Storage"
      case "network":
        return "Network"
      case "vms":
        return "VMs & LXCs"
      case "hardware":
        return "Hardware"
      case "terminal":
        return "Terminal"
      case "logs":
        return "System Logs"
      case "settings":
        return "Settings"
      default:
        return "Navigation Menu"
    }
  }

  return (
    <div className="min-h-screen bg-background">
      <OnboardingCarousel />
      <ReleaseNotesModal open={showReleaseNotes} onClose={() => setShowReleaseNotes(false)} />

      {!isServerConnected && (
        <div className="bg-red-500/10 border-b border-red-500/20 px-6 py-3">
          <div className="container mx-auto">
            <div className="flex items-center space-x-2 text-red-500 mb-2">
              <XCircle className="h-5 w-5" />
              <span className="font-medium">ProxMenux Server Connection Failed</span>
            </div>
            <div className="text-sm text-red-500/80 space-y-1 ml-7">
              <p>â€¢ Check that the monitor.service is running correctly.</p>
              <p>â€¢ The ProxMenux server should start automatically on port 8008</p>
              <p>
                â€¢ Try accessing:{" "}
                <a href={getApiUrl("/api/health")} target="_blank" rel="noopener noreferrer" className="underline">
                  {getApiUrl("/api/health")}
                </a>
              </p>
            </div>
          </div>
        </div>
      )}

      <header
        className="border-b border-border bg-card sticky top-0 z-50 shadow-sm cursor-pointer hover:bg-accent/5 transition-colors"
        onClick={() => setShowHealthModal(true)}
      >
        <div className="container mx-auto px-4 md:px-6 py-4 md:py-4">
          {/* Logo and Title */}
          <div className="flex items-start justify-between gap-3">
            {/* Logo and Title */}
            <div className="flex items-center space-x-2 md:space-x-3 min-w-0">
              <div className="w-16 h-16 md:w-10 md:h-10 relative flex items-center justify-center bg-primary/10 flex-shrink-0">
                <Image
                  src="/images/proxmenux-logo.png"
                  alt="ProxMenux Logo"
                  width={64}
                  height={64}
                  className="object-contain md:w-10 md:h-10"
                  priority
                  onError={(e) => {
                    console.log("[v0] Logo failed to load, using fallback icon")
                    const target = e.target as HTMLImageElement
                    target.style.display = "none"
                    const fallback = target.parentElement?.querySelector(".fallback-icon")
                    if (fallback) {
                      fallback.classList.remove("hidden")
                    }
                  }}
                />
                <Server className="h-8 w-8 md:h-6 md:w-6 text-primary absolute fallback-icon hidden" />
              </div>
              <div className="min-w-0">
                <h1 className="text-lg md:text-xl font-semibold text-foreground truncate">ProxMenux Monitor</h1>
                <p className="text-xs md:text-sm text-muted-foreground">Proxmox System Dashboard</p>
                <div className="lg:hidden flex items-center gap-1 text-xs text-muted-foreground mt-0.5">
                  <Server className="h-3 w-3" />
                  <span className="truncate">Node: {systemStatus.serverName}</span>
                </div>
              </div>
            </div>

            {/* Desktop Actions */}
            <div className="hidden lg:flex items-center space-x-4">
              <div className="flex items-center space-x-2">
                <Server className="h-4 w-4 text-muted-foreground" />
                <div className="text-sm">
                  <div className="font-medium text-foreground">Node: {systemStatus.serverName}</div>
                </div>
              </div>

              <Badge variant="outline" className={statusColor}>
                {statusIcon}
                <span className="ml-1 capitalize">{systemStatus.status}</span>
              </Badge>

              <div className="text-sm text-muted-foreground whitespace-nowrap">
                Uptime: {systemStatus.uptime || "N/A"}
              </div>

              <Button
                variant="outline"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation()
                  refreshData()
                }}
                disabled={isRefreshing}
                className="border-border/50 bg-transparent hover:bg-secondary"
              >
                <RefreshCw className={`h-4 w-4 mr-2 ${isRefreshing ? "animate-spin" : ""}`} />
                Refresh
              </Button>

              <div onClick={(e) => e.stopPropagation()}>
                <ThemeToggle />
              </div>
            </div>

            {/* Mobile Actions */}
            <div className="flex lg:hidden items-center gap-2">
              <Badge variant="outline" className={`${statusColor} text-xs px-2`}>
                {statusIcon}
                <span className="ml-1 capitalize hidden sm:inline">{systemStatus.status}</span>
              </Badge>

              <Button
                variant="ghost"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation()
                  refreshData()
                }}
                disabled={isRefreshing}
                className="h-8 w-8 p-0"
              >
                <RefreshCw className={`h-4 w-4 ${isRefreshing ? "animate-spin" : ""}`} />
              </Button>

              <div onClick={(e) => e.stopPropagation()}>
                <ThemeToggle />
              </div>
            </div>
          </div>

          {/* Mobile Server Info */}
          <div className="lg:hidden mt-2 flex items-center justify-end text-xs text-muted-foreground">
            <span className="whitespace-nowrap">Uptime: {systemStatus.uptime || "N/A"}</span>
          </div>
        </div>
      </header>

      <div
        className={`sticky z-40 bg-background
          top-[120px] md:top-[76px]
          transition-all duration-700 ease-[cubic-bezier(0.4,0,0.2,1)]
          ${showNavigation ? "translate-y-0 opacity-100" : "-translate-y-[120%] opacity-0 pointer-events-none"}
        `}
      >
        <div className="container mx-auto px-4 md:px-6 pt-4 md:pt-6">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-0">
            <TabsList className="hidden md:grid w-full grid-cols-8 bg-card border border-border">
              <TabsTrigger
                value="overview"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Overview
              </TabsTrigger>
              <TabsTrigger
                value="storage"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Storage
              </TabsTrigger>
              <TabsTrigger
                value="network"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Network
              </TabsTrigger>
              <TabsTrigger
                value="vms"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                VMs & LXCs
              </TabsTrigger>
              <TabsTrigger
                value="hardware"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Hardware
              </TabsTrigger>
              <TabsTrigger
                value="logs"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                System Logs
              </TabsTrigger>
              <TabsTrigger
                value="terminal"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Terminal
              </TabsTrigger>
              <TabsTrigger
                value="settings"
                className="data-[state=active]:bg-blue-500 data-[state=active]:text-white data-[state=active]:rounded-md"
              >
                Settings
              </TabsTrigger>
            </TabsList>

            <Sheet open={mobileMenuOpen} onOpenChange={setMobileMenuOpen}>
              <div className="md:hidden">
                <SheetTrigger asChild>
                  <Button
                    variant="outline"
                    className={`w-full justify-between border-border ${
                      activeTab ? "bg-blue-500/10 text-blue-500" : "bg-card"
                    }`}
                  >
                    <span>{getActiveTabLabel()}</span>
                    <Menu className="h-4 w-4" />
                  </Button>
                </SheetTrigger>
              </div>
              <SheetContent side="top" className="bg-card border-border">
                <div className="flex flex-col gap-2 mt-4">
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("overview")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "overview"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <LayoutDashboard className="h-5 w-5" />
                    <span>Overview</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("storage")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "storage"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <HardDrive className="h-5 w-5" />
                    <span>Storage</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("network")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "network"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <NetworkIcon className="h-5 w-5" />
                    <span>Network</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("vms")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "vms"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <Box className="h-5 w-5" />
                    <span>VMs & LXCs</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("hardware")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "hardware"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <Cpu className="h-5 w-5" />
                    <span>Hardware</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("logs")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "logs"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <FileText className="h-5 w-5" />
                    <span>System Logs</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("terminal")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "terminal"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <Terminal className="h-5 w-5" />
                    <span>Terminal</span>
                  </Button>
                  <Button
                    variant="ghost"
                    onClick={() => {
                      setActiveTab("settings")
                      setMobileMenuOpen(false)
                    }}
                    className={`w-full justify-start gap-3 ${
                      activeTab === "settings"
                        ? "bg-blue-500/10 text-blue-500 border-l-4 border-blue-500 rounded-l-none"
                        : ""
                    }`}
                  >
                    <SettingsIcon className="h-5 w-5" />
                    <span>Settings</span>
                  </Button>
                </div>
              </SheetContent>
            </Sheet>
          </Tabs>
        </div>
      </div>

      <div className="container mx-auto px-4 md:px-6 py-4 md:py-6">
        <Tabs value={activeTab} onValueChange={setActiveTab} className="space-y-4 md:space-y-6">
          <TabsContent value="overview" className="space-y-4 md:space-y-6 mt-0">
            <SystemOverview key={`overview-${componentKey}`} />
          </TabsContent>

          <TabsContent value="storage" className="space-y-4 md:space-y-6 mt-0">
            <StorageOverview key={`storage-${componentKey}`} />
          </TabsContent>

          <TabsContent value="network" className="space-y-4 md:space-y-6 mt-0">
            <NetworkMetrics key={`network-${componentKey}`} />
          </TabsContent>

          <TabsContent value="vms" className="space-y-4 md:space-y-6 mt-0">
            <VirtualMachines key={`vms-${componentKey}`} />
          </TabsContent>

          <TabsContent value="hardware" className="space-y-4 md:space-y-6 mt-0">
            <Hardware key={`hardware-${componentKey}`} />
          </TabsContent>

          <TabsContent value="logs" className="space-y-4 md:space-y-6 mt-0">
            <SystemLogs key={`logs-${componentKey}`} />
          </TabsContent>

          <TabsContent value="terminal" className="mt-0">
            <TerminalPanel key={`terminal-${componentKey}`} />
          </TabsContent>

          <TabsContent value="settings" className="space-y-4 md:space-y-6 mt-0">
            <Settings />
          </TabsContent>
        </Tabs>

        <footer className="mt-8 md:mt-12 pt-4 md:pt-6 border-t border-border text-center text-xs md:text-sm text-muted-foreground">
          <p className="font-medium mb-2">ProxMenux Monitor v1.0.2</p>
          <p>
            <a
              href="https://ko-fi.com/macrimi"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-500 hover:text-blue-600 hover:underline transition-colors"
            >
              Support and contribute to the project
            </a>
          </p>
        </footer>
      </div>

      <HealthStatusModal open={showHealthModal} onOpenChange={setShowHealthModal} getApiUrl={getApiUrl} />
    </div>
  )
}



================================================
FILE: AppImage/components/release-notes-modal.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Button } from "./ui/button"
import { Dialog, DialogContent, DialogTitle } from "./ui/dialog"
import { X, Sparkles, Link2, Shield, Zap, HardDrive, Gauge, Wrench, Settings } from "lucide-react"
import { Checkbox } from "./ui/checkbox"

const APP_VERSION = "1.0.2" // Sync with AppImage/package.json

interface ReleaseNote {
  date: string
  changes: {
    added?: string[]
    changed?: string[]
    fixed?: string[]
  }
}

export const CHANGELOG: Record<string, ReleaseNote> = {
  "1.0.1": {
    date: "November 11, 2025",
    changes: {
      added: [
        "Proxy Support - Access ProxMenux through reverse proxies with full functionality",
        "Authentication System - Secure your dashboard with password protection",
        "PCIe Link Speed Detection - View NVMe drive connection speeds and detect performance issues",
        "Enhanced Storage Display - Better formatting for disk sizes (auto-converts GB to TB when needed)",
        "SATA/SAS Information - View detailed interface information for all storage devices",
        "Two-Factor Authentication (2FA) - Enhanced security with TOTP support",
        "Health Monitoring System - Comprehensive system health checks with dismissible warnings",
        "Release Notes Modal - Automatic notification of new features and improvements",
      ],
      changed: [
        "Optimized VM & LXC page - Reduced CPU usage by 85% through intelligent caching",
        "Storage metrics now separate local and remote storage for clarity",
        "Update warnings now appear only after 365 days instead of 30 days",
        "API intervals staggered to distribute server load (23s and 37s)",
      ],
      fixed: [
        "Fixed dark mode text contrast issues in various components",
        "Corrected storage calculation discrepancies between Overview and Storage pages",
        "Resolved JSON stringify error in VM control actions",
        "Improved IP address fetching for LXC containers",
      ],
    },
  },
  "1.0.0": {
    date: "October 15, 2025",
    changes: {
      added: [
        "Initial release of ProxMenux Monitor",
        "Real-time system monitoring dashboard",
        "Storage management with SMART health monitoring",
        "Network metrics and bandwidth tracking",
        "VM & LXC container management",
        "Hardware information display",
        "System logs viewer with filtering",
      ],
    },
  },
}

const CURRENT_VERSION_FEATURES = [
  {
    icon: <Link2 className="h-5 w-5" />,
    text: "Proxy Support - Access ProxMenux through reverse proxies with full functionality",
  },
  {
    icon: <Shield className="h-5 w-5" />,
    text: "Two-Factor Authentication (2FA) - Enhanced security with TOTP support for login protection",
  },
  {
    icon: <Zap className="h-5 w-5" />,
    text: "Performance Improvements - Optimized loading times and reduced CPU usage across the application",
  },
  {
    icon: <HardDrive className="h-5 w-5" />,
    text: "Storage Enhancements - Improved disk space consumption display with local and remote storage separation",
  },
  {
    icon: <Gauge className="h-5 w-5" />,
    text: "PCIe Link Speed Detection - View NVMe drive connection speeds and identify performance bottlenecks",
  },
  {
    icon: <Wrench className="h-5 w-5" />,
    text: "Hardware Page Improvements - Enhanced hardware information display with detailed PCIe and interface data",
  },
  {
    icon: <Settings className="h-5 w-5" />,
    text: "New Settings Page - Centralized configuration for authentication, optimizations, and system preferences",
  },
]

interface ReleaseNotesModalProps {
  open: boolean
  onClose: () => void
}

export function ReleaseNotesModal({ open, onClose }: ReleaseNotesModalProps) {
  const [dontShowAgain, setDontShowAgain] = useState(false)

  const handleClose = () => {
    if (dontShowAgain) {
      localStorage.setItem("proxmenux-last-seen-version", APP_VERSION)
    }
    onClose()
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-2xl max-h-[85vh] p-0 gap-0 border-0 bg-transparent">
        <DialogTitle className="sr-only">Release Notes - Version {APP_VERSION}</DialogTitle>
        <div className="relative bg-card rounded-lg shadow-2xl h-full flex flex-col max-h-[85vh]">
          <Button
            variant="ghost"
            size="icon"
            className="absolute top-4 right-4 z-50 h-8 w-8 rounded-full bg-background/80 backdrop-blur-sm hover:bg-background"
            onClick={handleClose}
          >
            <X className="h-4 w-4" />
          </Button>

          <div className="relative h-32 md:h-40 bg-gradient-to-br from-amber-500 via-orange-500 to-red-500 flex items-center justify-center overflow-hidden flex-shrink-0">
            <div className="absolute inset-0 bg-black/10" />
            <div className="absolute inset-0 bg-[radial-gradient(circle_at_50%_120%,rgba(255,255,255,0.1),transparent)]" />

            <div className="relative z-10 text-white animate-pulse">
              <Sparkles className="h-12 w-12 md:h-14 md:w-14" />
            </div>

            <div className="absolute top-10 left-10 w-20 h-20 bg-white/10 rounded-full blur-2xl" />
            <div className="absolute bottom-10 right-10 w-32 h-32 bg-white/10 rounded-full blur-3xl" />
          </div>

          <div className="flex-1 overflow-y-auto p-6 md:p-8 space-y-4 md:space-y-6 min-h-0">
            <div className="space-y-2">
              <h2 className="text-xl md:text-2xl font-bold text-foreground text-balance">
                What's New in Version {APP_VERSION}
              </h2>
              <p className="text-sm text-muted-foreground leading-relaxed">
                We've added exciting new features and improvements to make ProxMenux Monitor even better!
              </p>
            </div>

            <div className="space-y-2">
              {CURRENT_VERSION_FEATURES.map((feature, index) => (
                <div
                  key={index}
                  className="flex items-start gap-2 md:gap-3 p-3 rounded-lg bg-muted/50 border border-border/50 hover:bg-muted/70 transition-colors"
                >
                  <div className="text-orange-500 mt-0.5 flex-shrink-0">{feature.icon}</div>
                  <p className="text-xs md:text-sm text-foreground leading-relaxed">{feature.text}</p>
                </div>
              ))}
            </div>
          </div>

          <div className="flex-shrink-0 p-6 md:p-8 pt-4 border-t border-border/50 bg-card">
            <div className="flex flex-col gap-3">
              <Button
                onClick={handleClose}
                className="w-full bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600"
              >
                <Sparkles className="h-4 w-4 mr-2" />
                Got it!
              </Button>

              <div className="flex items-center justify-center gap-2">
                <Checkbox
                  id="dont-show-version-again"
                  checked={dontShowAgain}
                  onCheckedChange={(checked) => setDontShowAgain(checked as boolean)}
                />
                <label
                  htmlFor="dont-show-version-again"
                  className="text-xs md:text-sm text-muted-foreground hover:text-foreground transition-colors cursor-pointer select-none"
                >
                  Don't show again for this version
                </label>
              </div>
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}

export function useVersionCheck() {
  const [showReleaseNotes, setShowReleaseNotes] = useState(false)

  useEffect(() => {
    const lastSeenVersion = localStorage.getItem("proxmenux-last-seen-version")

    if (lastSeenVersion !== APP_VERSION) {
      setShowReleaseNotes(true)
    }
  }, [])

  return { showReleaseNotes, setShowReleaseNotes }
}

export { APP_VERSION }



================================================
FILE: AppImage/components/script-terminal-modal.tsx
================================================
"use client"

import type React from "react"
import { useState, useEffect, useRef, useCallback } from "react"
import { Dialog, DialogContent, DialogTitle } from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { CheckCircle2, XCircle, Loader2, Activity, GripHorizontal } from "lucide-react"
import { API_PORT } from "../lib/api-config"
import { useIsMobile } from "@/hooks/use-mobile"

interface WebInteraction {
  type: "yesno" | "menu" | "msgbox" | "input" | "inputbox"
  id: string
  title: string
  message: string
  options?: Array<{ label: string; value: string }>
  default?: string
}

interface ScriptTerminalModalProps {
  open: boolean
  onClose: () => void
  scriptPath: string
  scriptName: string
  params?: Record<string, string>
  title: string
  description: string
}

export function ScriptTerminalModal({
  open,
  onClose,
  scriptPath,
  scriptName,
  params = {},
  title,
  description,
}: ScriptTerminalModalProps) {
  const termRef = useRef<any>(null)
  const wsRef = useRef<WebSocket | null>(null)
  const fitAddonRef = useRef<any>(null)
  const sessionIdRef = useRef<string>(Math.random().toString(36).substring(2, 8))

  const [isConnected, setIsConnected] = useState(false)
  const [isComplete, setIsComplete] = useState(false)
  const [exitCode, setExitCode] = useState<number | null>(null)
  const [currentInteraction, setCurrentInteraction] = useState<WebInteraction | null>(null)
  const [interactionInput, setInteractionInput] = useState("")
  const checkConnectionInterval = useRef<NodeJS.Timeout | null>(null)
  const isMobile = useIsMobile()

  const [isWaitingNextInteraction, setIsWaitingNextInteraction] = useState(false)
  const waitingTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  const [modalHeight, setModalHeight] = useState(80)
  const [isResizing, setIsResizing] = useState(false)
  const resizeHandlersRef = useRef<{
    handleMove: ((e: MouseEvent | TouchEvent) => void) | null
    handleEnd: (() => void) | null
  }>({ handleMove: null, handleEnd: null })

  const terminalContainerRef = useCallback(
    (node: HTMLDivElement | null) => {
      if (!node || !open || termRef.current) {
        return
      }

      console.log("[v0] Terminal container mounted, initializing...")

      const initializeTerminal = async () => {
        console.log("[v0] Loading xterm modules...")
        const [TerminalClass, FitAddonClass] = await Promise.all([
          import("xterm").then((mod) => mod.Terminal),
          import("xterm-addon-fit").then((mod) => mod.FitAddon),
          import("xterm/css/xterm.css"),
        ])

        console.log("[v0] Creating terminal instance...")
        const fontSize = window.innerWidth < 768 ? 12 : 16

        const term = new TerminalClass({
          rendererType: "dom",
          fontFamily: '"Courier", "Courier New", "Liberation Mono", "DejaVu Sans Mono", monospace',
          fontSize: fontSize,
          lineHeight: 1,
          cursorBlink: true,
          scrollback: 2000,
          disableStdin: false,
          customGlyphs: true,
          fontWeight: "500",
          fontWeightBold: "700",
          theme: {
            background: "#000000",
            foreground: "#ffffff",
            cursor: "#ffffff",
            cursorAccent: "#000000",
            black: "#2e3436",
            red: "#cc0000",
            green: "#4e9a06",
            yellow: "#c4a000",
            blue: "#3465a4",
            magenta: "#75507b",
            cyan: "#06989a",
            white: "#d3d7cf",
            brightBlack: "#555753",
            brightRed: "#ef2929",
            brightGreen: "#8ae234",
            brightYellow: "#fce94f",
            brightBlue: "#729fcf",
            brightMagenta: "#ad7fa8",
            brightCyan: "#34e2e2",
            brightWhite: "#eeeeec",
          },
        })

        const fitAddon = new FitAddonClass()
        term.loadAddon(fitAddon)
        console.log("[v0] Opening terminal in container...")
        term.open(node)

        termRef.current = term
        fitAddonRef.current = fitAddon

        setTimeout(() => {
          try {
            fitAddon.fit()
            console.log("[v0] Terminal fitted, cols:", term.cols, "rows:", term.rows)
          } catch (err) {
            console.log("[v0] Fit error:", err)
          }
        }, 50)

        const wsUrl = getScriptWebSocketUrl(sessionIdRef.current)
        console.log("[v0] Connecting to WebSocket:", wsUrl)
        const ws = new WebSocket(wsUrl)
        wsRef.current = ws

        ws.onopen = () => {
          console.log("[v0] WebSocket connected!")
          setIsConnected(true)

          const initMessage = {
            script_path: scriptPath,
            params: {
              EXECUTION_MODE: "web",
              ...params,
            },
          }

          console.log("[v0] Sending init message:", initMessage)
          ws.send(JSON.stringify(initMessage))

          setTimeout(() => {
            try {
              fitAddon.fit()
              const cols = term.cols
              const rows = term.rows
              console.log("[v0] Sending resize:", { cols, rows })
              ws.send(
                JSON.stringify({
                  type: "resize",
                  cols: cols,
                  rows: rows,
                }),
              )
            } catch (err) {
              console.log("[v0] Resize error:", err)
            }
          }, 100)
        }

        ws.onmessage = (event) => {
          console.log("[v0] WebSocket message received:", event.data.substring(0, 100))
          try {
            const msg = JSON.parse(event.data)

            if (msg.type === "web_interaction" && msg.interaction) {
              console.log("[v0] Web interaction detected:", msg.interaction.type)
              setIsWaitingNextInteraction(false)
              if (waitingTimeoutRef.current) {
                clearTimeout(waitingTimeoutRef.current)
              }
              setCurrentInteraction({
                type: msg.interaction.type,
                id: msg.interaction.id,
                title: msg.interaction.title || "",
                message: msg.interaction.message || "",
                options: msg.interaction.options,
                default: msg.interaction.default,
              })
              return
            }

            if (msg.type === "error") {
              console.log("[v0] Error message:", msg.message)
              term.writeln(`\x1b[31m${msg.message}\x1b[0m`)
              return
            }
          } catch {
            // Not JSON, es output normal de terminal
          }

          term.write(event.data)

          setIsWaitingNextInteraction(false)
          if (waitingTimeoutRef.current) {
            clearTimeout(waitingTimeoutRef.current)
          }
        }

        ws.onerror = (error) => {
          console.log("[v0] WebSocket error:", error)
          setIsConnected(false)
          term.writeln("\x1b[31mWebSocket error occurred\x1b[0m")
        }

        ws.onclose = (event) => {
          console.log("[v0] WebSocket closed:", event.code, event.reason)
          setIsConnected(false)
          term.writeln("\x1b[33mConnection closed\x1b[0m")

          if (!isComplete) {
            setIsComplete(true)
            setExitCode(event.code === 1000 ? 0 : 1)
          }
        }

        term.onData((data) => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(data)
          }
        })

        checkConnectionInterval.current = setInterval(() => {
          if (ws) {
            setIsConnected(ws.readyState === WebSocket.OPEN)
          }
        }, 500)

        let resizeTimeout: NodeJS.Timeout | null = null

        const resizeObserver = new ResizeObserver(() => {
          if (resizeTimeout) clearTimeout(resizeTimeout)
          resizeTimeout = setTimeout(() => {
            if (fitAddon && term && ws?.readyState === WebSocket.OPEN) {
              try {
                fitAddon.fit()
                ws.send(
                  JSON.stringify({
                    type: "resize",
                    cols: term.cols,
                    rows: term.rows,
                  }),
                )
              } catch (err) {
                // Ignore
              }
            }
          }, 100)
        })

        resizeObserver.observe(node)
      }

      initializeTerminal()
    },
    [open, scriptPath, params],
  )

  useEffect(() => {
    if (!open) {
      if (checkConnectionInterval.current) {
        clearInterval(checkConnectionInterval.current)
      }
      if (waitingTimeoutRef.current) {
        clearTimeout(waitingTimeoutRef.current)
      }
      if (wsRef.current) {
        wsRef.current.close()
        wsRef.current = null
      }
      if (termRef.current) {
        termRef.current.dispose()
        termRef.current = null
      }
      if (resizeHandlersRef.current.handleMove) {
        document.removeEventListener("mousemove", resizeHandlersRef.current.handleMove as any)
        document.removeEventListener("touchmove", resizeHandlersRef.current.handleMove as any)
      }
      if (resizeHandlersRef.current.handleEnd) {
        document.removeEventListener("mouseup", resizeHandlersRef.current.handleEnd)
        document.removeEventListener("touchend", resizeHandlersRef.current.handleEnd)
      }
      resizeHandlersRef.current = { handleMove: null, handleEnd: null }

      sessionIdRef.current = Math.random().toString(36).substring(2, 8)
      setIsComplete(false)
      setExitCode(null)
      setInteractionInput("")
      setCurrentInteraction(null)
      setIsWaitingNextInteraction(false)
      setIsConnected(false)
    }
  }, [open])

  const getScriptWebSocketUrl = (sid: string): string => {
    if (typeof window === "undefined") {
      return `ws://localhost:${API_PORT}/ws/script/${sid}`
    }

    const { hostname, protocol } = window.location
    const wsProtocol = protocol === "https:" ? "wss:" : "ws:"
    return `${wsProtocol}//${hostname}:${API_PORT}/ws/script/${sid}`
  }

  const handleInteractionResponse = (value: string) => {
    if (!wsRef.current || !currentInteraction) {
      return
    }

    if (value === "cancel" || value === "") {
      setCurrentInteraction(null)
      setInteractionInput("")
      handleCloseModal()
      return
    }

    const response = JSON.stringify({
      type: "interaction_response",
      id: currentInteraction.id,
      value: value,
    })

    if (wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.send(response)
    }

    setCurrentInteraction(null)
    setInteractionInput("")

    waitingTimeoutRef.current = setTimeout(() => {
      setIsWaitingNextInteraction(true)
    }, 50)
  }

  const handleCloseModal = () => {
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
      wsRef.current.close()
    }
    if (checkConnectionInterval.current) {
      clearInterval(checkConnectionInterval.current)
    }
    if (termRef.current) {
      termRef.current.dispose()
    }
    onClose()
  }

  const handleResizeStart = (e: React.MouseEvent | React.TouchEvent) => {
    e.preventDefault()
    e.stopPropagation()

    setIsResizing(true)
    const startY = "clientY" in e ? e.clientY : e.touches[0].clientY
    const startHeight = modalHeight

    const handleMove = (moveEvent: MouseEvent | TouchEvent) => {
      const currentY = moveEvent instanceof MouseEvent ? moveEvent.clientY : moveEvent.touches[0].clientY
      const deltaY = currentY - startY
      const deltaPercent = (deltaY / window.innerHeight) * 100
      const newHeight = Math.max(50, Math.min(95, startHeight + deltaPercent))

      setModalHeight(newHeight)

      if (fitAddonRef.current && termRef.current && wsRef.current?.readyState === WebSocket.OPEN) {
        try {
          setTimeout(() => {
            fitAddonRef.current.fit()
            wsRef.current?.send(
              JSON.stringify({
                type: "resize",
                cols: termRef.current.cols,
                rows: termRef.current.rows,
              }),
            )
          }, 10)
        } catch (err) {
          // Ignore
        }
      }
    }

    const handleEnd = () => {
      setIsResizing(false)

      if (fitAddonRef.current && termRef.current && wsRef.current?.readyState === WebSocket.OPEN) {
        try {
          setTimeout(() => {
            fitAddonRef.current.fit()
            wsRef.current?.send(
              JSON.stringify({
                type: "resize",
                cols: termRef.current.cols,
                rows: termRef.current.rows,
              }),
            )
          }, 50)
        } catch (err) {
          // Ignore
        }
      }

      document.removeEventListener("mousemove", handleMove as any)
      document.removeEventListener("touchmove", handleMove as any)
      document.removeEventListener("mouseup", handleEnd)
      document.removeEventListener("touchend", handleEnd)

      resizeHandlersRef.current = { handleMove: null, handleEnd: null }
    }

    resizeHandlersRef.current = { handleMove, handleEnd }

    document.addEventListener("mousemove", handleMove as any)
    document.addEventListener("touchmove", handleMove as any, { passive: false })
    document.addEventListener("mouseup", handleEnd)
    document.addEventListener("touchend", handleEnd)
  }

  return (
    <>
      <Dialog open={open}>
        <DialogContent
          className="max-w-4xl p-0 flex flex-col"
          style={{ height: isMobile ? "80vh" : `${modalHeight}vh` }}
          onInteractOutside={(e) => e.preventDefault()}
          onEscapeKeyDown={(e) => e.preventDefault()}
        >
          <DialogTitle className="sr-only">{title}</DialogTitle>

          <div className="flex items-center gap-2 p-4 border-b">
            {isComplete &&
              (exitCode === 0 ? (
                <CheckCircle2 className="h-5 w-5 text-green-500" />
              ) : (
                <XCircle className="h-5 w-5 text-red-500" />
              ))}
            <div>
              <h2 className="text-lg font-semibold">{title}</h2>
              {description && <p className="text-sm text-muted-foreground">{description}</p>}
            </div>
          </div>

          <div className="overflow-hidden relative flex-1">
            <div ref={terminalContainerRef} className="w-full h-full" />

            {isWaitingNextInteraction && !currentInteraction && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-sm">
                <div className="flex flex-col items-center gap-3">
                  <Loader2 className="h-8 w-8 animate-spin text-blue-500" />
                  <p className="text-sm text-muted-foreground">Processing...</p>
                </div>
              </div>
            )}
          </div>

          {!isMobile && (
            <div
              className={`h-2 cursor-ns-resize flex items-center justify-center transition-all duration-150 ${
                isResizing ? "bg-blue-500 h-3" : "bg-zinc-800 hover:bg-blue-500/50"
              }`}
              onMouseDown={handleResizeStart}
              onTouchStart={handleResizeStart}
            >
              <GripHorizontal
                className={`h-4 w-4 transition-all duration-150 ${isResizing ? "text-white scale-110" : "text-zinc-500"}`}
              />
            </div>
          )}

          <div className="flex items-center justify-between p-4 border-t">
            <div className="flex items-center gap-3">
              <Activity className="h-5 w-5 text-blue-500" />
              <div
                className={`w-2 h-2 rounded-full ${isConnected ? "bg-green-500" : "bg-red-500"}`}
                title={isConnected ? "Connected" : "Disconnected"}
              ></div>
              <span className="text-xs text-muted-foreground">{isConnected ? "Online" : "Offline"}</span>
            </div>

            <Button
              onClick={handleCloseModal}
              variant="outline"
              className="bg-red-600 hover:bg-red-700 border-red-500 text-white"
            >
              Close
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      {currentInteraction && (
        <Dialog open={true}>
          <DialogContent
            className="max-w-4xl max-h-[80vh] overflow-y-auto animate-in fade-in-0 zoom-in-95 duration-100"
            onInteractOutside={(e) => e.preventDefault()}
            onEscapeKeyDown={(e) => e.preventDefault()}
            hideClose
          >
            <DialogTitle>{currentInteraction.title}</DialogTitle>
            <div className="space-y-4">
              <p className="whitespace-pre-wrap">{currentInteraction.message}</p>

              {currentInteraction.type === "yesno" && (
                <div className="flex gap-2">
                  <Button
                    onClick={() => handleInteractionResponse("yes")}
                    className="flex-1 bg-blue-600 hover:bg-blue-700 text-white transition-all duration-150"
                  >
                    Yes
                  </Button>
                  <Button
                    onClick={() => handleInteractionResponse("cancel")}
                    variant="outline"
                    className="flex-1 hover:bg-red-600 hover:text-white hover:border-red-600 transition-all duration-150"
                  >
                    Cancel
                  </Button>
                </div>
              )}

              {currentInteraction.type === "menu" && currentInteraction.options && (
                <div className="space-y-2">
                  {currentInteraction.options.map((option, index) => (
                    <Button
                      key={option.value}
                      onClick={() => handleInteractionResponse(option.value)}
                      variant="outline"
                      className="w-full justify-start hover:bg-blue-600 hover:text-white transition-all duration-100 animate-in fade-in-0 slide-in-from-left-2"
                      style={{ animationDelay: `${index * 30}ms` }}
                    >
                      {option.label}
                    </Button>
                  ))}
                  <Button
                    onClick={() => handleInteractionResponse("cancel")}
                    variant="outline"
                    className="w-full hover:bg-red-600 hover:text-white hover:border-red-600 transition-all duration-150"
                  >
                    Cancel
                  </Button>
                </div>
              )}

              {(currentInteraction.type === "input" || currentInteraction.type === "inputbox") && (
                <div className="space-y-2">
                  <Label>Your input:</Label>
                  <Input
                    value={interactionInput}
                    onChange={(e) => setInteractionInput(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleInteractionResponse(interactionInput)
                      }
                    }}
                    placeholder={currentInteraction.default || ""}
                    className="transition-all duration-150"
                  />
                  <div className="flex gap-2">
                    <Button
                      onClick={() => handleInteractionResponse(interactionInput)}
                      className="flex-1 bg-blue-600 hover:bg-blue-700 transition-all duration-150"
                    >
                      Submit
                    </Button>
                    <Button
                      onClick={() => handleInteractionResponse("cancel")}
                      variant="outline"
                      className="flex-1 hover:bg-red-600 hover:text-white hover:border-red-600 transition-all duration-150"
                    >
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

              {currentInteraction.type === "msgbox" && (
                <div className="flex gap-2">
                  <Button
                    onClick={() => handleInteractionResponse("ok")}
                    className="flex-1 bg-blue-600 hover:bg-blue-700 transition-all duration-150"
                  >
                    OK
                  </Button>
                  <Button
                    onClick={() => handleInteractionResponse("cancel")}
                    variant="outline"
                    className="flex-1 hover:bg-red-600 hover:text-white hover:border-red-600 transition-all duration-150"
                  >
                    Cancel
                  </Button>
                </div>
              )}
            </div>
          </DialogContent>
        </Dialog>
      )}
    </>
  )
}



================================================
FILE: AppImage/components/settings.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Button } from "./ui/button"
import { Input } from "./ui/input"
import { Label } from "./ui/label"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "./ui/card"
import { Shield, Lock, User, AlertCircle, CheckCircle, Info, LogOut, Wrench, Package, Key, Copy, Eye, EyeOff, Ruler } from 'lucide-react'
import { APP_VERSION } from "./release-notes-modal"
import { getApiUrl, fetchApi } from "../lib/api-config"
import { TwoFactorSetup } from "./two-factor-setup"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select"
import { getNetworkUnit } from "../lib/format-network"

interface ProxMenuxTool {
  key: string
  name: string
  enabled: boolean
}

export function Settings() {
  const [authEnabled, setAuthEnabled] = useState(false)
  const [totpEnabled, setTotpEnabled] = useState(false)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [success, setSuccess] = useState("")

  // Setup form state
  const [showSetupForm, setShowSetupForm] = useState(false)
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [confirmPassword, setConfirmPassword] = useState("")

  // Change password form state
  const [showChangePassword, setShowChangePassword] = useState(false)
  const [currentPassword, setCurrentPassword] = useState("")
  const [newPassword, setNewPassword] = useState("")
  const [confirmNewPassword, setConfirmNewPassword] = useState("")

  const [show2FASetup, setShow2FASetup] = useState(false)
  const [show2FADisable, setShow2FADisable] = useState(false)
  const [disable2FAPassword, setDisable2FAPassword] = useState("")

  const [proxmenuxTools, setProxmenuxTools] = useState<ProxMenuxTool[]>([])
  const [loadingTools, setLoadingTools] = useState(true)
  const [expandedVersions, setExpandedVersions] = useState<Record<string, boolean>>({
    [APP_VERSION]: true, // Current version expanded by default
  })

  // API Token state management
  const [showApiTokenSection, setShowApiTokenSection] = useState(false)
  const [apiToken, setApiToken] = useState("")
  const [apiTokenVisible, setApiTokenVisible] = useState(false)
  const [tokenPassword, setTokenPassword] = useState("")
  const [tokenTotpCode, setTokenTotpCode] = useState("")
  const [generatingToken, setGeneratingToken] = useState(false)
  const [tokenCopied, setTokenCopied] = useState(false)

  const [networkUnitSettings, setNetworkUnitSettings] = useState<"Bytes" | "Bits">("Bytes")
  const [loadingUnitSettings, setLoadingUnitSettings] = useState(true)

  useEffect(() => {
    checkAuthStatus()
    loadProxmenuxTools()
    getUnitsSettings() // Load units settings on mount
  }, [])

  const checkAuthStatus = async () => {
    try {
      const response = await fetch(getApiUrl("/api/auth/status"))
      const data = await response.json()
      setAuthEnabled(data.auth_enabled || false)
      setTotpEnabled(data.totp_enabled || false) // Get 2FA status
    } catch (err) {
      console.error("Failed to check auth status:", err)
    }
  }

  const loadProxmenuxTools = async () => {
    try {
      const response = await fetch(getApiUrl("/api/proxmenux/installed-tools"))
      const data = await response.json()

      if (data.success) {
        setProxmenuxTools(data.installed_tools || [])
      }
    } catch (err) {
      console.error("Failed to load ProxMenux tools:", err)
    } finally {
      setLoadingTools(false)
    }
  }

  const handleEnableAuth = async () => {
    setError("")
    setSuccess("")

    if (!username || !password) {
      setError("Please fill in all fields")
      return
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match")
      return
    }

    if (password.length < 6) {
      setError("Password must be at least 6 characters")
      return
    }

    setLoading(true)

    try {
      const response = await fetch(getApiUrl("/api/auth/setup"), {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          username,
          password,
          enable_auth: true,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || "Failed to enable authentication")
      }

      // Save token
      localStorage.setItem("proxmenux-auth-token", data.token)
      localStorage.setItem("proxmenux-auth-setup-complete", "true")

      setSuccess("Authentication enabled successfully!")
      setAuthEnabled(true)
      setShowSetupForm(false)
      setUsername("")
      setPassword("")
      setConfirmPassword("")
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to enable authentication")
    } finally {
      setLoading(false)
    }
  }

  const handleDisableAuth = async () => {
    if (
      !confirm(
        "Are you sure you want to disable authentication? This will remove password protection from your dashboard.",
      )
    ) {
      return
    }

    setLoading(true)
    setError("")
    setSuccess("")

    try {
      const token = localStorage.getItem("proxmenux-auth-token")
      const response = await fetch(getApiUrl("/api/auth/disable"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || "Failed to disable authentication")
      }

      localStorage.removeItem("proxmenux-auth-token")
      localStorage.removeItem("proxmenux-auth-setup-complete")

      setSuccess("Authentication disabled successfully! Reloading...")

      setTimeout(() => {
        window.location.reload()
      }, 1000)
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to disable authentication. Please try again.")
    } finally {
      setLoading(false)
    }
  }

  const handleChangePassword = async () => {
    setError("")
    setSuccess("")

    if (!currentPassword || !newPassword) {
      setError("Please fill in all fields")
      return
    }

    if (newPassword !== confirmNewPassword) {
      setError("New passwords do not match")
      return
    }

    if (newPassword.length < 6) {
      setError("Password must be at least 6 characters")
      return
    }

    setLoading(true)

    try {
      const response = await fetch(getApiUrl("/api/auth/change-password"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("proxmenux-auth-token")}`,
        },
        body: JSON.stringify({
          current_password: currentPassword,
          new_password: newPassword,
        }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || "Failed to change password")
      }

      // Update token if provided
      if (data.token) {
        localStorage.setItem("proxmenux-auth-token", data.token)
      }

      setSuccess("Password changed successfully!")
      setShowChangePassword(false)
      setCurrentPassword("")
      setNewPassword("")
      setConfirmNewPassword("")
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to change password")
    } finally {
      setLoading(false)
    }
  }

  const handleDisable2FA = async () => {
    setError("")
    setSuccess("")

    if (!disable2FAPassword) {
      setError("Please enter your password")
      return
    }

    setLoading(true)

    try {
      const token = localStorage.getItem("proxmenux-auth-token")
      const response = await fetch(getApiUrl("/api/auth/totp/disable"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ password: disable2FAPassword }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || "Failed to disable 2FA")
      }

      setSuccess("2FA disabled successfully!")
      setTotpEnabled(false)
      setShow2FADisable(false)
      setDisable2FAPassword("")
      checkAuthStatus()
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to disable 2FA")
    } finally {
      setLoading(false)
    }
  }

  const handleLogout = () => {
    localStorage.removeItem("proxmenux-auth-token")
    localStorage.removeItem("proxmenux-auth-setup-complete")
    window.location.reload()
  }

  const handleGenerateApiToken = async () => {
    setError("")
    setSuccess("")

    if (!tokenPassword) {
      setError("Please enter your password")
      return
    }

    if (totpEnabled && !tokenTotpCode) {
      setError("Please enter your 2FA code")
      return
    }

    setGeneratingToken(true)

    try {
      const data = await fetchApi("/api/auth/generate-api-token", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          password: tokenPassword,
          totp_token: totpEnabled ? tokenTotpCode : undefined,
        }),
      })

      if (!data.success) {
        setError(data.message || data.error || "Failed to generate API token")
        return
      }

      if (!data.token) {
        setError("No token received from server")
        return
      }

      setApiToken(data.token)
      setSuccess("API token generated successfully! Make sure to copy it now as you won't be able to see it again.")
      setTokenPassword("")
      setTokenTotpCode("")
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to generate API token. Please try again.")
    } finally {
      setGeneratingToken(false)
    }
  }

  const copyApiToken = () => {
    navigator.clipboard.writeText(apiToken)
    setTokenCopied(true)
    setTimeout(() => setTokenCopied(false), 2000)
  }

  const toggleVersion = (version: string) => {
    setExpandedVersions((prev) => ({
      ...prev,
      [version]: !prev[version],
    }))
  }

  const changeNetworkUnit = (unit: string) => {
    const networkUnit = unit as "Bytes" | "Bits"
    localStorage.setItem("proxmenux-network-unit", networkUnit)
    setNetworkUnitSettings(networkUnit)
    
    // Dispatch custom event to notify other components
    window.dispatchEvent(new CustomEvent("networkUnitChanged", { detail: networkUnit }))
    
    // Also dispatch storage event for backward compatibility
    window.dispatchEvent(new StorageEvent("storage", {
      key: "proxmenux-network-unit",
      newValue: networkUnit,
      url: window.location.href
    }))
  }

  const getUnitsSettings = () => {
    const networkUnit = getNetworkUnit()
    setNetworkUnitSettings(networkUnit)
    setLoadingUnitSettings(false)
  }

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold">Settings</h1>
        <p className="text-muted-foreground mt-2">Manage your dashboard security and preferences</p>
      </div>

      {/* Authentication Settings */}
      <Card>
        <CardHeader>
          <div className="flex items-center gap-2">
            <Shield className="h-5 w-5 text-blue-500" />
            <CardTitle>Authentication</CardTitle>
          </div>
          <CardDescription>Protect your dashboard with username and password authentication</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          {error && (
            <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3 flex items-start gap-2">
              <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
              <p className="text-sm text-red-500">{error}</p>
            </div>
          )}

          {success && (
            <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-3 flex items-start gap-2">
              <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
              <p className="text-sm text-green-500">{success}</p>
            </div>
          )}

          <div className="flex items-center justify-between p-4 bg-muted/50 rounded-lg">
            <div className="flex items-center gap-3">
              <div
                className={`w-10 h-10 rounded-full flex items-center justify-center ${authEnabled ? "bg-green-500/10" : "bg-gray-500/10"}`}
              >
                <Lock className={`h-5 w-5 ${authEnabled ? "text-green-500" : "text-gray-500"}`} />
              </div>
              <div>
                <p className="font-medium">Authentication Status</p>
                <p className="text-sm text-muted-foreground">
                  {authEnabled ? "Password protection is enabled" : "No password protection"}
                </p>
              </div>
            </div>
            <div
              className={`px-3 py-1 rounded-full text-sm font-medium ${authEnabled ? "bg-green-500/10 text-green-500" : "bg-gray-500/10 text-gray-500"}`}
            >
              {authEnabled ? "Enabled" : "Disabled"}
            </div>
          </div>

          {!authEnabled && !showSetupForm && (
            <div className="space-y-3">
              <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 flex items-start gap-2">
                <Info className="h-5 w-5 text-blue-500 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-blue-500">
                  Enable authentication to protect your dashboard when accessing from non-private networks.
                </p>
              </div>
              <Button onClick={() => setShowSetupForm(true)} className="w-full bg-blue-500 hover:bg-blue-600">
                <Shield className="h-4 w-4 mr-2" />
                Enable Authentication
              </Button>
            </div>
          )}

          {!authEnabled && showSetupForm && (
            <div className="space-y-4 border border-border rounded-lg p-4">
              <h3 className="font-semibold">Setup Authentication</h3>

              <div className="space-y-2">
                <Label htmlFor="setup-username">Username</Label>
                <div className="relative">
                  <User className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="setup-username"
                    type="text"
                    placeholder="Enter username"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    className="pl-10"
                    disabled={loading}
                  />
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="setup-password">Password</Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="setup-password"
                    type="password"
                    placeholder="Enter password (min 6 characters)"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className="pl-10"
                    disabled={loading}
                  />
                </div>
              </div>

              <div className="space-y-2">
                <Label htmlFor="setup-confirm-password">Confirm Password</Label>
                <div className="relative">
                  <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    id="setup-confirm-password"
                    type="password"
                    placeholder="Confirm password"
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    className="pl-10"
                    disabled={loading}
                  />
                </div>
              </div>

              <div className="flex gap-2">
                <Button onClick={handleEnableAuth} className="flex-1 bg-blue-500 hover:bg-blue-600" disabled={loading}>
                  {loading ? "Enabling..." : "Enable"}
                </Button>
                <Button onClick={() => setShowSetupForm(false)} variant="outline" className="flex-1" disabled={loading}>
                  Cancel
                </Button>
              </div>
            </div>
          )}

          {authEnabled && (
            <div className="space-y-3">
              <Button onClick={handleLogout} variant="outline" className="w-full bg-transparent">
                <LogOut className="h-4 w-4 mr-2" />
                Logout
              </Button>

              {!showChangePassword && (
                <Button onClick={() => setShowChangePassword(true)} variant="outline" className="w-full">
                  <Lock className="h-4 w-4 mr-2" />
                  Change Password
                </Button>
              )}

              {showChangePassword && (
                <div className="space-y-4 border border-border rounded-lg p-4">
                  <h3 className="font-semibold">Change Password</h3>

                  <div className="space-y-2">
                    <Label htmlFor="current-password">Current Password</Label>
                    <div className="relative">
                      <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                      <Input
                        id="current-password"
                        type="password"
                        placeholder="Enter current password"
                        value={currentPassword}
                        onChange={(e) => setCurrentPassword(e.target.value)}
                        className="pl-10"
                        disabled={loading}
                      />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="new-password">New Password</Label>
                    <div className="relative">
                      <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                      <Input
                        id="new-password"
                        type="password"
                        placeholder="Enter new password (min 6 characters)"
                        value={newPassword}
                        onChange={(e) => setNewPassword(e.target.value)}
                        className="pl-10"
                        disabled={loading}
                      />
                    </div>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="confirm-new-password">Confirm New Password</Label>
                    <div className="relative">
                      <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                      <Input
                        id="confirm-new-password"
                        type="password"
                        placeholder="Confirm new password"
                        value={confirmNewPassword}
                        onChange={(e) => setConfirmNewPassword(e.target.value)}
                        className="pl-10"
                        disabled={loading}
                      />
                    </div>
                  </div>

                  <div className="flex gap-2">
                    <Button
                      onClick={handleChangePassword}
                      className="flex-1 bg-blue-500 hover:bg-blue-600"
                      disabled={loading}
                    >
                      {loading ? "Changing..." : "Change Password"}
                    </Button>
                    <Button
                      onClick={() => setShowChangePassword(false)}
                      variant="outline"
                      className="flex-1"
                      disabled={loading}
                    >
                      Cancel
                    </Button>
                  </div>
                </div>
              )}

              {!totpEnabled && (
                <div className="space-y-3">
                  <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 flex items-start gap-2">
                    <Info className="h-5 w-5 text-blue-500 flex-shrink-0 mt-0.5" />
                    <div className="text-sm text-blue-400">
                      <p className="font-medium mb-1">Two-Factor Authentication (2FA)</p>
                      <p className="text-blue-300">
                        Add an extra layer of security by requiring a code from your authenticator app in addition to
                        your password.
                      </p>
                    </div>
                  </div>

                  <Button onClick={() => setShow2FASetup(true)} variant="outline" className="w-full">
                    <Shield className="h-4 w-4 mr-2" />
                    Enable Two-Factor Authentication
                  </Button>
                </div>
              )}

              {totpEnabled && (
                <div className="space-y-3">
                  <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-3 flex items-center gap-2">
                    <CheckCircle className="h-5 w-5 text-green-500" />
                    <p className="text-sm text-green-500 font-medium">2FA is enabled</p>
                  </div>

                  {!show2FADisable && (
                    <Button onClick={() => setShow2FADisable(true)} variant="outline" className="w-full">
                      <Shield className="h-4 w-4 mr-2" />
                      Disable 2FA
                    </Button>
                  )}

                  {show2FADisable && (
                    <div className="space-y-4 border border-border rounded-lg p-4">
                      <h3 className="font-semibold">Disable Two-Factor Authentication</h3>
                      <p className="text-sm text-muted-foreground">Enter your password to confirm</p>

                      <div className="space-y-2">
                        <Label htmlFor="disable-2fa-password">Password</Label>
                        <div className="relative">
                          <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                          <Input
                            id="disable-2fa-password"
                            type="password"
                            placeholder="Enter your password"
                            value={disable2FAPassword}
                            onChange={(e) => setDisable2FAPassword(e.target.value)}
                            className="pl-10"
                            disabled={loading}
                          />
                        </div>
                      </div>

                      <div className="flex gap-2">
                        <Button onClick={handleDisable2FA} variant="destructive" className="flex-1" disabled={loading}>
                          {loading ? "Disabling..." : "Disable 2FA"}
                        </Button>
                        <Button
                          onClick={() => {
                            setShow2FADisable(false)
                            setDisable2FAPassword("")
                            setError("")
                          }}
                          variant="outline"
                          className="flex-1"
                          disabled={loading}
                        >
                          Cancel
                        </Button>
                      </div>
                    </div>
                  )}
                </div>
              )}

              <Button onClick={handleDisableAuth} variant="destructive" className="w-full" disabled={loading}>
                Disable Authentication
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Network Units Settings */}
      <Card>
        <CardHeader>
          <div className="flex items-center gap-2">
            <Ruler className="h-5 w-5 text-green-500" />
            <CardTitle>Network Units</CardTitle>
          </div>
          <CardDescription>Change how network traffic is displayed</CardDescription>
        </CardHeader>
        <CardContent>
          {loadingUnitSettings ? (
            <div className="flex items-center justify-center py-8">
              <div className="animate-spin h-8 w-8 border-4 border-green-500 border-t-transparent rounded-full" />
            </div>
          ) : (
            <div className="text-foreground flex items-center justify-between">
              <div className="flex items-center">Network Unit Display</div>
              <Select value={networkUnitSettings} onValueChange={changeNetworkUnit}>
                <SelectTrigger className="w-28 h-8 text-xs">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Bytes">Bytes</SelectItem>
                  <SelectItem value="Bits">Bits</SelectItem>
                </SelectContent>
              </Select>
            </div>
          )}
        </CardContent>
      </Card>

      {/* API Access Tokens */}
      {authEnabled && (
        <Card>
          <CardHeader>
            <div className="flex items-center gap-2">
              <Key className="h-5 w-5 text-purple-500" />
              <CardTitle>API Access Tokens</CardTitle>
            </div>
            <CardDescription>
              Generate long-lived API tokens for external integrations like Homepage and Home Assistant
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {error && (
              <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3 flex items-start gap-2">
                <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-red-500">{error}</p>
              </div>
            )}

            {success && (
              <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-3 flex items-start gap-2">
                <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
                <p className="text-sm text-green-500">{success}</p>
              </div>
            )}

            <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-4">
              <div className="flex items-start gap-3">
                <Info className="h-5 w-5 text-blue-500 flex-shrink-0 mt-0.5" />
                <div className="space-y-2 text-sm text-blue-400">
                  <p className="font-medium">About API Tokens</p>
                  <ul className="list-disc list-inside space-y-1 text-blue-300">
                    <li>Tokens are valid for 1 year</li>
                    <li>Use them to access APIs from external services</li>
                    <li>Include in Authorization header: Bearer YOUR_TOKEN</li>
                    <li>See README.md for complete integration examples</li>
                  </ul>
                </div>
              </div>
            </div>

            {!showApiTokenSection && !apiToken && (
              <Button onClick={() => setShowApiTokenSection(true)} className="w-full bg-purple-500 hover:bg-purple-600">
                <Key className="h-4 w-4 mr-2" />
                Generate New API Token
              </Button>
            )}

            {showApiTokenSection && !apiToken && (
              <div className="space-y-4 border border-border rounded-lg p-4">
                <h3 className="font-semibold">Generate API Token</h3>
                <p className="text-sm text-muted-foreground">
                  Enter your credentials to generate a new long-lived API token
                </p>

                <div className="space-y-2">
                  <Label htmlFor="token-password">Password</Label>
                  <div className="relative">
                    <Lock className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      id="token-password"
                      type="password"
                      placeholder="Enter your password"
                      value={tokenPassword}
                      onChange={(e) => setTokenPassword(e.target.value)}
                      className="pl-10"
                      disabled={generatingToken}
                    />
                  </div>
                </div>

                {totpEnabled && (
                  <div className="space-y-2">
                    <Label htmlFor="token-totp">2FA Code</Label>
                    <div className="relative">
                      <Shield className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                      <Input
                        id="token-totp"
                        type="text"
                        placeholder="Enter 6-digit code"
                        value={tokenTotpCode}
                        onChange={(e) => setTokenTotpCode(e.target.value)}
                        className="pl-10"
                        maxLength={6}
                        disabled={generatingToken}
                      />
                    </div>
                  </div>
                )}

                <div className="flex gap-2">
                  <Button
                    onClick={handleGenerateApiToken}
                    className="flex-1 bg-purple-500 hover:bg-purple-600"
                    disabled={generatingToken}
                  >
                    {generatingToken ? "Generating..." : "Generate Token"}
                  </Button>
                  <Button
                    onClick={() => {
                      setShowApiTokenSection(false)
                      setTokenPassword("")
                      setTokenTotpCode("")
                      setError("")
                    }}
                    variant="outline"
                    className="flex-1"
                    disabled={generatingToken}
                  >
                    Cancel
                  </Button>
                </div>
              </div>
            )}

            {apiToken && (
              <div className="space-y-4 border border-green-500/20 bg-green-500/5 rounded-lg p-4">
                <div className="flex items-center gap-2 text-green-500">
                  <CheckCircle className="h-5 w-5" />
                  <h3 className="font-semibold">Your API Token</h3>
                </div>

                <div className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-3 flex items-start gap-2">
                  <AlertCircle className="h-5 w-5 text-amber-500 flex-shrink-0 mt-0.5" />
                  <div className="space-y-1">
                    <p className="text-sm text-amber-600 dark:text-amber-400 font-semibold">
                      âš ï¸ Important: Save this token now!
                    </p>
                    <p className="text-xs text-amber-600/80 dark:text-amber-400/80">
                      You won't be able to see it again. Store it securely.
                    </p>
                  </div>
                </div>

                <div className="space-y-2">
                  <Label>Token</Label>
                  <div className="relative">
                    <Input
                      value={apiToken}
                      readOnly
                      type={apiTokenVisible ? "text" : "password"}
                      className="pr-20 font-mono text-sm"
                    />
                    <div className="absolute right-2 top-1/2 -translate-y-1/2 flex gap-1">
                      <Button
                        size="sm"
                        variant="ghost"
                        onClick={() => setApiTokenVisible(!apiTokenVisible)}
                        className="h-7 w-7 p-0"
                      >
                        {apiTokenVisible ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                      </Button>
                      <Button size="sm" variant="ghost" onClick={copyApiToken} className="h-7 w-7 p-0">
                        <Copy className={`h-4 w-4 ${tokenCopied ? "text-green-500" : ""}`} />
                      </Button>
                    </div>
                  </div>
                  {tokenCopied && (
                    <p className="text-xs text-green-500 flex items-center gap-1">
                      <CheckCircle className="h-3 w-3" />
                      Copied to clipboard!
                    </p>
                  )}
                </div>

                <div className="space-y-2">
                  <p className="text-sm font-medium">How to use this token:</p>
                  <div className="bg-muted/50 rounded p-3 text-xs font-mono">
                    <p className="text-muted-foreground mb-2"># Add to request headers:</p>
                    <p>Authorization: Bearer YOUR_TOKEN_HERE</p>
                  </div>
                  <p className="text-xs text-muted-foreground">
                    See the README documentation for complete integration examples with Homepage and Home Assistant.
                  </p>
                </div>

                <Button
                  onClick={() => {
                    setApiToken("")
                    setShowApiTokenSection(false)
                  }}
                  variant="outline"
                  className="w-full"
                >
                  Done
                </Button>
              </div>
            )}
          </CardContent>
        </Card>
      )}

      {/* ProxMenux Optimizations */}
      <Card>
        <CardHeader>
          <div className="flex items-center gap-2">
            <Wrench className="h-5 w-5 text-orange-500" />
            <CardTitle>ProxMenux Optimizations</CardTitle>
          </div>
          <CardDescription>System optimizations and utilities installed via ProxMenux</CardDescription>
        </CardHeader>
        <CardContent>
          {loadingTools ? (
            <div className="flex items-center justify-center py-8">
              <div className="animate-spin h-8 w-8 border-4 border-orange-500 border-t-transparent rounded-full" />
            </div>
          ) : proxmenuxTools.length === 0 ? (
            <div className="text-center py-8">
              <Package className="h-12 w-12 text-muted-foreground mx-auto mb-3 opacity-50" />
              <p className="text-muted-foreground">No ProxMenux optimizations installed yet</p>
              <p className="text-sm text-muted-foreground mt-1">Run ProxMenux to configure system optimizations</p>
            </div>
          ) : (
            <div className="space-y-2">
              <div className="flex items-center justify-between mb-4 pb-2 border-b border-border">
                <span className="text-sm font-medium text-muted-foreground">Installed Tools</span>
                <span className="text-sm font-semibold text-orange-500">{proxmenuxTools.length} active</span>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                {proxmenuxTools.map((tool) => (
                  <div
                    key={tool.key}
                    className="flex items-center gap-2 p-3 bg-muted/50 rounded-lg border border-border hover:bg-muted transition-colors"
                  >
                    <div className="w-2 h-2 rounded-full bg-green-500 flex-shrink-0" />
                    <span className="text-sm font-medium">{tool.name}</span>
                  </div>
                ))}
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      <TwoFactorSetup
        open={show2FASetup}
        onClose={() => setShow2FASetup(false)}
        onSuccess={() => {
          setSuccess("2FA enabled successfully!")
          checkAuthStatus()
        }}
      />
    </div>
  )
}



================================================
FILE: AppImage/components/sidebar.tsx
================================================
"use client"

import { LayoutDashboard, HardDrive, Network, Server, Cpu, FileText, SettingsIcon, Terminal } from "lucide-react"

const menuItems = [
  { name: "Overview", href: "/", icon: LayoutDashboard },
  { name: "Storage", href: "/storage", icon: HardDrive },
  { name: "Network", href: "/network", icon: Network },
  { name: "Virtual Machines", href: "/virtual-machines", icon: Server },
  { name: "Hardware", href: "/hardware", icon: Cpu },
  { name: "System Logs", href: "/logs", icon: FileText },
  { name: "Terminal", href: "/terminal", icon: Terminal },
  { name: "Settings", href: "/settings", icon: SettingsIcon },
]

const Sidebar = ({ currentPath, setOpen }) => {
  const handleNavigation = (tabName: string) => {
    // Dispatch custom event to change tab in dashboard
    const event = new CustomEvent("changeTab", { detail: { tab: tabName } })
    window.dispatchEvent(event)
    setOpen(false)
  }

  return (
    <div>
      <button
        onClick={() => handleNavigation("overview")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/" || currentPath === "/overview"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <LayoutDashboard className="h-5 w-5" />
        <span>Overview</span>
      </button>

      <button
        onClick={() => handleNavigation("storage")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/storage"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <HardDrive className="h-5 w-5" />
        <span>Storage</span>
      </button>

      <button
        onClick={() => handleNavigation("network")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/network"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <Network className="h-5 w-5" />
        <span>Network</span>
      </button>

      <button
        onClick={() => handleNavigation("vms")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/virtual-machines"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <Server className="h-5 w-5" />
        <span>VMs & LXCs</span>
      </button>

      <button
        onClick={() => handleNavigation("hardware")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/hardware"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <Cpu className="h-5 w-5" />
        <span>Hardware</span>
      </button>

      <button
        onClick={() => handleNavigation("logs")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/logs"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <FileText className="h-5 w-5" />
        <span>System Logs</span>
      </button>

      <button
        onClick={() => handleNavigation("terminal")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/terminal"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <Terminal className="h-5 w-5" />
        <span>Terminal</span>
      </button>

      <button
        onClick={() => handleNavigation("settings")}
        className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
          currentPath === "/settings"
            ? "bg-blue-500/10 text-blue-500"
            : "text-muted-foreground hover:text-foreground hover:bg-accent"
        }`}
      >
        <SettingsIcon className="h-5 w-5" />
        <span>Settings</span>
      </button>
    </div>
  )
}

export default Sidebar



================================================
FILE: AppImage/components/storage-metrics.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card"
import { Progress } from "./ui/progress"
import { Badge } from "./ui/badge"
import { HardDrive, Database, Archive, AlertTriangle, CheckCircle, Activity, AlertCircle } from "lucide-react"
import { formatStorage } from "@/lib/utils"

interface StorageData {
  total: number
  used: number
  available: number
  disks: DiskInfo[]
}

interface DiskInfo {
  name: string
  mountpoint: string
  fstype: string
  total: number
  used: number
  available: number
  usage_percent: number
  health: string
  temperature: number
}

const fetchStorageData = async (): Promise<StorageData | null> => {
  try {
    console.log("[v0] Fetching storage data from Flask server...")
    const response = await fetch("/api/storage", {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
      signal: AbortSignal.timeout(5000),
    })

    if (!response.ok) {
      throw new Error(`Flask server responded with status: ${response.status}`)
    }

    const data = await response.json()
    console.log("[v0] Successfully fetched storage data from Flask:", data)
    return data
  } catch (error) {
    console.error("[v0] Failed to fetch storage data from Flask server:", error)
    return null
  }
}

export function StorageMetrics() {
  const [storageData, setStorageData] = useState<StorageData | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true)
      setError(null)
      const result = await fetchStorageData()

      if (!result) {
        setError("Flask server not available. Please ensure the server is running.")
      } else {
        setStorageData(result)
      }

      setLoading(false)
    }

    fetchData()
    const interval = setInterval(fetchData, 60000)
    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="space-y-6">
        <div className="text-center py-8">
          <div className="text-lg font-medium text-foreground mb-2">Loading storage data...</div>
        </div>
      </div>
    )
  }

  if (error || !storageData) {
    return (
      <div className="space-y-6">
        <Card className="bg-red-500/10 border-red-500/20">
          <CardContent className="p-6">
            <div className="flex items-center gap-3 text-red-600">
              <AlertCircle className="h-6 w-6" />
              <div>
                <div className="font-semibold text-lg mb-1">Flask Server Not Available</div>
                <div className="text-sm">
                  {error || "Unable to connect to the Flask server. Please ensure the server is running and try again."}
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    )
  }

  const usagePercent = storageData.total > 0 ? (storageData.used / storageData.total) * 100 : 0

  return (
    <div className="space-y-6">
      {/* Storage Overview Cards */}
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-3 lg:gap-6">
        <Card className="bg-card border-border">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">Total Storage</CardTitle>
            <HardDrive className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{formatStorage(storageData.total)}</div>
            <Progress value={usagePercent} className="mt-2" />
            <p className="text-xs text-muted-foreground mt-2">
              {formatStorage(storageData.used)} used â€¢ {formatStorage(storageData.available)} available
            </p>
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">Used Storage</CardTitle>
            <Database className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{formatStorage(storageData.used)}</div>
            <Progress value={usagePercent} className="mt-2" />
            <p className="text-xs text-muted-foreground mt-2">{usagePercent.toFixed(1)}% of total space</p>
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <Archive className="h-5 w-5 mr-2" />
              Available
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{formatStorage(storageData.available)}</div>
            <div className="flex items-center mt-2">
              <Badge variant="outline" className="bg-green-500/10 text-green-500 border-green-500/20">
                {((storageData.available / storageData.total) * 100).toFixed(1)}% Free
              </Badge>
            </div>
            <p className="text-xs text-muted-foreground mt-2">Available space</p>
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <Activity className="h-5 w-5 mr-2" />
              Disks
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{storageData.disks.length}</div>
            <div className="flex items-center space-x-2 mt-2">
              <Badge variant="outline" className="bg-green-500/10 text-green-500 border-green-500/20">
                {storageData.disks.filter((d) => d.health === "healthy").length} Healthy
              </Badge>
            </div>
            <p className="text-xs text-muted-foreground mt-2">Storage devices</p>
          </CardContent>
        </Card>
      </div>

      {/* Disk Details */}
      <Card className="bg-card border-border">
        <CardHeader>
          <CardTitle className="text-foreground flex items-center">
            <Database className="h-5 w-5 mr-2" />
            Storage Devices
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {storageData.disks.map((disk, index) => (
              <div
                key={index}
                className="flex items-center justify-between p-4 rounded-lg border border-border bg-card/50"
              >
                <div className="flex items-center space-x-4">
                  <HardDrive className="h-5 w-5 text-muted-foreground" />
                  <div>
                    <div className="font-medium text-foreground">{disk.name}</div>
                    <div className="text-sm text-muted-foreground">
                      {disk.fstype} â€¢ {disk.mountpoint}
                    </div>
                  </div>
                </div>

                <div className="flex items-center space-x-6">
                  <div className="text-right">
                    <div className="text-sm font-medium text-foreground">
                      {formatStorage(disk.used)} / {formatStorage(disk.total)}
                    </div>
                    <Progress value={disk.usage_percent} className="w-24 mt-1" />
                  </div>

                  <div className="text-center">
                    <div className="text-sm text-muted-foreground">Temp</div>
                    <div className="text-sm font-medium text-foreground">{disk.temperature}Â°C</div>
                  </div>

                  <Badge
                    variant="outline"
                    className={
                      disk.health === "healthy"
                        ? "bg-green-500/10 text-green-500 border-green-500/20"
                        : "bg-yellow-500/10 text-yellow-500 border-yellow-500/20"
                    }
                  >
                    {disk.health === "healthy" ? (
                      <CheckCircle className="h-3 w-3 mr-1" />
                    ) : (
                      <AlertTriangle className="h-3 w-3 mr-1" />
                    )}
                    {disk.health}
                  </Badge>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    </div>
  )
}



================================================
FILE: AppImage/components/storage-overview.tsx
================================================
"use client"

import { useEffect, useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { HardDrive, Database, AlertTriangle, CheckCircle2, XCircle, Square, Thermometer, Archive } from "lucide-react"
import { Badge } from "@/components/ui/badge"
import { Progress } from "@/components/ui/progress"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { fetchApi } from "../lib/api-config"

interface DiskInfo {
  name: string
  size?: number // Changed from string to number (KB) for formatMemory()
  size_formatted?: string // Added formatted size string for display
  temperature: number
  health: string
  power_on_hours?: number
  smart_status?: string
  model?: string
  serial?: string
  mountpoint?: string
  fstype?: string
  total?: number
  used?: number
  available?: number
  usage_percent?: number
  reallocated_sectors?: number
  pending_sectors?: number
  crc_errors?: number
  rotation_rate?: number
  power_cycles?: number
  percentage_used?: number // NVMe: Percentage Used (0-100)
  media_wearout_indicator?: number // SSD: Media Wearout Indicator
  wear_leveling_count?: number // SSD: Wear Leveling Count
  total_lbas_written?: number // SSD/NVMe: Total LBAs Written (GB)
  ssd_life_left?: number // SSD: SSD Life Left percentage
}

interface ZFSPool {
  name: string
  size: string
  allocated: string
  free: string
  health: string
}

interface StorageData {
  total: number
  used: number
  available: number
  disks: DiskInfo[]
  zfs_pools: ZFSPool[]
  disk_count: number
  healthy_disks: number
  warning_disks: number
  critical_disks: number
  error?: string
}

interface ProxmoxStorage {
  name: string
  type: string
  status: string
  total: number
  used: number
  available: number
  percent: number
  node: string // Added node property for detailed debug logging
}

interface ProxmoxStorageData {
  storage: ProxmoxStorage[]
  error?: string
}

const formatStorage = (sizeInGB: number): string => {
  if (sizeInGB < 1) {
    // Less than 1 GB, show in MB
    return `${(sizeInGB * 1024).toFixed(1)} MB`
  } else if (sizeInGB > 999) {
    return `${(sizeInGB / 1024).toFixed(2)} TB`
  } else {
    // Between 1 and 999 GB, show in GB
    return `${sizeInGB.toFixed(2)} GB`
  }
}

export function StorageOverview() {
  const [storageData, setStorageData] = useState<StorageData | null>(null)
  const [proxmoxStorage, setProxmoxStorage] = useState<ProxmoxStorageData | null>(null)
  const [loading, setLoading] = useState(true)
  const [selectedDisk, setSelectedDisk] = useState<DiskInfo | null>(null)
  const [detailsOpen, setDetailsOpen] = useState(false)

  const fetchStorageData = async () => {
    try {
      const [data, proxmoxData] = await Promise.all([
        fetchApi<StorageData>("/api/storage"),
        fetchApi<ProxmoxStorageData>("/api/proxmox-storage"),
      ])

      setStorageData(data)
      setProxmoxStorage(proxmoxData)
    } catch (error) {
      console.error("Error fetching storage data:", error)
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchStorageData()
    const interval = setInterval(fetchStorageData, 60000)
    return () => clearInterval(interval)
  }, [])

  const getHealthIcon = (health: string) => {
    switch (health.toLowerCase()) {
      case "healthy":
      case "passed":
      case "online":
        return <CheckCircle2 className="h-5 w-5 text-green-500" />
      case "warning":
        return <AlertTriangle className="h-5 w-5 text-yellow-500" />
      case "critical":
      case "failed":
      case "degraded":
        return <XCircle className="h-5 w-5 text-red-500" />
      default:
        return <AlertTriangle className="h-5 w-5 text-gray-500" />
    }
  }

  const getHealthBadge = (health: string) => {
    switch (health.toLowerCase()) {
      case "healthy":
      case "passed":
      case "online":
        return <Badge className="bg-green-500/10 text-green-500 border-green-500/20">Healthy</Badge>
      case "warning":
        return <Badge className="bg-yellow-500/10 text-yellow-500 border-yellow-500/20">Warning</Badge>
      case "critical":
      case "failed":
      case "degraded":
        return <Badge className="bg-red-500/10 text-red-500 border-red-500/20">Critical</Badge>
      default:
        return <Badge className="bg-gray-500/10 text-gray-500 border-gray-500/20">Unknown</Badge>
    }
  }

  const getTempColor = (temp: number, diskName?: string, rotationRate?: number) => {
    if (temp === 0) return "text-gray-500"

    // Determinar el tipo de disco
    let diskType = "HDD" // Por defecto
    if (diskName) {
      if (diskName.startsWith("nvme")) {
        diskType = "NVMe"
      } else if (!rotationRate || rotationRate === 0) {
        diskType = "SSD"
      }
    }

    // Aplicar rangos de temperatura segÃºn el tipo
    switch (diskType) {
      case "NVMe":
        // NVMe: â‰¤70Â°C verde, 71-80Â°C amarillo, >80Â°C rojo
        if (temp <= 70) return "text-green-500"
        if (temp <= 80) return "text-yellow-500"
        return "text-red-500"

      case "SSD":
        // SSD: â‰¤59Â°C verde, 60-70Â°C amarillo, >70Â°C rojo
        if (temp <= 59) return "text-green-500"
        if (temp <= 70) return "text-yellow-500"
        return "text-red-500"

      case "HDD":
      default:
        // HDD: â‰¤45Â°C verde, 46-55Â°C amarillo, >55Â°C rojo
        if (temp <= 45) return "text-green-500"
        if (temp <= 55) return "text-yellow-500"
        return "text-red-500"
    }
  }

  const formatHours = (hours: number) => {
    if (hours === 0) return "N/A"
    const years = Math.floor(hours / 8760)
    const days = Math.floor((hours % 8760) / 24)
    if (years > 0) {
      return `${years}y ${days}d`
    }
    return `${days}d`
  }

  const formatRotationRate = (rpm: number | undefined) => {
    if (!rpm || rpm === 0) return "SSD"
    return `${rpm.toLocaleString()} RPM`
  }

  const getDiskType = (diskName: string, rotationRate: number | undefined): string => {
    if (diskName.startsWith("nvme")) {
      return "NVMe"
    }
    // rotation_rate = -1 means HDD but RPM is unknown (detected via kernel rotational flag)
    // rotation_rate = 0 or undefined means SSD
    // rotation_rate > 0 means HDD with known RPM
    if (rotationRate === -1) {
      return "HDD"
    }
    if (!rotationRate || rotationRate === 0) {
      return "SSD"
    }
    return "HDD"
  }

  const getDiskTypeBadge = (diskName: string, rotationRate: number | undefined) => {
    const diskType = getDiskType(diskName, rotationRate)
    const badgeStyles: Record<string, { className: string; label: string }> = {
      NVMe: {
        className: "bg-purple-500/10 text-purple-500 border-purple-500/20",
        label: "NVMe",
      },
      SSD: {
        className: "bg-cyan-500/10 text-cyan-500 border-cyan-500/20",
        label: "SSD",
      },
      HDD: {
        className: "bg-blue-500/10 text-blue-500 border-blue-500/20",
        label: "HDD",
      },
    }
    return badgeStyles[diskType]
  }

  const handleDiskClick = (disk: DiskInfo) => {
    setSelectedDisk(disk)
    setDetailsOpen(true)
  }

  const getStorageTypeBadge = (type: string) => {
    const typeColors: Record<string, string> = {
      pbs: "bg-purple-500/10 text-purple-500 border-purple-500/20",
      dir: "bg-blue-500/10 text-blue-500 border-blue-500/20",
      lvmthin: "bg-cyan-500/10 text-cyan-500 border-cyan-500/20",
      zfspool: "bg-green-500/10 text-green-500 border-green-500/20",
      nfs: "bg-orange-500/10 text-orange-500 border-orange-500/20",
      cifs: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20",
    }
    return typeColors[type.toLowerCase()] || "bg-gray-500/10 text-gray-500 border-gray-500/20"
  }

  const getStatusIcon = (status: string) => {
    switch (status.toLowerCase()) {
      case "active":
      case "online":
        return <CheckCircle2 className="h-5 w-5 text-green-500" />
      case "inactive":
      case "offline":
        return <Square className="h-5 w-5 text-gray-500" />
      case "error":
      case "failed":
        return <AlertTriangle className="h-5 w-5 text-red-500" />
      default:
        return <CheckCircle2 className="h-5 w-5 text-gray-500" />
    }
  }

  const getWearIndicator = (disk: DiskInfo): { value: number; label: string } | null => {
    const diskType = getDiskType(disk.name, disk.rotation_rate)

    if (diskType === "NVMe" && disk.percentage_used !== undefined && disk.percentage_used !== null) {
      return { value: disk.percentage_used, label: "Percentage Used" }
    }

    if (diskType === "SSD") {
      // Prioridad: Media Wearout Indicator > Wear Leveling Count > SSD Life Left
      if (disk.media_wearout_indicator !== undefined && disk.media_wearout_indicator !== null) {
        return { value: disk.media_wearout_indicator, label: "Media Wearout" }
      }
      if (disk.wear_leveling_count !== undefined && disk.wear_leveling_count !== null) {
        return { value: disk.wear_leveling_count, label: "Wear Level" }
      }
      if (disk.ssd_life_left !== undefined && disk.ssd_life_left !== null) {
        return { value: 100 - disk.ssd_life_left, label: "Life Used" }
      }
    }

    return null
  }

  const getWearColor = (wearPercent: number): string => {
    if (wearPercent <= 50) return "text-green-500"
    if (wearPercent <= 80) return "text-yellow-500"
    return "text-red-500"
  }

  const getEstimatedLifeRemaining = (disk: DiskInfo): string | null => {
    const wearIndicator = getWearIndicator(disk)
    if (!wearIndicator || !disk.power_on_hours || disk.power_on_hours === 0) {
      return null
    }

    const wearPercent = wearIndicator.value
    const hoursUsed = disk.power_on_hours

    // Si el desgaste es 0, no podemos calcular
    if (wearPercent === 0) {
      return "N/A"
    }

    // Calcular horas totales estimadas: hoursUsed / (wearPercent / 100)
    const totalEstimatedHours = hoursUsed / (wearPercent / 100)
    const remainingHours = totalEstimatedHours - hoursUsed

    // Convertir a aÃ±os
    const remainingYears = remainingHours / 8760 // 8760 horas en un aÃ±o

    if (remainingYears < 1) {
      const remainingMonths = Math.round(remainingYears * 12)
      return `~${remainingMonths} months`
    }

    return `~${remainingYears.toFixed(1)} years`
  }

  const getDiskHealthBreakdown = () => {
    if (!storageData || !storageData.disks) {
      return { normal: 0, warning: 0, critical: 0 }
    }

    let normal = 0
    let warning = 0
    let critical = 0

    storageData.disks.forEach((disk) => {
      if (disk.temperature === 0) {
        // Si no hay temperatura, considerarlo normal
        normal++
        return
      }

      const diskType = getDiskType(disk.name, disk.rotation_rate)

      switch (diskType) {
        case "NVMe":
          if (disk.temperature <= 70) normal++
          else if (disk.temperature <= 80) warning++
          else critical++
          break
        case "SSD":
          if (disk.temperature <= 59) normal++
          else if (disk.temperature <= 70) warning++
          else critical++
          break
        case "HDD":
        default:
          if (disk.temperature <= 45) normal++
          else if (disk.temperature <= 55) warning++
          else critical++
          break
      }
    })

    return { normal, warning, critical }
  }

  const getDiskTypesBreakdown = () => {
    if (!storageData || !storageData.disks) {
      return { nvme: 0, ssd: 0, hdd: 0 }
    }

    let nvme = 0
    let ssd = 0
    let hdd = 0

    storageData.disks.forEach((disk) => {
      const diskType = getDiskType(disk.name, disk.rotation_rate)
      if (diskType === "NVMe") nvme++
      else if (diskType === "SSD") ssd++
      else if (diskType === "HDD") hdd++
    })

    return { nvme, ssd, hdd }
  }

  const getWearProgressColor = (wearPercent: number): string => {
    if (wearPercent < 70) return "[&>div]:bg-blue-500"
    if (wearPercent < 85) return "[&>div]:bg-yellow-500"
    return "[&>div]:bg-red-500"
  }

  const getUsageColor = (percent: number): string => {
    if (percent < 70) return "text-blue-500"
    if (percent < 85) return "text-yellow-500"
    if (percent < 95) return "text-orange-500"
    return "text-red-500"
  }

  const diskHealthBreakdown = getDiskHealthBreakdown()
  const diskTypesBreakdown = getDiskTypesBreakdown()

  const localStorageTypes = ["dir", "lvmthin", "lvm", "zfspool", "btrfs"]
  const remoteStorageTypes = ["pbs", "nfs", "cifs", "smb", "glusterfs", "iscsi", "iscsidirect", "rbd", "cephfs"]

  const totalLocalUsed =
    proxmoxStorage?.storage
      .filter(
        (storage) =>
          storage &&
          storage.name &&
          storage.status === "active" &&
          storage.total > 0 &&
          storage.used >= 0 &&
          storage.available >= 0 &&
          localStorageTypes.includes(storage.type.toLowerCase()),
      )
      .reduce((sum, storage) => sum + storage.used, 0) || 0

  const totalLocalCapacity =
    proxmoxStorage?.storage
      .filter(
        (storage) =>
          storage &&
          storage.name &&
          storage.status === "active" &&
          storage.total > 0 &&
          storage.used >= 0 &&
          storage.available >= 0 &&
          localStorageTypes.includes(storage.type.toLowerCase()),
      )
      .reduce((sum, storage) => sum + storage.total, 0) || 0

  const localUsagePercent = totalLocalCapacity > 0 ? ((totalLocalUsed / totalLocalCapacity) * 100).toFixed(2) : "0.00"

  const totalRemoteUsed =
    proxmoxStorage?.storage
      .filter(
        (storage) =>
          storage &&
          storage.name &&
          storage.status === "active" &&
          storage.total > 0 &&
          storage.used >= 0 &&
          storage.available >= 0 &&
          remoteStorageTypes.includes(storage.type.toLowerCase()),
      )
      .reduce((sum, storage) => sum + storage.used, 0) || 0

  const totalRemoteCapacity =
    proxmoxStorage?.storage
      .filter(
        (storage) =>
          storage &&
          storage.name &&
          storage.status === "active" &&
          storage.total > 0 &&
          storage.used >= 0 &&
          storage.available >= 0 &&
          remoteStorageTypes.includes(storage.type.toLowerCase()),
      )
      .reduce((sum, storage) => sum + storage.total, 0) || 0

  const remoteUsagePercent =
    totalRemoteCapacity > 0 ? ((totalRemoteUsed / totalRemoteCapacity) * 100).toFixed(2) : "0.00"

  const remoteStorageCount =
    proxmoxStorage?.storage.filter(
      (storage) =>
        storage &&
        storage.name &&
        storage.status === "active" &&
        remoteStorageTypes.includes(storage.type.toLowerCase()),
    ).length || 0

  if (loading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-muted-foreground">Loading storage information...</div>
      </div>
    )
  }

  if (!storageData || storageData.error) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-red-500">Error loading storage data: {storageData?.error || "Unknown error"}</div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Storage Summary */}
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-3 lg:gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Total Storage</CardTitle>
            <HardDrive className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold">{storageData.total.toFixed(1)} TB</div>
            <p className="text-xs text-muted-foreground mt-1">{storageData.disk_count} physical disks</p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Local Used</CardTitle>
            <Database className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold">{formatStorage(totalLocalUsed)}</div>
            <p className="text-xs mt-1">
              <span className={getUsageColor(Number.parseFloat(localUsagePercent))}>{localUsagePercent}%</span>
              <span className="text-muted-foreground"> of </span>
              <span className="text-green-500">{formatStorage(totalLocalCapacity)}</span>
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Remote Used</CardTitle>
            <Archive className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold">
              {remoteStorageCount > 0 ? formatStorage(totalRemoteUsed) : "None"}
            </div>
            <p className="text-xs mt-1">
              {remoteStorageCount > 0 ? (
                <>
                  <span className={getUsageColor(Number.parseFloat(remoteUsagePercent))}>{remoteUsagePercent}%</span>
                  <span className="text-muted-foreground"> of </span>
                  <span className="text-green-500">{formatStorage(totalRemoteCapacity)}</span>
                </>
              ) : (
                <span className="text-muted-foreground">No remote storage</span>
              )}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Physical Disks</CardTitle>
            <HardDrive className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold">{storageData.disk_count} disks</div>
            <div className="space-y-1 mt-1">
              <p className="text-xs">
                {diskTypesBreakdown.nvme > 0 && <span className="text-purple-500">{diskTypesBreakdown.nvme} NVMe</span>}
                {diskTypesBreakdown.ssd > 0 && (
                  <>
                    {diskTypesBreakdown.nvme > 0 && ", "}
                    <span className="text-cyan-500">{diskTypesBreakdown.ssd} SSD</span>
                  </>
                )}
                {diskTypesBreakdown.hdd > 0 && (
                  <>
                    {(diskTypesBreakdown.nvme > 0 || diskTypesBreakdown.ssd > 0) && ", "}
                    <span className="text-blue-500">{diskTypesBreakdown.hdd} HDD</span>
                  </>
                )}
              </p>
              <p className="text-xs">
                <span className="text-green-500">{diskHealthBreakdown.normal} normal</span>
                {diskHealthBreakdown.warning > 0 && (
                  <>
                    {", "}
                    <span className="text-yellow-500">{diskHealthBreakdown.warning} warning</span>
                  </>
                )}
                {diskHealthBreakdown.critical > 0 && (
                  <>
                    {", "}
                    <span className="text-red-500">{diskHealthBreakdown.critical} critical</span>
                  </>
                )}
              </p>
            </div>
          </CardContent>
        </Card>
      </div>

      {proxmoxStorage && proxmoxStorage.storage && proxmoxStorage.storage.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5" />
              Proxmox Storage
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {proxmoxStorage.storage
                .filter((storage) => storage && storage.name && storage.used >= 0 && storage.available >= 0)
                .sort((a, b) => a.name.localeCompare(b.name))
                .map((storage) => (
                  <div
                    key={storage.name}
                    className={`border rounded-lg p-4 ${
                      storage.status === "error" ? "border-red-500/50 bg-red-500/5" : ""
                    }`}
                  >
                    <div className="flex items-center justify-between mb-3">
                      {/* Desktop: Icon + Name + Badge tipo alineados horizontalmente */}
                      <div className="hidden md:flex items-center gap-3">
                        <Database className="h-5 w-5 text-muted-foreground" />
                        <h3 className="font-semibold text-lg">{storage.name}</h3>
                        <Badge className={getStorageTypeBadge(storage.type)}>{storage.type}</Badge>
                      </div>

                      <div className="flex md:hidden items-center gap-2 flex-1">
                        <Database className="h-5 w-5 text-muted-foreground flex-shrink-0" />
                        <Badge className={getStorageTypeBadge(storage.type)}>{storage.type}</Badge>
                        <h3 className="font-semibold text-base flex-1 min-w-0 truncate">{storage.name}</h3>
                        {getStatusIcon(storage.status)}
                      </div>

                      {/* Desktop: Badge active + Porcentaje */}
                      <div className="hidden md:flex items-center gap-2">
                        <Badge
                          className={
                            storage.status === "active"
                              ? "bg-green-500/10 text-green-500 border-green-500/20"
                              : storage.status === "error"
                                ? "bg-red-500/10 text-red-500 border-red-500/20"
                                : "bg-gray-500/10 text-gray-500 border-gray-500/20"
                          }
                        >
                          {storage.status}
                        </Badge>
                        <span className="text-sm font-medium">{storage.percent}%</span>
                      </div>
                    </div>

                    <div className="space-y-2">
                      <Progress
                        value={storage.percent}
                        className={`h-2 ${
                          storage.percent > 90
                            ? "[&>div]:bg-red-500"
                            : storage.percent > 75
                              ? "[&>div]:bg-yellow-500"
                              : "[&>div]:bg-blue-500"
                        }`}
                      />
                      <div className="grid grid-cols-3 gap-4 text-sm">
                        <div>
                          <p className="text-muted-foreground">Total</p>
                          <p className="font-medium">{formatStorage(storage.total)}</p>
                        </div>
                        <div>
                          <p className="text-muted-foreground">Used</p>
                          <p
                            className={`font-medium ${
                              storage.percent > 90
                                ? "text-red-400"
                                : storage.percent > 75
                                  ? "text-yellow-400"
                                  : "text-blue-400"
                            }`}
                          >
                            {formatStorage(storage.used)}
                          </p>
                        </div>
                        <div>
                          <p className="text-muted-foreground">Available</p>
                          <p className="font-medium text-green-400">{formatStorage(storage.available)}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* ZFS Pools */}
      {storageData.zfs_pools && storageData.zfs_pools.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Database className="h-5 w-5" />
              ZFS Pools
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {storageData.zfs_pools.map((pool) => (
                <div key={pool.name} className="border rounded-lg p-4">
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-3">
                      <h3 className="font-semibold text-lg">{pool.name}</h3>
                      {getHealthBadge(pool.health)}
                    </div>
                    {getHealthIcon(pool.health)}
                  </div>
                  <div className="grid grid-cols-3 gap-4 text-sm">
                    <div>
                      <p className="text-sm text-muted-foreground">Size</p>
                      <p className="font-medium">{pool.size}</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground">Allocated</p>
                      <p className="font-medium">{pool.allocated}</p>
                    </div>
                    <div>
                      <p className="text-sm text-muted-foreground">Free</p>
                      <p className="font-medium">{pool.free}</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Physical Disks */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <HardDrive className="h-5 w-5" />
            Physical Disks & SMART Status
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {storageData.disks.map((disk) => (
              <div key={disk.name}>
                <div
                  className="sm:hidden border border-white/10 rounded-lg p-4 cursor-pointer bg-white/5 transition-colors"
                  onClick={() => handleDiskClick(disk)}
                >
                  <div className="space-y-2 mb-3">
                    {/* Row 1: Device name and type badge */}
                    <div className="flex items-center gap-2">
                      <HardDrive className="h-5 w-5 text-muted-foreground flex-shrink-0" />
                      <h3 className="font-semibold">/dev/{disk.name}</h3>
                      <Badge className={getDiskTypeBadge(disk.name, disk.rotation_rate).className}>
                        {getDiskTypeBadge(disk.name, disk.rotation_rate).label}
                      </Badge>
                    </div>

                    {/* Row 2: Model, temperature, and health status */}
                    <div className="flex items-center justify-between gap-3 pl-7">
                      {disk.model && disk.model !== "Unknown" && (
                        <p className="text-sm text-muted-foreground truncate flex-1 min-w-0">{disk.model}</p>
                      )}
                      <div className="flex items-center gap-3 flex-shrink-0">
                        {disk.temperature > 0 && (
                          <div className="flex items-center gap-1">
                            <Thermometer
                              className={`h-4 w-4 ${getTempColor(disk.temperature, disk.name, disk.rotation_rate)}`}
                            />
                            <span
                              className={`text-sm font-medium ${getTempColor(disk.temperature, disk.name, disk.rotation_rate)}`}
                            >
                              {disk.temperature}Â°C
                            </span>
                          </div>
                        )}
                        {getHealthBadge(disk.health)}
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 gap-4 text-sm">
                    {disk.size_formatted && (
                      <div>
                        <p className="text-sm text-muted-foreground">Size</p>
                        <p className="font-medium">{disk.size_formatted}</p>
                      </div>
                    )}
                    {disk.smart_status && disk.smart_status !== "unknown" && (
                      <div>
                        <p className="text-sm text-muted-foreground">SMART Status</p>
                        <p className="font-medium capitalize">{disk.smart_status}</p>
                      </div>
                    )}
                    {disk.power_on_hours !== undefined && disk.power_on_hours > 0 && (
                      <div>
                        <p className="text-sm text-muted-foreground">Power On Time</p>
                        <p className="font-medium">{formatHours(disk.power_on_hours)}</p>
                      </div>
                    )}
                    {disk.serial && disk.serial !== "Unknown" && (
                      <div>
                        <p className="text-sm text-muted-foreground">Serial</p>
                        <p className="font-medium text-xs">{disk.serial}</p>
                      </div>
                    )}
                  </div>
                </div>

                <div
                  className="hidden sm:block border border-white/10 rounded-lg p-4 cursor-pointer bg-card hover:bg-white/5 transition-colors"
                  onClick={() => handleDiskClick(disk)}
                >
                  <div className="space-y-2 mb-3">
                    {/* Row 1: Device name and type badge */}
                    <div className="flex items-center gap-2">
                      <HardDrive className="h-5 w-5 text-muted-foreground flex-shrink-0" />
                      <h3 className="font-semibold">/dev/{disk.name}</h3>
                      <Badge className={getDiskTypeBadge(disk.name, disk.rotation_rate).className}>
                        {getDiskTypeBadge(disk.name, disk.rotation_rate).label}
                      </Badge>
                    </div>

                    {/* Row 2: Model, temperature, and health status */}
                    <div className="flex items-center justify-between gap-3 pl-7">
                      {disk.model && disk.model !== "Unknown" && (
                        <p className="text-sm text-muted-foreground truncate flex-1 min-w-0">{disk.model}</p>
                      )}
                      <div className="flex items-center gap-3 flex-shrink-0">
                        {disk.temperature > 0 && (
                          <div className="flex items-center gap-1">
                            <Thermometer
                              className={`h-4 w-4 ${getTempColor(disk.temperature, disk.name, disk.rotation_rate)}`}
                            />
                            <span
                              className={`text-sm font-medium ${getTempColor(disk.temperature, disk.name, disk.rotation_rate)}`}
                            >
                              {disk.temperature}Â°C
                            </span>
                          </div>
                        )}
                        {getHealthBadge(disk.health)}
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    {disk.size_formatted && (
                      <div>
                        <p className="text-sm text-muted-foreground">Size</p>
                        <p className="font-medium">{disk.size_formatted}</p>
                      </div>
                    )}
                    {disk.smart_status && disk.smart_status !== "unknown" && (
                      <div>
                        <p className="text-sm text-muted-foreground">SMART Status</p>
                        <p className="font-medium capitalize">{disk.smart_status}</p>
                      </div>
                    )}
                    {disk.power_on_hours !== undefined && disk.power_on_hours > 0 && (
                      <div>
                        <p className="text-sm text-muted-foreground">Power On Time</p>
                        <p className="font-medium">{formatHours(disk.power_on_hours)}</p>
                      </div>
                    )}
                    {disk.serial && disk.serial !== "Unknown" && (
                      <div>
                        <p className="text-sm text-muted-foreground">Serial</p>
                        <p className="font-medium text-xs">{disk.serial}</p>
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Disk Details Dialog */}
      <Dialog open={detailsOpen} onOpenChange={setDetailsOpen}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <HardDrive className="h-5 w-5" />
              Disk Details: /dev/{selectedDisk?.name}
            </DialogTitle>
            <DialogDescription>Complete SMART information and health status</DialogDescription>
          </DialogHeader>
          {selectedDisk && (
            <div className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <p className="text-sm text-muted-foreground">Model</p>
                  <p className="font-medium">{selectedDisk.model}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Serial Number</p>
                  <p className="font-medium">{selectedDisk.serial}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Capacity</p>
                  <p className="font-medium">{selectedDisk.size_formatted}</p>
                </div>
                <div>
                  <p className="text-sm text-muted-foreground">Health Status</p>
                  <div className="mt-1">{getHealthBadge(selectedDisk.health)}</div>
                </div>
              </div>

              {/* Wear & Lifetime Section */}
              {getWearIndicator(selectedDisk) && (
                <div className="border-t pt-4">
                  <h4 className="font-semibold mb-3">Wear & Lifetime</h4>
                  <div className="space-y-3">
                    <div>
                      <div className="flex items-center justify-between mb-2">
                        <p className="text-sm text-muted-foreground">{getWearIndicator(selectedDisk)!.label}</p>
                        <p className={`font-medium ${getWearColor(getWearIndicator(selectedDisk)!.value)}`}>
                          {getWearIndicator(selectedDisk)!.value}%
                        </p>
                      </div>
                      <Progress
                        value={getWearIndicator(selectedDisk)!.value}
                        className={`h-2 ${getWearProgressColor(getWearIndicator(selectedDisk)!.value)}`}
                      />
                    </div>
                    {getEstimatedLifeRemaining(selectedDisk) && (
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <p className="text-sm text-muted-foreground">Estimated Life Remaining</p>
                          <p className="font-medium">{getEstimatedLifeRemaining(selectedDisk)}</p>
                        </div>
                        {selectedDisk.total_lbas_written && selectedDisk.total_lbas_written > 0 && (
                          <div>
                            <p className="text-sm text-muted-foreground">Total Data Written</p>
                            <p className="font-medium">
                              {selectedDisk.total_lbas_written >= 1024
                                ? `${(selectedDisk.total_lbas_written / 1024).toFixed(2)} TB`
                                : `${selectedDisk.total_lbas_written.toFixed(2)} GB`}
                            </p>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              )}

              <div className="border-t pt-4">
                <h4 className="font-semibold mb-3">SMART Attributes</h4>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <p className="text-sm text-muted-foreground">Temperature</p>
                    <p
                      className={`font-medium ${getTempColor(selectedDisk.temperature, selectedDisk.name, selectedDisk.rotation_rate)}`}
                    >
                      {selectedDisk.temperature > 0 ? `${selectedDisk.temperature}Â°C` : "N/A"}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Power On Hours</p>
                    <p className="font-medium">
                      {selectedDisk.power_on_hours && selectedDisk.power_on_hours > 0
                        ? `${selectedDisk.power_on_hours.toLocaleString()}h (${formatHours(selectedDisk.power_on_hours)})`
                        : "N/A"}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Rotation Rate</p>
                    <p className="font-medium">{formatRotationRate(selectedDisk.rotation_rate)}</p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Power Cycles</p>
                    <p className="font-medium">
                      {selectedDisk.power_cycles && selectedDisk.power_cycles > 0
                        ? selectedDisk.power_cycles.toLocaleString()
                        : "N/A"}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">SMART Status</p>
                    <p className="font-medium capitalize">{selectedDisk.smart_status}</p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Reallocated Sectors</p>
                    <p
                      className={`font-medium ${selectedDisk.reallocated_sectors && selectedDisk.reallocated_sectors > 0 ? "text-yellow-500" : ""}`}
                    >
                      {selectedDisk.reallocated_sectors ?? 0}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">Pending Sectors</p>
                    <p
                      className={`font-medium ${selectedDisk.pending_sectors && selectedDisk.pending_sectors > 0 ? "text-yellow-500" : ""}`}
                    >
                      {selectedDisk.pending_sectors ?? 0}
                    </p>
                  </div>
                  <div>
                    <p className="text-sm text-muted-foreground">CRC Errors</p>
                    <p
                      className={`font-medium ${selectedDisk.crc_errors && selectedDisk.crc_errors > 0 ? "text-yellow-500" : ""}`}
                    >
                      {selectedDisk.crc_errors ?? 0}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>
    </div>
  )
}



================================================
FILE: AppImage/components/system-overview.tsx
================================================
"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "./ui/card"
import { Progress } from "./ui/progress"
import { Badge } from "./ui/badge"
import { Cpu, MemoryStick, Thermometer, Server, Zap, AlertCircle, HardDrive, Network } from "lucide-react"
import { NodeMetricsCharts } from "./node-metrics-charts"
import { NetworkTrafficChart } from "./network-traffic-chart"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "./ui/select"
import { fetchApi } from "../lib/api-config"
import { formatNetworkTraffic, getNetworkUnit } from "../lib/format-network"

interface SystemData {
  cpu_usage: number
  memory_usage: number
  memory_total: number
  memory_used: number
  temperature: number
  uptime: string
  load_average: number[]
  hostname: string
  node_id: string
  timestamp: string
  cpu_cores?: number
  cpu_threads?: number
  proxmox_version?: string
  kernel_version?: string
  available_updates?: number
}

interface VMData {
  vmid: number
  name: string
  status: string
  cpu: number
  mem: number
  maxmem: number
  disk: number
  maxdisk: number
  uptime: number
  type?: string
}

interface StorageData {
  total: number
  used: number
  available: number
  disk_count: number
  disks: Array<{
    name: string
    mountpoint: string
    total: number
    used: number
    available: number
    usage_percent: number
  }>
}

interface NetworkData {
  interfaces: Array<{
    name: string
    status: string
    addresses: Array<{ ip: string; netmask: string }>
  }>
  traffic: {
    bytes_sent: number
    bytes_recv: number
    packets_sent: number
    packets_recv: number
  }
  physical_active_count?: number
  physical_total_count?: number
  bridge_active_count?: number
  bridge_total_count?: number
  physical_interfaces?: Array<{
    name: string
    status: string
    addresses: Array<{ ip: string; netmask: string }>
  }>
  bridge_interfaces?: Array<{
    name: string
    status: string
    addresses: Array<{ ip: string; netmask: string }>
  }>
}

interface ProxmoxStorageData {
  storage: Array<{
    name: string
    type: string
    status: string
    total: number
    used: number
    available: number
    percent: number
  }>
}

const fetchSystemData = async (retries = 3, delayMs = 500): Promise<SystemData | null> => {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const data = await fetchApi<SystemData>("/api/system")
      return data
    } catch (error) {
      if (attempt === retries - 1) {
        console.error("[v0] Failed to fetch system data after retries:", error)
        return null
      }
      // Wait before retry
      await new Promise((resolve) => setTimeout(resolve, delayMs))
    }
  }
  return null
}

const fetchVMData = async (): Promise<VMData[]> => {
  try {
    const data = await fetchApi<any>("/api/vms")
    return Array.isArray(data) ? data : data.vms || []
  } catch (error) {
    console.error("[v0] Failed to fetch VM data:", error)
    return []
  }
}

const fetchStorageData = async (): Promise<StorageData | null> => {
  try {
    const data = await fetchApi<StorageData>("/api/storage/summary")
    return data
  } catch (error) {
    console.log("[v0] Storage API not available (this is normal if not configured)")
    return null
  }
}

const fetchNetworkData = async (): Promise<NetworkData | null> => {
  try {
    const data = await fetchApi<NetworkData>("/api/network/summary")
    return data
  } catch (error) {
    console.log("[v0] Network API not available (this is normal if not configured)")
    return null
  }
}

const fetchProxmoxStorageData = async (): Promise<ProxmoxStorageData | null> => {
  try {
    const data = await fetchApi<ProxmoxStorageData>("/api/proxmox-storage")
    return data
  } catch (error) {
    console.log("[v0] Proxmox storage API not available")
    return null
  }
}

const getUnitsSettings = (): "Bytes" | "Bits" => {
  if (typeof window === "undefined") return "Bytes"
  const raw = window.localStorage.getItem("proxmenux-network-unit")
  return raw && raw.toLowerCase() === "bits" ? "Bits" : "Bytes"
}

export function SystemOverview() {
  const [systemData, setSystemData] = useState<SystemData | null>(null)
  const [vmData, setVmData] = useState<VMData[]>([])
  const [storageData, setStorageData] = useState<StorageData | null>(null)
  const [proxmoxStorageData, setProxmoxStorageData] = useState<ProxmoxStorageData | null>(null)
  const [networkData, setNetworkData] = useState<NetworkData | null>(null)
  const [loadingStates, setLoadingStates] = useState({
    system: true,
    vms: true,
    storage: true,
    network: true,
  })
  const [error, setError] = useState<string | null>(null)
  const [hasAttemptedLoad, setHasAttemptedLoad] = useState(false) // Added hasAttemptedLoad state
  const [networkTimeframe, setNetworkTimeframe] = useState("day")
  const [networkTotals, setNetworkTotals] = useState<{ received: number; sent: number }>({ received: 0, sent: 0 })
  const [networkUnit, setNetworkUnit] = useState<"Bytes" | "Bits">("Bytes") // Added networkUnit state

  useEffect(() => {
    const fetchAllData = async () => {
      const [systemResult, vmResult, storageResults, networkResult] = await Promise.all([
        fetchSystemData().finally(() => setLoadingStates((prev) => ({ ...prev, system: false }))),
        fetchVMData().finally(() => setLoadingStates((prev) => ({ ...prev, vms: false }))),
        Promise.all([fetchStorageData(), fetchProxmoxStorageData()]).finally(() =>
          setLoadingStates((prev) => ({ ...prev, storage: false })),
        ),
        fetchNetworkData().finally(() => setLoadingStates((prev) => ({ ...prev, network: false }))),
      ])

      setHasAttemptedLoad(true)

      if (!systemResult) {
        setError("Flask server not available. Please ensure the server is running.")
        return
      }

      setSystemData(systemResult)
      setVmData(vmResult)
      setStorageData(storageResults[0])
      setProxmoxStorageData(storageResults[1])
      setNetworkData(networkResult)

      setTimeout(async () => {
        const refreshedSystemData = await fetchSystemData()
        if (refreshedSystemData) {
          setSystemData(refreshedSystemData)
        }
      }, 2000)
    }

    fetchAllData()

    const systemInterval = setInterval(async () => {
      const data = await fetchSystemData()
      if (data) setSystemData(data)
    }, 9000)

    const vmInterval = setInterval(async () => {
      const data = await fetchVMData()
      setVmData(data)
    }, 59000)

    const storageInterval = setInterval(async () => {
      const [storage, proxmoxStorage] = await Promise.all([fetchStorageData(), fetchProxmoxStorageData()])
      if (storage) setStorageData(storage)
      if (proxmoxStorage) setProxmoxStorageData(proxmoxStorage)
    }, 59000)

    const networkInterval = setInterval(async () => {
      const data = await fetchNetworkData()
      if (data) setNetworkData(data)
    }, 59000)

    setNetworkUnit(getNetworkUnit()) // Load initial setting

    const handleUnitChange = (e: CustomEvent) => {
      setNetworkUnit(e.detail === "Bits" ? "Bits" : "Bytes")
    }

    window.addEventListener("networkUnitChanged" as any, handleUnitChange)

    return () => {
      clearInterval(systemInterval)
      clearInterval(vmInterval)
      clearInterval(storageInterval)
      clearInterval(networkInterval)
      window.removeEventListener("networkUnitChanged" as any, handleUnitChange)
    }
  }, [])

  if (!hasAttemptedLoad || loadingStates.system) {
    return (
      <div className="space-y-6">
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6">
          {[...Array(4)].map((_, i) => (
            <Card key={i} className="bg-card border-border animate-pulse">
              <CardContent className="p-6">
                <div className="h-4 bg-muted rounded w-1/2 mb-4"></div>
                <div className="h-8 bg-muted rounded w-3/4 mb-2"></div>
                <div className="h-2 bg-muted rounded w-full mb-2"></div>
                <div className="h-3 bg-muted rounded w-2/3"></div>
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    )
  }

  if (error || !systemData) {
    return (
      <div className="space-y-6">
        <Card className="bg-red-500/10 border-red-500/20">
          <CardContent className="p-6">
            <div className="flex items-center gap-3 text-red-600">
              <AlertCircle className="h-6 w-6" />
              <div>
                <div className="font-semibold text-lg mb-1">Flask Server Not Available</div>
                <div className="text-sm">
                  {error || "Unable to connect to the Flask server. Please ensure the server is running and try again."}
                </div>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    )
  }

  const vmStats = {
    total: vmData.length,
    running: vmData.filter((vm) => vm.status === "running").length,
    stopped: vmData.filter((vm) => vm.status === "stopped").length,
    lxc: vmData.filter((vm) => vm.type === "lxc").length,
    vms: vmData.filter((vm) => vm.type === "qemu" || !vm.type).length,
  }

  const getTemperatureStatus = (temp: number) => {
    if (temp === 0) return { status: "N/A", color: "bg-gray-500/10 text-gray-500 border-gray-500/20" }
    if (temp < 60) return { status: "Normal", color: "bg-green-500/10 text-green-500 border-green-500/20" }
    if (temp < 75) return { status: "Warm", color: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20" }
    return { status: "Hot", color: "bg-red-500/10 text-red-500 border-red-500/20" }
  }

  const formatUptime = (seconds: number) => {
    if (!seconds || seconds === 0) return "Stopped"
    const days = Math.floor(seconds / 86400)
    const hours = Math.floor((seconds % 86400) / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)

    if (days > 0) return `${days}d ${hours}h`
    if (hours > 0) return `${hours}h ${minutes}m`
    return `${minutes}m`
  }

  const formatBytes = (bytes: number) => {
    return (bytes / 1024 ** 3).toFixed(2)
  }

  const tempStatus = getTemperatureStatus(systemData.temperature)

  const localStorage = proxmoxStorageData?.storage.find((s) => s.name === "local")

  const vmLxcStorages = proxmoxStorageData?.storage.filter(
    (s) =>
      (s.type === "lvm" || s.type === "lvmthin" || s.type === "zfspool" || s.type === "btrfs" || s.type === "dir") &&
      s.type !== "nfs" &&
      s.type !== "cifs" &&
      s.type !== "iscsi" &&
      s.name !== "local",
  )

  const vmLxcStorageTotal = vmLxcStorages?.reduce((acc, s) => acc + s.total, 0) || 0
  const vmLxcStorageUsed = vmLxcStorages?.reduce((acc, s) => acc + s.used, 0) || 0
  const vmLxcStorageAvailable = vmLxcStorages?.reduce((acc, s) => acc + s.available, 0) || 0
  const vmLxcStoragePercent = vmLxcStorageTotal > 0 ? (vmLxcStorageUsed / vmLxcStorageTotal) * 100 : 0

  const getLoadStatus = (load: number, cores: number) => {
    if (load < cores) {
      return { status: "Normal", color: "bg-green-500/10 text-green-500 border-green-500/20" }
    } else if (load < cores * 1.5) {
      return { status: "Moderate", color: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20" }
    } else {
      return { status: "High", color: "bg-red-500/10 text-red-500 border-red-500/20" }
    }
  }

  const systemAlerts = []
  if (systemData.available_updates && systemData.available_updates > 0) {
    systemAlerts.push({
      type: "warning",
      message: `${systemData.available_updates} updates available`,
    })
  }
  if (vmStats.stopped > 0) {
    systemAlerts.push({
      type: "info",
      message: `${vmStats.stopped} VM${vmStats.stopped > 1 ? "s" : ""} stopped`,
    })
  }
  if (systemData.temperature > 75) {
    systemAlerts.push({
      type: "warning",
      message: "High temperature detected",
    })
  }
  if (localStorage && localStorage.percent > 90) {
    systemAlerts.push({
      type: "warning",
      message: "System storage almost full",
    })
  }

  const loadStatus = getLoadStatus(systemData.load_average[0], systemData.cpu_cores || 8)

  const getTimeframeLabel = (timeframe: string): string => {
    switch (timeframe) {
      case "hour":
        return "1h"
      case "day":
        return "24h"
      case "week":
        return "7d"
      case "month":
        return "30d"
      case "year":
        return "1y"
      default:
        return timeframe
    }
  }

  return (
    <div className="space-y-6">
      <div className="grid grid-cols-2 lg:grid-cols-4 gap-3 lg:gap-6">
        <Card className="bg-card border-border">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">CPU Usage</CardTitle>
            <Cpu className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{systemData.cpu_usage}%</div>
            <Progress value={systemData.cpu_usage} className="mt-2 [&>div]:bg-blue-500" />
            <p className="text-xs text-muted-foreground mt-2">Real-time usage</p>
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">Memory Usage</CardTitle>
            <MemoryStick className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">{systemData.memory_used.toFixed(1)} GB</div>
            <Progress value={systemData.memory_usage} className="mt-2 [&>div]:bg-blue-500" />
            <p className="text-xs text-muted-foreground mt-2">
              <span className="text-green-500 font-medium">{systemData.memory_usage.toFixed(1)}%</span> of{" "}
              {systemData.memory_total} GB
            </p>
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <Server className="h-5 w-5 mr-2" />
              Active VM & LXC
            </CardTitle>
          </CardHeader>
          <CardContent>
            {loadingStates.vms ? (
              <div className="space-y-2 animate-pulse">
                <div className="h-8 bg-muted rounded w-12"></div>
                <div className="h-5 bg-muted rounded w-24"></div>
                <div className="h-4 bg-muted rounded w-32"></div>
              </div>
            ) : (
              <>
                <div className="text-xl lg:text-2xl font-bold text-foreground">{vmStats.running}</div>
                <div className="mt-2 flex flex-wrap gap-1">
                  <Badge variant="outline" className="bg-green-500/10 text-green-500 border-green-500/20">
                    {vmStats.running} Running
                  </Badge>
                  {vmStats.stopped > 0 && (
                    <Badge variant="outline" className="bg-red-500/10 text-red-500 border-red-500/20">
                      {vmStats.stopped} Stopped
                    </Badge>
                  )}
                </div>
                <p className="text-xs text-muted-foreground mt-2">
                  Total: {vmStats.vms} VMs, {vmStats.lxc} LXC
                </p>
              </>
            )}
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium text-muted-foreground">Temperature</CardTitle>
            <Thermometer className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-xl lg:text-2xl font-bold text-foreground">
              {systemData.temperature === 0 ? "N/A" : `${systemData.temperature}Â°C`}
            </div>
            <div className="flex items-center mt-2">
              <Badge variant="outline" className={tempStatus.color}>
                {tempStatus.status}
              </Badge>
            </div>
            <p className="text-xs text-muted-foreground mt-2">
              {systemData.temperature === 0 ? "No sensor available" : "Live temperature reading"}
            </p>
          </CardContent>
        </Card>
      </div>

      <NodeMetricsCharts />

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <HardDrive className="h-5 w-5 mr-2" />
              Storage Overview
            </CardTitle>
          </CardHeader>
          <CardContent>
            {loadingStates.storage ? (
              <div className="space-y-4 animate-pulse">
                <div className="h-6 bg-muted rounded w-full"></div>
                <div className="h-4 bg-muted rounded w-3/4"></div>
                <div className="h-4 bg-muted rounded w-2/3"></div>
              </div>
            ) : storageData ? (
              <div className="space-y-4">
                {(() => {
                  const totalCapacity = (vmLxcStorageTotal || 0) + (localStorage?.total || 0)
                  const totalUsed = (vmLxcStorageUsed || 0) + (localStorage?.used || 0)
                  const totalAvailable = (vmLxcStorageAvailable || 0) + (localStorage?.available || 0)
                  const totalPercent = totalCapacity > 0 ? (totalUsed / totalCapacity) * 100 : 0

                  return totalCapacity > 0 ? (
                    <div className="space-y-2 pb-4 border-b-2 border-border">
                      <div className="flex justify-between items-center">
                        <span className="text-sm font-medium text-foreground">Total Node Capacity:</span>
                        <span className="text-lg font-bold text-foreground">
                          {formatNetworkTraffic(totalCapacity, "Bytes")}
                        </span>
                      </div>
                      <Progress
                        value={totalPercent}
                        className="mt-2 h-3 [&>div]:bg-gradient-to-r [&>div]:from-blue-500 [&>div]:to-purple-500"
                      />
                      <div className="flex justify-between items-center mt-1">
                        <div className="flex items-center gap-3">
                          <span className="text-xs text-muted-foreground">
                            Used:{" "}
                            <span className="font-semibold text-foreground">
                              {formatNetworkTraffic(totalUsed, "Bytes")}
                            </span>
                          </span>
                          <span className="text-xs text-muted-foreground">
                            Free:{" "}
                            <span className="font-semibold text-green-500">
                              {formatNetworkTraffic(totalAvailable, "Bytes")}
                            </span>
                          </span>
                        </div>
                        <span className="text-xs font-semibold text-muted-foreground">{totalPercent.toFixed(1)}%</span>
                      </div>
                    </div>
                  ) : null
                })()}

                <div className="space-y-2 pb-3 border-b border-border">
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Total Capacity:</span>
                    <span className="text-lg font-semibold text-foreground">{storageData.total} TB</span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Physical Disks:</span>
                    <span className="text-sm font-semibold text-foreground">
                      {storageData.disk_count} disk{storageData.disk_count !== 1 ? "s" : ""}
                    </span>
                  </div>
                </div>

                {vmLxcStorages && vmLxcStorages.length > 0 ? (
                  <div className="space-y-2 pb-3 border-b border-border">
                    <div className="text-xs font-medium text-muted-foreground mb-2">VM/LXC Storage</div>
                    <div className="flex justify-between items-center">
                      <span className="text-xs text-muted-foreground">Used:</span>
                      <span className="text-sm font-semibold text-foreground">
                        {formatNetworkTraffic(vmLxcStorageUsed, "Bytes")}
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-xs text-muted-foreground">Available:</span>
                      <span className="text-sm font-semibold text-green-500">
                        {formatNetworkTraffic(vmLxcStorageAvailable, "Bytes")}
                      </span>
                    </div>
                    <Progress value={vmLxcStoragePercent} className="mt-2 [&>div]:bg-blue-500" />
                    <div className="flex justify-between items-center mt-1">
                      <span className="text-xs text-muted-foreground">
                        {formatNetworkTraffic(vmLxcStorageUsed, "Bytes")} /{" "}
                        {formatNetworkTraffic(vmLxcStorageTotal, "Bytes")}
                      </span>
                      <span className="text-xs text-muted-foreground">{vmLxcStoragePercent.toFixed(1)}%</span>
                    </div>
                    {vmLxcStorages.length > 1 && (
                      <div className="text-xs text-muted-foreground mt-1">
                        {vmLxcStorages.length} storage volume{vmLxcStorages.length > 1 ? "s" : ""}
                      </div>
                    )}
                  </div>
                ) : (
                  <div className="space-y-2 pb-3 border-b border-border">
                    <div className="text-xs font-medium text-muted-foreground mb-2">VM/LXC Storage</div>
                    <div className="text-center py-4 text-muted-foreground text-sm">No VM/LXC storage configured</div>
                  </div>
                )}

                {localStorage && (
                  <div className="space-y-2">
                    <div className="text-xs font-medium text-muted-foreground mb-2">Local Storage (System)</div>
                    <div className="flex justify-between items-center">
                      <span className="text-xs text-muted-foreground">Used:</span>
                      <span className="text-sm font-semibold text-foreground">
                        {formatNetworkTraffic(localStorage.used, "Bytes")}
                      </span>
                    </div>
                    <div className="flex justify-between items-center">
                      <span className="text-xs text-muted-foreground">Available:</span>
                      <span className="text-sm font-semibold text-green-500">
                        {formatNetworkTraffic(localStorage.available, "Bytes")}
                      </span>
                    </div>
                    <Progress value={localStorage.percent} className="mt-2 [&>div]:bg-purple-500" />
                    <div className="flex justify-between items-center mt-1">
                      <span className="text-xs text-muted-foreground">
                        {formatNetworkTraffic(localStorage.used, "Bytes")} /{" "}
                        {formatNetworkTraffic(localStorage.total, "Bytes")}
                      </span>
                      <span className="text-xs text-muted-foreground">{localStorage.percent.toFixed(1)}%</span>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="text-center py-8 text-muted-foreground">Storage data not available</div>
            )}
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center justify-between">
              <div className="flex items-center">
                <Network className="h-5 w-5 mr-2" />
                Network Overview
              </div>
              <Select value={networkTimeframe} onValueChange={setNetworkTimeframe}>
                <SelectTrigger className="w-28 h-8 text-xs">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="hour">1 Hour</SelectItem>
                  <SelectItem value="day">24 Hours</SelectItem>
                  <SelectItem value="week">7 Days</SelectItem>
                  <SelectItem value="month">30 Days</SelectItem>
                  <SelectItem value="year">1 Year</SelectItem>
                </SelectContent>
              </Select>
            </CardTitle>
          </CardHeader>
          <CardContent>
            {loadingStates.network ? (
              <div className="space-y-4 animate-pulse">
                <div className="h-6 bg-muted rounded w-full"></div>
                <div className="h-4 bg-muted rounded w-3/4"></div>
                <div className="h-4 bg-muted rounded w-2/3"></div>
              </div>
            ) : networkData ? (
              <div className="space-y-4">
                <div className="flex justify-between items-center pb-3 border-b border-border">
                  <span className="text-sm text-muted-foreground">Active Interfaces:</span>
                  <span className="text-lg font-semibold text-foreground">
                    {(networkData.physical_active_count || 0) + (networkData.bridge_active_count || 0)}
                  </span>
                </div>

                <div className="space-y-2">
                  {networkData.physical_interfaces && networkData.physical_interfaces.length > 0 && (
                    <div className="flex flex-wrap gap-2">
                      {networkData.physical_interfaces
                        .filter((iface) => iface.status === "up")
                        .map((iface) => (
                          <Badge
                            key={iface.name}
                            variant="outline"
                            className="bg-blue-500/10 text-blue-500 border-blue-500/20"
                          >
                            {iface.name}
                          </Badge>
                        ))}
                    </div>
                  )}

                  {networkData.bridge_interfaces && networkData.bridge_interfaces.length > 0 && (
                    <div className="flex flex-wrap gap-2">
                      {networkData.bridge_interfaces
                        .filter((iface) => iface.status === "up")
                        .map((iface) => (
                          <Badge
                            key={iface.name}
                            variant="outline"
                            className="bg-green-500/10 text-green-500 border-green-500/20"
                          >
                            {iface.name}
                          </Badge>
                        ))}
                    </div>
                  )}
                </div>

                <div className="pt-2 border-t border-border space-y-2">
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Received:</span>
                    <span className="text-lg font-semibold text-green-500 flex items-center gap-1">
                      â†“{" "}
                      {networkUnit === "Bytes"
                        ? `${networkTotals.received.toFixed(2)} GB`
                        : formatNetworkTraffic(networkTotals.received * 1024 * 1024 * 1024, "Bits")}
                      <span className="text-xs text-muted-foreground">({getTimeframeLabel(networkTimeframe)})</span>
                    </span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span className="text-sm text-muted-foreground">Sent:</span>
                    <span className="text-lg font-semibold text-blue-500 flex items-center gap-1">
                      â†‘{" "}
                      {networkUnit === "Bytes"
                        ? `${networkTotals.sent.toFixed(2)} GB`
                        : formatNetworkTraffic(networkTotals.sent * 1024 * 1024 * 1024, "Bits")}
                      <span className="text-xs text-muted-foreground">({getTimeframeLabel(networkTimeframe)})</span>
                    </span>
                  </div>
                </div>

                <div className="pt-3 border-t border-border">
                  <NetworkTrafficChart
                    timeframe={networkTimeframe}
                    onTotalsCalculated={setNetworkTotals}
                    networkUnit={networkUnit}
                  />
                </div>
              </div>
            ) : (
              <div className="text-center py-8 text-muted-foreground">Network data not available</div>
            )}
          </CardContent>
        </Card>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <Server className="h-5 w-5 mr-2" />
              System Information
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="flex justify-between">
              <span className="text-muted-foreground">Uptime:</span>
              <span className="text-foreground">{systemData.uptime}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Proxmox Version:</span>
              <span className="text-foreground">{systemData.proxmox_version || "N/A"}</span>
            </div>
            <div className="flex justify-between">
              <span className="text-muted-foreground">Kernel:</span>
              <span className="text-foreground font-mono text-sm">{systemData.kernel_version || "Linux"}</span>
            </div>
            {systemData.available_updates !== undefined && systemData.available_updates > 0 && (
              <div className="flex justify-between">
                <span className="text-muted-foreground">Available Updates:</span>
                <Badge variant="outline" className="bg-yellow-500/10 text-yellow-500 border-yellow-500/20">
                  {systemData.available_updates} packages
                </Badge>
              </div>
            )}
          </CardContent>
        </Card>

        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="text-foreground flex items-center">
              <Zap className="h-5 w-5 mr-2" />
              System Overview
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="flex justify-between items-center pb-3 border-b border-border">
              <div className="flex flex-col">
                <span className="text-sm text-muted-foreground">Load Average (1m):</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-lg font-semibold text-foreground font-mono">
                  {systemData.load_average[0].toFixed(2)}
                </span>
                <Badge variant="outline" className={loadStatus.color}>
                  {loadStatus.status}
                </Badge>
              </div>
            </div>

            <div className="flex justify-between items-center pb-3 border-b border-border">
              <span className="text-sm text-muted-foreground">CPU Threads:</span>
              <span className="text-lg font-semibold text-foreground">{systemData.cpu_threads || "N/A"}</span>
            </div>

            <div className="flex justify-between items-center pb-3 border-b border-border">
              <span className="text-sm text-muted-foreground">Physical Disks:</span>
              <span className="text-lg font-semibold text-foreground">{storageData?.disk_count || "N/A"}</span>
            </div>

            <div className="flex justify-between items-center">
              <span className="text-sm text-muted-foreground">Network Interfaces:</span>
              <span className="text-lg font-semibold text-foreground">
                {networkData?.physical_total_count || networkData?.physical_interfaces?.length || "N/A"}
              </span>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  )
}



================================================
FILE: AppImage/components/terminal-panel.tsx
================================================
"use client"

import type React from "react"
import { useEffect, useRef, useState } from "react"
import { API_PORT } from "../lib/api-config"
import { fetchApi } from "@/lib/api-config" // Cambiando import para usar fetchApi directamente
import {
  Activity,
  Trash2,
  X,
  Search,
  Send,
  Lightbulb,
  Terminal,
  Plus,
  AlignJustify,
  Grid2X2,
  GripHorizontal,
} from "lucide-react"
import { Button } from "@/components/ui/button"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import type { CheatSheetResult } from "@/lib/cheat-sheet-result" // Declare CheatSheetResult here

type TerminalPanelProps = {
  websocketUrl?: string
  onClose?: () => void
}

interface TerminalInstance {
  id: string
  title: string
  term: any
  ws: WebSocket | null
  isConnected: boolean
  fitAddon: any // Added fitAddon to TerminalInstance
}

function getWebSocketUrl(): string {
  if (typeof window === "undefined") {
    return "ws://localhost:8008/ws/terminal"
  }

  const { protocol, hostname, port } = window.location
  const isStandardPort = port === "" || port === "80" || port === "443"

  const wsProtocol = protocol === "https:" ? "wss:" : "ws:"

  if (isStandardPort) {
    return `${wsProtocol}//${hostname}/ws/terminal`
  } else {
    return `${wsProtocol}//${hostname}:${API_PORT}/ws/terminal`
  }
}

function getApiUrl(endpoint?: string): string {
  if (typeof window === "undefined") {
    return "http://localhost:8008"
  }

  const { protocol, hostname } = window.location
  const apiProtocol = protocol === "https:" ? "https:" : "http:"
  return `${apiProtocol}//${hostname}:${API_PORT}${endpoint || ""}`
}

const proxmoxCommands = [
  { cmd: "pvesh get /nodes", desc: "List all Proxmox nodes" },
  { cmd: "pvesh get /nodes/{node}/qemu", desc: "List VMs on a node" },
  { cmd: "pvesh get /nodes/{node}/lxc", desc: "List LXC containers on a node" },
  { cmd: "pvesh get /nodes/{node}/storage", desc: "List storage on a node" },
  { cmd: "pvesh get /nodes/{node}/network", desc: "List network interfaces" },
  { cmd: "qm list", desc: "List all QEMU/KVM virtual machines" },
  { cmd: "qm start <vmid>", desc: "Start a virtual machine" },
  { cmd: "qm stop <vmid>", desc: "Stop a virtual machine" },
  { cmd: "qm shutdown <vmid>", desc: "Shutdown a virtual machine gracefully" },
  { cmd: "qm status <vmid>", desc: "Show VM status" },
  { cmd: "qm config <vmid>", desc: "Show VM configuration" },
  { cmd: "qm snapshot <vmid> <snapname>", desc: "Create VM snapshot" },
  { cmd: "pct list", desc: "List all LXC containers" },
  { cmd: "pct start <vmid>", desc: "Start LXC container" },
  { cmd: "pct stop <vmid>", desc: "Stop LXC container" },
  { cmd: "pct enter <vmid>", desc: "Enter LXC container console" },
  { cmd: "pct config <vmid>", desc: "Show container configuration" },
  { cmd: "pvesm status", desc: "Show storage status" },
  { cmd: "pvesm list <storage>", desc: "List storage content" },
  { cmd: "pveperf", desc: "Test Proxmox system performance" },
  { cmd: "pveversion", desc: "Show Proxmox VE version" },
  { cmd: "systemctl status pve-cluster", desc: "Check cluster status" },
  { cmd: "pvecm status", desc: "Show cluster status" },
  { cmd: "pvecm nodes", desc: "List cluster nodes" },
  { cmd: "zpool status", desc: "Show ZFS pool status" },
  { cmd: "zpool list", desc: "List all ZFS pools" },
  { cmd: "zfs list", desc: "List all ZFS datasets" },
  { cmd: "ls -la", desc: "List all files with details" },
  { cmd: "cd /path/to/dir", desc: "Change directory" },
  { cmd: "mkdir dirname", desc: "Create new directory" },
  { cmd: "rm -rf dirname", desc: "Remove directory recursively" },
  { cmd: "cp source dest", desc: "Copy files or directories" },
  { cmd: "mv source dest", desc: "Move or rename files" },
  { cmd: "cat filename", desc: "Display file contents" },
  { cmd: "grep 'pattern' file", desc: "Search for pattern in file" },
  { cmd: "find . -name 'file'", desc: "Find files by name" },
  { cmd: "chmod 755 file", desc: "Change file permissions" },
  { cmd: "chown user:group file", desc: "Change file owner" },
  { cmd: "tar -xzf file.tar.gz", desc: "Extract tar.gz archive" },
  { cmd: "tar -czf archive.tar.gz dir/", desc: "Create tar.gz archive" },
  { cmd: "df -h", desc: "Show disk usage" },
  { cmd: "du -sh *", desc: "Show directory sizes" },
  { cmd: "free -h", desc: "Show memory usage" },
  { cmd: "top", desc: "Show running processes" },
  { cmd: "ps aux | grep process", desc: "Find running process" },
  { cmd: "kill -9 PID", desc: "Force kill process" },
  { cmd: "systemctl status service", desc: "Check service status" },
  { cmd: "systemctl start service", desc: "Start a service" },
  { cmd: "systemctl stop service", desc: "Stop a service" },
  { cmd: "systemctl restart service", desc: "Restart a service" },
  { cmd: "apt update && apt upgrade", desc: "Update Debian/Ubuntu packages" },
  { cmd: "apt install package", desc: "Install package on Debian/Ubuntu" },
  { cmd: "apt remove package", desc: "Remove package" },
  { cmd: "docker ps", desc: "List running containers" },
  { cmd: "docker images", desc: "List Docker images" },
  { cmd: "docker exec -it container bash", desc: "Enter container shell" },
  { cmd: "ip addr show", desc: "Show IP addresses" },
  { cmd: "ping host", desc: "Test network connectivity" },
  { cmd: "curl -I url", desc: "Get HTTP headers" },
  { cmd: "wget url", desc: "Download file from URL" },
  { cmd: "ssh user@host", desc: "Connect via SSH" },
  { cmd: "scp file user@host:/path", desc: "Copy file via SSH" },
  { cmd: "tail -f /var/log/syslog", desc: "Follow log file in real-time" },
  { cmd: "history", desc: "Show command history" },
  { cmd: "clear", desc: "Clear terminal screen" },
]

export const TerminalPanel: React.FC<TerminalPanelProps> = ({ websocketUrl, onClose }) => {
  const [terminals, setTerminals] = useState<TerminalInstance[]>([])
  const [activeTerminalId, setActiveTerminalId] = useState<string>("")
  const [layout, setLayout] = useState<"single" | "grid">("grid")
  const [isMobile, setIsMobile] = useState(false)
  const [isTablet, setIsTablet] = useState(false)
  const [terminalHeight, setTerminalHeight] = useState<number>(500) // altura por defecto en px
  const [searchModalOpen, setSearchModalOpen] = useState(false)
  const [searchQuery, setSearchQuery] = useState("")
  const [filteredCommands, setFilteredCommands] = useState<Array<{ cmd: string; desc: string }>>(proxmoxCommands)
  const [isSearching, setIsSearching] = useState(false)
  const [searchResults, setSearchResults] = useState<CheatSheetResult[]>([])
  const [useOnline, setUseOnline] = useState(true)

  const containerRefs = useRef<{ [key: string]: HTMLDivElement | null }>({})

  useEffect(() => {
    const updateDeviceType = () => {
      const width = window.innerWidth
      const isTouchDevice = "ontouchstart" in window || navigator.maxTouchPoints > 0
      const isTabletSize = width >= 768 && width <= 1366 // iPads Pro pueden llegar a 1366px

      setIsMobile(width < 768)
      setIsTablet(isTouchDevice && isTabletSize)
    }

    updateDeviceType()
    const handleResize = () => updateDeviceType()
    window.addEventListener("resize", handleResize)

    const savedHeight = localStorage.getItem("terminalHeight")
    if (savedHeight) {
      setTerminalHeight(Number.parseInt(savedHeight, 10))
    }

    return () => {
      window.removeEventListener("resize", handleResize)
    }
  }, [])

  const handleResizeStart = (e: React.MouseEvent | React.TouchEvent) => {
    // Bloquear solo en pantallas muy pequeÃ±as (mÃ³viles)
    if (window.innerWidth < 640 && !isTablet) {
      return
    }

    e.preventDefault()
    e.stopPropagation()

    // Detectar si es touch o mouse
    const clientY = "touches" in e ? e.touches[0].clientY : e.clientY
    const startY = clientY
    const startHeight = terminalHeight

    const handleMove = (moveEvent: MouseEvent | TouchEvent) => {
      const currentY = "touches" in moveEvent ? moveEvent.touches[0].clientY : moveEvent.clientY
      const deltaY = currentY - startY
      const newHeight = Math.max(200, Math.min(2400, startHeight + deltaY))

      setTerminalHeight(newHeight)
    }

    const handleEnd = () => {
      document.removeEventListener("mousemove", handleMove as any)
      document.removeEventListener("mouseup", handleEnd)
      document.removeEventListener("touchmove", handleMove as any)
      document.removeEventListener("touchend", handleEnd)

      localStorage.setItem("terminalHeight", terminalHeight.toString())
    }

    document.addEventListener("mousemove", handleMove as any)
    document.addEventListener("mouseup", handleEnd)
    document.addEventListener("touchmove", handleMove as any, { passive: false })
    document.addEventListener("touchend", handleEnd)
  }

  useEffect(() => {
    if (terminals.length === 0) {
      addNewTerminal()
    }
  }, [])

  useEffect(() => {
    const searchCheatSh = async (query: string) => {
      if (!query.trim()) {
        setSearchResults([])
        setFilteredCommands(proxmoxCommands)
        return
      }

      try {
        setIsSearching(true)

        const searchEndpoint = `/api/terminal/search-command?q=${encodeURIComponent(query)}`

        const data = await fetchApi<{ success: boolean; examples: any[] }>(searchEndpoint, {
          method: "GET",
          signal: AbortSignal.timeout(10000),
        })

        if (!data.success || !data.examples || data.examples.length === 0) {
          throw new Error("No examples found")
        }

        console.log("[v0] Received parsed examples from server:", data.examples.length)

        const formattedResults: CheatSheetResult[] = data.examples.map((example: any) => ({
          command: example.command,
          description: example.description || "",
          examples: [example.command],
        }))

        setUseOnline(true)
        setSearchResults(formattedResults)
      } catch (error) {
        console.log("[v0] Error fetching from cheat.sh proxy, using offline commands:", error)
        const filtered = proxmoxCommands.filter(
          (item) =>
            item.cmd.toLowerCase().includes(query.toLowerCase()) ||
            item.desc.toLowerCase().includes(query.toLowerCase()),
        )
        setFilteredCommands(filtered)
        setSearchResults([])
        setUseOnline(false)
      } finally {
        setIsSearching(false)
      }
    }

    const debounce = setTimeout(() => {
      if (searchQuery && searchQuery.length >= 2) {
        searchCheatSh(searchQuery)
      } else {
        setSearchResults([])
        setFilteredCommands(proxmoxCommands)
      }
    }, 800)

    return () => clearTimeout(debounce)
  }, [searchQuery])

  const addNewTerminal = () => {
    if (terminals.length >= 4) return

    const newId = `terminal-${Date.now()}`
    setTerminals((prev) => [
      ...prev,
      {
        id: newId,
        title: `Terminal ${prev.length + 1}`,
        term: null,
        ws: null,
        isConnected: false,
        fitAddon: null, // Added fitAddon initialization
      },
    ])
    setActiveTerminalId(newId)
  }

  const closeTerminal = (id: string) => {
    const terminal = terminals.find((t) => t.id === id)
    if (terminal) {
      if (terminal.ws) {
        terminal.ws.close()
      }
      if (terminal.term) {
        terminal.term.dispose()
      }
    }

    setTerminals((prev) => {
      const filtered = prev.filter((t) => t.id !== id)
      if (filtered.length > 0 && activeTerminalId === id) {
        setActiveTerminalId(filtered[0].id)
      }
      return filtered
    })

    delete containerRefs.current[id]
  }

  useEffect(() => {
    terminals.forEach((terminal) => {
      const container = containerRefs.current[terminal.id]
      if (!terminal.term && container) {
        initializeTerminal(terminal, container)
      }
    })
  }, [terminals, isMobile])

  useEffect(() => {
    if (window.innerWidth < 640) return

    terminals.forEach((terminal) => {
      if (terminal.term && terminal.fitAddon && terminal.isConnected) {
        try {
          setTimeout(() => {
            terminal.fitAddon?.fit()
            if (terminal.ws?.readyState === WebSocket.OPEN) {
              const cols = terminal.term?.cols || 80
              const rows = terminal.term?.rows || 24
              terminal.ws.send(
                JSON.stringify({
                  type: "resize",
                  cols,
                  rows,
                }),
              )
            }
          }, 100)
        } catch (err) {
          console.warn("[Terminal] resize on height change failed:", err)
        }
      }
    })
  }, [terminalHeight, layout, terminals, isMobile])

  const initializeTerminal = async (terminal: TerminalInstance, container: HTMLDivElement) => {
    const [TerminalClass, FitAddonClass] = await Promise.all([
      import("xterm").then((mod) => mod.Terminal),
      import("xterm-addon-fit").then((mod) => mod.FitAddon),
      import("xterm/css/xterm.css"),
    ]).then(([Terminal, FitAddon]) => [Terminal, FitAddon])

    const fontSize = window.innerWidth < 768 ? 12 : 16

    const term = new TerminalClass({
      rendererType: "dom",
      fontFamily: '"Courier", "Courier New", "Liberation Mono", "DejaVu Sans Mono", monospace',
      fontSize: fontSize,
      lineHeight: 1,
      cursorBlink: true,
      scrollback: 2000,
      disableStdin: false,
      customGlyphs: true,
      fontWeight: "500",
      fontWeightBold: "700",
      theme: {
        background: "#000000",
        foreground: "#ffffff",
        cursor: "#ffffff",
        cursorAccent: "#000000",
        black: "#2e3436",
        red: "#cc0000",
        green: "#4e9a06",
        yellow: "#c4a000",
        blue: "#3465a4",
        magenta: "#75507b",
        cyan: "#06989a",
        white: "#d3d7cf",
        brightBlack: "#555753",
        brightRed: "#ef2929",
        brightGreen: "#8ae234",
        brightYellow: "#fce94f",
        brightBlue: "#729fcf",
        brightMagenta: "#ad7fa8",
        brightCyan: "#34e2e2",
        brightWhite: "#eeeeec",
      },
    })

    const fitAddon = new FitAddonClass()
    term.loadAddon(fitAddon)

    term.open(container)

    fitAddon.fit()

    const wsUrl = websocketUrl || getWebSocketUrl()
    const ws = new WebSocket(wsUrl)

    const syncSizeWithBackend = () => {
      try {
        fitAddon.fit()
        if (ws.readyState === WebSocket.OPEN) {
          const cols = term.cols
          const rows = term.rows
          ws.send(
            JSON.stringify({
              type: "resize",
              cols,
              rows,
            }),
          )
        }
      } catch (err) {
        console.warn("[Terminal] resize failed:", err)
      }
    }

    ws.onopen = () => {
      setTerminals((prev) =>
        prev.map((t) => (t.id === terminal.id ? { ...t, isConnected: true, term, ws, fitAddon } : t)),
      )
      term.writeln("\x1b[32mConnected to ProxMenux terminal.\x1b[0m")
      syncSizeWithBackend()
    }

    ws.onmessage = (event) => {
      term.write(event.data)
    }

    ws.onerror = (error) => {
      console.error("[v0] TerminalPanel: WebSocket error:", error)
      setTerminals((prev) => prev.map((t) => (t.id === terminal.id ? { ...t, isConnected: false } : t)))
      term.writeln("\r\n\x1b[31m[ERROR] WebSocket connection error\x1b[0m")
    }

    ws.onclose = () => {
      setTerminals((prev) => prev.map((t) => (t.id === terminal.id ? { ...t, isConnected: false } : t)))
      term.writeln("\r\n\x1b[33m[INFO] Connection closed\x1b[0m")
    }

    term.onData((data) => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(data)
      }
    })

    let resizeTimeout: any = null

    const handleResize = () => {
      clearTimeout(resizeTimeout)
      resizeTimeout = setTimeout(() => {
        syncSizeWithBackend()
      }, 150)
    }

    window.addEventListener("resize", handleResize)

    return () => {
      window.removeEventListener("resize", handleResize)
      ws.close()
      term.dispose()
    }
  }

  const handleKeyButton = (key: string, e?: React.MouseEvent | React.TouchEvent) => {
    // Prevenir comportamientos por defecto del navegador
    if (e) {
      e.preventDefault()
      e.stopPropagation()
    }

    const activeTerminal = terminals.find((t) => t.id === activeTerminalId)
    if (!activeTerminal || !activeTerminal.ws || activeTerminal.ws.readyState !== WebSocket.OPEN) return

    let seq = ""
    switch (key) {
      case "UP":
        seq = "\x1bOA"
        break
      case "DOWN":
        seq = "\x1bOB"
        break
      case "RIGHT":
        seq = "\x1bOC"
        break
      case "LEFT":
        seq = "\x1bOD"
        break
      case "ESC":
        seq = "\x1b"
        break
      case "TAB":
        seq = "\t"
        break
      case "CTRL_C":
        seq = "\x03"
        break
      default:
        break
    }

    activeTerminal.ws.send(seq)
  }

  const handleClear = () => {
    const activeTerminal = terminals.find((t) => t.id === activeTerminalId)
    if (activeTerminal?.term) {
      activeTerminal.term.clear()
    }
  }

  const handleClose = () => {
    terminals.forEach((terminal) => {
      if (terminal.ws) terminal.ws.close()
      if (terminal.term) terminal.term.dispose()
    })
    onClose?.()
  }

  const sendToActiveTerminal = (command: string) => {
    const activeTerminal = terminals.find((t) => t.id === activeTerminalId)

    if (activeTerminal?.ws && activeTerminal.ws.readyState === WebSocket.OPEN) {
      activeTerminal.ws.send(command)

      setTimeout(() => {
        setSearchModalOpen(false)
      }, 100)
    }
  }

  const sendSequence = (seq: string, e?: React.MouseEvent | React.TouchEvent) => {
    if (e) {
      e.preventDefault()
      e.stopPropagation()
    }

    const activeTerminal = terminals.find((t) => t.id === activeTerminalId)
    if (activeTerminal?.ws && activeTerminal.ws.readyState === WebSocket.OPEN) {
      activeTerminal.ws.send(seq)
    }
  }

  const getLayoutClass = () => {
    const count = terminals.length
    if (isMobile || count === 1) return "grid grid-cols-1"

    // Vista de cuadrÃ­cula 2x2
    if (layout === "grid") {
      if (count === 2) return "grid grid-cols-2"
      if (count === 3) return "grid grid-cols-2 grid-rows-2"
      if (count === 4) return "grid grid-cols-2 grid-rows-2"
    }

    if (count === 2) return "grid grid-cols-1 grid-rows-2"
    if (count === 3) return "grid grid-cols-1 grid-rows-3"
    if (count === 4) return "grid grid-cols-1 grid-rows-4"

    // Vista de filas apiladas (single) - una terminal debajo de otra
    return "grid grid-cols-1"
  }

  const activeTerminal = terminals.find((t) => t.id === activeTerminalId)

  return (
    <div className="flex flex-col h-full bg-zinc-950 rounded-md overflow-hidden">
      <div className="flex items-center justify-between px-4 py-2 bg-zinc-900 border-b border-zinc-800">
        <div className="flex items-center gap-3">
          <Activity className="h-5 w-5 text-blue-500" />
          <div
            className={`w-2 h-2 rounded-full ${activeTerminal?.isConnected ? "bg-green-500" : "bg-red-500"}`}
            title={activeTerminal?.isConnected ? "Connected" : "Disconnected"}
          ></div>
          <span className="text-xs text-zinc-500">{terminals.length} / 4 terminals</span>
        </div>

        <div className="flex gap-2">
          {!isMobile && terminals.length > 1 && (
            <>
              <Button
                onClick={() => setLayout("single")}
                variant="outline"
                size="sm"
                className={`h-8 px-2 ${layout === "single" ? "bg-blue-500/20 border-blue-500" : ""}`}
                title="Vista apilada (filas)"
              >
                <AlignJustify className="h-4 w-4" />
              </Button>
              <Button
                onClick={() => setLayout("grid")}
                variant="outline"
                size="sm"
                className={`h-8 px-2 ${layout === "grid" ? "bg-blue-500/20 border-blue-500" : ""}`}
                title="Vista cuadrÃ­cula 2x2"
              >
                <Grid2X2 className="h-4 w-4" />
              </Button>
            </>
          )}
          <Button
            onClick={addNewTerminal}
            variant="outline"
            size="sm"
            disabled={terminals.length >= 4}
            className="h-8 gap-2 bg-green-600 hover:bg-green-700 border-green-500 text-white disabled:opacity-50"
          >
            <Plus className="h-4 w-4" />
            <span className="hidden sm:inline">New</span>
          </Button>
          <Button
            onClick={() => setSearchModalOpen(true)}
            variant="outline"
            size="sm"
            disabled={!activeTerminal?.isConnected}
            className="h-8 gap-2 bg-blue-600 hover:bg-blue-700 border-blue-500 text-white disabled:opacity-50"
          >
            <Search className="h-4 w-4" />
            <span className="hidden sm:inline">Search</span>
          </Button>
          <Button
            onClick={handleClear}
            variant="outline"
            size="sm"
            disabled={!activeTerminal?.isConnected}
            className="h-8 gap-2 bg-yellow-600 hover:bg-yellow-700 border-yellow-500 text-white disabled:opacity-50"
          >
            <Trash2 className="h-4 w-4" />
            <span className="hidden sm:inline">Clear</span>
          </Button>
          <Button
            onClick={handleClose}
            variant="outline"
            size="sm"
            className="h-8 gap-2 bg-red-600 hover:bg-red-700 border-red-500 text-white"
          >
            <X className="h-4 w-4" />
            <span className="hidden sm:inline">Close</span>
          </Button>
        </div>
      </div>

      <div
        data-terminal-container
        ref={(el) => {
          containerRefs.current["main"] = el
        }}
        className={`overflow-hidden flex flex-col ${isMobile ? "flex-1 h-[60vh]" : "overflow-hidden"} w-full max-w-full`}
        style={!isMobile || isTablet ? { height: `${terminalHeight}px`, flexShrink: 0 } : undefined}
      >
        {isMobile ? (
          <Tabs value={activeTerminalId} onValueChange={setActiveTerminalId} className="h-full flex flex-col">
            <TabsList className="w-full justify-start bg-zinc-900 rounded-none border-b border-zinc-800 overflow-x-auto">
              {terminals.map((terminal) => (
                <TabsTrigger key={terminal.id} value={terminal.id} className="relative">
                  {terminal.title}
                  {terminals.length > 1 && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation()
                        closeTerminal(terminal.id)
                      }}
                      className="ml-2 hover:bg-zinc-700 rounded p-0.5"
                    >
                      <X className="h-3 w-3" />
                    </button>
                  )}
                </TabsTrigger>
              ))}
            </TabsList>
            {terminals.map((terminal) => (
              <TabsContent
                key={terminal.id}
                value={terminal.id}
                forceMount
                className={`flex-1 h-full mt-0 ${activeTerminalId === terminal.id ? "block" : "hidden"}`}
              >
                <div
                  ref={(el) => (containerRefs.current[terminal.id] = el)}
                  className="w-full h-full flex-1 bg-black overflow-hidden"
                />
              </TabsContent>
            ))}
          </Tabs>
        ) : (
          <div className={`${getLayoutClass()} h-full gap-0.5 bg-zinc-800 p-0.5 w-full overflow-hidden`}>
            {terminals.map((terminal) => (
              <div
                key={terminal.id}
                className={`relative bg-zinc-900 overflow-hidden flex flex-col min-h-0 w-full ${
                  terminals.length > 1 && activeTerminalId === terminal.id ? "ring-2 ring-blue-500" : ""
                }`}
              >
                <div className="flex-shrink-0 flex items-center justify-between px-2 py-1 bg-zinc-900/95 border-b border-zinc-800">
                  <button
                    onClick={() => setActiveTerminalId(terminal.id)}
                    className={`text-xs font-medium ${
                      activeTerminalId === terminal.id ? "text-blue-400" : "text-zinc-500"
                    }`}
                  >
                    {terminal.title}
                  </button>
                  {terminals.length > 1 && (
                    <button onClick={() => closeTerminal(terminal.id)} className="hover:bg-zinc-700 rounded p-0.5">
                      <X className="h-3 w-3" />
                    </button>
                  )}
                </div>
                <div
                  ref={(el) => (containerRefs.current[terminal.id] = el)}
                  onClick={() => setActiveTerminalId(terminal.id)}
                  className="flex-1 w-full max-w-full bg-black overflow-hidden cursor-pointer"
                  data-terminal-container
                />
              </div>
            ))}
          </div>
        )}
      </div>

      {(isTablet || (!isMobile && !isTablet)) && terminals.length > 0 && (
        <div
          onMouseDown={handleResizeStart}
          onTouchStart={handleResizeStart}
          className="h-2 w-full cursor-row-resize bg-zinc-800 hover:bg-blue-600 transition-colors flex items-center justify-center group relative"
          style={{ touchAction: "none" }}
        >
          <GripHorizontal className="h-4 w-4 text-zinc-600 group-hover:text-white pointer-events-none" />
        </div>
      )}

      {(isMobile || isTablet) && (
        <div className="flex flex-wrap gap-2 justify-center items-center px-2 bg-zinc-900 text-sm rounded-b-md border-t border-zinc-700 py-1.5">
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              sendSequence("\x1b", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            ESC
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              sendSequence("\t", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            TAB
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              handleKeyButton("UP", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            â†‘
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              handleKeyButton("DOWN", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            â†“
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              handleKeyButton("LEFT", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            â†
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              handleKeyButton("RIGHT", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            â†’
          </Button>
          <Button
            onPointerDown={(e) => {
              e.preventDefault()
              e.stopPropagation()
              sendSequence("\x03", e)
            }}
            variant="outline"
            size="sm"
            className="h-8 px-3 text-xs"
          >
            CTRL+C
          </Button>
        </div>
      )}

      <Dialog open={searchModalOpen} onOpenChange={setSearchModalOpen}>
        <DialogContent className="max-w-3xl max-h-[85vh] overflow-hidden flex flex-col">
          <DialogHeader className="flex flex-row items-center justify-between space-y-0 pb-4 border-b border-zinc-800">
            <DialogTitle className="text-xl font-semibold">Search Commands</DialogTitle>
            <div className="flex items-center gap-2">
              <div
                className={`w-2 h-2 rounded-full ${useOnline ? "bg-green-500" : "bg-red-500"}`}
                title={useOnline ? "Online - Using cheat.sh API" : "Offline - Using local commands"}
              />
            </div>
          </DialogHeader>

          <DialogDescription className="sr-only">Search for Linux and Proxmox commands</DialogDescription>

          <div className="space-y-4">
            <div className="relative">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-zinc-500" />
              <Input
                placeholder="Search commands... (e.g., tar, docker, qm, systemctl)"
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-10 bg-zinc-900 border-zinc-700 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 text-base"
                autoCapitalize="none"
                autoComplete="off"
                autoCorrect="off"
                spellCheck={false}
              />
            </div>

            {isSearching && (
              <div className="text-center py-4 text-zinc-400">
                <div className="animate-spin inline-block w-6 h-6 border-2 border-current border-t-transparent rounded-full mb-2" />
                <p className="text-sm">Searching cheat.sh...</p>
              </div>
            )}

            <div className="flex-1 overflow-y-auto space-y-2 pr-2 max-h-[50vh]">
              {searchResults.length > 0 ? (
                <>
                  {searchResults.map((result, index) => (
                    <div
                      key={index}
                      className="p-4 rounded-lg border border-zinc-700 bg-zinc-800/50 hover:border-zinc-600 transition-colors"
                    >
                      {result.description && (
                        <p className="text-xs text-zinc-400 mb-2 leading-relaxed"># {result.description}</p>
                      )}
                      <div
                        onClick={() => sendToActiveTerminal(result.command)}
                        className="flex items-start justify-between gap-2 cursor-pointer group hover:bg-zinc-800/50 rounded p-2 -m-2"
                      >
                        <code className="text-sm text-blue-400 font-mono break-all flex-1">{result.command}</code>
                        <Send className="h-4 w-4 text-zinc-600 group-hover:text-blue-400 flex-shrink-0 mt-0.5 transition-colors" />
                      </div>
                    </div>
                  ))}

                  <div className="text-center py-2">
                    <p className="text-xs text-zinc-500">
                      <Lightbulb className="inline-block w-3 h-3 mr-1" />
                      Powered by cheat.sh
                    </p>
                  </div>
                </>
              ) : filteredCommands.length > 0 && !useOnline ? (
                filteredCommands.map((item, index) => (
                  <div
                    key={index}
                    onClick={() => sendToActiveTerminal(item.cmd)}
                    className="p-3 rounded-lg border border-zinc-700 bg-zinc-800/50 hover:bg-zinc-800 hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <div className="flex items-start justify-between gap-2">
                      <div className="flex-1 min-w-0">
                        <code className="text-sm text-blue-400 font-mono break-all">{item.cmd}</code>
                        <p className="text-xs text-zinc-400 mt-1">{item.desc}</p>
                      </div>
                      <Button
                        onClick={(e) => {
                          e.stopPropagation()
                          sendToActiveTerminal(item.cmd)
                        }}
                        size="sm"
                        variant="ghost"
                        className="shrink-0 h-7 px-2 text-xs"
                      >
                        <Send className="h-3 w-3 mr-1" />
                        Send
                      </Button>
                    </div>
                  </div>
                ))
              ) : !isSearching && !searchQuery && !useOnline ? (
                proxmoxCommands.map((item, index) => (
                  <div
                    key={index}
                    onClick={() => sendToActiveTerminal(item.cmd)}
                    className="p-3 rounded-lg border border-zinc-700 bg-zinc-800/50 hover:bg-zinc-800 hover:border-blue-500 cursor-pointer transition-colors"
                  >
                    <div className="flex items-start justify-between gap-2">
                      <div className="flex-1 min-w-0">
                        <code className="text-sm text-blue-400 font-mono break-all">{item.cmd}</code>
                        <p className="text-xs text-zinc-400 mt-1">{item.desc}</p>
                      </div>
                      <Button
                        onClick={(e) => {
                          e.stopPropagation()
                          sendToActiveTerminal(item.cmd)
                        }}
                        size="sm"
                        variant="ghost"
                        className="shrink-0 h-7 px-2 text-xs"
                      >
                        <Send className="h-3 w-3 mr-1" />
                        Send
                      </Button>
                    </div>
                  </div>
                ))
              ) : !isSearching ? (
                <div className="text-center py-12 space-y-4">
                  {searchQuery ? (
                    <>
                      <Search className="w-12 h-12 text-zinc-600 mx-auto" />
                      <div>
                        <p className="text-zinc-400 font-medium">No results found for "{searchQuery}"</p>
                        <p className="text-xs text-zinc-500 mt-1">Try a different command or check your spelling</p>
                      </div>
                    </>
                  ) : (
                    <>
                      <Terminal className="w-12 h-12 text-zinc-600 mx-auto" />
                      <div>
                        <p className="text-zinc-400 font-medium mb-2">Search for any command</p>
                        <div className="text-sm text-zinc-500 space-y-1">
                          <p>Try searching for:</p>
                          <div className="flex flex-wrap justify-center gap-2 mt-2">
                            {["tar", "grep", "docker", "qm", "systemctl"].map((cmd) => (
                              <code
                                key={cmd}
                                onClick={() => setSearchQuery(cmd)}
                                className="px-2 py-1 bg-zinc-800 rounded text-blue-400 cursor-pointer hover:bg-zinc-700"
                              >
                                {cmd}
                              </code>
                            ))}
                          </div>
                        </div>
                      </div>
                      {useOnline && (
                        <div className="flex items-center justify-center gap-2 text-xs text-zinc-600 mt-4">
                          <Lightbulb className="w-3 h-3" />
                          <span>Powered by cheat.sh</span>
                        </div>
                      )}
                    </>
                  )}
                </div>
              ) : null}
            </div>

            <div className="pt-2 border-t border-zinc-800 flex items-center justify-between text-xs text-zinc-500">
              <div className="flex items-center gap-2">
                <Lightbulb className="w-3 h-3" />
                <span>Tip: Search for any Linux command or Proxmox commands (qm, pct, zpool)</span>
              </div>
              {useOnline && searchResults.length > 0 && <span className="text-zinc-600">Powered by cheat.sh</span>}
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  )
}



================================================
FILE: AppImage/components/theme-provider.tsx
================================================
"use client"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import type { ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}



================================================
FILE: AppImage/components/theme-toggle.tsx
================================================
"use client"
import { Moon, Sun } from "lucide-react"
import { useTheme } from "next-themes"
import { useEffect, useState } from "react"

import { Button } from "./ui/button"

export function ThemeToggle() {
  const { theme, setTheme } = useTheme()
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  const handleThemeToggle = () => {
    console.log("[v0] Current theme:", theme)
    const newTheme = theme === "light" ? "dark" : "light"
    console.log("[v0] Switching to theme:", newTheme)
    setTheme(newTheme)
  }

  if (!mounted) {
    return (
      <Button variant="outline" size="sm" className="border-border bg-transparent w-9 h-9">
        <Sun className="h-4 w-4" />
        <span className="sr-only">Toggle theme</span>
      </Button>
    )
  }

  return (
    <Button variant="outline" size="sm" onClick={handleThemeToggle} className="border-border bg-transparent w-9 h-9">
      <Sun className="h-4 w-4 rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-4 w-4 rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  )
}



================================================
FILE: AppImage/components/two-factor-setup.tsx
================================================
"use client"

import { useState } from "react"
import { Button } from "./ui/button"
import { Input } from "./ui/input"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "./ui/dialog"
import { AlertCircle, CheckCircle, Copy, Shield, Check } from "lucide-react"
import { getApiUrl } from "../lib/api-config"

interface TwoFactorSetupProps {
  open: boolean
  onClose: () => void
  onSuccess: () => void
}

export function TwoFactorSetup({ open, onClose, onSuccess }: TwoFactorSetupProps) {
  const [step, setStep] = useState(1)
  const [qrCode, setQrCode] = useState("")
  const [secret, setSecret] = useState("")
  const [backupCodes, setBackupCodes] = useState<string[]>([])
  const [verificationCode, setVerificationCode] = useState("")
  const [error, setError] = useState("")
  const [loading, setLoading] = useState(false)
  const [copiedSecret, setCopiedSecret] = useState(false)
  const [copiedCodes, setCopiedCodes] = useState(false)

  const handleSetupStart = async () => {
    setError("")
    setLoading(true)

    try {
      const token = localStorage.getItem("proxmenux-auth-token")
      const response = await fetch(getApiUrl("/api/auth/totp/setup"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || "Failed to setup 2FA")
      }

      setQrCode(data.qr_code)
      setSecret(data.secret)
      setBackupCodes(data.backup_codes)
      setStep(2)
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to setup 2FA")
    } finally {
      setLoading(false)
    }
  }

  const handleVerify = async () => {
    if (!verificationCode || verificationCode.length !== 6) {
      setError("Please enter a 6-digit code")
      return
    }

    setError("")
    setLoading(true)

    try {
      const token = localStorage.getItem("proxmenux-auth-token")
      const response = await fetch(getApiUrl("/api/auth/totp/enable"), {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ token: verificationCode }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.message || "Invalid verification code")
      }

      setStep(3)
    } catch (err) {
      setError(err instanceof Error ? err.message : "Verification failed")
    } finally {
      setLoading(false)
    }
  }

  const copyToClipboard = (text: string, type: "secret" | "codes") => {
    navigator.clipboard.writeText(text)
    if (type === "secret") {
      setCopiedSecret(true)
      setTimeout(() => setCopiedSecret(false), 2000)
    } else {
      setCopiedCodes(true)
      setTimeout(() => setCopiedCodes(false), 2000)
    }
  }

  const handleClose = () => {
    setStep(1)
    setQrCode("")
    setSecret("")
    setBackupCodes([])
    setVerificationCode("")
    setError("")
    onClose()
  }

  const handleFinish = () => {
    handleClose()
    onSuccess()
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="max-w-md max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Shield className="h-5 w-5 text-blue-500" />
            Setup Two-Factor Authentication
          </DialogTitle>
          <DialogDescription>Add an extra layer of security to your account</DialogDescription>
        </DialogHeader>

        {error && (
          <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-3 flex items-start gap-2">
            <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
            <p className="text-sm text-red-500">{error}</p>
          </div>
        )}

        {step === 1 && (
          <div className="space-y-4">
            <div className="bg-blue-500/10 border border-blue-500/20 rounded-lg p-4">
              <p className="text-sm text-blue-500">
                Two-factor authentication (2FA) adds an extra layer of security by requiring a code from your
                authentication app in addition to your password.
              </p>
            </div>

            <div className="space-y-2">
              <h4 className="font-medium">You will need:</h4>
              <ul className="text-sm text-muted-foreground space-y-1 list-disc list-inside">
                <li>An authentication app (Google Authenticator, Authy, etc.)</li>
                <li>Scan a QR code or enter a key manually</li>
                <li>Store backup codes securely</li>
              </ul>
            </div>

            <Button onClick={handleSetupStart} className="w-full bg-blue-500 hover:bg-blue-600" disabled={loading}>
              {loading ? "Starting..." : "Start Setup"}
            </Button>
          </div>
        )}

        {step === 2 && (
          <div className="space-y-4">
            <div className="space-y-2">
              <h4 className="font-medium">1. Scan the QR code</h4>
              <p className="text-sm text-muted-foreground">Open your authentication app and scan this QR code</p>
              {qrCode && (
                <div className="flex justify-center p-4 bg-white rounded-lg">
                  <img src={qrCode || "/placeholder.svg"} alt="QR Code" width={200} height={200} className="rounded" />
                </div>
              )}
            </div>

            <div className="space-y-2">
              <h4 className="font-medium">Or enter the key manually:</h4>
              <div className="flex gap-2">
                <Input value={secret} readOnly className="font-mono text-sm" />
                <Button
                  variant="outline"
                  size="icon"
                  onClick={() => copyToClipboard(secret, "secret")}
                  title="Copy key"
                >
                  {copiedSecret ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4" />}
                </Button>
              </div>
            </div>

            <div className="space-y-2">
              <h4 className="font-medium">2. Enter the verification code</h4>
              <p className="text-sm text-muted-foreground">Enter the 6-digit code that appears in your app</p>
              <Input
                type="text"
                placeholder="000000"
                value={verificationCode}
                onChange={(e) => setVerificationCode(e.target.value.replace(/\D/g, "").slice(0, 6))}
                className="text-center text-lg tracking-widest font-mono text-base"
                maxLength={6}
                disabled={loading}
              />
            </div>

            <div className="flex gap-2">
              <Button onClick={handleVerify} className="flex-1 bg-blue-500 hover:bg-blue-600" disabled={loading}>
                {loading ? "Verifying..." : "Verify and Enable"}
              </Button>
              <Button onClick={handleClose} variant="outline" className="flex-1 bg-transparent" disabled={loading}>
                Cancel
              </Button>
            </div>
          </div>
        )}

        {step === 3 && (
          <div className="space-y-4">
            <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-4 flex items-start gap-2">
              <CheckCircle className="h-5 w-5 text-green-500 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-medium text-green-500">2FA Enabled Successfully</p>
                <p className="text-sm text-green-500 mt-1">
                  Your account is now protected with two-factor authentication
                </p>
              </div>
            </div>

            <div className="space-y-2">
              <h4 className="font-medium text-orange-500">Important: Save your backup codes</h4>
              <p className="text-sm text-muted-foreground">
                These codes will allow you to access your account if you lose access to your authentication app. Store
                them in a safe place.
              </p>

              <div className="bg-muted/50 rounded-lg p-4 space-y-2">
                <div className="flex justify-between items-center mb-2">
                  <span className="text-sm font-medium">Backup Codes</span>
                  <Button variant="outline" size="sm" onClick={() => copyToClipboard(backupCodes.join("\n"), "codes")}>
                    {copiedCodes ? (
                      <Check className="h-4 w-4 text-green-500 mr-2" />
                    ) : (
                      <Copy className="h-4 w-4 mr-2" />
                    )}
                    Copy All
                  </Button>
                </div>
                <div className="grid grid-cols-2 gap-2">
                  {backupCodes.map((code, index) => (
                    <div key={index} className="bg-background rounded px-3 py-2 font-mono text-sm text-center">
                      {code}
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <Button onClick={handleFinish} className="w-full bg-blue-500 hover:bg-blue-600">
              Finish
            </Button>
          </div>
        )}
      </DialogContent>
    </Dialog>
  )
}



================================================
FILE: AppImage/components/ui/badge.tsx
================================================
import type * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
)

export interface BadgeProps extends React.HTMLAttributes<HTMLDivElement>, VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return <div className={cn(badgeVariants({ variant }), className)} {...props} />
}

export { Badge, badgeVariants }



================================================
FILE: AppImage/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return <Comp className={cn(buttonVariants({ variant, size, className }))} ref={ref} {...props} />
  },
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
FILE: AppImage/components/ui/card.tsx
================================================
import * as React from "react"
import { cn } from "@/lib/utils"

const Card = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)} {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex flex-col space-y-1.5 p-6", className)} {...props} />
  ),
)
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLHeadingElement>>(
  ({ className, ...props }, ref) => (
    <h3 ref={ref} className={cn("text-2xl font-semibold leading-none tracking-tight", className)} {...props} />
  ),
)
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<HTMLParagraphElement, React.HTMLAttributes<HTMLParagraphElement>>(
  ({ className, ...props }, ref) => (
    <p ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
  ),
)
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />,
)
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<HTMLDivElement, React.HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div ref={ref} className={cn("flex items-center p-6 pt-0", className)} {...props} />
  ),
)
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: AppImage/components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"
import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator className={cn("flex items-center justify-center text-current")}>
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



================================================
FILE: AppImage/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] rounded-lg",
        className,
      )}
      aria-describedby={props["aria-describedby"] || undefined}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)} {...props} />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



================================================
FILE: AppImage/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-lg border border-input bg-background px-4 py-2 text-sm shadow-sm transition-all file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 hover:border-ring/50",
        className,
      )}
      ref={ref}
      {...props}
    />
  )
})
Input.displayName = "Input"

export { Input }



================================================
FILE: AppImage/components/ui/label.tsx
================================================
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils"

const labelVariants = cva("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70")

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> & VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: AppImage/components/ui/progress.tsx
================================================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn("relative h-2 w-full overflow-hidden rounded-full bg-secondary", className)}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }



================================================
FILE: AppImage/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root ref={ref} className={cn("relative overflow-hidden", className)} {...props}>
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">{children}</ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className,
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }



================================================
FILE: AppImage/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn("flex cursor-default items-center justify-center py-1", className)}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName = SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]",
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label ref={ref} className={cn("px-2 py-1.5 text-sm font-semibold", className)} {...props} />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator ref={ref} className={cn("-mx-1 my-1 h-px bg-muted", className)} {...props} />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
FILE: AppImage/components/ui/sheet.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = DialogPrimitive.Root

const SheetTrigger = DialogPrimitive.Trigger

const SheetClose = DialogPrimitive.Close

const SheetPortal = DialogPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className,
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = DialogPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  },
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<React.ElementRef<typeof DialogPrimitive.Content>, SheetContentProps>(
  ({ side = "right", className, children, ...props }, ref) => (
    <SheetPortal>
      <SheetOverlay />
      <DialogPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
        {children}
        <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </SheetPortal>
  ),
)
SheetContent.displayName = DialogPrimitive.Content.displayName

const SheetHeader = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col space-y-2 text-center sm:text-left", className)} {...props} />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) => (
  <div className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)} {...props} />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title ref={ref} className={cn("text-lg font-semibold text-foreground", className)} {...props} />
))
SheetTitle.displayName = DialogPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description ref={ref} className={cn("text-sm text-muted-foreground", className)} {...props} />
))
SheetDescription.displayName = DialogPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: AppImage/components/ui/tabs.tsx
================================================
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"
import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className,
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className,
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className,
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: AppImage/hooks/use-mobile.tsx
================================================
"use client"

import { useEffect, useState } from "react"

export function useIsMobile() {
  const [isMobile, setIsMobile] = useState(false)

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768)
    }

    // Check on mount
    checkMobile()

    // Listen for resize
    window.addEventListener("resize", checkMobile)

    return () => window.removeEventListener("resize", checkMobile)
  }, [])

  return isMobile
}



================================================
FILE: AppImage/lib/api-config.ts
================================================
/**
 * API Configuration for ProxMenux Monitor
 * Handles API URL generation with automatic proxy detection
 */

/**
 * API Server Port Configuration
 * Default: 8008 (production)
 * Can be changed to 8009 for beta testing
 * This can also be set via NEXT_PUBLIC_API_PORT environment variable
 */
export const API_PORT = process.env.NEXT_PUBLIC_API_PORT || "8008"

/**
 * Gets the base URL for API calls
 * Automatically detects if running behind a proxy by checking if we're on a standard port
 *
 * @returns Base URL for API endpoints
 */
export function getApiBaseUrl(): string {
  if (typeof window === "undefined") {
    console.log("[v0] getApiBaseUrl: Running on server (SSR)")
    return ""
  }

  const { protocol, hostname, port } = window.location

  console.log("[v0] getApiBaseUrl - protocol:", protocol, "hostname:", hostname, "port:", port)

  // If accessing via standard ports (80/443) or no port, assume we're behind a proxy
  // In this case, use relative URLs so the proxy handles routing
  const isStandardPort = port === "" || port === "80" || port === "443"

  console.log("[v0] getApiBaseUrl - isStandardPort:", isStandardPort)

  if (isStandardPort) {
    // Behind a proxy - use relative URL
    console.log("[v0] getApiBaseUrl: Detected proxy access, using relative URLs")
    return ""
  } else {
    // Direct access - use explicit API port
    const baseUrl = `${protocol}//${hostname}:${API_PORT}`
    console.log("[v0] getApiBaseUrl: Direct access detected, using:", baseUrl)
    return baseUrl
  }
}

/**
 * Constructs a full API URL
 *
 * @param endpoint - API endpoint path (e.g., '/api/system')
 * @returns Full API URL
 */
export function getApiUrl(endpoint: string): string {
  const baseUrl = getApiBaseUrl()

  // Ensure endpoint starts with /
  const normalizedEndpoint = endpoint.startsWith("/") ? endpoint : `/${endpoint}`

  return `${baseUrl}${normalizedEndpoint}`
}

/**
 * Gets the JWT token from localStorage
 *
 * @returns JWT token or null if not authenticated
 */
export function getAuthToken(): string | null {
  if (typeof window === "undefined") {
    return null
  }
  const token = localStorage.getItem("proxmenux-auth-token")
  console.log(
    "[v0] getAuthToken called:",
    token ? `Token found (length: ${token.length})` : "No token found in localStorage",
  )
  return token
}

/**
 * Fetches data from an API endpoint with error handling
 *
 * @param endpoint - API endpoint path
 * @param options - Fetch options
 * @returns Promise with the response data
 */
export async function fetchApi<T>(endpoint: string, options?: RequestInit): Promise<T> {
  const url = getApiUrl(endpoint)

  const token = getAuthToken()

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...(options?.headers as Record<string, string>),
  }

  if (token) {
    headers["Authorization"] = `Bearer ${token}`
    console.log("[v0] fetchApi:", endpoint, "- Authorization header ADDED")
  } else {
    console.log("[v0] fetchApi:", endpoint, "- NO TOKEN - Request will fail if endpoint is protected")
  }

  try {
    const response = await fetch(url, {
      ...options,
      headers,
      cache: "no-store",
    })

    console.log("[v0] fetchApi:", endpoint, "- Response status:", response.status)

    if (!response.ok) {
      if (response.status === 401) {
        console.error("[v0] fetchApi: 401 UNAUTHORIZED -", endpoint, "- Token present:", !!token)
        throw new Error(`Unauthorized: ${endpoint}`)
      }
      throw new Error(`API request failed: ${response.status} ${response.statusText}`)
    }

    return response.json()
  } catch (error) {
    console.error("[v0] fetchApi error for", endpoint, ":", error)
    throw error
  }
}



================================================
FILE: AppImage/lib/format-network.ts
================================================
/**
 * Utility functions for formatting network traffic data
 * Supports conversion between Bytes and Bits based on user preferences
 */

export type NetworkUnit = 'Bytes' | 'Bits';

/**
 * Format network traffic value with appropriate unit
 * @param bytes - Value in bytes
 * @param unit - Target unit ('Bytes' or 'Bits')
 * @param decimals - Number of decimal places (default: 2)
 * @returns Formatted string with value and unit
 */
export function formatNetworkTraffic(
  bytes: number,
  unit: NetworkUnit = 'Bytes',
  decimals: number = 2
): string {
  if (bytes === 0) return unit === 'Bits' ? '0 b' : '0 B';

  const k = unit === 'Bits' ? 1000 : 1024;
  const dm = decimals < 0 ? 0 : Math.min(decimals, 2);
  
  // For Bits: convert bytes to bits first (multiply by 8)
  const value = unit === 'Bits' ? bytes * 8 : bytes;
  
  const sizes = unit === 'Bits' 
    ? ['b', 'Kb', 'Mb', 'Gb', 'Tb', 'Pb']
    : ['B', 'KB', 'MB', 'GB', 'TB', 'PB'];

  const i = Math.floor(Math.log(value) / Math.log(k));
  const finalDecimals = 2; // Always use 2 decimals for consistency
  const formattedValue = parseFloat((value / Math.pow(k, i)).toFixed(finalDecimals));

  return `${formattedValue} ${sizes[i]}`;
}

/**
 * Get the current network unit preference from localStorage
 * @returns 'Bytes' or 'Bits'
 */
export function getNetworkUnit(): NetworkUnit {
  if (typeof window === 'undefined') return 'Bytes';
  
  const stored = localStorage.getItem('proxmenux-network-unit');
  return stored === 'Bits' ? 'Bits' : 'Bytes';
}

/**
 * Get the label for network traffic based on current unit
 * @param direction - 'received' or 'sent'
 * @returns Label string
 */
export function getNetworkLabel(direction: 'received' | 'sent'): string {
  const unit = getNetworkUnit();
  const prefix = direction === 'received' ? 'Received' : 'Sent';
  return unit === 'Bits' ? `${prefix}` : `${prefix}`;
}

/**
 * Get the unit suffix for displaying in charts
 * @returns Unit suffix string (e.g., 'GB' or 'Gb')
 */
export function getNetworkUnitSuffix(): string {
  const unit = getNetworkUnit();
  return unit === 'Bits' ? 'b' : 'B';
}



================================================
FILE: AppImage/lib/script-executor.ts
================================================
import { exec } from "child_process"
import { promisify } from "util"

const execAsync = promisify(exec)

interface ScriptExecutorOptions {
  env?: Record<string, string>
  timeout?: number
}

interface ScriptResult {
  stdout: string
  stderr: string
  exitCode: number
}

export async function executeScript(scriptPath: string, options: ScriptExecutorOptions = {}): Promise<ScriptResult> {
  const { env = {}, timeout = 300000 } = options // 5 minutes default timeout

  try {
    const { stdout, stderr } = await execAsync(`bash ${scriptPath}`, {
      env: { ...process.env, ...env },
      timeout,
      maxBuffer: 1024 * 1024 * 10, // 10MB buffer
    })

    return {
      stdout,
      stderr,
      exitCode: 0,
    }
  } catch (error: any) {
    return {
      stdout: error.stdout || "",
      stderr: error.stderr || error.message || "Unknown error",
      exitCode: error.code || 1,
    }
  }
}



================================================
FILE: AppImage/lib/utils.ts
================================================
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatStorage(sizeInGB: number): string {
  if (sizeInGB < 1) {
    // Less than 1 GB, show in MB
    const mb = sizeInGB * 1024
    return `${mb % 1 === 0 ? mb.toFixed(0) : mb.toFixed(1)} MB`
  } else if (sizeInGB < 1024) {
    // Less than 1024 GB, show in GB
    return `${sizeInGB % 1 === 0 ? sizeInGB.toFixed(0) : sizeInGB.toFixed(1)} GB`
  } else {
    // 1024 GB or more, show in TB
    const tb = sizeInGB / 1024
    return `${tb % 1 === 0 ? tb.toFixed(0) : tb.toFixed(1)} TB`
  }
}



================================================
FILE: AppImage/public/manifest.json
================================================
{
  "name": "ProxMenux Monitor",
  "short_name": "ProxMenux",
  "description": "Proxmox System Dashboard and Monitor",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#2b2f36",
  "theme_color": "#2b2f36",
  "icons": [
    {
      "src": "/images/proxmenux-logo.png",
      "sizes": "256x256",
      "type": "image/png"
    }
  ]
}



================================================
FILE: AppImage/public/images/onboarding/README.md
================================================
# Onboarding Images

Place your screenshot images here with the following names:

- `imagen1.png` - Overview section screenshot
- `imagen2.png` - Storage section screenshot
- `imagen3.png` - Network section screenshot
- `imagen4.png` - VMs & LXCs section screenshot
- `imagen5.png` - Hardware section screenshot
- `imagen6.png` - System Logs section screenshot

## Image Guidelines

- **Format**: PNG or JPG
- **Recommended size**: 1200x800px or similar aspect ratio
- **Quality**: High quality screenshots showing the main features of each section
- **Content**: Capture the full section with representative data

## Notes

- The last slide (Future Updates) doesn't need an image as it uses an icon
- If an image fails to load, the component will show a fallback icon
- Images should be optimized for web (compressed but still high quality)



================================================
FILE: AppImage/scripts/AppRun
================================================
#!/bin/bash

# ProxMenux Monitor AppImage Entry Point
# This script is executed when the AppImage is run

# Get the directory where this AppImage is mounted
APPDIR="$(dirname "$(readlink -f "${0}")")"

export PATH="${APPDIR}/usr/bin:${PATH}"
export LD_LIBRARY_PATH="${APPDIR}/usr/lib/x86_64-linux-gnu:${APPDIR}/usr/lib:${APPDIR}/lib/x86_64-linux-gnu:${APPDIR}/lib:${LD_LIBRARY_PATH}"
export PYTHONPATH="${APPDIR}/usr/lib/python3/dist-packages:${APPDIR}/usr/lib/python3/site-packages:${PYTHONPATH}"

# Change to the AppImage directory
cd "${APPDIR}"

# Check for translation argument
if [[ "$1" == "--translate" ]]; then
    echo "ğŸŒ Starting ProxMenux Translation Service..."
    exec python3 "${APPDIR}/usr/bin/translate_cli.py" "${@:2}"
else
    echo "ğŸš€ Starting ProxMenux Monitor Dashboard..."
    echo ""
    
    echo "ğŸ”§ Hardware monitoring tools:"
    [ -x "${APPDIR}/usr/bin/ipmitool" ] && echo "  âœ… ipmitool available" || echo "  âš ï¸  ipmitool not available"
    [ -x "${APPDIR}/usr/bin/sensors" ] && echo "  âœ… sensors available" || echo "  âš ï¸  sensors not available"
    [ -x "${APPDIR}/usr/bin/upsc" ] && echo "  âœ… upsc available" || echo "  âš ï¸  upsc not available"
    
    if [ -x "${APPDIR}/usr/bin/ipmitool" ]; then
        if ldd "${APPDIR}/usr/bin/ipmitool" 2>/dev/null | grep -q "libfreeipmi.so.17 => not found"; then
            echo "  âš ï¸  libfreeipmi.so.17 not found - ipmitool may not work"
        elif ldd "${APPDIR}/usr/bin/ipmitool" 2>/dev/null | grep -q "libfreeipmi.so.17"; then
            echo "  âœ… libfreeipmi.so.17 loaded successfully"
        fi
    fi
    
    echo ""
    
    # Start the Flask server
    exec python3 "${APPDIR}/usr/bin/flask_server.py"
fi



================================================
FILE: AppImage/scripts/auth_manager.py
================================================
"""
Authentication Manager Module
Handles all authentication-related operations including:
- Loading/saving auth configuration
- Password hashing and verification
- JWT token generation and validation
- Auth status checking
- Two-Factor Authentication (2FA/TOTP)
"""

import os
import json
import hashlib
import secrets
from datetime import datetime, timedelta
from pathlib import Path

try:
    import jwt
    JWT_AVAILABLE = True
except ImportError:
    JWT_AVAILABLE = False
    print("Warning: PyJWT not available. Authentication features will be limited.")

try:
    import pyotp
    import segno
    import io
    import base64
    TOTP_AVAILABLE = True
except ImportError:
    TOTP_AVAILABLE = False
    print("Warning: pyotp/segno not available. 2FA features will be disabled.")

# Configuration
CONFIG_DIR = Path.home() / ".config" / "proxmenux-monitor"
AUTH_CONFIG_FILE = CONFIG_DIR / "auth.json"
JWT_SECRET = "proxmenux-monitor-secret-key-change-in-production"
JWT_ALGORITHM = "HS256"
TOKEN_EXPIRATION_HOURS = 24


def ensure_config_dir():
    """Ensure the configuration directory exists"""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)


def load_auth_config():
    """
    Load authentication configuration from file
    Returns dict with structure:
    {
        "enabled": bool,
        "username": str,
        "password_hash": str,
        "declined": bool,
        "configured": bool,
        "totp_enabled": bool,  # 2FA enabled flag
        "totp_secret": str,    # TOTP secret key
        "backup_codes": list   # List of backup codes
    }
    """
    if not AUTH_CONFIG_FILE.exists():
        return {
            "enabled": False,
            "username": None,
            "password_hash": None,
            "declined": False,
            "configured": False,
            "totp_enabled": False,
            "totp_secret": None,
            "backup_codes": []
        }
    
    try:
        with open(AUTH_CONFIG_FILE, 'r') as f:
            config = json.load(f)
            # Ensure all required fields exist
            config.setdefault("declined", False)
            config.setdefault("configured", config.get("enabled", False) or config.get("declined", False))
            config.setdefault("totp_enabled", False)
            config.setdefault("totp_secret", None)
            config.setdefault("backup_codes", [])
            return config
    except Exception as e:
        print(f"Error loading auth config: {e}")
        return {
            "enabled": False,
            "username": None,
            "password_hash": None,
            "declined": False,
            "configured": False,
            "totp_enabled": False,
            "totp_secret": None,
            "backup_codes": []
        }


def save_auth_config(config):
    """Save authentication configuration to file"""
    ensure_config_dir()
    try:
        with open(AUTH_CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print(f"Error saving auth config: {e}")
        return False


def hash_password(password):
    """Hash a password using SHA-256"""
    return hashlib.sha256(password.encode()).hexdigest()


def verify_password(password, password_hash):
    """Verify a password against its hash"""
    return hash_password(password) == password_hash


def generate_token(username):
    """Generate a JWT token for the given username"""
    if not JWT_AVAILABLE:
        return None
    
    payload = {
        'username': username,
        'exp': datetime.utcnow() + timedelta(hours=TOKEN_EXPIRATION_HOURS),
        'iat': datetime.utcnow()
    }
    
    try:
        token = jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        print(f"Error generating token: {e}")
        return None


def verify_token(token):
    """
    Verify a JWT token
    Returns username if valid, None otherwise
    """
    if not JWT_AVAILABLE or not token:
        return None
    
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        return payload.get('username')
    except jwt.ExpiredSignatureError:
        print("Token has expired")
        return None
    except jwt.InvalidTokenError as e:
        print(f"Invalid token: {e}")
        return None


def get_auth_status():
    """
    Get current authentication status
    Returns dict with:
    {
        "auth_enabled": bool,
        "auth_configured": bool,
        "declined": bool,
        "username": str or None,
        "authenticated": bool,
        "totp_enabled": bool  # 2FA status
    }
    """
    config = load_auth_config()
    return {
        "auth_enabled": config.get("enabled", False),
        "auth_configured": config.get("configured", False),
        "declined": config.get("declined", False),
        "username": config.get("username") if config.get("enabled") else None,
        "authenticated": False,
        "totp_enabled": config.get("totp_enabled", False)  # Include 2FA status
    }


def setup_auth(username, password):
    """
    Set up authentication with username and password
    Returns (success: bool, message: str)
    """
    if not username or not password:
        return False, "Username and password are required"
    
    if len(password) < 6:
        return False, "Password must be at least 6 characters"
    
    config = {
        "enabled": True,
        "username": username,
        "password_hash": hash_password(password),
        "declined": False,
        "configured": True,
        "totp_enabled": False,
        "totp_secret": None,
        "backup_codes": []
    }
    
    if save_auth_config(config):
        return True, "Authentication configured successfully"
    else:
        return False, "Failed to save authentication configuration"


def decline_auth():
    """
    Mark authentication as declined by user
    Returns (success: bool, message: str)
    """
    config = load_auth_config()
    config["enabled"] = False
    config["declined"] = True
    config["configured"] = True
    config["username"] = None
    config["password_hash"] = None
    config["totp_enabled"] = False
    config["totp_secret"] = None
    config["backup_codes"] = []
    
    if save_auth_config(config):
        return True, "Authentication declined"
    else:
        return False, "Failed to save configuration"


def disable_auth():
    """
    Disable authentication (different from decline - can be re-enabled)
    Returns (success: bool, message: str)
    """
    config = load_auth_config()
    config["enabled"] = False
    config["username"] = None
    config["password_hash"] = None
    config["declined"] = False
    config["configured"] = False
    config["totp_enabled"] = False
    config["totp_secret"] = None
    config["backup_codes"] = []
    
    if save_auth_config(config):
        return True, "Authentication disabled"
    else:
        return False, "Failed to save configuration"


def enable_auth():
    """
    Enable authentication (must already be configured)
    Returns (success: bool, message: str)
    """
    config = load_auth_config()
    
    if not config.get("username") or not config.get("password_hash"):
        return False, "Authentication not configured. Please set up username and password first."
    
    config["enabled"] = True
    config["declined"] = False
    
    if save_auth_config(config):
        return True, "Authentication enabled"
    else:
        return False, "Failed to save configuration"


def change_password(old_password, new_password):
    """
    Change the authentication password
    Returns (success: bool, message: str)
    """
    config = load_auth_config()
    
    if not config.get("enabled"):
        return False, "Authentication is not enabled"
    
    if not verify_password(old_password, config.get("password_hash", "")):
        return False, "Current password is incorrect"
    
    if len(new_password) < 6:
        return False, "New password must be at least 6 characters"
    
    config["password_hash"] = hash_password(new_password)
    
    if save_auth_config(config):
        return True, "Password changed successfully"
    else:
        return False, "Failed to save new password"


def generate_totp_secret():
    """Generate a new TOTP secret key"""
    if not TOTP_AVAILABLE:
        return None
    return pyotp.random_base32()


def generate_totp_qr(username, secret):
    """
    Generate a QR code for TOTP setup
    Returns base64 encoded SVG image
    """
    if not TOTP_AVAILABLE:
        return None
    
    try:
        # Create TOTP URI
        totp = pyotp.TOTP(secret)
        uri = totp.provisioning_uri(
            name=username,
            issuer_name="ProxMenux Monitor"
        )
        
        qr = segno.make(uri)
        
        # Convert to SVG string
        buffer = io.BytesIO()
        qr.save(buffer, kind='svg', scale=4, border=2)
        svg_bytes = buffer.getvalue()
        svg_content = svg_bytes.decode('utf-8')
        
        # Return as data URL
        svg_base64 = base64.b64encode(svg_content.encode()).decode('utf-8')
        return f"data:image/svg+xml;base64,{svg_base64}"
    except Exception as e:
        print(f"Error generating QR code: {e}")
        return None


def generate_backup_codes(count=8):
    """Generate backup codes for 2FA recovery"""
    codes = []
    for _ in range(count):
        # Generate 8-character alphanumeric code
        code = ''.join(secrets.choice('ABCDEFGHJKLMNPQRSTUVWXYZ23456789') for _ in range(8))
        # Format as XXXX-XXXX for readability
        formatted = f"{code[:4]}-{code[4:]}"
        codes.append({
            "code": hashlib.sha256(formatted.encode()).hexdigest(),
            "used": False
        })
    return codes


def setup_totp(username):
    """
    Set up TOTP for a user
    Returns (success: bool, secret: str, qr_code: str, backup_codes: list, message: str)
    """
    if not TOTP_AVAILABLE:
        return False, None, None, None, "2FA is not available (pyotp/segno not installed)"
    
    config = load_auth_config()
    
    if not config.get("enabled"):
        return False, None, None, None, "Authentication must be enabled first"
    
    if config.get("username") != username:
        return False, None, None, None, "Invalid username"
    
    # Generate new secret and backup codes
    secret = generate_totp_secret()
    qr_code = generate_totp_qr(username, secret)
    backup_codes_plain = []
    backup_codes_hashed = generate_backup_codes()
    
    # Generate plain text backup codes for display (only returned once)
    for i in range(8):
        code = ''.join(secrets.choice('ABCDEFGHJKLMNPQRSTUVWXYZ23456789') for _ in range(8))
        formatted = f"{code[:4]}-{code[4:]}"
        backup_codes_plain.append(formatted)
        backup_codes_hashed[i]["code"] = hashlib.sha256(formatted.encode()).hexdigest()
    
    # Store secret and hashed backup codes (not enabled yet until verified)
    config["totp_secret"] = secret
    config["backup_codes"] = backup_codes_hashed
    
    if save_auth_config(config):
        return True, secret, qr_code, backup_codes_plain, "2FA setup initiated"
    else:
        return False, None, None, None, "Failed to save 2FA configuration"


def verify_totp(username, token, use_backup=False):
    """
    Verify a TOTP token or backup code
    Returns (success: bool, message: str)
    """
    if not TOTP_AVAILABLE and not use_backup:
        return False, "2FA is not available"
    
    config = load_auth_config()
    
    if not config.get("totp_enabled"):
        return False, "2FA is not enabled"
    
    if config.get("username") != username:
        return False, "Invalid username"
    
    # Check backup code
    if use_backup:
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        for backup_code in config.get("backup_codes", []):
            if backup_code["code"] == token_hash and not backup_code["used"]:
                backup_code["used"] = True
                save_auth_config(config)
                return True, "Backup code accepted"
        return False, "Invalid or already used backup code"
    
    # Check TOTP token
    totp = pyotp.TOTP(config.get("totp_secret"))
    if totp.verify(token, valid_window=1):  # Allow 1 time step tolerance
        return True, "2FA verification successful"
    else:
        return False, "Invalid 2FA code"


def enable_totp(username, verification_token):
    """
    Enable TOTP after successful verification
    Returns (success: bool, message: str)
    """
    if not TOTP_AVAILABLE:
        return False, "2FA is not available"
    
    config = load_auth_config()
    
    if not config.get("totp_secret"):
        return False, "2FA has not been set up. Please set up 2FA first."
    
    if config.get("username") != username:
        return False, "Invalid username"
    
    # Verify the token before enabling
    totp = pyotp.TOTP(config.get("totp_secret"))
    if not totp.verify(verification_token, valid_window=1):
        return False, "Invalid verification code. Please try again."
    
    config["totp_enabled"] = True
    
    if save_auth_config(config):
        return True, "2FA enabled successfully"
    else:
        return False, "Failed to enable 2FA"


def disable_totp(username, password):
    """
    Disable TOTP (requires password confirmation)
    Returns (success: bool, message: str)
    """
    config = load_auth_config()
    
    if config.get("username") != username:
        return False, "Invalid username"
    
    if not verify_password(password, config.get("password_hash", "")):
        return False, "Invalid password"
    
    config["totp_enabled"] = False
    config["totp_secret"] = None
    config["backup_codes"] = []
    
    if save_auth_config(config):
        return True, "2FA disabled successfully"
    else:
        return False, "Failed to disable 2FA"


def authenticate(username, password, totp_token=None):
    """
    Authenticate a user with username, password, and optional TOTP
    Returns (success: bool, token: str or None, requires_totp: bool, message: str)
    """
    config = load_auth_config()
    
    if not config.get("enabled"):
        return False, None, False, "Authentication is not enabled"
    
    if username != config.get("username"):
        return False, None, False, "Invalid username or password"
    
    if not verify_password(password, config.get("password_hash", "")):
        return False, None, False, "Invalid username or password"
    
    if config.get("totp_enabled"):
        if not totp_token:
            return False, None, True, "2FA code required"
        
        # Verify TOTP token or backup code
        success, message = verify_totp(username, totp_token, use_backup=len(totp_token) == 9)  # Backup codes are formatted XXXX-XXXX
        if not success:
            return False, None, True, message
    
    token = generate_token(username)
    if token:
        return True, token, False, "Authentication successful"
    else:
        return False, None, False, "Failed to generate authentication token"



================================================
FILE: AppImage/scripts/build_appimage.sh
================================================
#!/bin/bash

# ProxMenux Monitor AppImage Builder
# This script creates a single AppImage with Flask server, Next.js dashboard, and translation support

set -e

WORK_DIR="/tmp/proxmenux_build"
APP_DIR="$WORK_DIR/ProxMenux.AppDir"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DIST_DIR="$SCRIPT_DIR/../dist"
APPIMAGE_ROOT="$SCRIPT_DIR/.."

VERSION=$(node -p "require('$APPIMAGE_ROOT/package.json').version")
APPIMAGE_NAME="ProxMenux-${VERSION}.AppImage"

echo "ğŸš€ Building ProxMenux Monitor AppImage v${VERSION} with hardware monitoring tools..."

# Clean and create work directory
rm -rf "$WORK_DIR"
mkdir -p "$APP_DIR"
mkdir -p "$DIST_DIR"

# Download appimagetool if not exists
if [ ! -f "$WORK_DIR/appimagetool" ]; then
    echo "ğŸ“¥ Downloading appimagetool..."
    wget -q "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage" -O "$WORK_DIR/appimagetool"
    chmod +x "$WORK_DIR/appimagetool"
fi

# Create directory structure
mkdir -p "$APP_DIR/usr/bin"
mkdir -p "$APP_DIR/usr/lib/python3/dist-packages"
mkdir -p "$APP_DIR/usr/share/applications"
mkdir -p "$APP_DIR/usr/share/icons/hicolor/256x256/apps"
mkdir -p "$APP_DIR/web"

echo "ğŸ”¨ Building Next.js application..."
cd "$APPIMAGE_ROOT"
if [ ! -f "package.json" ]; then
    echo "âŒ Error: package.json not found in AppImage directory"
    exit 1
fi

# Install dependencies if node_modules doesn't exist
if [ ! -d "node_modules" ]; then
    echo "ğŸ“¦ Installing dependencies..."
    npm install
fi

echo "ğŸ—ï¸  Building Next.js static export..."
npm run export

echo "ğŸ” Checking export results..."
if [ -d "out" ]; then
    echo "âœ… Export directory found"
    echo "ğŸ“ Contents of out directory:"
    ls -la out/
    if [ -f "out/index.html" ]; then
        echo "âœ… index.html found in out directory"
    else
        echo "âŒ index.html NOT found in out directory"
        echo "ğŸ“ Looking for HTML files:"
        find out/ -name "*.html" -type f || echo "No HTML files found"
    fi
else
    echo "âŒ Error: Next.js export failed - out directory not found"
    echo "ğŸ“ Current directory contents:"
    ls -la
    echo "ğŸ“ Looking for any build outputs:"
    find . -name "*.html" -type f 2>/dev/null || echo "No HTML files found anywhere"
    exit 1
fi

# Return to script directory
cd "$SCRIPT_DIR"

# Copy Flask server
echo "ğŸ“‹ Copying Flask server..."
cp "$SCRIPT_DIR/flask_server.py" "$APP_DIR/usr/bin/"
cp "$SCRIPT_DIR/flask_auth_routes.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  flask_auth_routes.py not found"
cp "$SCRIPT_DIR/auth_manager.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  auth_manager.py not found"
cp "$SCRIPT_DIR/jwt_middleware.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  jwt_middleware.py not found"
cp "$SCRIPT_DIR/health_monitor.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  health_monitor.py not found"
cp "$SCRIPT_DIR/health_persistence.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  health_persistence.py not found"
cp "$SCRIPT_DIR/flask_health_routes.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  flask_health_routes.py not found"
cp "$SCRIPT_DIR/flask_proxmenux_routes.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  flask_proxmenux_routes.py not found"
cp "$SCRIPT_DIR/flask_terminal_routes.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  flask_terminal_routes.py not found"
cp "$SCRIPT_DIR/hardware_monitor.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  hardware_monitor.py not found"
cp "$SCRIPT_DIR/proxmox_storage_monitor.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  proxmox_storage_monitor.py not found"
cp "$SCRIPT_DIR/flask_script_runner.py" "$APP_DIR/usr/bin/" 2>/dev/null || echo "âš ï¸  flask_script_runner.py not found"

echo "ğŸ“‹ Adding translation support..."
cat > "$APP_DIR/usr/bin/translate_cli.py" << 'PYEOF'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ProxMenux translate CLI
stdin JSON -> {"text":"...", "dest_lang":"es", "context":"...", "cache_file":"/usr/local/share/proxmenux/cache.json"}
stdout JSON -> {"success":true,"text":"..."} or {"success":false,"error":"..."}
"""
import sys, json, re
from pathlib import Path

# Ensure embedded site-packages are discoverable
HERE = Path(__file__).resolve().parents[2]  # .../AppDir
DIST = HERE / "usr" / "lib" / "python3" / "dist-packages"
SITE = HERE / "usr" / "lib" / "python3" / "site-packages"
for p in (str(DIST), str(SITE)):
    if p not in sys.path:
        sys.path.insert(0, p)

# Python 3.13 compat: inline 'cgi' shim
try:
    import cgi
except Exception:
    import types, html
    def _parse_header(value: str):
        value = str(value or "")
        parts = [p.strip() for p in value.split(";")]
        if not parts:
            return "", {}
        key = parts[0].lower()
        params = {}
        for item in parts[1:]:
            if not item:
                continue
            if "=" in item:
                k, v = item.split("=", 1)
                k = k.strip().lower()
                v = v.strip().strip('"').strip("'")
                params[k] = v
            else:
                params[item.strip().lower()] = ""
        return key, params
    cgi = types.SimpleNamespace(parse_header=_parse_header, escape=html.escape)

try:
    from googletrans import Translator
except Exception as e:
    print(json.dumps({"success": False, "error": f"ImportError: {e}"}))
    sys.exit(0)

def load_json_stdin():
    try:
        return json.load(sys.stdin)
    except Exception as e:
        print(json.dumps({"success": False, "error": f"Invalid JSON input: {e}"}))
        sys.exit(0)

def ensure_cache(path: Path):
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        if not path.exists():
            path.write_text("{}", encoding="utf-8")
        json.loads(path.read_text(encoding="utf-8") or "{}")
    except Exception:
        path.write_text("{}", encoding="utf-8")

def read_cache(path: Path):
    try:
        return json.loads(path.read_text(encoding="utf-8") or "{}")
    except Exception:
        return {}

def write_cache(path: Path, cache: dict):
    tmp = path.with_suffix(".tmp")
    tmp.write_text(json.dumps(cache, ensure_ascii=False), encoding="utf-8")
    tmp.replace(path)

def clean_translated(s: str) -> str:
    s = re.sub(r'^.*?(Translate:|Traducir:|Traduire:|Ãœbersetzen:|Tradurre:|Traduzir:|ç¿»è¯‘:|ç¿»è¨³:)', '', s, flags=re.IGNORECASE | re.DOTALL).strip()
    s = re.sub(r'^.*?(Context:|Contexto:|Contexte:|Kontext:|Contesto:|ä¸Šä¸‹æ–‡ï¼š|ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼š).*?:', '', s, flags=re.IGNORECASE | re.DOTALL).strip()
    return s.strip()

def main():
    req = load_json_stdin()
    text = req.get("text", "")
    dest = req.get("dest_lang", "en") or "en"
    context = req.get("context", "")
    cache_file = Path(req.get("cache_file", "")) if req.get("cache_file") else None

    if dest == "en":
        print(json.dumps({"success": True, "text": text}))
        return

    cache = {}
    if cache_file:
        ensure_cache(cache_file)
        cache = read_cache(cache_file)
        if text in cache and (dest in cache[text] or "notranslate" in cache[text]):
            found = cache[text].get(dest) or cache[text].get("notranslate")
            print(json.dumps({"success": True, "text": found}))
            return

    try:
        full = (context + " " + text).strip() if context else text
        tr = Translator()
        result = tr.translate(full, dest=dest).text
        result = clean_translated(result)

        if cache_file:
            cache.setdefault(text, {})
            cache[text][dest] = result
            write_cache(cache_file, cache)

        print(json.dumps({"success": True, "text": result}))
    except Exception as e:
        print(json.dumps({"success": False, "error": str(e)}))

if __name__ == "__main__":
    main()
PYEOF

chmod +x "$APP_DIR/usr/bin/translate_cli.py"

# Copy Next.js build
echo "ğŸ“‹ Copying web dashboard..."
if [ -d "$APPIMAGE_ROOT/out" ]; then
    mkdir -p "$APP_DIR/web"
    echo "ğŸ“ Copying from $APPIMAGE_ROOT/out to $APP_DIR/web"
    cp -r "$APPIMAGE_ROOT/out"/* "$APP_DIR/web/"
    
    if [ -f "$APP_DIR/web/index.html" ]; then
        echo "âœ… index.html copied successfully to $APP_DIR/web/"
    else
        echo "âŒ index.html NOT found after copying"
        echo "ğŸ“ Contents of $APP_DIR/web:"
        ls -la "$APP_DIR/web/" || echo "Directory is empty or doesn't exist"
    fi
    
    if [ -d "$APPIMAGE_ROOT/public" ]; then
        cp -r "$APPIMAGE_ROOT/public"/* "$APP_DIR/web/" 2>/dev/null || true
    fi
    cp "$APPIMAGE_ROOT/package.json" "$APP_DIR/web/"
    
    echo "âœ… Next.js static export copied successfully"
else
    echo "âŒ Error: Next.js export not found even after building"
    exit 1
fi

# Copy AppRun script
echo "ğŸ“‹ Copying AppRun script..."
if [ -f "$SCRIPT_DIR/AppRun" ]; then
    cp "$SCRIPT_DIR/AppRun" "$APP_DIR/AppRun"
    chmod +x "$APP_DIR/AppRun"
    echo "âœ… AppRun script copied successfully"
else
    echo "âŒ Error: AppRun script not found at $SCRIPT_DIR/AppRun"
    exit 1
fi

# Create desktop file
cat > "$APP_DIR/proxmenux-monitor.desktop" << EOF
[Desktop Entry]
Type=Application
Name=ProxMenux Monitor
Comment=Proxmox System Monitoring Dashboard with Translation Support
Exec=AppRun
Icon=proxmenux-monitor
Categories=System;Monitor;
Terminal=false
StartupNotify=true
EOF

# Copy desktop file to applications directory
cp "$APP_DIR/proxmenux-monitor.desktop" "$APP_DIR/usr/share/applications/"

# Download and set icon
echo "ğŸ¨ Setting up icon..."
if [ -f "$APPIMAGE_ROOT/public/images/proxmenux-logo.png" ]; then
    cp "$APPIMAGE_ROOT/public/images/proxmenux-logo.png" "$APP_DIR/proxmenux-monitor.png"
else
    wget -q "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo.png" -O "$APP_DIR/proxmenux-monitor.png" || {
        echo "âš ï¸  Could not download logo, creating placeholder..."
        convert -size 256x256 xc:blue -fill white -gravity center -pointsize 24 -annotate +0+0 "PM" "$APP_DIR/proxmenux-monitor.png" 2>/dev/null || {
            echo "âš ï¸  ImageMagick not available, skipping icon creation"
        }
    }
fi

if [ -f "$APP_DIR/proxmenux-monitor.png" ]; then
    cp "$APP_DIR/proxmenux-monitor.png" "$APP_DIR/usr/share/icons/hicolor/256x256/apps/"
fi

echo "ğŸ“¦ Installing Python dependencies..."
# Phase 1: Install googletrans with its old dependencies
pip3 install --target "$APP_DIR/usr/lib/python3/dist-packages" \
    googletrans==4.0.0-rc1 \
    httpx==0.13.3 \
    httpcore==0.9.1 \
    h11==0.9.0 || true

# Phase 2: Install modern Flask/WebSocket dependencies (will upgrade h11 and related packages)
pip3 install --target "$APP_DIR/usr/lib/python3/dist-packages" --upgrade --no-deps \
    flask \
    flask-cors \
    psutil \
    requests \
    PyJWT \
    pyotp \
    segno \
    beautifulsoup4

# Phase 3: Install WebSocket with newer h11
pip3 install --target "$APP_DIR/usr/lib/python3/dist-packages" --upgrade \
    h11>=0.14.0 \
    wsproto>=1.2.0 \
    simple-websocket>=0.10.0 \
    flask-sock>=0.6.0

cat > "$APP_DIR/usr/lib/python3/dist-packages/cgi.py" << 'PYEOF'
from typing import Tuple, Dict
try:
    from html import escape as _html_escape
except Exception:
    def _html_escape(s, quote=True): return s

__all__ = ["parse_header", "escape"]

def escape(s, quote=True):
    return _html_escape(s, quote=quote)

def parse_header(value: str) -> Tuple[str, Dict[str, str]]:
    if not isinstance(value, str):
        value = str(value or "")
    parts = [p.strip() for p in value.split(";")]
    if not parts:
        return "", {}
    key = parts[0].lower()
    params: Dict[str, str] = {}
    for item in parts[1:]:
        if not item:
            continue
        if "=" in item:
            k, v = item.split("=", 1)
            k = k.strip().lower()
            v = v.strip().strip('"').strip("'")
            params[k] = v
        else:
            params[item.strip().lower()] = ""
    return key, params
PYEOF

echo "ğŸ”§ Installing hardware monitoring tools..."
mkdir -p "$WORK_DIR/debs"
cd "$WORK_DIR/debs"

echo "ğŸ“¥ Downloading hardware monitoring tools (dynamic via APT)..."

dl_pkg() {
  local out="$1"; shift
  local pkg deb_file
  for pkg in "$@"; do
    echo "  - trying: $pkg"
    if apt-get download -y "$pkg" >/dev/null 2>&1; then
      deb_file="$(ls -1 ${pkg}_*.deb 2>/dev/null | head -n1)"
      if [ -n "$deb_file" ] && [ -f "$deb_file" ]; then
        mv "$deb_file" "$out"
        echo "    âœ… downloaded: $pkg -> $out"
        return 0
      fi
    fi
  done

  if command -v sudo >/dev/null 2>&1 && sudo -n true >/dev/null 2>&1; then
    echo "  â†» retry with sudo apt-get update && download"
    sudo apt-get update -qq || true
    for pkg in "$@"; do
      echo "  - trying (sudo): $pkg"
      if sudo apt-get download -y "$pkg" >/dev/null 2>&1; then
        deb_file="$(ls -1 ${pkg}_*.deb 2>/dev/null | head -n1)"
        if [ -n "$deb_file" ] && [ -f "$deb_file" ]; then
          mv "$deb_file" "$out"
          echo "    âœ… downloaded (sudo): $pkg -> $out"
          return 0
        fi
      fi
    done
  fi
  echo "    âš ï¸  none of the candidates could be downloaded for $out"
  return 1
}

dl_pkg "ipmitool.deb"        "ipmitool"                         || true
dl_pkg "libfreeipmi17.deb"   "libfreeipmi17"                    || true
dl_pkg "lm-sensors.deb"      "lm-sensors"                       || true
dl_pkg "nut-client.deb"      "nut-client"                       || true
dl_pkg "libupsclient.deb"    "libupsclient6" "libupsclient5" "libupsclient4" || true

echo "ğŸ“¦ Extracting .deb packages into AppDir..."
extracted_count=0
shopt -s nullglob
for deb in *.deb; do
  echo "  -> $deb"
  if file "$deb" | grep -q "Debian binary package"; then
    dpkg-deb -x "$deb" "$APP_DIR" && extracted_count=$((extracted_count + 1))
  else
    echo "    âš ï¸  $deb is not a valid .deb, skipping"
  fi
done
shopt -u nullglob

if [ $extracted_count -eq 0 ]; then
  echo "âš ï¸  No packages extracted; hardware/GPU monitoring may be unavailable"
else
  echo "âœ… Extracted $extracted_count package(s)"
fi

if [ -d "$APP_DIR/bin" ]; then
  echo "ğŸ“‹ Normalizing /bin -> /usr/bin"
  mkdir -p "$APP_DIR/usr/bin"
  cp -r "$APP_DIR/bin/"* "$APP_DIR/usr/bin/" 2>/dev/null || true
  rm -rf "$APP_DIR/bin"
fi

echo "ğŸ” Sanity check (ldd + presence of libfreeipmi)"
export LD_LIBRARY_PATH="$APP_DIR/lib:$APP_DIR/lib/x86_64-linux-gnu:$APP_DIR/usr/lib:$APP_DIR/usr/lib/x86_64-linux-gnu"

if ! find "$APP_DIR/usr/lib" "$APP_DIR/lib" -maxdepth 3 -name 'libfreeipmi.so.17*' | grep -q .; then
  echo "âŒ libfreeipmi.so.17 not found inside AppDir (ipmitool will fail)"
  exit 1
fi

if [ -x "$APP_DIR/usr/bin/ipmitool" ] && ldd "$APP_DIR/usr/bin/ipmitool" | grep -q 'not found'; then
  echo "âŒ ipmitool has unresolved libs:"
  ldd "$APP_DIR/usr/bin/ipmitool" | grep 'not found' || true
  exit 1
fi

if [ -x "$APP_DIR/usr/bin/upsc" ] && ldd "$APP_DIR/usr/bin/upsc" | grep -q 'not found'; then
  echo "âš ï¸ upsc has unresolved libs, trying to auto-fix..."
  missing="$(ldd "$APP_DIR/usr/bin/upsc" | awk '/not found/{print $1}' | tr -d ' ')"
  echo "   missing: $missing"
  case "$missing" in
    libupsclient.so.6) need_pkg="libupsclient6" ;;
    libupsclient.so.5) need_pkg="libupsclient5" ;;
    libupsclient.so.4) need_pkg="libupsclient4" ;;
    *) need_pkg="" ;;
  esac

  if [ -n "$need_pkg" ]; then
    echo "   downloading: $need_pkg"
    dl_pkg "libupsclient_autofix.deb" "$need_pkg" || true
    if [ -f "libupsclient_autofix.deb" ]; then
      dpkg-deb -x "libupsclient_autofix.deb" "$APP_DIR"
      echo "   re-checking ldd for upsc..."
      if ldd "$APP_DIR/usr/bin/upsc" | grep -q 'not found'; then
        echo "âŒ upsc still has unresolved libs:"
        ldd "$APP_DIR/usr/bin/upsc" | grep 'not found' || true
        exit 1
      fi
    else
      echo "âŒ could not download $need_pkg automatically"
      exit 1
    fi
  else
    echo "âŒ unknown missing library for upsc: $missing"
    exit 1
  fi
fi

echo "âœ… Sanity check OK (ipmitool/upsc ready; libfreeipmi present)"

# Info rÃ¡pida
[ -x "$APP_DIR/usr/bin/sensors" ]         && echo "  â€¢ sensors: OK"            || echo "  â€¢ sensors: missing"
[ -x "$APP_DIR/usr/bin/ipmitool" ]        && echo "  â€¢ ipmitool: OK"           || echo "  â€¢ ipmitool: missing"
[ -x "$APP_DIR/usr/bin/upsc" ]            && echo "  â€¢ upsc: OK"               || echo "  â€¢ upsc: missing"
[ -x "$APP_DIR/usr/bin/nvidia-smi" ]      && echo "  â€¢ nvidia-smi: OK"         || echo "  â€¢ nvidia-smi: missing"
[ -x "$APP_DIR/usr/bin/intel_gpu_top" ]   && echo "  â€¢ intel-gpu-tools: OK"    || echo "  â€¢ intel-gpu-tools: missing"
[ -x "$APP_DIR/usr/bin/radeontop" ]       && echo "  â€¢ radeontop: OK"          || echo "  â€¢ radeontop: missing"

# Build AppImage
echo "ğŸ”¨ Building unified AppImage v${VERSION}..."
cd "$WORK_DIR"
export NO_CLEANUP=1
export APPIMAGE_EXTRACT_AND_RUN=1
ARCH=x86_64 ./appimagetool --no-appstream --verbose "$APP_DIR" "$APPIMAGE_NAME"

# Move to dist directory
mv "$APPIMAGE_NAME" "$DIST_DIR/"

echo "âœ… Unified AppImage created: $DIST_DIR/$APPIMAGE_NAME"
echo ""
echo "ğŸ“‹ Usage:"
echo "   Dashboard: ./$APPIMAGE_NAME"
echo "   Translation: ./$APPIMAGE_NAME --translate"
echo ""
echo "ğŸš€ Installation:"
echo "   sudo cp $DIST_DIR/$APPIMAGE_NAME /usr/local/bin/proxmenux-monitor"
echo "   sudo chmod +x /usr/local/bin/proxmenux-monitor"



================================================
FILE: AppImage/scripts/flask_auth_routes.py
================================================
"""
Flask Authentication Routes
Provides REST API endpoints for authentication management
"""

from flask import Blueprint, jsonify, request
import auth_manager
import jwt
import datetime

auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/api/auth/status', methods=['GET'])
def auth_status():
    """Get current authentication status"""
    try:
        status = auth_manager.get_auth_status()
        
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if token:
            username = auth_manager.verify_token(token)
            if username:
                status['authenticated'] = True
        
        return jsonify(status)
    except Exception as e:
        return jsonify({"error": str(e)}), 500


@auth_bp.route('/api/auth/setup', methods=['POST'])
def auth_setup():
    """Set up authentication with username and password"""
    try:
        data = request.json
        username = data.get('username')
        password = data.get('password')
        
        success, message = auth_manager.setup_auth(username, password)
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/decline', methods=['POST'])
def auth_decline():
    """Decline authentication setup"""
    try:
        success, message = auth_manager.decline_auth()
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/login', methods=['POST'])
def auth_login():
    """Authenticate user and return JWT token"""
    try:
        data = request.json
        username = data.get('username')
        password = data.get('password')
        totp_token = data.get('totp_token')  # Optional 2FA token
        
        success, token, requires_totp, message = auth_manager.authenticate(username, password, totp_token)
        
        if success:
            return jsonify({"success": True, "token": token, "message": message})
        elif requires_totp:
            return jsonify({"success": False, "requires_totp": True, "message": message}), 200
        else:
            return jsonify({"success": False, "message": message}), 401
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/enable', methods=['POST'])
def auth_enable():
    """Enable authentication"""
    try:
        success, message = auth_manager.enable_auth()
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/disable', methods=['POST'])
def auth_disable():
    """Disable authentication"""
    try:
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        if not token or not auth_manager.verify_token(token):
            return jsonify({"success": False, "message": "Unauthorized"}), 401
            
        success, message = auth_manager.disable_auth()
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/change-password', methods=['POST'])
def auth_change_password():
    """Change authentication password"""
    try:
        data = request.json
        old_password = data.get('old_password')
        new_password = data.get('new_password')
        
        success, message = auth_manager.change_password(old_password, new_password)
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/skip', methods=['POST'])
def auth_skip():
    """Skip authentication setup (same as decline)"""
    try:
        success, message = auth_manager.decline_auth()
        
        if success:
            # Return success with clear indication that APIs should be accessible
            return jsonify({
                "success": True, 
                "message": message,
                "auth_declined": True  # Add explicit flag for frontend
            })
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/totp/setup', methods=['POST'])
def totp_setup():
    """Initialize TOTP setup for a user"""
    try:
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        username = auth_manager.verify_token(token)
        
        if not username:
            return jsonify({"success": False, "message": "Unauthorized"}), 401
        
        success, secret, qr_code, backup_codes, message = auth_manager.setup_totp(username)
        
        if success:
            return jsonify({
                "success": True,
                "secret": secret,
                "qr_code": qr_code,
                "backup_codes": backup_codes,
                "message": message
            })
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/totp/enable', methods=['POST'])
def totp_enable():
    """Enable TOTP after verification"""
    try:
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        username = auth_manager.verify_token(token)
        
        if not username:
            return jsonify({"success": False, "message": "Unauthorized"}), 401
        
        data = request.json
        verification_token = data.get('token')
        
        if not verification_token:
            return jsonify({"success": False, "message": "Verification token required"}), 400
        
        success, message = auth_manager.enable_totp(username, verification_token)
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/totp/disable', methods=['POST'])
def totp_disable():
    """Disable TOTP (requires password confirmation)"""
    try:
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        username = auth_manager.verify_token(token)
        
        if not username:
            return jsonify({"success": False, "message": "Unauthorized"}), 401
        
        data = request.json
        password = data.get('password')
        
        if not password:
            return jsonify({"success": False, "message": "Password required"}), 400
        
        success, message = auth_manager.disable_totp(username, password)
        
        if success:
            return jsonify({"success": True, "message": message})
        else:
            return jsonify({"success": False, "message": message}), 400
    except Exception as e:
        return jsonify({"success": False, "message": str(e)}), 500


@auth_bp.route('/api/auth/generate-api-token', methods=['POST'])
def generate_api_token():
    """Generate a long-lived API token for external integrations (Homepage, Home Assistant, etc.)"""
    try:
        auth_header = request.headers.get('Authorization', '')
        token = auth_header.replace('Bearer ', '')
        
        if not token:
            return jsonify({"success": False, "message": "Unauthorized. Please log in first."}), 401
        
        username = auth_manager.verify_token(token)
        
        if not username:
            return jsonify({"success": False, "message": "Invalid or expired session. Please log in again."}), 401
        
        data = request.json
        password = data.get('password')
        totp_token = data.get('totp_token')  # Optional 2FA token
        token_name = data.get('token_name', 'API Token')  # Optional token description
        
        if not password:
            return jsonify({"success": False, "message": "Password is required"}), 400
        
        # Authenticate user with password and optional 2FA
        success, _, requires_totp, message = auth_manager.authenticate(username, password, totp_token)
        
        if success:
            # Generate a long-lived token (1 year expiration)
            api_token = jwt.encode({
                'username': username,
                'token_name': token_name,
                'exp': datetime.datetime.utcnow() + datetime.timedelta(days=365),
                'iat': datetime.datetime.utcnow()
            }, auth_manager.JWT_SECRET, algorithm='HS256')
            
            return jsonify({
                "success": True, 
                "token": api_token,
                "token_name": token_name,
                "expires_in": "365 days",
                "message": "API token generated successfully. Store this token securely, it will not be shown again."
            })
        elif requires_totp:
            return jsonify({"success": False, "requires_totp": True, "message": message}), 200
        else:
            return jsonify({"success": False, "message": message}), 401
    except Exception as e:
        print(f"[ERROR] generate_api_token: {str(e)}")  # Log error for debugging
        return jsonify({"success": False, "message": f"Internal error: {str(e)}"}), 500



================================================
FILE: AppImage/scripts/flask_health_routes.py
================================================
"""
Flask routes for health monitoring with persistence support
"""

from flask import Blueprint, jsonify, request
from health_monitor import health_monitor
from health_persistence import health_persistence

health_bp = Blueprint('health', __name__)

@health_bp.route('/api/health/status', methods=['GET'])
def get_health_status():
    """Get overall health status summary"""
    try:
        status = health_monitor.get_overall_status()
        return jsonify(status)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@health_bp.route('/api/health/details', methods=['GET'])
def get_health_details():
    """Get detailed health status with all checks"""
    try:
        details = health_monitor.get_detailed_status()
        return jsonify(details)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@health_bp.route('/api/system-info', methods=['GET'])
def get_system_info():
    """
    Get lightweight system info for header display.
    Returns: hostname, uptime, and health status with proper structure.
    """
    try:
        info = health_monitor.get_system_info()
        
        if 'health' in info:
            status_map = {
                'OK': 'healthy',
                'WARNING': 'warning',
                'CRITICAL': 'critical',
                'UNKNOWN': 'warning'
            }
            current_status = info['health'].get('status', 'OK').upper()
            info['health']['status'] = status_map.get(current_status, 'healthy')
        
        return jsonify(info)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@health_bp.route('/api/health/acknowledge', methods=['POST'])
def acknowledge_error():
    """Acknowledge an error manually (user dismissed it)"""
    try:
        data = request.get_json()
        if not data or 'error_key' not in data:
            return jsonify({'error': 'error_key is required'}), 400
        
        error_key = data['error_key']
        health_persistence.acknowledge_error(error_key)
        return jsonify({'success': True, 'message': 'Error acknowledged'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@health_bp.route('/api/health/active-errors', methods=['GET'])
def get_active_errors():
    """Get all active persistent errors"""
    try:
        category = request.args.get('category')
        errors = health_persistence.get_active_errors(category)
        return jsonify({'errors': errors})
    except Exception as e:
        return jsonify({'error': str(e)}), 500



================================================
FILE: AppImage/scripts/flask_proxmenux_routes.py
================================================
from flask import Blueprint, jsonify
import json
import os

proxmenux_bp = Blueprint('proxmenux', __name__)

# Tool descriptions mapping
TOOL_DESCRIPTIONS = {
    'lvm_repair': 'LVM PV Headers Repair',
    'repo_cleanup': 'Repository Cleanup',
    'subscription_banner': 'Subscription Banner Removal',
    'time_sync': 'Time Synchronization',
    'apt_languages': 'APT Language Skip',
    'journald': 'Journald Optimization',
    'logrotate': 'Logrotate Optimization',
    'system_limits': 'System Limits Increase',
    'entropy': 'Entropy Generation (haveged)',
    'memory_settings': 'Memory Settings Optimization',
    'kernel_panic': 'Kernel Panic Configuration',
    'apt_ipv4': 'APT IPv4 Force',
    'kexec': 'kexec for quick reboots',
    'network_optimization': 'Network Optimizations',
    'bashrc_custom': 'Bashrc Customization',
    'figurine': 'Figurine',
    'fastfetch': 'Fastfetch',
    'log2ram': 'Log2ram (SSD Protection)',
    'amd_fixes': 'AMD CPU (Ryzen/EPYC) fixes',
    'persistent_network': 'Setting persistent network interfaces'
}

@proxmenux_bp.route('/api/proxmenux/installed-tools', methods=['GET'])
def get_installed_tools():
    """Get list of installed ProxMenux tools/optimizations"""
    installed_tools_path = '/usr/local/share/proxmenux/installed_tools.json'
    
    try:
        if not os.path.exists(installed_tools_path):
            return jsonify({
                'success': True,
                'installed_tools': [],
                'message': 'No ProxMenux optimizations installed yet'
            })
        
        with open(installed_tools_path, 'r') as f:
            data = json.load(f)
        
        # Convert to list format with descriptions
        tools = []
        for tool_key, enabled in data.items():
            if enabled:  # Only include enabled tools
                tools.append({
                    'key': tool_key,
                    'name': TOOL_DESCRIPTIONS.get(tool_key, tool_key.replace('_', ' ').title()),
                    'enabled': enabled
                })
        
        # Sort alphabetically by name
        tools.sort(key=lambda x: x['name'])
        
        return jsonify({
            'success': True,
            'installed_tools': tools,
            'total_count': len(tools)
        })
    
    except json.JSONDecodeError:
        return jsonify({
            'success': False,
            'error': 'Invalid JSON format in installed_tools.json'
        }), 500
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500



================================================
FILE: AppImage/scripts/flask_script_runner.py
================================================
#!/usr/bin/env python3
"""
Script Runner System for ProxMenux
Executes bash scripts and provides real-time log streaming with interactive menu support
"""

import os
import sys
import json
import subprocess
import threading
import time
from datetime import datetime
from pathlib import Path
import uuid

class ScriptRunner:
    """Manages script execution with real-time log streaming and menu interactions"""
    
    def __init__(self):
        self.active_sessions = {}
        self.log_dir = Path("/var/log/proxmenux/scripts")
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.interaction_handlers = {}
    
    def create_session(self, script_name):
        """Create a new script execution session"""
        session_id = str(uuid.uuid4())[:8]
        log_file = self.log_dir / f"{script_name}_{session_id}_{int(time.time())}.log"
        
        self.active_sessions[session_id] = {
            'script_name': script_name,
            'log_file': str(log_file),
            'start_time': datetime.now().isoformat(),
            'status': 'initializing',
            'process': None,
            'exit_code': None,
            'pending_interaction': None
        }
        
        return session_id
    
    def execute_script(self, script_path, session_id, env_vars=None):
        """Execute a script in web mode with logging"""
        if session_id not in self.active_sessions:
            return {'success': False, 'error': 'Invalid session ID'}
        
        session = self.active_sessions[session_id]
        log_file = session['log_file']
        
        print(f"[DEBUG] execute_script called for session {session_id}", file=sys.stderr, flush=True)
        print(f"[DEBUG] Script path: {script_path}", file=sys.stderr, flush=True)
        print(f"[DEBUG] Log file: {log_file}", file=sys.stderr, flush=True)
        
        # Prepare environment
        env = os.environ.copy()
        env['EXECUTION_MODE'] = 'web'
        env['LOG_FILE'] = log_file
        
        if env_vars:
            env.update(env_vars)
        
        print(f"[DEBUG] Environment variables set: EXECUTION_MODE=web, LOG_FILE={log_file}", file=sys.stderr, flush=True)
        
        # Initialize log file
        with open(log_file, 'w') as f:
            init_line = json.dumps({
                'type': 'init',
                'session_id': session_id,
                'script': script_path,
                'timestamp': int(time.time())
            }) + '\n'
            f.write(init_line)
            print(f"[DEBUG] Wrote init line to log: {init_line.strip()}", file=sys.stderr, flush=True)
        
        try:
            # Execute script
            session['status'] = 'running'
            print(f"[DEBUG] Starting subprocess with /bin/bash {script_path}", file=sys.stderr, flush=True)
            
            process = subprocess.Popen(
                ['/bin/bash', script_path],
                env=env,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                bufsize=0  # Unbuffered
            )
            
            print(f"[DEBUG] Process started with PID: {process.pid}", file=sys.stderr, flush=True)
            session['process'] = process
            
            lines_read = [0]  # Lista para compartir entre threads
            
            def monitor_output():
                print(f"[DEBUG] monitor_output thread started for session {session_id}", file=sys.stderr, flush=True)
                print(f"[DEBUG] Will monitor log file: {log_file}", file=sys.stderr, flush=True)
                
                try:
                    # Read log file in real-time (similar to tail -f)
                    last_position = 0
                    
                    # Wait a moment for script to start writing
                    time.sleep(0.5)
                    
                    while process.poll() is None or last_position < os.path.getsize(log_file):
                        try:
                            if os.path.exists(log_file):
                                with open(log_file, 'r') as log_f:
                                    log_f.seek(last_position)
                                    new_lines = log_f.readlines()
                                    
                                    for line in new_lines:
                                        decoded_line = line.rstrip()
                                        if decoded_line:  # Skip empty lines
                                            lines_read[0] += 1
                                            print(f"[DEBUG] Read line {lines_read[0]} from log: {decoded_line[:100]}...", file=sys.stderr, flush=True)
                                            
                                            # Check for interaction requests in the line
                                            if 'WEB_INTERACTION:' in decoded_line:
                                                print(f"[DEBUG] Detected WEB_INTERACTION line: {decoded_line}", file=sys.stderr, flush=True)
                                                session['pending_interaction'] = decoded_line
                                    
                                    last_position = log_f.tell()
                        
                        except Exception as e:
                            print(f"[DEBUG ERROR] Error reading log file: {e}", file=sys.stderr, flush=True)
                        
                        time.sleep(0.1)  # Poll every 100ms
                    
                    print(f"[DEBUG] monitor_output thread finished. Total lines read: {lines_read[0]}", file=sys.stderr, flush=True)
                    
                except Exception as e:
                    print(f"[DEBUG ERROR] Exception in monitor_output: {e}", file=sys.stderr, flush=True)
            
            monitor_thread = threading.Thread(target=monitor_output, daemon=False)
            monitor_thread.start()
            
            print(f"[DEBUG] Waiting for process to complete...", file=sys.stderr, flush=True)
            
            # Wait for completion
            process.wait()
            print(f"[DEBUG] Process exited with code: {process.returncode}", file=sys.stderr, flush=True)
            
            monitor_thread.join(timeout=30)
            if monitor_thread.is_alive():
                print(f"[DEBUG WARNING] monitor_thread still alive after 30s timeout", file=sys.stderr, flush=True)
            else:
                print(f"[DEBUG] monitor_thread joined successfully", file=sys.stderr, flush=True)
            
            session['exit_code'] = process.returncode
            session['status'] = 'completed' if process.returncode == 0 else 'failed'
            session['end_time'] = datetime.now().isoformat()
            
            print(f"[DEBUG] Script execution completed. Lines captured: {lines_read[0]}", file=sys.stderr, flush=True)
            
            return {
                'success': True,
                'session_id': session_id,
                'exit_code': process.returncode,
                'log_file': log_file
            }
            
        except Exception as e:
            print(f"[DEBUG ERROR] Exception in execute_script: {e}", file=sys.stderr, flush=True)
            session['status'] = 'error'
            session['error'] = str(e)
            return {
                'success': False,
                'error': str(e)
            }
    
    def get_session_status(self, session_id):
        """Get current status of a script execution session"""
        if session_id not in self.active_sessions:
            return {'success': False, 'error': 'Session not found'}
        
        session = self.active_sessions[session_id]
        return {
            'success': True,
            'session_id': session_id,
            'status': session['status'],
            'start_time': session['start_time'],
            'script_name': session['script_name'],
            'exit_code': session['exit_code'],
            'pending_interaction': session.get('pending_interaction')
        }
    
    def respond_to_interaction(self, session_id, interaction_id, value):
        """Respond to a script interaction request"""
        if session_id not in self.active_sessions:
            return {'success': False, 'error': 'Session not found'}
        
        session = self.active_sessions[session_id]
        
        # Write response to file that script is waiting for
        response_file = f"/tmp/nvidia_response_{interaction_id}.json"
        with open(response_file, 'w') as f:
            json.dump({
                'interaction_id': interaction_id,
                'value': value,
                'timestamp': int(time.time())
            }, f)
        
        # Clear pending interaction
        session['pending_interaction'] = None
        
        return {'success': True}
    
    def stream_logs(self, session_id):
        """Generator that yields log entries as they are written"""
        if session_id not in self.active_sessions:
            yield json.dumps({'type': 'error', 'message': 'Invalid session ID'})
            return
        
        session = self.active_sessions[session_id]
        log_file = session['log_file']
        
        # Wait for log file to be created
        timeout = 10
        start = time.time()
        while not os.path.exists(log_file) and (time.time() - start) < timeout:
            time.sleep(0.1)
        
        if not os.path.exists(log_file):
            yield json.dumps({'type': 'error', 'message': 'Log file not created'})
            return
        
        # Stream log file
        with open(log_file, 'r') as f:
            # Start from beginning
            f.seek(0)
            
            while session['status'] in ['initializing', 'running']:
                line = f.readline()
                if line:
                    # Try to parse as JSON, yield as-is if not JSON
                    try:
                        log_entry = json.loads(line.strip())
                        yield json.dumps(log_entry)
                    except json.JSONDecodeError:
                        yield json.dumps({'type': 'raw', 'message': line.strip()})
                else:
                    time.sleep(0.1)
            
            # Read any remaining lines after completion
            for line in f:
                try:
                    log_entry = json.loads(line.strip())
                    yield json.dumps(log_entry)
                except json.JSONDecodeError:
                    yield json.dumps({'type': 'raw', 'message': line.strip()})
    
    def cleanup_session(self, session_id):
        """Clean up a completed session"""
        if session_id in self.active_sessions:
            del self.active_sessions[session_id]
            return {'success': True}
        return {'success': False, 'error': 'Session not found'}

# Global instance
script_runner = ScriptRunner()



================================================
FILE: AppImage/scripts/flask_terminal_routes.py
================================================
#!/usr/bin/env python3
"""
ProxMenux Terminal WebSocket Routes
Provides a WebSocket endpoint for interactive terminal sessions
"""

from flask import Blueprint, jsonify, request
from flask_sock import Sock
import subprocess
import os
import pty
import select
import struct
import fcntl
import termios
import threading
import time
import requests
import json
import tempfile
import base64

terminal_bp = Blueprint('terminal', __name__)
sock = Sock()

# Active terminal sessions
active_sessions = {}

@terminal_bp.route('/api/terminal/health', methods=['GET'])
def terminal_health():
    """Health check for terminal service"""
    return {'success': True, 'active_sessions': len(active_sessions)}

@terminal_bp.route('/api/terminal/search-command', methods=['GET'])
def search_command():
    """Proxy endpoint for cheat.sh API to avoid CORS issues"""
    query = request.args.get('q', '')
    
    if not query or len(query) < 2:
        return jsonify({'error': 'Query too short'}), 400
    
    try:
        url = f'https://cht.sh/{query.replace(" ", "+")}?QT'
        headers = {
            'User-Agent': 'curl/7.68.0'
        }
        
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            content = response.text
            examples = []
            current_description = []
            
            for line in content.split('\n'):
                stripped = line.strip()
                
                # Ignorar lÃ­neas vacÃ­as
                if not stripped:
                    continue
                
                # Si es un comentario
                if stripped.startswith('#'):
                    # Acumular descripciones
                    current_description.append(stripped[1:].strip())
                # Si no es comentario, es un comando
                elif stripped and not stripped.startswith('http'):
                    # Unir las descripciones acumuladas
                    description = ' '.join(current_description) if current_description else ''
                    
                    examples.append({
                        'description': description,
                        'command': stripped
                    })
                    
                    # Resetear descripciones para el siguiente comando
                    current_description = []
            
            return jsonify({
                'success': True,
                'examples': examples
            })
        else:
            return jsonify({
                'success': False,
                'error': f'API returned status {response.status_code}'
            }), response.status_code
            
    except requests.Timeout:
        return jsonify({
            'success': False,
            'error': 'Request timeout'
        }), 504
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

def set_winsize(fd, rows, cols):
    """Set terminal window size"""
    try:
        winsize = struct.pack('HHHH', rows, cols, 0, 0)
        fcntl.ioctl(fd, termios.TIOCSWINSZ, winsize)
    except Exception as e:
        print(f"Error setting window size: {e}")

def read_and_forward_output(master_fd, ws):
    """Read from PTY and send to WebSocket"""
    while True:
        try:
            # Use select with timeout to check if data is available
            r, _, _ = select.select([master_fd], [], [], 0.01)
            if master_fd in r:
                try:
                    data = os.read(master_fd, 4096)
                    if data:
                        ws.send(data.decode('utf-8', errors='ignore'))
                    else:
                        break
                except OSError:
                    break
        except Exception as e:
            print(f"Error reading from PTY: {e}")
            break

@sock.route('/ws/terminal')
def terminal_websocket(ws):
    """WebSocket endpoint for terminal sessions"""
    
    # Create pseudo-terminal
    master_fd, slave_fd = pty.openpty()
    
    # Start bash process
    shell_process = subprocess.Popen(
        ['/bin/bash', '-i'],
        stdin=slave_fd,
        stdout=slave_fd,
        stderr=slave_fd,
        preexec_fn=os.setsid,
        cwd='/',
        env=dict(os.environ, TERM='xterm-256color', PS1='\\u@\\h:\\w\\$ ')
    )
    
    session_id = id(ws)
    active_sessions[session_id] = {
        'process': shell_process,
        'master_fd': master_fd
    }
    
    # Set non-blocking mode for master_fd
    flags = fcntl.fcntl(master_fd, fcntl.F_GETFL)
    fcntl.fcntl(master_fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    
    # Set initial terminal size
    set_winsize(master_fd, 30, 120)
    
    # Start thread to read PTY output and forward to WebSocket
    output_thread = threading.Thread(
        target=read_and_forward_output,
        args=(master_fd, ws),
        daemon=True
    )
    output_thread.start()
    
    try:
        while True:
            # Receive data from WebSocket (blocking)
            data = ws.receive(timeout=None)
            
            if data is None:
                # Client closed connection
                break

            handled = False

            # Try to handle JSON control messages (e.g. resize)
            if isinstance(data, str):
                try:
                    msg = json.loads(data)
                except Exception:
                    msg = None

                if isinstance(msg, dict) and msg.get('type') == 'resize':
                    cols = int(msg.get('cols', 120))
                    rows = int(msg.get('rows', 30))
                    set_winsize(master_fd, rows, cols)
                    handled = True

            if handled:
                # Control message processed, do not send to bash
                continue

            # Optional: legacy resize escape sequence support
            if isinstance(data, str) and data.startswith('\x1b[8;'):
                try:
                    parts = data[4:-1].split(';')
                    rows, cols = int(parts[0]), int(parts[1])
                    set_winsize(master_fd, rows, cols)
                    continue
                except Exception:
                    pass
            
            # Send input to bash
            try:
                os.write(master_fd, data.encode('utf-8'))
            except OSError as e:
                print(f"Error writing to PTY: {e}")
                break
            
            # Check if process is still alive
            if shell_process.poll() is not None:
                break
                
    except Exception as e:
        print(f"Terminal session error: {e}")
    finally:
        # Cleanup
        try:
            shell_process.terminate()
            shell_process.wait(timeout=1)
        except:
            try:
                shell_process.kill()
            except:
                pass
        
        try:
            os.close(master_fd)
        except:
            pass
        
        try:
            os.close(slave_fd)
        except:
            pass
        
        if session_id in active_sessions:
            del active_sessions[session_id]

@sock.route('/ws/script/<session_id>')
def script_websocket(ws, session_id):
    """WebSocket endpoint for executing scripts with hybrid web mode"""
    
    try:
        init_data = ws.receive(timeout=10)
        
        if not init_data:
            error_msg = '{"type": "error", "message": "No script data received"}\r\n'
            ws.send(error_msg)
            return
            
        script_data = json.loads(init_data)
        
        script_path = script_data.get('script_path')
        params = script_data.get('params', {})
        
        if not script_path:
            error_msg = '{"type": "error", "message": "No script_path provided"}\r\n'
            ws.send(error_msg)
            return
        
        if not os.path.exists(script_path):
            error_msg = f'{{"type": "error", "message": "Script not found: {script_path}"}}\r\n'
            ws.send(error_msg)
            return
            
    except Exception as e:
        error_msg = f'{{"type": "error", "message": "Invalid init data: {str(e)}"}}\r\n'
        ws.send(error_msg)
        return
    
    web_log_fd, web_log_path = tempfile.mkstemp(suffix='.log', prefix='proxmenux_web_')
    
    # Create pseudo-terminal for script execution
    master_fd, slave_fd = pty.openpty()
    
    env = os.environ.copy()
    env['EXECUTION_MODE'] = 'web'
    env['WEB_LOG'] = web_log_path
    for key, value in params.items():
        env[key] = str(value)
    env['PYTHONUNBUFFERED'] = '1'
    env['TERM'] = 'xterm-256color'
    
    script_process = subprocess.Popen(
        ['/bin/bash', script_path],
        stdin=slave_fd,
        stdout=slave_fd,
        stderr=slave_fd,
        preexec_fn=os.setsid,
        env=env
    )
    
    # Set non-blocking mode for master_fd
    flags = fcntl.fcntl(master_fd, fcntl.F_GETFL)
    fcntl.fcntl(master_fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)
    
    # Set terminal size
    set_winsize(master_fd, 30, 120)
    
    def monitor_web_log():
        last_position = 0
        
        while script_process.poll() is None:
            try:
                if os.path.exists(web_log_path):
                    with open(web_log_path, 'r') as f:
                        f.seek(last_position)
                        new_lines = f.readlines()
                        last_position = f.tell()
                        
                        for line in new_lines:
                            line = line.strip()
                            if line.startswith('WEB_INTERACTION:'):
                                try:
                                    # Parse: WEB_INTERACTION:type:id:title_b64:message_b64[:options_json]
                                    parts = line[16:].split(':', 4)
                                    interaction_type = parts[0]
                                    interaction_id = parts[1]
                                    title_b64 = parts[2]
                                    message_b64 = parts[3]
                                    
                                    title = base64.b64decode(title_b64).decode('utf-8')
                                    message = base64.b64decode(message_b64).decode('utf-8')
                                    
                                    interaction_data = {
                                        'type': 'web_interaction',
                                        'interaction': {
                                            'type': interaction_type,
                                            'id': interaction_id,
                                            'title': title,
                                            'message': message
                                        }
                                    }
                                    
                                    # Parse options for menu
                                    if interaction_type == 'menu' and len(parts) > 4:
                                        options_json = parts[4]
                                        interaction_data['interaction']['options'] = json.loads(options_json)
                                    
                                    # Parse default for inputbox
                                    if interaction_type == 'inputbox' and len(parts) > 4:
                                        default_b64 = parts[4]
                                        interaction_data['interaction']['default'] = base64.b64decode(default_b64).decode('utf-8')
                                    
                                    # Send interaction to WebSocket
                                    ws.send(json.dumps(interaction_data))
                                    
                                except Exception as e:
                                    pass
                
                time.sleep(0.01)
            except Exception as e:
                break
    
    web_log_thread = threading.Thread(target=monitor_web_log, daemon=True)
    web_log_thread.start()
    
    # Thread to read script output and forward to WebSocket
    def read_script_output():
        while True:
            try:
                r, _, _ = select.select([master_fd], [], [], 0.01)
                if master_fd in r:
                    try:
                        data = os.read(master_fd, 4096)
                        if not data:
                            break
                        
                        text = data.decode('utf-8', errors='ignore')
                        
                        # Send raw text to terminal
                        try:
                            ws.send(text)
                        except Exception as e:
                            break
                            
                    except OSError as e:
                        break
            except Exception as e:
                break
        
        script_process.wait()
        exit_code = script_process.returncode if script_process.returncode is not None else 0
        
        try:
            ws.send(f'\r\n[Script exited with code {exit_code}]\r\n')
        except Exception as e:
            pass
    
    output_thread = threading.Thread(target=read_script_output, daemon=True)
    output_thread.start()
    
    try:
        while True:
            data = ws.receive(timeout=None)
            
            if data is None:
                break
            
            try:
                msg = json.loads(data)
                
                if msg.get('type') == 'interaction_response':
                    interaction_id = msg.get('id')
                    value = msg.get('value')
                    
                    # Write response to the file the script is waiting for
                    response_file = f"/tmp/proxmenux_response_{interaction_id}"
                    
                    with open(response_file, 'w') as f:
                        f.write(value)
                    
                    continue
                
                # Handle resize
                if msg.get('type') == 'resize':
                    cols = int(msg.get('cols', 120))
                    rows = int(msg.get('rows', 30))
                    set_winsize(master_fd, rows, cols)
                    continue
                    
            except json.JSONDecodeError:
                # Raw text input, send to script
                try:
                    os.write(master_fd, data.encode('utf-8'))
                except OSError as e:
                    break
            
            if script_process.poll() is not None:
                break
                
    except Exception as e:
        pass
    finally:
        try:
            script_process.terminate()
            script_process.wait(timeout=1)
        except:
            try:
                script_process.kill()
            except:
                pass
        
        try:
            os.close(master_fd)
        except:
            pass
        
        try:
            os.close(slave_fd)
        except:
            pass
        
        try:
            os.close(web_log_fd)
            os.unlink(web_log_path)
        except:
            pass

def init_terminal_routes(app):
    """Initialize terminal routes with Flask app"""
    sock.init_app(app)
    app.register_blueprint(terminal_bp)



================================================
FILE: AppImage/scripts/hardware_monitor.py
================================================
#!/usr/bin/env python3
"""
Hardware Monitor - RAPL Power Monitoring and GPU Identification

This module provides:
1. CPU power consumption monitoring using Intel RAPL (Running Average Power Limit)
2. PCI GPU identification for better fan labeling
3. HBA controller detection and temperature monitoring

Only contains these specialized functions - all other hardware monitoring 
is handled by flask_server.py to avoid code duplication.
"""

import os
import time
import subprocess
import re
from typing import Dict, Any, Optional

# Global variable to store previous energy reading for power calculation
_last_energy_reading = {'energy_uj': None, 'timestamp': None}


def get_pci_gpu_map() -> Dict[str, Dict[str, str]]:
    """
    Get a mapping of PCI addresses to GPU names from lspci.
    
    This function parses lspci output to identify GPU models by their PCI addresses,
    which allows us to provide meaningful names for GPU fans in sensors output.
    
    Returns:
        dict: Mapping of PCI addresses (e.g., '02:00.0') to GPU info
              Example: {
                  '02:00.0': {
                      'vendor': 'NVIDIA', 
                      'name': 'GeForce GTX 1080',
                      'full_name': 'NVIDIA Corporation GP104 [GeForce GTX 1080]'
                  }
              }
    """
    gpu_map = {}
    
    try:
        # Run lspci to get VGA/3D/Display controllers
        result = subprocess.run(
            ['lspci', '-nn'],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0:
            for line in result.stdout.split('\n'):
                if 'VGA compatible controller' in line or '3D controller' in line or 'Display controller' in line:
                    # Example line: "02:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP104 [GeForce GTX 1080] [10de:1b80]"
                    match = re.match(r'^([0-9a-f]{2}:[0-9a-f]{2}\.[0-9a-f])\s+.*:\s+(.+?)\s+\[([0-9a-f]{4}):([0-9a-f]{4})\]', line)
                    
                    if match:
                        pci_address = match.group(1)
                        device_name = match.group(2).strip()
                        
                        # Extract vendor
                        vendor = None
                        if 'NVIDIA' in device_name.upper() or 'GEFORCE' in device_name.upper() or 'QUADRO' in device_name.upper():
                            vendor = 'NVIDIA'
                        elif 'AMD' in device_name.upper() or 'RADEON' in device_name.upper():
                            vendor = 'AMD'
                        elif 'INTEL' in device_name.upper() or 'ARC' in device_name.upper():
                            vendor = 'Intel'
                        
                        # Extract model name (text between brackets is usually the commercial name)
                        bracket_match = re.search(r'\[([^\]]+)\]', device_name)
                        if bracket_match:
                            model_name = bracket_match.group(1)
                        else:
                            # Fallback: use everything after the vendor name
                            if vendor:
                                model_name = device_name.split(vendor)[-1].strip()
                            else:
                                model_name = device_name
                        
                        gpu_map[pci_address] = {
                            'vendor': vendor if vendor else 'Unknown',
                            'name': model_name,
                            'full_name': device_name
                        }
    
    except Exception:
        pass
    
    return gpu_map


def get_power_info() -> Optional[Dict[str, Any]]:
    """
    Get CPU power consumption using Intel RAPL interface.
    
    This function measures power consumption by reading energy counters
    from /sys/class/powercap/intel-rapl interfaces and calculating
    the power draw based on the change in energy over time.
    
    Used as fallback when IPMI power monitoring is not available.
    
    Returns:
        dict: Power meter information with 'name', 'watts', and 'adapter' keys
              or None if RAPL interface is unavailable
              
    Example:
        {
            'name': 'CPU Power',
            'watts': 45.32,
            'adapter': 'Intel RAPL (CPU only)'
        }
    """
    global _last_energy_reading
    
    rapl_path = '/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj'
    
    if os.path.exists(rapl_path):
        try:
            # Read current energy value in microjoules
            with open(rapl_path, 'r') as f:
                current_energy_uj = int(f.read().strip())
            current_time = time.time()
            
            watts = 0.0
            
            # Calculate power if we have a previous reading
            if _last_energy_reading['energy_uj'] is not None and _last_energy_reading['timestamp'] is not None:
                time_diff = current_time - _last_energy_reading['timestamp']
                if time_diff > 0:
                    energy_diff = current_energy_uj - _last_energy_reading['energy_uj']
                    # Handle counter overflow (wraps around at max value)
                    if energy_diff < 0:
                        energy_diff = current_energy_uj
                    # Power (W) = Energy (ÂµJ) / time (s) / 1,000,000
                    watts = round((energy_diff / time_diff) / 1000000, 2)
            
            # Store current reading for next calculation
            _last_energy_reading['energy_uj'] = current_energy_uj
            _last_energy_reading['timestamp'] = current_time
            
            # Detect CPU vendor for display purposes
            cpu_vendor = 'CPU'
            try:
                with open('/proc/cpuinfo', 'r') as f:
                    cpuinfo = f.read()
                    if 'GenuineIntel' in cpuinfo:
                        cpu_vendor = 'Intel'
                    elif 'AuthenticAMD' in cpuinfo:
                        cpu_vendor = 'AMD'
            except:
                pass
            
            return {
                'name': 'CPU Power',
                'watts': watts,
                'adapter': f'{cpu_vendor} RAPL (CPU only)'
            }
        except Exception:
            pass
    
    return None


def get_hba_info() -> list[Dict[str, Any]]:
    """
    Detect HBA/RAID controllers from lspci.
    
    This function identifies LSI/Broadcom, Adaptec, and other RAID/HBA controllers
    present in the system via lspci output.
    
    Returns:
        list: List of HBA controller dictionaries
              Example: [
                  {
                      'pci_address': '01:00.0',
                      'vendor': 'LSI/Broadcom',
                      'model': 'SAS3008 PCI-Express Fusion-MPT SAS-3',
                      'controller_id': 0
                  }
              ]
    """
    hba_list = []
    
    try:
        # Run lspci to find RAID/SAS controllers
        result = subprocess.run(
            ['lspci', '-nn'],
            capture_output=True,
            text=True,
            timeout=5
        )
        
        if result.returncode == 0:
            controller_id = 0
            for line in result.stdout.split('\n'):
                # Look for RAID bus controller, SCSI storage controller, Serial Attached SCSI controller
                if any(keyword in line for keyword in ['RAID bus controller', 'SCSI storage controller', 'Serial Attached SCSI']):
                    # Example: "01:00.0 RAID bus controller [0104]: Broadcom / LSI SAS3008 PCI-Express Fusion-MPT SAS-3 [1000:0097]"
                    match = re.match(r'^([0-9a-f]{2}:[0-9a-f]{2}\.[0-9a-f])\s+.*:\s+(.+?)\s+\[([0-9a-f]{4}):([0-9a-f]{4})\]', line)
                    
                    if match:
                        pci_address = match.group(1)
                        device_name = match.group(2).strip()
                        
                        # Extract vendor
                        vendor = 'Unknown'
                        if 'LSI' in device_name.upper() or 'BROADCOM' in device_name.upper() or 'AVAGO' in device_name.upper():
                            vendor = 'LSI/Broadcom'
                        elif 'ADAPTEC' in device_name.upper():
                            vendor = 'Adaptec'
                        elif 'ARECA' in device_name.upper():
                            vendor = 'Areca'
                        elif 'HIGHPOINT' in device_name.upper():
                            vendor = 'HighPoint'
                        elif 'DELL' in device_name.upper():
                            vendor = 'Dell'
                        elif 'HP' in device_name.upper() or 'HEWLETT' in device_name.upper():
                            vendor = 'HP'
                        
                        # Extract model name
                        model_name = device_name
                        # Remove vendor prefix if present
                        for v in ['Broadcom / LSI', 'Broadcom', 'LSI Logic', 'LSI', 'Adaptec', 'Areca', 'HighPoint', 'Dell', 'HP', 'Hewlett-Packard']:
                            if model_name.startswith(v):
                                model_name = model_name[len(v):].strip()
                        
                        hba_list.append({
                            'pci_address': pci_address,
                            'vendor': vendor,
                            'model': model_name,
                            'controller_id': controller_id,
                            'full_name': device_name
                        })
                        controller_id += 1
    
    except Exception:
        pass
    
    return hba_list


def get_hba_temperatures() -> list[Dict[str, Any]]:
    """
    Get HBA controller temperatures using storcli64 or megacli.
    
    This function attempts to read temperature data from LSI/Broadcom RAID controllers
    using the storcli64 tool (preferred) or megacli as fallback.
    
    Returns:
        list: List of temperature dictionaries
              Example: [
                  {
                      'name': 'HBA Controller 0',
                      'temperature': 65,
                      'adapter': 'LSI/Broadcom SAS3008'
                  }
              ]
    """
    temperatures = []
    
    # Check which tool is available
    storcli_paths = [
        '/opt/MegaRAID/storcli/storcli64',
        '/usr/sbin/storcli64',
        '/usr/local/sbin/storcli64',
        'storcli64'
    ]
    
    megacli_paths = [
        '/opt/MegaRAID/MegaCli/MegaCli64',
        '/usr/sbin/megacli',
        '/usr/local/sbin/megacli',
        'megacli'
    ]
    
    storcli_path = None
    megacli_path = None
    
    # Find storcli64
    for path in storcli_paths:
        try:
            result = subprocess.run([path, '-v'], capture_output=True, timeout=2)
            if result.returncode == 0:
                storcli_path = path
                break
        except:
            continue
    
    # Try storcli64 first (preferred)
    if storcli_path:
        try:
            # Get list of controllers
            result = subprocess.run(
                [storcli_path, 'show'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                # Parse controller IDs
                controller_ids = []
                for line in result.stdout.split('\n'):
                    match = re.search(r'^\s*(\d+)\s+', line)
                    if match and 'Ctl' in line:
                        controller_ids.append(match.group(1))
                
                # Get temperature for each controller
                for ctrl_id in controller_ids:
                    try:
                        temp_result = subprocess.run(
                            [storcli_path, f'/c{ctrl_id}', 'show', 'temperature'],
                            capture_output=True,
                            text=True,
                            timeout=10
                        )
                        
                        if temp_result.returncode == 0:
                            # Parse temperature from output
                            for line in temp_result.stdout.split('\n'):
                                if 'ROC temperature' in line or 'Controller Temp' in line:
                                    temp_match = re.search(r'(\d+)\s*C', line)
                                    if temp_match:
                                        temp_c = int(temp_match.group(1))
                                        
                                        # Get HBA info for better naming
                                        hba_list = get_hba_info()
                                        adapter_name = 'LSI/Broadcom Controller'
                                        if int(ctrl_id) < len(hba_list):
                                            hba = hba_list[int(ctrl_id)]
                                            adapter_name = f"{hba['vendor']} {hba['model']}"
                                        
                                        temperatures.append({
                                            'name': f'HBA Controller {ctrl_id}',
                                            'temperature': temp_c,
                                            'adapter': adapter_name
                                        })
                                        break
                    except:
                        continue
        except:
            pass
    
    # Fallback to megacli if storcli not available
    elif not temperatures:
        for path in megacli_paths:
            try:
                result = subprocess.run([path, '-v'], capture_output=True, timeout=2)
                if result.returncode == 0:
                    megacli_path = path
                    break
            except:
                continue
        
        if megacli_path:
            try:
                # Get adapter count
                result = subprocess.run(
                    [megacli_path, '-adpCount'],
                    capture_output=True,
                    text=True,
                    timeout=10
                )
                
                if result.returncode == 0:
                    # Parse adapter count
                    adapter_count = 0
                    for line in result.stdout.split('\n'):
                        if 'Controller Count' in line:
                            count_match = re.search(r'(\d+)', line)
                            if count_match:
                                adapter_count = int(count_match.group(1))
                                break
                    
                    # Get temperature for each adapter
                    for adapter_id in range(adapter_count):
                        try:
                            temp_result = subprocess.run(
                                [megacli_path, '-AdpAllInfo', f'-a{adapter_id}'],
                                capture_output=True,
                                text=True,
                                timeout=10
                            )
                            
                            if temp_result.returncode == 0:
                                # Parse temperature
                                for line in temp_result.stdout.split('\n'):
                                    if 'ROC temperature' in line or 'Controller Temp' in line:
                                        temp_match = re.search(r'(\d+)\s*C', line)
                                        if temp_match:
                                            temp_c = int(temp_match.group(1))
                                            
                                            # Get HBA info for better naming
                                            hba_list = get_hba_info()
                                            adapter_name = 'LSI/Broadcom Controller'
                                            if adapter_id < len(hba_list):
                                                hba = hba_list[adapter_id]
                                                adapter_name = f"{hba['vendor']} {hba['model']}"
                                            
                                            temperatures.append({
                                                'name': f'HBA Controller {adapter_id}',
                                                'temperature': temp_c,
                                                'adapter': adapter_name
                                            })
                                            break
                        except:
                            continue
            except:
                pass
    
    return temperatures



================================================
FILE: AppImage/scripts/health_persistence.py
================================================
"""
Health Monitor Persistence Module
Manages persistent error tracking across AppImage updates using SQLite.
Stores errors in /root/.config/proxmenux-monitor/health_monitor.db

Features:
- Persistent error storage (survives AppImage updates)
- Smart error resolution (auto-clear when VM starts, or after 48h)
- Event system for future Telegram notifications
- Manual acknowledgment support

Author: MacRimi
Version: 1.0
"""

import sqlite3
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path

class HealthPersistence:
    """Manages persistent health error tracking"""
    
    # Error retention periods (seconds)
    VM_ERROR_RETENTION = 48 * 3600  # 48 hours
    LOG_ERROR_RETENTION = 24 * 3600  # 24 hours
    DISK_ERROR_RETENTION = 48 * 3600  # 48 hours
    UPDATES_SUPPRESSION = 180 * 24 * 3600  # 180 days (6 months)
    
    def __init__(self):
        """Initialize persistence with database in config directory"""
        self.data_dir = Path('/root/.config/proxmenux-monitor')
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        self.db_path = self.data_dir / 'health_monitor.db'
        self._init_database()
    
    def _init_database(self):
        """Initialize SQLite database with required tables"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        # Errors table
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS errors (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                error_key TEXT UNIQUE NOT NULL,
                category TEXT NOT NULL,
                severity TEXT NOT NULL,
                reason TEXT NOT NULL,
                details TEXT,
                first_seen TEXT NOT NULL,
                last_seen TEXT NOT NULL,
                resolved_at TEXT,
                acknowledged INTEGER DEFAULT 0,
                notification_sent INTEGER DEFAULT 0
            )
        ''')
        
        # Events table (for future Telegram notifications)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS events (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                event_type TEXT NOT NULL,
                error_key TEXT NOT NULL,
                timestamp TEXT NOT NULL,
                data TEXT
            )
        ''')
        
        # Indexes for performance
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_error_key ON errors(error_key)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_category ON errors(category)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_resolved ON errors(resolved_at)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_events_error ON events(error_key)')
        
        conn.commit()
        conn.close()
    
    def record_error(self, error_key: str, category: str, severity: str, 
                    reason: str, details: Optional[Dict] = None) -> Dict[str, Any]:
        """
        Record or update an error.
        Returns event info (new_error, updated, etc.)
        """
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        now = datetime.now().isoformat()
        details_json = json.dumps(details) if details else None
        
        cursor.execute('''
            SELECT acknowledged, resolved_at 
            FROM errors 
            WHERE error_key = ? AND acknowledged = 1
        ''', (error_key,))
        ack_check = cursor.fetchone()
        
        if ack_check and ack_check[1]:  # Has resolved_at timestamp
            try:
                resolved_dt = datetime.fromisoformat(ack_check[1])
                hours_since_ack = (datetime.now() - resolved_dt).total_seconds() / 3600
                
                if category == 'updates':
                    # Updates: suppress for 180 days (6 months)
                    suppression_hours = self.UPDATES_SUPPRESSION / 3600
                else:
                    # Other errors: suppress for 24 hours
                    suppression_hours = 24
                
                if hours_since_ack < suppression_hours:
                    # Skip re-adding recently acknowledged errors
                    conn.close()
                    return {'type': 'skipped_acknowledged', 'needs_notification': False}
            except Exception:
                pass
        
        cursor.execute('''
            SELECT id, first_seen, notification_sent, acknowledged, resolved_at 
            FROM errors WHERE error_key = ?
        ''', (error_key,))
        existing = cursor.fetchone()
        
        event_info = {'type': 'updated', 'needs_notification': False}
        
        if existing:
            error_id, first_seen, notif_sent, acknowledged, resolved_at = existing
            
            if acknowledged == 1:
                conn.close()
                return {'type': 'skipped_acknowledged', 'needs_notification': False}
            
            # Update existing error (only if NOT acknowledged)
            cursor.execute('''
                UPDATE errors 
                SET last_seen = ?, severity = ?, reason = ?, details = ?
                WHERE error_key = ? AND acknowledged = 0
            ''', (now, severity, reason, details_json, error_key))
            
            # Check if severity escalated
            cursor.execute('SELECT severity FROM errors WHERE error_key = ?', (error_key,))
            old_severity_row = cursor.fetchone()
            if old_severity_row:
                old_severity = old_severity_row[0]
                if old_severity == 'WARNING' and severity == 'CRITICAL':
                    event_info['type'] = 'escalated'
                    event_info['needs_notification'] = True
        else:
            # Insert new error
            cursor.execute('''
                INSERT INTO errors 
                (error_key, category, severity, reason, details, first_seen, last_seen)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (error_key, category, severity, reason, details_json, now, now))
            
            event_info['type'] = 'new'
            event_info['needs_notification'] = True
        
        # Record event
        self._record_event(cursor, event_info['type'], error_key, 
                          {'severity': severity, 'reason': reason})
        
        conn.commit()
        conn.close()
        
        return event_info
    
    def resolve_error(self, error_key: str, reason: str = 'auto-resolved'):
        """Mark an error as resolved"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        now = datetime.now().isoformat()
        
        cursor.execute('''
            UPDATE errors 
            SET resolved_at = ?
            WHERE error_key = ? AND resolved_at IS NULL
        ''', (now, error_key))
        
        if cursor.rowcount > 0:
            self._record_event(cursor, 'resolved', error_key, {'reason': reason})
        
        conn.commit()
        conn.close()
    
    def acknowledge_error(self, error_key: str):
        """
        Manually acknowledge an error (won't notify again or re-appear for 24h).
        Also marks as resolved so it disappears from active errors.
        """
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        now = datetime.now().isoformat()
        
        cursor.execute('''
            UPDATE errors 
            SET acknowledged = 1, resolved_at = ?
            WHERE error_key = ?
        ''', (now, error_key))
        
        self._record_event(cursor, 'acknowledged', error_key, {})
        
        conn.commit()
        conn.close()
    
    def get_active_errors(self, category: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get all active (unresolved) errors, optionally filtered by category"""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        if category:
            cursor.execute('''
                SELECT * FROM errors 
                WHERE resolved_at IS NULL AND category = ?
                ORDER BY severity DESC, last_seen DESC
            ''', (category,))
        else:
            cursor.execute('''
                SELECT * FROM errors 
                WHERE resolved_at IS NULL
                ORDER BY severity DESC, last_seen DESC
            ''')
        
        rows = cursor.fetchall()
        conn.close()
        
        errors = []
        for row in rows:
            error_dict = dict(row)
            if error_dict.get('details'):
                error_dict['details'] = json.loads(error_dict['details'])
            errors.append(error_dict)
        
        return errors
    
    def cleanup_old_errors(self):
        """Clean up old resolved errors and auto-resolve stale errors"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        now = datetime.now()
        
        # Delete resolved errors older than 7 days
        cutoff_resolved = (now - timedelta(days=7)).isoformat()
        cursor.execute('DELETE FROM errors WHERE resolved_at < ?', (cutoff_resolved,))
        
        # Auto-resolve VM/CT errors older than 48h
        cutoff_vm = (now - timedelta(seconds=self.VM_ERROR_RETENTION)).isoformat()
        cursor.execute('''
            UPDATE errors 
            SET resolved_at = ?
            WHERE category = 'vms' 
              AND resolved_at IS NULL 
              AND first_seen < ?
              AND acknowledged = 0
        ''', (now.isoformat(), cutoff_vm))
        
        # Auto-resolve log errors older than 24h
        cutoff_logs = (now - timedelta(seconds=self.LOG_ERROR_RETENTION)).isoformat()
        cursor.execute('''
            UPDATE errors 
            SET resolved_at = ?
            WHERE category = 'logs' 
              AND resolved_at IS NULL 
              AND first_seen < ?
              AND acknowledged = 0
        ''', (now.isoformat(), cutoff_logs))
        
        # Delete old events (>30 days)
        cutoff_events = (now - timedelta(days=30)).isoformat()
        cursor.execute('DELETE FROM events WHERE timestamp < ?', (cutoff_events,))
        
        conn.commit()
        conn.close()
    
    def check_vm_running(self, vm_id: str) -> bool:
        """
        Check if a VM/CT is running and resolve error if so.
        Returns True if running and error was resolved.
        """
        import subprocess
        
        try:
            # Check qm status for VMs
            result = subprocess.run(
                ['qm', 'status', vm_id],
                capture_output=True,
                text=True,
                timeout=2
            )
            
            if result.returncode == 0 and 'running' in result.stdout.lower():
                self.resolve_error(f'vm_{vm_id}', 'VM started')
                return True
            
            # Check pct status for containers
            result = subprocess.run(
                ['pct', 'status', vm_id],
                capture_output=True,
                text=True,
                timeout=2
            )
            
            if result.returncode == 0 and 'running' in result.stdout.lower():
                self.resolve_error(f'ct_{vm_id}', 'Container started')
                return True
            
            return False
            
        except Exception:
            return False
    
    def _record_event(self, cursor, event_type: str, error_key: str, data: Dict):
        """Internal: Record an event"""
        cursor.execute('''
            INSERT INTO events (event_type, error_key, timestamp, data)
            VALUES (?, ?, ?, ?)
        ''', (event_type, error_key, datetime.now().isoformat(), json.dumps(data)))
    
    def get_unnotified_errors(self) -> List[Dict[str, Any]]:
        """Get errors that need Telegram notification"""
        conn = sqlite3.connect(str(self.db_path))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute('''
            SELECT * FROM errors 
            WHERE notification_sent = 0 
              AND resolved_at IS NULL 
              AND acknowledged = 0
            ORDER BY severity DESC, first_seen ASC
        ''')
        
        rows = cursor.fetchall()
        conn.close()
        
        errors = []
        for row in rows:
            error_dict = dict(row)
            if error_dict.get('details'):
                error_dict['details'] = json.loads(error_dict['details'])
            errors.append(error_dict)
        
        return errors
    
    def mark_notified(self, error_key: str):
        """Mark error as notified"""
        conn = sqlite3.connect(str(self.db_path))
        cursor = conn.cursor()
        
        cursor.execute('''
            UPDATE errors 
            SET notification_sent = 1
            WHERE error_key = ?
        ''', (error_key,))
        
        conn.commit()
        conn.close()


# Global instance
health_persistence = HealthPersistence()



================================================
FILE: AppImage/scripts/jwt_middleware.py
================================================
"""
JWT Middleware Module
Provides decorator to protect Flask routes with JWT authentication
Automatically checks auth status and validates tokens
"""

from flask import request, jsonify
from functools import wraps
from auth_manager import load_auth_config, verify_token


def require_auth(f):
    """
    Decorator to protect Flask routes with JWT authentication
    
    Behavior:
    - If auth is disabled or declined: Allow access (no token required)
    - If auth is enabled: Require valid JWT token in Authorization header
    - Returns 401 if auth required but token missing/invalid
    
    Usage:
        @app.route('/api/protected')
        @require_auth
        def protected_route():
            return jsonify({"data": "secret"})
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # Check if authentication is enabled
        config = load_auth_config()
        
        # If auth is disabled or declined, allow access
        if not config.get("enabled", False) or config.get("declined", False):
            return f(*args, **kwargs)
        
        # Auth is enabled, require token
        auth_header = request.headers.get('Authorization')
        
        if not auth_header:
            return jsonify({
                "error": "Authentication required",
                "message": "No authorization header provided"
            }), 401
        
        # Extract token from "Bearer <token>" format
        parts = auth_header.split()
        if len(parts) != 2 or parts[0].lower() != 'bearer':
            return jsonify({
                "error": "Invalid authorization header",
                "message": "Authorization header must be in format: Bearer <token>"
            }), 401
        
        token = parts[1]
        
        # Verify token
        username = verify_token(token)
        if not username:
            return jsonify({
                "error": "Invalid or expired token",
                "message": "Please log in again"
            }), 401
        
        # Token is valid, allow access
        return f(*args, **kwargs)
    
    return decorated_function


def optional_auth(f):
    """
    Decorator for routes that can optionally use auth
    Passes username if authenticated, None otherwise
    
    Usage:
        @app.route('/api/optional')
        @optional_auth
        def optional_route(username=None):
            if username:
                return jsonify({"message": f"Hello {username}"})
            return jsonify({"message": "Hello guest"})
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        config = load_auth_config()
        username = None
        
        if config.get("enabled", False):
            auth_header = request.headers.get('Authorization')
            if auth_header:
                parts = auth_header.split()
                if len(parts) == 2 and parts[0].lower() == 'bearer':
                    username = verify_token(parts[1])
        
        # Inject username into kwargs
        kwargs['username'] = username
        return f(*args, **kwargs)
    
    return decorated_function



================================================
FILE: AppImage/scripts/proxmox_storage_monitor.py
================================================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ProxMenux - Proxmox Storage Monitor
Monitors configured Proxmox storages and tracks unavailable storages
"""

import json
import subprocess
import socket
from typing import Dict, List, Any, Optional


class ProxmoxStorageMonitor:
    """Monitor Proxmox storage configuration and status"""
    
    def __init__(self):
        self.configured_storages: Dict[str, Dict[str, Any]] = {}
        self._load_configured_storages()
    
    def _get_node_name(self) -> str:
        """Get current Proxmox node name"""
        try:
            result = subprocess.run(
                ['pvesh', 'get', '/nodes', '--output-format', 'json'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0:
                nodes = json.loads(result.stdout)
                hostname = socket.gethostname()
                for node in nodes:
                    if node.get('node') == hostname:
                        return hostname
                if nodes:
                    return nodes[0].get('node', hostname)
            return socket.gethostname()
        except Exception:
            return socket.gethostname()
    
    def _load_configured_storages(self) -> None:
        """Load configured storages from Proxmox configuration"""
        try:
            local_node = self._get_node_name()
            
            # Read storage configuration from pvesh
            result = subprocess.run(
                ['pvesh', 'get', '/storage', '--output-format', 'json'],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode != 0:
                return
            
            storages = json.loads(result.stdout)
            
            for storage in storages:
                storage_id = storage.get('storage')
                if not storage_id:
                    continue
                
                # Check if storage is enabled for this node
                nodes = storage.get('nodes')
                if nodes and local_node not in nodes.split(','):
                    continue
                
                disabled = storage.get('disable', 0)
                if disabled == 1:
                    continue
                
                self.configured_storages[storage_id] = {
                    'name': storage_id,
                    'type': storage.get('type', 'unknown'),
                    'content': storage.get('content', ''),
                    'path': storage.get('path', ''),
                    'enabled': True
                }
        
        except Exception:
            pass
    
    def get_storage_status(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Get storage status, including unavailable storages
        
        Returns:
            {
                'available': [...],
                'unavailable': [...]
            }
        """
        try:
            local_node = self._get_node_name()
            
            # Get current storage status from pvesh
            result = subprocess.run(
                ['pvesh', 'get', '/cluster/resources', '--type', 'storage', '--output-format', 'json'],
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode != 0:
                return {'available': [], 'unavailable': list(self.configured_storages.values())}
            
            resources = json.loads(result.stdout)
            
            # Track which configured storages are available
            available_storages = []
            unavailable_storages = []
            seen_storage_names = set()
            
            for resource in resources:
                node = resource.get('node', '')
                
                # Filter only local node storages
                if node != local_node:
                    continue
                
                name = resource.get('storage', 'unknown')
                seen_storage_names.add(name)
                storage_type = resource.get('plugintype', 'unknown')
                status = resource.get('status', 'unknown')
                
                try:
                    total = int(resource.get('maxdisk', 0))
                    used = int(resource.get('disk', 0))
                    available = total - used if total > 0 else 0
                except (ValueError, TypeError):
                    total = 0
                    used = 0
                    available = 0
                
                # Calculate percentage
                percent = (used / total * 100) if total > 0 else 0.0
                
                # Convert bytes to GB
                total_gb = round(total / (1024**3), 2)
                used_gb = round(used / (1024**3), 2)
                available_gb = round(available / (1024**3), 2)
                
                storage_info = {
                    'name': name,
                    'type': storage_type,
                    'total': total_gb,
                    'used': used_gb,
                    'available': available_gb,
                    'percent': round(percent, 2),
                    'node': node
                }
                
                # Check if storage is available
                if total == 0 or status.lower() != "available":
                    storage_info['status'] = 'error'
                    storage_info['status_detail'] = 'unavailable' if total == 0 else status
                    unavailable_storages.append(storage_info)
                else:
                    storage_info['status'] = 'active'
                    available_storages.append(storage_info)
            
            # Check for configured storages that are completely missing
            for storage_name, storage_config in self.configured_storages.items():
                if storage_name not in seen_storage_names:
                    unavailable_storages.append({
                        'name': storage_name,
                        'type': storage_config['type'],
                        'status': 'error',
                        'status_detail': 'not_found',
                        'total': 0,
                        'used': 0,
                        'available': 0,
                        'percent': 0,
                        'node': local_node
                    })
            
            return {
                'available': available_storages,
                'unavailable': unavailable_storages
            }
        
        except Exception:
            return {
                'available': [],
                'unavailable': list(self.configured_storages.values())
            }
    
    def get_unavailable_count(self) -> int:
        """Get count of unavailable storages"""
        status = self.get_storage_status()
        return len(status['unavailable'])
    
    def reload_configuration(self) -> None:
        """Reload storage configuration from Proxmox"""
        self.configured_storages.clear()
        self._load_configured_storages()


# Global instance
proxmox_storage_monitor = ProxmoxStorageMonitor()



================================================
FILE: AppImage/types/hardware.ts
================================================
import { fetchApi } from "@/lib/api-config"

export interface Temperature {
  name: string
  original_name?: string
  current: number
  high?: number
  critical?: number
  adapter?: string
}

export interface PowerMeter {
  name: string
  watts: number
  adapter?: string
}

export interface NetworkInterface {
  name: string
  type: string
  speed?: string
  status?: string
}

export interface StorageDevice {
  name: string
  type: string
  size?: string
  model?: string
  driver?: string
  interface?: string
  serial?: string
  family?: string
  firmware?: string
  rotation_rate?: number | string
  form_factor?: string
  sata_version?: string
  pcie_gen?: string // e.g., "PCIe 4.0"
  pcie_width?: string // e.g., "x4"
  pcie_max_gen?: string // Maximum supported PCIe generation
  pcie_max_width?: string // Maximum supported PCIe lanes
  sas_version?: string // e.g., "SAS-3"
  sas_speed?: string // e.g., "12Gb/s"
  link_speed?: string // Generic link speed info
}

export interface PCIDevice {
  slot: string
  type: string
  device: string
  vendor: string
  class: string
  driver?: string
  kernel_module?: string
  irq?: string
  memory_address?: string
  link_speed?: string
  capabilities?: string[]
  gpu_memory?: string
  gpu_driver_version?: string
  gpu_cuda_version?: string
  gpu_compute_capability?: string
  gpu_power_draw?: string
  gpu_temperature?: number
  gpu_utilization?: number
  gpu_memory_used?: string
  gpu_memory_total?: string
  gpu_clock_speed?: string
  gpu_memory_clock?: string
}

export interface Fan {
  name: string
  original_name?: string
  speed: number
  unit: string
  adapter?: string
}

export interface PowerSupply {
  name: string
  watts: number
  status?: string
}

export interface UPS {
  name: string
  host?: string
  is_remote?: boolean
  connection_type?: string
  status: string
  model?: string
  manufacturer?: string
  serial?: string
  device_type?: string
  firmware?: string
  driver?: string
  battery_charge?: string
  battery_charge_raw?: number
  battery_voltage?: string
  battery_date?: string
  time_left?: string
  time_left_seconds?: number
  load_percent?: string
  load_percent_raw?: number
  input_voltage?: string
  input_frequency?: string
  output_voltage?: string
  output_frequency?: string
  real_power?: string
  apparent_power?: string
  [key: string]: any
}

export interface GPU {
  slot: string
  name: string
  vendor: string
  type: string
  pci_class?: string
  pci_driver?: string
  pci_kernel_module?: string
  driver_version?: string
  memory_total?: string
  memory_used?: string
  memory_free?: string
  temperature?: number
  power_draw?: string
  power_limit?: string
  utilization_gpu?: number
  utilization_memory?: number
  clock_graphics?: string
  clock_memory?: string
  engine_render?: number
  engine_blitter?: number
  engine_video?: number
  engine_video_enhance?: number
  pcie_gen?: string
  pcie_width?: string
  fan_speed?: number
  fan_unit?: string
  processes?: Array<{
    pid: string
    name: string
    memory: string
  }>
  has_monitoring_tool?: boolean
  note?: string
}

export interface DiskHardwareInfo {
  type?: string
  driver?: string
  interface?: string
  model?: string
  serial?: string
  family?: string
  firmware?: string
  rotation_rate?: string
  form_factor?: string
  sata_version?: string
}

export interface NetworkHardwareInfo {
  driver?: string
  kernel_modules?: string
  subsystem?: string
  max_link_speed?: string
  max_link_width?: string
  current_link_speed?: string
  current_link_width?: string
  interface_name?: string
  interface_speed?: string
  mac_address?: string
}

export interface HardwareData {
  cpu?: {
    model?: string
    cores_per_socket?: number
    sockets?: number
    total_threads?: number
    l3_cache?: string
    virtualization?: string
  }
  motherboard?: {
    manufacturer?: string
    model?: string
    bios?: {
      vendor?: string
      version?: string
      date?: string
    }
  }
  memory_modules?: Array<{
    slot: string
    size?: string
    type?: string
    speed?: string
    manufacturer?: string
  }>
  temperatures?: Temperature[]
  power_meter?: PowerMeter
  network_cards?: NetworkInterface[]
  storage_devices?: StorageDevice[]
  pci_devices?: PCIDevice[]
  gpus?: GPU[]
  fans?: Fan[]
  power_supplies?: PowerSupply[]
  ups?: UPS | UPS[]
}

export const fetcher = async (url: string) => {
  // Extract just the endpoint from the URL if it's a full URL
  const endpoint = url.startsWith("http") ? new URL(url).pathname : url
  return fetchApi(endpoint)
}



================================================
FILE: assets/base-packages.txt
================================================
# base-packages.txt - Generated on 2025-05-15 21:15:29
# Proxmox Version: pve-manager/8.4.1/ (running kernel: 6.8.12-9-pve)

adduser
apparmor
apt
apt-listchanges
apt-utils
attr
base-files
base-passwd
bash
bash-completion
bc
bind9-dnsutils
bind9-host
bind9-libs
binutils
binutils-common
binutils-x86-64-linux-gnu
bridge-utils
bsdextrautils
bsd-mailx
bsdutils
btrfs-progs
busybox
bzip2
ca-certificates
ceph-common
ceph-fuse
chrony
cifs-utils
console-setup
console-setup-linux
coreutils
corosync
cpio
criu
cron
cron-daemon-common
cstream
curl
dash
dbus
dbus-bin
dbus-daemon
dbus-session-bus-common
dbus-system-bus-common
debconf
debconf-i18n
debian-archive-keyring
debian-faq
debianutils
dialog
diffutils
dirmngr
distro-info-data
dmeventd
dmidecode
dmsetup
doc-debian
dosfstools
dpkg
dtach
e2fsprogs
ebtables
efibootmgr
eject
ethtool
faketime
fdisk
fdutils
file
findutils
fontconfig
fontconfig-config
fonts-dejavu-core
fonts-font-awesome
fonts-font-logos
fonts-glyphicons-halflings
frr
frr-pythontools
fuse
gcc-12-base
gdisk
genisoimage
gettext-base
glusterfs-client
glusterfs-common
gnupg
gnupg-l10n
gnupg-utils
gnutls-bin
gpg
gpg-agent
gpgconf
gpgsm
gpgv
gpg-wks-client
gpg-wks-server
grep
groff-base
grub2-common
grub-common
grub-efi-amd64
grub-efi-amd64-bin
grub-efi-amd64-signed
grub-pc-bin
gzip
hdparm
hostname
ifupdown2
inetutils-telnet
init
initramfs-tools
initramfs-tools-core
init-system-helpers
iproute2
ipset
iptables
iputils-ping
isc-dhcp-client
isc-dhcp-common
iso-codes
jq
kbd
keyboard-configuration
keyutils
klibc-utils
kmod
krb5-locales
ksm-control-daemon
less
libacl1
libaio1
libanyevent-http-perl
libanyevent-perl
libapparmor1
libappconfig-perl
libapt-pkg6.0
libapt-pkg-perl
libarchive13
libargon2-1
libasound2
libasound2-data
libassuan0
libasyncns0
libattr1
libaudit1
libaudit-common
libauthen-pam-perl
libavahi-client3
libavahi-common3
libavahi-common-data
libbabeltrace1
libbinutils
libblas3
libblkid1
libbpf1
libbrotli1
libbsd0
libbytes-random-secure-perl
libbz2-1.0
libc6
libcairo2
libcap2
libcap2-bin
libcap-ng0
libc-ares2
libc-bin
libcbor0.8
libcephfs2
libcfg7
libc-l10n
libclone-perl
libcmap4
libcom-err2
libcommon-sense-perl
libconvert-asn1-perl
libcorosync-common4
libcpg4
libcrypt1
libcrypt-openssl-bignum-perl
libcrypt-openssl-random-perl
libcrypt-openssl-rsa-perl
libcrypt-random-seed-perl
libcryptsetup12
libcrypt-ssleay-perl
libctf0
libctf-nobfd0
libcurl3-gnutls
libcurl4
libdatrie1
libdb5.3
libdbi1
libdbus-1-3
libdebconfclient0
libdevel-cycle-perl
libdevmapper1.02.1
libdevmapper-event1.02.1
libdigest-hmac-perl
libdouble-conversion3
libdrm2
libdrm-common
libdw1
libedit2
libefiboot1
libefivar1
libelf1
libencode-locale-perl
libepoxy0
libevent-2.1-7
libevent-core-2.1-7
libexpat1
libext2fs2
libfaketime
libfdisk1
libfdt1
libffi8
libfido2-1
libfile-chdir-perl
libfile-find-rule-perl
libfile-listing-perl
libfile-readbackwards-perl
libfilesys-df-perl
libflac12
libfmt9
libfontconfig1
libfreetype6
libfribidi0
libfstrm0
libfuse2
libfuse3-3
libgbm1
libgcc-s1
libgcrypt20
libgdbm6
libgdbm-compat4
libgfapi0
libgfchangelog0
libgfrpc0
libgfxdr0
libglib2.0-0
libglusterd0
libglusterfs0
libgmp10
libgnutls30
libgnutls-dane0
libgnutlsxx30
libgoogle-perftools4
libgpg-error0
libgprofng0
libgraphite2-3
libgssapi-krb5-2
libgstreamer1.0-0
libgstreamer-plugins-base1.0-0
libharfbuzz0b
libhogweed6
libhtml-parser-perl
libhtml-tagset-perl
libhtml-tree-perl
libhttp-cookies-perl
libhttp-daemon-perl
libhttp-date-perl
libhttp-message-perl
libhttp-negotiate-perl
libibverbs1
libicu72
libidn2-0
libinih1
libio-html-perl
libio-multiplex-perl
libio-socket-ssl-perl
libio-stringy-perl
libip4tc2
libip6tc2
libipset13
libiscsi7
libisns0
libjansson4
libjemalloc2
libjpeg62-turbo
libjq1
libjs-bootstrap
libjs-extjs
libjs-jquery
libjson-c5
libjson-glib-1.0-0
libjson-glib-1.0-common
libjson-perl
libjson-xs-perl
libjs-qrcodejs
libjs-sencha-touch
libk5crypto3
libkeyutils1
libklibc
libkmod2
libknet1
libkrb5-3
libkrb5support0
libksba8
libldap-2.5-0
libldb2
liblinear4
liblinux-inotify2-perl
liblmdb0
liblocale-gettext-perl
liblockfile1
liblockfile-bin
liblttng-ust1
liblttng-ust-common1
liblttng-ust-ctl5
liblua5.3-0
liblvm2cmd2.03
liblwp-mediatypes-perl
liblwp-protocol-https-perl
liblz4-1
liblzma5
liblzo2-2
libmagic1
libmagic-mgc
libmath-random-isaac-perl
libmaxminddb0
libmd0
libmime-base32-perl
libmnl0
libmount1
libmp3lame0
libmpg123-0
libncurses6
libncursesw6
libnet1
libnetaddr-ip-perl
libnet-dbus-perl
libnet-dns-perl
libnetfilter-conntrack3
libnetfilter-log1
libnet-http-perl
libnet-ip-perl
libnet-ldap-perl
libnet-ssleay-perl
libnet-subnet-perl
libnettle8
libnewt0.52
libnfnetlink0
libnfsidmap1
libnftables1
libnftnl11
libnghttp2-14
libnl-3-200
libnl-route-3-200
libnozzle1
libnpth0
libnsl2
libnspr4
libnss3
libnss-systemd
libnuma1
libnumber-compare-perl
libnvpair3linux
liboath0
libogg0
libonig5
libopeniscsiusr
libopus0
liborc-0.4-0
libp11-kit0
libpam0g
libpam-modules
libpam-modules-bin
libpam-runtime
libpam-systemd
libpango-1.0-0
libpangocairo-1.0-0
libpangoft2-1.0-0
libpcap0.8
libpci3
libpcre2-16-0
libpcre2-8-0
libpcre3
libperl5.36
libpipeline1
libpixman-1-0
libpng16-16
libpopt0
libposix-strptime-perl
libproc2-0
libprotobuf32
libprotobuf-c1
libproxmox-acme-perl
libproxmox-acme-plugins
libproxmox-backup-qemu0
libproxmox-rs-perl
libpsl5
libpulse0
libpve-access-control
libpve-apiclient-perl
libpve-cluster-api-perl
libpve-cluster-perl
libpve-common-perl
libpve-guest-common-perl
libpve-http-server-perl
libpve-network-api-perl
libpve-network-perl
libpve-notify-perl
libpve-rs-perl
libpve-storage-perl
libpve-u2f-server-perl
libpython3.11-minimal
libpython3.11-stdlib
libpython3-stdlib
libqb100
libqrencode4
libqt5core5a
libqt5dbus5
libqt5network5
libquorum5
librabbitmq4
librados2
librados2-perl
libradosstriper1
librbd1
librdkafka1
librdmacm1
libreadline8
libregexp-ipv6-perl
librgw2
librrd8
librrds-perl
librtmp1
libsasl2-2
libsasl2-modules-db
libseccomp2
libselinux1
libsemanage2
libsemanage-common
libsepol2
libslang2
libslirp0
libsmartcols1
libsmbclient
libsnappy1v5
libsndfile1
libsocket6-perl
libspice-server1
libsqlite3-0
libss2
libssh2-1
libssl3
libstatgrab10
libstdc++6
libstring-shellquote-perl
libsubid4
libsystemd0
libsystemd-shared
libtalloc2
libtasn1-6
libtcmalloc-minimal4
libtdb1
libtemplate-perl
libterm-readline-gnu-perl
libtevent0
libtext-charwidth-perl
libtext-glob-perl
libtext-iconv-perl
libtext-wrapi18n-perl
libthai0
libthai-data
libthrift-0.17.0
libtimedate-perl
libtinfo6
libtirpc3
libtirpc-common
libtpms0
libtry-tiny-perl
libtypes-serialiser-perl
libu2f-server0
libuchardet0
libudev1
libunbound8
libunistring2
libunwind8
liburcu8
liburing2
liburi-perl
libusb-1.0-0
libusbredirparser1
libuuid1
libuuid-perl
libuutil3linux
libuv1
libva2
libva-drm2
libvirglrenderer1
libvorbis0a
libvorbisenc2
libvotequorum8
libvulkan1
libwayland-server0
libwbclient0
libwrap0
libwww-perl
libwww-robotrules-perl
libx11-6
libx11-data
libx11-xcb1
libxau6
libxcb1
libxcb-render0
libxcb-shm0
libxdmcp6
libxext6
libxml2
libxml-libxml-perl
libxml-namespacesupport-perl
libxml-parser-perl
libxml-sax-base-perl
libxml-sax-perl
libxml-twig-perl
libxrender1
libxslt1.1
libxtables12
libxxhash0
libyaml-0-2
libyaml-libyaml-perl
libyang3
libzfs4linux
libzpool5linux
libzstd1
linux-base
locales
login
logrotate
logsave
lsof
lua-lpeg
lvm2
lxcfs
lxc-pve
lzop
mailcap
man-db
manpages
mawk
media-types
memtest86+
mime-support
mokutil
mount
nano
ncurses-base
ncurses-bin
ncurses-term
netbase
netcat-traditional
nfs-common
nftables
nmap
nmap-common
novnc-pve
open-iscsi
openssh-client
openssh-server
openssh-sftp-server
openssl
passwd
pci.ids
pciutils
perl
perl-base
perl-modules-5.36
perl-openssl-defaults
pinentry-curses
postfix
procmail
procps
proxmox-archive-keyring
proxmox-backup-client
proxmox-backup-file-restore
proxmox-backup-restore-image
proxmox-default-kernel
proxmox-firewall
proxmox-grub
proxmox-kernel-6.8
proxmox-kernel-6.8.12-10-pve-signed
proxmox-kernel-6.8.12-9-pve-signed
proxmox-kernel-helper
proxmox-mail-forward
proxmox-mini-journalreader
proxmox-offline-mirror-docs
proxmox-offline-mirror-helper
proxmox-termproxy
proxmox-ve
proxmox-websocket-tunnel
proxmox-widget-toolkit
psmisc
pv
pve-cluster
pve-container
pve-docs
pve-edk2-firmware
pve-edk2-firmware-legacy
pve-edk2-firmware-ovmf
pve-esxi-import-tools
pve-firewall
pve-firmware
pve-ha-manager
pve-i18n
pve-lxc-syscalld
pve-manager
pve-qemu-kvm
pve-xtermjs
python3
python3.11
python3.11-minimal
python3.11-venv
python3-apt
python3-ceph-argparse
python3-ceph-common
python3-cephfs
python3-certifi
python3-chardet
python3-charset-normalizer
python3-debconf
python3-debian
python3-debianbts
python3-distutils
python3-httplib2
python3-idna
python3-jwt
python3-lib2to3
python3-minimal
python3-pip-whl
python3-pkg-resources
python3-prettytable
python3-protobuf
python3-pycurl
python3-pyparsing
python3-pysimplesoap
python3-pyvmomi
python3-rados
python3-rbd
python3-reportbug
python3-requests
python3-rgw
python3-setuptools
python3-setuptools-whl
python3-six
python3-systemd
python3-urllib3
python3-venv
python3-wcwidth
python3-yaml
python-apt-common
qemu-server
qrencode
readline-common
reportbug
rpcbind
rrdcached
rsync
runit-helper
samba-common
samba-libs
sed
sensible-utils
sgml-base
shared-mime-info
shim-helpers-amd64-signed
shim-signed
shim-signed-common
shim-unsigned
smartmontools
smbclient
socat
spiceterm
spl
sqlite3
ssh
ssl-cert
strace
swtpm
swtpm-libs
swtpm-tools
systemd
systemd-boot
systemd-boot-efi
systemd-sysv
sysvinit-utils
tar
tasksel
tasksel-data
tcpdump
thin-provisioning-tools
time
traceroute
tzdata
ucf
udev
uidmap
usbutils
usrmerge
util-linux
util-linux-extra
vim-common
vim-tiny
virtiofsd
vncterm
wamerican
wget
whiptail
xfsprogs
xkb-data
xsltproc
xz-utils
zfs-initramfs
zfsutils-linux
zfs-zed
zlib1g
zstd


================================================
FILE: docs/01.PROXMENUX_REVIEW.md
================================================

---

# **AnÃ¡lisis Completo del proyecto ProxMenux**

## **1. Estructura General del Proyecto**

### **Archivos Principales**
- **[install_proxmenux.sh](cci:7://file:///home/debian/src/ProxMenuxOffline/install_proxmenux.sh:0:0-0:0)**: Script de instalaciÃ³n principal (723 lÃ­neas)
- **[menu](cci:7://file:///home/debian/src/ProxMenuxOffline/menu:0:0-0:0)**: Script principal que se instala como comando del sistema (93 lÃ­neas)
- **[version.txt](cci:7://file:///home/debian/src/ProxMenuxOffline/version.txt:0:0-0:0)**: Control de versiones (actual: 1.1.7)

### **Directorios Principales**
```
ProxMenuxOffline/
â”œâ”€â”€ scripts/           # 122 archivos de scripts bash
â”‚   â”œâ”€â”€ menus/        # 13 scripts de menÃºs
â”‚   â”œâ”€â”€ lxc/          # 6 scripts para contenedores LXC
â”‚   â”œâ”€â”€ vm/           # 13 scripts para mÃ¡quinas virtuales
â”‚   â”œâ”€â”€ storage/      # 9 scripts de almacenamiento
â”‚   â”œâ”€â”€ share/        # 12 scripts para compartir recursos
â”‚   â”œâ”€â”€ utilities/    # 6 utilidades del sistema
â”‚   â”œâ”€â”€ global/       # 10 funciones comunes
â”‚   â”œâ”€â”€ backup_restore/ # 6 scripts de respaldo
â”‚   â”œâ”€â”€ post_install/ # 3 scripts post-instalaciÃ³n
â”‚   â””â”€â”€ gpu_tpu/      # Scripts para hardware grÃ¡fico
â”œâ”€â”€ web/              # 136 archivos - Dashboard Next.js
â”œâ”€â”€ AppImage/         # 54 archivos - ProxMenux Monitor
â”œâ”€â”€ json/             # Archivos de cachÃ© de traducciones
â”œâ”€â”€ lang/             # Archivos de idioma
â”œâ”€â”€ guides/           # 5 guÃ­as de usuario
â””â”€â”€ images/           # 7 imÃ¡genes del proyecto
```

---

## **2. Flujo de InstalaciÃ³n**

### **Script: [install_proxmenux.sh](cci:7://file:///home/debian/src/ProxMenuxOffline/install_proxmenux.sh:0:0-0:0)**

**Fase 1: InicializaciÃ³n**
- Verifica permisos root (lÃ­nea 716-719)
- Carga [utils.sh](cci:7://file:///home/debian/src/ProxMenuxOffline/scripts/utils.sh:0:0-0:0) desde GitHub (lÃ­nea 54-57)
- Limpia archivos corruptos de configuraciÃ³n (lÃ­nea 59-68)

**Fase 2: DetecciÃ³n de InstalaciÃ³n Existente**
- FunciÃ³n [check_existing_installation()](cci:1://file:///home/debian/src/ProxMenuxOffline/install_proxmenux.sh:70:0-106:1) (lÃ­nea 71-107)
- Detecta 4 tipos: `none`, `normal`, `translation`, `unknown`
- Verifica entorno virtual Python en `/opt/googletrans-env`
- Verifica configuraciÃ³n de idioma en `/usr/local/share/proxmenux/config.json`

**Fase 3: SelecciÃ³n de VersiÃ³n**
- **VersiÃ³n Normal** (opciÃ³n 1):
  - Dependencias: `dialog`, `curl`, `jq`
  - Solo inglÃ©s
  - MÃ¡s ligera y rÃ¡pida
  
- **VersiÃ³n con TraducciÃ³n** (opciÃ³n 2):
  - Dependencias adicionales: `python3`, `python3-venv`, `python3-pip`
  - Instala `googletrans==4.0.0-rc1` en entorno virtual
  - Soporte multiidioma: en, es, fr, de, it, pt
  - **Nota**: No compatible con Proxmox VE 9+ (lÃ­nea 639-658)

**Fase 4: InstalaciÃ³n Normal** ([install_normal_version()](cci:1://file:///home/debian/src/ProxMenuxOffline/install_proxmenux.sh:402:0-484:1))
1. Instala dependencias bÃ¡sicas
2. Crea directorios:
   - `/usr/local/bin` (ejecutables)
   - `/usr/local/share/proxmenux` (archivos del sistema)
3. Descarga desde GitHub:
   - `utils.sh` â†’ `/usr/local/share/proxmenux/utils.sh`
   - `menu` â†’ `/usr/local/bin/menu`
   - `version.txt` â†’ `/usr/local/share/proxmenux/version.txt`
4. Instala ProxMenux Monitor (AppImage)

**Fase 5: InstalaciÃ³n con TraducciÃ³n** (`install_translation_version()`)
- Pasos adicionales:
  - Selector de idioma interactivo (lÃ­nea 234-273)
  - Crea entorno virtual Python en `/opt/googletrans-env`
  - Instala googletrans con pip
  - Descarga `cache.json` con traducciones precargadas
  - Sistema de cachÃ© para reducir llamadas a la API de traducciÃ³n

**Fase 6: ProxMenux Monitor**
- Descarga AppImage desde GitHub (lÃ­nea 317-360)
- Verifica checksum SHA256 (lÃ­nea 333-351)
- Crea servicio systemd `/etc/systemd/system/proxmenux-monitor.service`
- Puerto por defecto: 8008
- Se ejecuta como usuario root
- Auto-inicio en boot

---

## **3. Funcionamiento del Comando `menu`**

### **Script Principal: `/usr/local/bin/menu`**

**Flujo de EjecuciÃ³n:**

1. **Carga de ConfiguraciÃ³n** (lÃ­nea 33-44):
   ```bash
   REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"
   BASE_DIR="/usr/local/share/proxmenux"
   source "$UTILS_FILE"
   ```

2. **Sistema de TraducciÃ³n** (lÃ­nea 89-92):
   - Carga idioma desde `config.json`
   - Inicializa cachÃ© de traducciones
   - FunciÃ³n `translate()` en `utils.sh`

3. **VerificaciÃ³n de Actualizaciones** (lÃ­nea 48-80):
   - Compara versiÃ³n local vs remota
   - Prompt interactivo para actualizar
   - Descarga y ejecuta nuevo `install_proxmenux.sh` si hay actualizaciÃ³n

4. **EjecuciÃ³n del MenÃº Principal** (lÃ­nea 84-86):
   ```bash
   exec bash <(curl -fsSL "$REPO_URL/scripts/menus/main_menu.sh")
   ```

**Importante**: El comando `menu` **NO ejecuta scripts locales**, siempre descarga desde GitHub.

---

## **4. Sistema de MenÃºs**

### **MenÃº Principal: `scripts/menus/main_menu.sh`**

**Compatibilidad PVE 9** (lÃ­nea 26-64):
- Detecta versiÃ³n de Proxmox
- Si PVE 9+ y tiene traducciones instaladas â†’ fuerza reinstalaciÃ³n en versiÃ³n normal
- Previene errores de compatibilidad

**Opciones del MenÃº** (lÃ­nea 97-111):
```
1. Settings post-install Proxmox    â†’ menu_post_install.sh
2. Hardware: GPUs and Coral-TPU     â†’ hw_grafics_menu.sh
3. Create VM from template          â†’ create_vm_menu.sh
4. Disk and Storage Manager         â†’ storage_menu.sh
5. Mount and Share Manager          â†’ share_menu.sh
6. Proxmox VE Helper Scripts        â†’ menu_Helper_Scripts.sh
7. Network Management               â†’ network_menu.sh
8. Utilities and Tools              â†’ utilities_menu.sh
h. Help and Info Commands           â†’ help_info_menu.sh
s. Settings                         â†’ config_menu.sh
0. Exit
```

**PatrÃ³n de EjecuciÃ³n**:
```bash
exec bash <(curl -s "$REPO_URL/scripts/menus/submenu.sh")
```

Todos los menÃºs descargan y ejecutan scripts desde GitHub en tiempo real.

---

## **5. Scripts Locales vs Remotos**

### **Estado Actual**
- **Scripts locales**: EstÃ¡n presentes en el repositorio (122 archivos)
- **EjecuciÃ³n**: Siempre desde GitHub mediante `curl`
- **Ventaja actual**: Actualizaciones automÃ¡ticas sin reinstalar
- **Desventaja**: Requiere conexiÃ³n a internet constante

### **Scripts Principales Disponibles Localmente**

**GestiÃ³n de VMs** (`scripts/vm/`):
- `create_vm.sh` - Crear VMs
- `synology.sh` (39KB) - InstalaciÃ³n Synology DSM
- `zimaos.sh` (40KB) - InstalaciÃ³n ZimaOS
- `uupdump_creator.sh` - Creador de ISOs Windows
- `select_windows_iso.sh`, `select_linux_iso.sh`, `select_nas_iso.sh`

**GestiÃ³n de LXC** (`scripts/lxc/`):
- `lxc-manual-guide.sh` - GuÃ­a manual
- `lxc-privileged-to-unprivileged.sh`
- `lxc-unprivileged-to-privileged.sh`

**Almacenamiento** (`scripts/storage/`):
- `disk-passthrough.sh` - Passthrough disco a VM
- `disk-passthrough_ct.sh` - Passthrough disco a LXC (22KB)
- `import-disk-image.sh` - Importar imÃ¡genes
- `format-disk.sh`, `mount-disk-on-host.sh`

**Compartir Recursos** (`scripts/share/`):
- `lxc-mount-manager_minimal.sh` (35KB) - GestiÃ³n mount points
- `nfs_host.sh` (35KB) - Servidor NFS en host
- `samba_host.sh` (52KB) - Servidor Samba en host
- `nfs_client.sh`, `samba_client.sh` - Clientes en LXC
- `local-shared-manager.sh` - Directorios compartidos locales

**Post-InstalaciÃ³n** (`scripts/post_install/`):
- `auto_post_install.sh` (29KB) - Automatizado sin interacciÃ³n
- `customizable_post_install.sh` (148KB) - Personalizable
- `uninstall-tools.sh` (34KB) - Desinstalador

**Utilidades** (`scripts/utilities/`):
- `upgrade_pve8_to_pve9.sh` (35KB) - Upgrade PVE 8â†’9
- `system_utils.sh` (20KB) - Instalador de utilidades
- `proxmox_update.sh` - ActualizaciÃ³n de Proxmox

**Red** (`scripts/menus/network_menu.sh`):
- 43KB de funcionalidades de red
- Optimizaciones para LXC+NFS

**Global** (`scripts/global/`):
- `update-pve.sh`, `update-pve8.sh`, `update-pve9_2.sh`
- `remove-banner-pve8.sh`, `remove-banner-pve9.sh`
- `share-common.func` (30KB) - Funciones compartidas

---

## **6. Sistema de Utilidades: `utils.sh`**

### **Funciones Principales**

**Interfaz Visual** (lÃ­nea 50-71):
- DefiniciÃ³n de colores ANSI
- CÃ³digos de estilo para terminal
- Spinner animado (lÃ­nea 75-88)

**Mensajes Estandarizados**:
- `msg_info()` - Info con spinner
- `msg_ok()` - Ã‰xito (checkmark verde)
- `msg_error()` - Error (rojo)
- `msg_warn()` - Advertencia (amarillo)
- `msg_title()` - TÃ­tulos
- `type_text()` - Efecto mÃ¡quina de escribir

**Sistema de TraducciÃ³n** (lÃ­nea 232-305):
```bash
translate() {
    # Si idioma es "en" â†’ retorna texto original
    # Busca en cachÃ© local (cache.json)
    # Si no existe â†’ llama a googletrans vÃ­a Python
    # Guarda en cachÃ© para futuras traducciones
    # Limpia prefijos de contexto
}
```

**Contexto de TraducciÃ³n** (lÃ­nea 48):
```bash
TRANSLATION_CONTEXT="Context: Technical message for Proxmox and IT. Translate:"
```

**Logo ASCII** (lÃ­nea 314-400):
- Dos versiones: terminal noVNC y SSH
- DetecciÃ³n automÃ¡tica del entorno
- DiseÃ±o en ASCII art con colores

---

## **7. ProxMenux Monitor**

### **Componente Web (AppImage)**

**TecnologÃ­a**:
- **Frontend**: Next.js 14, React 18, TypeScript
- **UI**: Radix UI + shadcn/ui + Tailwind CSS
- **GrÃ¡ficos**: Recharts
- **Backend**: Flask (Python) para recolecciÃ³n de datos del sistema
- **Empaquetado**: AppImage (10.3 MB)

**CaracterÃ­sticas**:
- Dashboard en tiempo real
- Monitoreo de CPU, RAM, temperatura
- Estado de VMs y LXC containers
- GestiÃ³n de almacenamiento visual
- EstadÃ­sticas de red
- Logs del sistema
- Tema oscuro/claro
- Responsive design
- Puerto: 8008

**Servicio Systemd**:
```ini
[Unit]
Description=ProxMenux Monitor - Web Dashboard
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/usr/local/share/proxmenux
ExecStart=/usr/local/share/proxmenux/ProxMenux-Monitor.AppImage
Restart=on-failure
RestartSec=10
Environment="PORT=8008"
```

**Estado**: Se instala automÃ¡ticamente en ambas versiones (normal y traducciÃ³n)

---

## **8. Sistema de ConfiguraciÃ³n**

### **Archivos de ConfiguraciÃ³n**

**`/usr/local/share/proxmenux/config.json`**:
- Estado de instalaciÃ³n de componentes
- Idioma seleccionado
- Timestamps de instalaciÃ³n
- Estados: `installed`, `already_installed`, `failed`

**Componentes Rastreados** (lÃ­nea 201):
```json
{
  "dialog": {"status": "installed", "timestamp": "..."},
  "curl": {"status": "already_installed", "timestamp": "..."},
  "jq": {"status": "installed", "timestamp": "..."},
  "python3": {"status": "installed", "timestamp": "..."},
  "virtual_environment": {"status": "created", "timestamp": "..."},
  "googletrans": {"status": "installed", "timestamp": "..."},
  "proxmenux_monitor": {"status": "installed", "timestamp": "..."},
  "language": "es"
}
```

**`/usr/local/share/proxmenux/cache.json`**:
- Traducciones cacheadas (100 KB)
- Formato: `{"texto_original": {"es": "traducciÃ³n", "fr": "traduction"}}`
- Reduce llamadas a Google Translate API

**`/usr/local/share/proxmenux/installed_tools.json`**:
- Registro de herramientas post-instalaciÃ³n
- Usado por el desinstalador

---

## **9. Funcionalidades Destacadas**

### **Post-InstalaciÃ³n Automatizada**
- **Optimizaciones de repositorios**: Limpia duplicados, configura repos gratuitos
- **EliminaciÃ³n de banner de suscripciÃ³n**: Con respaldo y reversiÃ³n
- **OptimizaciÃ³n de memoria y kernel**: Ajustes segÃºn RAM disponible
- **Log2RAM**: InstalaciÃ³n automÃ¡tica en SSD/NVMe
- **Network tuning**: OptimizaciÃ³n de stack de red
- **LÃ­mites del sistema**: Aumenta lÃ­mites de archivos y procesos
- **ConfiguraciÃ³n de journald**: Ajustada para Log2RAM
- **EntropÃ­a**: Mejora generaciÃ³n de nÃºmeros aleatorios
- **Aliases bash**: PersonalizaciÃ³n del entorno

### **GestiÃ³n de ComparticiÃ³n de Recursos**
**Enfoque**: Mount Points LXC (Host â†” Container)
- DetecciÃ³n automÃ¡tica de tipo de filesystem
- Mapeo UID/GID para contenedores unprivileged
- VisualizaciÃ³n de mount points existentes
- EliminaciÃ³n segura con verificaciÃ³n

**Configuraciones disponibles**:
- NFS: Host, Client LXC, Server LXC
- Samba: Host, Client LXC, Server LXC
- Directorios locales compartidos

### **Hardware Especializado**
- **Coral TPU**: InstalaciÃ³n de drivers compatible con PVE 8 y 9
- **GPUs**: Passthrough y configuraciÃ³n para VMs y LXC
- **iGPU**: ConfiguraciÃ³n para contenedores LXC

### **Upgrade PVE 8 â†’ 9**
- Script de 35 KB con verificaciones exhaustivas
- GuÃ­a manual interactiva
- Checker de compatibilidad

---

## **10. Arquitectura de EjecuciÃ³n**

### **PatrÃ³n de Descarga DinÃ¡mica**

**Todos los scripts siguen este patrÃ³n**:
```bash
exec bash <(curl -s "$REPO_URL/scripts/path/to/script.sh")
```

**Ventajas**:
- âœ… Usuarios siempre tienen la Ãºltima versiÃ³n
- âœ… No requiere reinstalaciÃ³n para actualizaciones
- âœ… Hotfixes inmediatos
- âœ… Control centralizado de versiones

**Consideraciones**:
- âš ï¸ Requiere internet en cada ejecuciÃ³n
- âš ï¸ Dependencia de disponibilidad de GitHub
- âš ï¸ No funciona offline
- âš ï¸ Los scripts locales del repo no se usan directamente

### **Sistema de Versionado**
- `version.txt` en repo: versiÃ³n remota
- `/usr/local/share/proxmenux/version.txt`: versiÃ³n local instalada
- Check en cada ejecuciÃ³n del comando `menu`
- Prompt para actualizar si hay nueva versiÃ³n

---

## **11. Flujo de NavegaciÃ³n**

```
Comando: menu
    â†“
Verifica actualizaciones
    â†“
Carga utils.sh y traducciones
    â†“
Descarga main_menu.sh desde GitHub
    â†“
Usuario selecciona opciÃ³n
    â†“
Descarga submenu correspondiente desde GitHub
    â†“
Usuario selecciona acciÃ³n
    â†“
Descarga y ejecuta script especÃ­fico desde GitHub
    â†“
Retorna al menÃº anterior
```

**Ejemplo de navegaciÃ³n**:
```
menu â†’ main_menu.sh
  â†’ opciÃ³n 5: share_menu.sh
    â†’ opciÃ³n 4: lxc-mount-manager_minimal.sh (35KB)
      â†’ Ejecuta acciones
      â†’ Retorna a share_menu.sh
    â†’ opciÃ³n 0: Retorna a main_menu.sh
  â†’ opciÃ³n 0: Exit
```

---

## **12. IntegraciÃ³n con Comunidad**

### **Scripts de la Comunidad Integrados**

**Proxmox VE Helper-Scripts**:
- Post-install script oficial
- Ejecutado desde: `https://github.com/community-scripts/ProxmoxVE`

**Xshok-proxmox** (fork):
- Post-install alternativo
- Descarga desde fork de MacRimi

**Elementos compartidos**:
- Funciones de `utils.sh` basadas en Helper-Scripts
- Misma filosofÃ­a de mensajes estandarizados
- Licencia MIT compatible

---

## **13. Sistema de DesinstalaciÃ³n**

### **FunciÃ³n: `uninstall_proxmenux()`** (lÃ­nea 109-161)

**Proceso**:
1. ConfirmaciÃ³n interactiva (whiptail)
2. Desinstala googletrans y entorno virtual Python
3. Selector de dependencias a eliminar (python3, python3-venv, pip)
4. Elimina `/usr/local/bin/menu`
5. Elimina `/usr/local/share/proxmenux/`
6. Restaura `.bashrc` desde backup
7. Restaura `/etc/motd` desde backup

**Tool-specific uninstaller**: `scripts/post_install/uninstall-tools.sh`
- Lee `installed_tools.json`
- Permite desinstalar herramientas individualmente
- Restaura configuraciones originales

---

## **14. Estructura de Archivos JSON**

### **`json/cache.json`** (100 KB)
Traducciones precargadas para acelerar el sistema

### **`json/helpers_cache.json`** (273 KB)
CachÃ© extendido, probablemente para Helper Scripts

### **`lang/cache.json`** (5.5 KB)
CachÃ© de idiomas especÃ­fico

### **`lang/en.lang`** y **`lang/es.lang`**
Archivos de idioma estÃ¡ticos (4-5 KB cada uno)

---

## **15. Resumen de Componentes**

| Componente | UbicaciÃ³n | FunciÃ³n |
|------------|-----------|---------|
| **Instalador** | `install_proxmenux.sh` | InstalaciÃ³n inicial y actualizaciones |
| **Comando principal** | `/usr/local/bin/menu` | Punto de entrada del usuario |
| **Utilidades** | `/usr/local/share/proxmenux/utils.sh` | Funciones compartidas |
| **ConfiguraciÃ³n** | `/usr/local/share/proxmenux/config.json` | Estado del sistema |
| **CachÃ© traducciones** | `/usr/local/share/proxmenux/cache.json` | Traducciones cacheadas |
| **Entorno Python** | `/opt/googletrans-env/` | TraducciÃ³n (solo versiÃ³n translation) |
| **Monitor** | `/usr/local/share/proxmenux/ProxMenux-Monitor.AppImage` | Dashboard web |
| **Servicio Monitor** | `/etc/systemd/system/proxmenux-monitor.service` | Servicio systemd |
| **Scripts** | GitHub (descarga dinÃ¡mica) | Todos los scripts funcionales |

---

## **ConclusiÃ³n**

ProxMenuxOffline es un **sistema modular de gestiÃ³n de Proxmox VE** que utiliza una arquitectura hÃ­brida:

- **NÃºcleo local**: Comando `menu`, utilidades, sistema de configuraciÃ³n
- **Scripts remotos**: Toda la funcionalidad se descarga dinÃ¡micamente desde GitHub
- **Dashboard web**: AppImage independiente con Next.js + Flask
- **Sistema de traducciÃ³n**: Opcional, basado en Python + googletrans + cachÃ©

El proyecto tiene **122 scripts bash** en el repositorio local que **podrÃ­an ejecutarse localmente**, pero actualmente **todos se descargan desde GitHub en tiempo de ejecuciÃ³n**. Esta arquitectura prioriza mantener a los usuarios actualizados sobre la ejecuciÃ³n offline.


================================================
FILE: docs/02.GUIA_MODIFICACION_OFFLINE.md
================================================
# Scripts a Modificar para EjecuciÃ³n 100% Local

**Fecha**: 2025-11-01  
**Objetivo**: Eliminar dependencias de GitHub y permitir ejecuciÃ³n completamente local  
**Repositorio**: ProxMenuxDotDeb

---

## Resumen Ejecutivo

Para que ProxMenux funcione 100% localmente sin depender de GitHub, se deben modificar **47 archivos** en total:

- **2 archivos principales** (instalador y comando menu)
- **13 scripts de menÃºs** (sistema de navegaciÃ³n)
- **32 scripts funcionales** (operaciones especÃ­ficas)

**Cambios principales**:
1. Cambiar `REPO_URL` de GitHub a rutas locales del sistema
2. Reemplazar descargas `curl` por ejecuciÃ³n de scripts locales
3. Copiar todos los scripts a `/usr/local/share/proxmenux/scripts/` durante instalaciÃ³n

---

## 1. Archivos Principales (CRÃTICOS) âš ï¸

### 1.1. `install_proxmenux.sh` (RaÃ­z del repositorio)

**LÃ­neas a modificar**:
- **LÃ­nea 37**: `REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"`
- **LÃ­nea 38**: `UTILS_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/scripts/utils.sh"`
- **LÃ­nea 54-57**: Carga de `utils.sh` con curl
- **LÃ­nea 459-476**: Descarga de archivos con wget (versiÃ³n normal)
- **LÃ­nea 583-603**: Descarga de archivos con wget (versiÃ³n traducciÃ³n)

**Cambios necesarios**:
```bash
# Cambiar URLs a rutas locales
REPO_URL="/usr/local/share/proxmenux"
UTILS_URL="./scripts/utils.sh"

# Reemplazar wget por cp
# En lugar de descargar, copiar archivos locales del repositorio
```

**Impacto**: ğŸ”´ CRÃTICO - Sin esto, la instalaciÃ³n falla completamente

---

### 1.2. `menu` (RaÃ­z del repositorio)

**LÃ­neas a modificar**:
- **LÃ­nea 34**: `REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"`
- **LÃ­nea 52**: VerificaciÃ³n de actualizaciones (curl remoto)
- **LÃ­nea 72**: Descarga de instalador actualizado
- **LÃ­nea 85**: `exec bash <(curl -fsSL "$REPO_URL/scripts/menus/main_menu.sh")`

**Cambios necesarios**:
```bash
# Cambiar a ruta local
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"

# Ejecutar localmente
exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
```

**Impacto**: ğŸ”´ CRÃTICO - Es el punto de entrada del usuario

---

## 2. Scripts de MenÃºs (13 archivos)

### 2.1. `scripts/menus/main_menu.sh` â­

**Modificaciones**:
- **LÃ­nea 14**: `REPO_URL`
- **LÃ­nea 57**: curl para reinstalaciÃ³n PVE9
- **LÃ­neas 125-135**: Todas las opciones del menÃº (12 lÃ­neas)

**Comandos a reemplazar**:
```bash
# Todas estas lÃ­neas:
exec bash <(curl -s "$REPO_URL/scripts/menus/menu_post_install.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/hw_grafics_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/create_vm_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/storage_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/share_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/menu_Helper_Scripts.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/network_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/utilities_menu.sh")
bash <(curl -s "$REPO_URL/scripts/help_info_menu.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/config_menu.sh")
```

---

### 2.2. `scripts/menus/menu_post_install.sh`

**Modificaciones**:
- **LÃ­nea 12**: `REPO_URL`
- **LÃ­nea 73**: `bash <(curl -s $REPO_URL/scripts/post_install/auto_post_install.sh)`
- **LÃ­nea 171**: `exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh")`

**Nota**: Mantener URLs remotas para scripts de comunidad externa (lÃ­neas 90-91)

---

### 2.3. `scripts/menus/config_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- No tiene llamadas curl âœ…

---

### 2.4. `scripts/menus/create_vm_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- MÃºltiples `exec bash <(curl -s ...)` en opciones del menÃº

---

### 2.5. `scripts/menus/hw_grafics_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- **LÃ­neas 38, 44, 50, 55, 56**: Llamadas curl

**Comandos a reemplazar**:
```bash
bash <(curl -s "$REPO_URL/scripts/configure_igpu_lxc.sh")
bash <(curl -s "$REPO_URL/scripts/install_coral_lxc.sh")
bash <(curl -s "$REPO_URL/scripts/gpu_tpu/install_coral_pve9.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh")
```

---

### 2.6. `scripts/menus/lxc_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- Todos los `exec bash <(curl ...)`

---

### 2.7. `scripts/menus/menu_Helper_Scripts.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- **LÃ­nea 296**: `exec bash <(curl -s ...)`

**Nota**: Mantener URLs de Helper-Scripts externos (comunidad)

---

### 2.8. `scripts/menus/network_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- **LÃ­nea 1085**: `exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh")`

---

### 2.9. `scripts/menus/share_menu.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`
- **LÃ­neas 46, 55-82, 85**: 11 llamadas curl

**Comandos a reemplazar**:
```bash
bash <(curl -s "$REPO_URL/scripts/share/nfs_host.sh")
bash <(curl -s "$REPO_URL/scripts/share/samba_host.sh")
bash <(curl -s "$REPO_URL/scripts/share/local-shared-manager.sh")
bash <(curl -s "$REPO_URL/scripts/share/lxc-mount-manager_minimal.sh")
bash <(curl -s "$REPO_URL/scripts/share/nfs_client.sh")
bash <(curl -s "$REPO_URL/scripts/share/samba_client.sh")
bash <(curl -s "$REPO_URL/scripts/share/nfs_lxc_server.sh")
bash <(curl -s "$REPO_URL/scripts/share/samba_lxc_server.sh")
bash <(curl -s "$REPO_URL/scripts/share/commands_share.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh") # 2 veces
```

---

### 2.10. `scripts/menus/storage_menu.sh`

**Modificaciones**:
- **LÃ­nea 15**: `REPO_URL`
- **LÃ­neas 39, 42, 45, 48, 51**: 5 llamadas curl

**Comandos a reemplazar**:
```bash
bash <(curl -s "$REPO_URL/scripts/storage/disk-passthrough.sh")
bash <(curl -s "$REPO_URL/scripts/storage/disk-passthrough_ct.sh")
bash <(curl -s "$REPO_URL/scripts/storage/import-disk-image.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh") # 2 veces
```

---

### 2.11. `scripts/menus/utilities_menu.sh`

**Modificaciones**:
- **LÃ­nea 15**: `REPO_URL`
- **LÃ­neas 39, 45, 67, 74, 79, 80**: 6 llamadas curl

**Comandos a reemplazar**:
```bash
bash <(curl -s "$REPO_URL/scripts/utilities/uup_dump_iso_creator.sh")
bash <(curl -s "$REPO_URL/scripts/utilities/system_utils.sh")
bash <(curl -s "$REPO_URL/scripts/utilities/proxmox_update.sh")
bash <(curl -s "$REPO_URL/scripts/utilities/upgrade_pve8_to_pve9.sh")
exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh") # 2 veces
```

---

### 2.12. `scripts/menus/main_menu_.sh`

**Modificaciones**: Igual que `main_menu.sh` (archivo alternativo/backup)

---

### 2.13. `scripts/menus/sm.sh`

**Modificaciones**: Igual que `share_menu.sh` (archivo alternativo)

---

## 3. Scripts Post-InstalaciÃ³n (3 archivos)

### 3.1. `scripts/post_install/auto_post_install.sh`

**Modificaciones**:
- **LÃ­nea 39**: `REPO_URL`
- **LÃ­nea 110**: `bash <(curl -fsSL "$REPO_URL/scripts/global/update-pve9_2.sh")`
- **LÃ­nea 113**: `bash <(curl -fsSL "$REPO_URL/scripts/global/update-pve8.sh")`
- **LÃ­nea 150**: `bash <(curl -fsSL "$REPO_URL/scripts/global/remove-banner-pve-v3.sh")`
- **LÃ­nea 157**: `bash <(curl -fsSL "$REPO_URL/scripts/global/remove-banner-pve8.sh")`

---

### 3.2. `scripts/post_install/customizable_post_install.sh`

**Modificaciones**:
- **LÃ­nea 39**: `REPO_URL`
- **LÃ­nea 197**: `bash <(curl -fsSL "$REPO_URL/scripts/global/update-pve9_2.sh")`
- **LÃ­nea 200**: `bash <(curl -fsSL "$REPO_URL/scripts/global/update-pve8.sh")`
- **LÃ­nea 2905**: `bash <(curl -fsSL "$REPO_URL/scripts/global/remove-banner-pve-v3.sh")`
- **LÃ­nea 2908**: `bash <(curl -fsSL "$REPO_URL/scripts/global/remove-banner-pve8.sh")`

---

### 3.3. `scripts/post_install/uninstall-tools.sh`

**Modificaciones**: Solo lectura de configs locales âœ…

---

## 4. Scripts de VMs (8 archivos)

### 4.1. `scripts/vm/create_vm.sh`

**Modificaciones**:
- **LÃ­nea 29**: `REPO_URL`
- **LÃ­neas 30-32**: `VM_REPO`, `ISO_REPO`, `MENU_REPO`

---

### 4.2. `scripts/vm/select_linux_iso.sh`

**Modificaciones**:
- **LÃ­nea 28**: `REPO_URL`
- **LÃ­nea 222**: `exec bash <(curl -s "$REPO_URL/scripts/vm/create_vm.sh")`

---

### 4.3. `scripts/vm/select_windows_iso.sh`

**Modificaciones**:
- **LÃ­nea 27**: `REPO_URL`
- **LÃ­nea 28**: `UUP_REPO`

---

### 4.4. `scripts/vm/select_nas_iso.sh`

**Modificaciones**:
- **LÃ­nea 31**: `REPO_URL`
- **LÃ­nea 65**: `bash <(curl -s "$REPO_URL/scripts/vm/synology.sh")`
- **LÃ­nea 106**: `bash <(curl -s "$REPO_URL/scripts/vm/zimaos.sh")`

---

### 4.5. `scripts/vm/synology.sh`

**Modificaciones**:
- **LÃ­nea 32**: `REPO_URL`

---

### 4.6. `scripts/vm/synology_.sh`

**Modificaciones**:
- **LÃ­nea 32**: `REPO_URL`

---

### 4.7. `scripts/vm/zimaos.sh`

**Modificaciones**:
- Verificar si tiene `REPO_URL`

---

### 4.8. `scripts/vm/vm_creator.sh`

**Modificaciones**:
- **LÃ­nea 497**: `bash <(curl -fsSL "$REPO_URL/scripts/menus/create_vm_menu.sh")`

---

## 5. Scripts de LXC (4 archivos)

### 5.1. `scripts/lxc/lxc-manual-guide.sh`

**Modificaciones**:
- **LÃ­nea 14**: `REPO_URL`

---

### 5.2. `scripts/lxc/lxc-privileged-to-unprivileged.sh`

**Modificaciones**:
- **LÃ­nea 18**: `REPO_URL`

---

### 5.3. `scripts/lxc/lxc-unprivileged-to-privileged.sh`

**Modificaciones**:
- **LÃ­nea 19**: `REPO_URL`

---

### 5.4. `scripts/lxc/lxc-mount-manager_minimal.sh`

**Modificaciones**:
- Verificar si tiene `REPO_URL`

---

## 6. Scripts de Compartir Recursos (9 archivos)

### 6.1. `scripts/share/nfs_host.sh`

**Modificaciones**:
- **LÃ­nea 16**: `REPO_URL`

---

### 6.2. `scripts/share/nfs_client.sh`

**Modificaciones**:
- **LÃ­nea 16**: `REPO_URL`

---

### 6.3. `scripts/share/nfs_lxc_server.sh`

**Modificaciones**:
- **LÃ­nea 16**: `REPO_URL`

---

### 6.4. `scripts/share/samba_host.sh`

**Modificaciones**:
- **LÃ­nea 16**: `REPO_URL`

---

### 6.5. `scripts/share/samba_client.sh`

**Modificaciones**:
- **LÃ­nea 18**: `REPO_URL`

---

### 6.6. `scripts/share/samba_lxc_server.sh`

**Modificaciones**:
- **LÃ­nea 16**: `REPO_URL`

---

### 6.7. `scripts/share/local-shared-manager.sh`

**Modificaciones**:
- **LÃ­nea 13**: `REPO_URL`

---

### 6.8. `scripts/share/lxc-mount-manager_minimal.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 6.9. `scripts/share/commands_share.sh`

**Modificaciones**:
- **LÃ­nea 14**: `REPO_URL`

---

## 7. Scripts de Almacenamiento (3 archivos)

### 7.1. `scripts/storage/disk-passthrough.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 7.2. `scripts/storage/disk-passthrough_ct.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 7.3. `scripts/storage/import-disk-image.sh`

**Modificaciones**:
- **LÃ­nea 30**: `REPO_URL`

---

## 8. Scripts de Utilidades (4 archivos)

### 8.1. `scripts/utilities/upgrade_pve8_to_pve9.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 8.2. `scripts/utilities/system_utils.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 8.3. `scripts/utilities/proxmox_update.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

### 8.4. `scripts/utilities/uup_dump_iso_creator.sh`

**Modificaciones**:
- Verificar `REPO_URL`

---

## 9. Scripts Globales (3 archivos)

### 9.1. `scripts/global/update-pve.sh`

**Modificaciones**:
- **LÃ­nea 32**: `source <(curl -s "$REPO_URL/scripts/global/common-functions.sh")`

**Cambiar a**:
```bash
source "$LOCAL_SCRIPTS/global/common-functions.sh"
```

---

### 9.2. `scripts/global/update-pve8.sh`

**Modificaciones**:
- **LÃ­nea 32**: `source <(curl -s "$REPO_URL/scripts/global/common-functions.sh")`

---

### 9.3. `scripts/global/update-pve9_2.sh`

**Modificaciones**:
- **LÃ­nea 32**: `source <(curl -s "$REPO_URL/scripts/global/common-functions.sh")`

---

## 10. Scripts de Hardware (2 archivos)

### 10.1. `scripts/configure_igpu_lxc.sh`

**Modificaciones**:
- **LÃ­nea 19**: `REPO_URL`

---

### 10.2. `scripts/install_coral_lxc.sh`

**Modificaciones**:
- **LÃ­nea 25**: `REPO_URL`

---

## 11. Scripts de Red (2 archivos)

### 11.1. `scripts/repair_network.sh`

**Modificaciones**:
- **LÃ­nea 204**: `exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh")`
- **LÃ­nea 205**: `exec bash <(curl -s "$REPO_URL/scripts/menus/main_menu.sh")`

---

### 11.2. `scripts/telegram-notifier.sh`

**Modificaciones**:
- **LÃ­nea 5**: `REPO_URL`

---

## 12. Scripts Duplicados/Alternos (en `scripts/auto_post_install.sh`)

**Modificaciones**: Igual que `scripts/post_install/auto_post_install.sh`

---

## Tabla Resumen

| CategorÃ­a | Archivos | Modificaciones Principales |
|-----------|----------|---------------------------|
| **Principales** | 2 | REPO_URL + curl â†’ rutas locales |
| **MenÃºs** | 13 | REPO_URL + exec bash curl |
| **Post-Install** | 3 | bash curl a scripts global |
| **VMs** | 8 | REPO_URL + llamadas remotas |
| **LXC** | 4 | REPO_URL |
| **Share** | 9 | REPO_URL |
| **Storage** | 3 | REPO_URL |
| **Utilities** | 4 | REPO_URL |
| **Global** | 3 | source curl |
| **Hardware** | 2 | REPO_URL |
| **Red** | 2 | exec bash curl |
| **TOTAL** | **47** | **~150-200 lÃ­neas** |

---

## Plan de ImplementaciÃ³n Recomendado

### Paso 1: PreparaciÃ³n
```bash
# Crear backup
cp -r . ../ProxMenuxDotDeb_backup

# --------------------------------------------------------------------
# Documentar informaciÃ³n relevante del proyecto en directorio "docs"
# --------------------------------------------------------------------
```

### Paso 2: ModificaciÃ³n AutomÃ¡tica Global
```bash
# Script de conversiÃ³n masiva
find . -name "*.sh" -o -name "menu" | xargs sed -i \
  's|REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"|LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"|g'

# Cambiar referencias
find . -name "*.sh" -o -name "menu" | xargs sed -i \
  's|\$REPO_URL/scripts|\$LOCAL_SCRIPTS|g'

# Cambiar bash curl
find . -name "*.sh" -o -name "menu" | xargs sed -i -E \
  's|bash <\(curl -[sfSL]+ "\$REPO_URL/([^"]+)"|bash "\$LOCAL_SCRIPTS/\1"|g'

# Cambiar exec bash curl
find . -name "*.sh" -o -name "menu" | xargs sed -i -E \
  's|exec bash <\(curl -[sfSL]+ "\$REPO_URL/([^"]+)"|exec bash "\$LOCAL_SCRIPTS/\1"|g'

# Cambiar source curl
find . -name "*.sh" | xargs sed -i -E \
  's|source <\(curl -[sfSL]+ "\$REPO_URL/([^"]+)"|source "\$LOCAL_SCRIPTS/\1"|g'
```

### Paso 3: Modificar install_proxmenux.sh manualmente

Cambiar secciones de descarga wget por copias locales:
```bash
# En lugar de:
wget -qO "$dest" "$url"

# Usar:
cp "./scripts/utils.sh" "$UTILS_FILE"
cp "./menu" "$INSTALL_DIR/$MENU_SCRIPT"
cp "./version.txt" "$LOCAL_VERSION_FILE"
```

Agregar copia de todos los scripts:
```bash
msg_info "Copying local scripts..."
mkdir -p "$BASE_DIR/scripts"
cp -r "./scripts/"* "$BASE_DIR/scripts/"
chmod -R +x "$BASE_DIR/scripts/"
```

### Paso 4: Modificar comando menu

Comentar o modificar verificaciÃ³n de actualizaciones remotas.

### Paso 5: ValidaciÃ³n
```bash
# Verificar que no queden referencias remotas
grep -r "githubusercontent.com" . --include="*.sh" --include="menu"

# Verificar llamadas curl
grep -r "curl.*REPO_URL" . --include="*.sh" --include="menu"

# Contar archivos modificados
grep -r "LOCAL_SCRIPTS=" . --include="*.sh" --include="menu" | wc -l
```

---

## Estructura Post-ModificaciÃ³n

```
/usr/local/share/proxmenux/
â”œâ”€â”€ utils.sh
â”œâ”€â”€ config.json
â”œâ”€â”€ cache.json
â”œâ”€â”€ version.txt
â”œâ”€â”€ ProxMenux-Monitor.AppImage
â””â”€â”€ scripts/                    # â­ NUEVO
    â”œâ”€â”€ menus/
    â”‚   â”œâ”€â”€ main_menu.sh
    â”‚   â”œâ”€â”€ menu_post_install.sh
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ post_install/
    â”œâ”€â”€ vm/
    â”œâ”€â”€ lxc/
    â”œâ”€â”€ storage/
    â”œâ”€â”€ share/
    â”œâ”€â”€ utilities/
    â”œâ”€â”€ global/
    â””â”€â”€ gpu_tpu/

/usr/local/bin/
â””â”€â”€ menu
```

---

## Consideraciones Especiales

### Scripts Externos de la Comunidad
Mantener URLs remotas para:
- Proxmox VE Helper-Scripts (community-scripts)
- xshok-proxmox scripts

### ProxMenux Monitor
El AppImage se mantiene descargable desde GitHub durante la instalaciÃ³n inicial (10 MB).

### Sistema de Actualizaciones
Opciones:
1. Deshabilitar completamente
2. Mostrar mensaje para ejecutar `install_proxmenux.sh` manualmente
3. Sistema hÃ­brido (check opcional remoto)

---

## Checklist de ValidaciÃ³n

- [ok] Backup completo del repositorio
- [ok] ConversiÃ³n automÃ¡tica ejecutada
- [ok] `install_proxmenux.sh` modificado
- [ok] `menu` modificado
- [ip] Scripts de menÃºs verificados
- [ ] Sin referencias a githubusercontent.com
- [ ] Sin llamadas curl a REPO_URL
- [ ] InstalaciÃ³n local funcional
- [ ] NavegaciÃ³n por todos los menÃºs OK
- [ ] EjecuciÃ³n offline confirmada

---

**Total de archivos a modificar**: 47  
**LÃ­neas estimadas**: ~150-200  
**Tiempo estimado**: 2-4 horas  
**Riesgo**: Medio (requiere testing)  
**Beneficio**: Sistema completamente offline



================================================
FILE: guides/backup_cloud.md
================================================
---
title: "Proxmox Backup Cloud"
description: "Set up a simple backup service in Proxmox VE using your personal cloud storage provider (Google Drive, Mega, Dropbox, OneDrive, etc.) as an additional datastore, using rclone for secure backups without scripts."
---



## Preparation:

Connect to Proxmox via your preferred SSH client or from Proxmox's own Shell. Create a new directory in the /mnt folder. You can name it whatever helps you identify it; for example, if you're using Google Drive, you might call it gdrive. Here's how to do it:

```bash
mkdir /mnt/gdrive
```

Now let's add this directory to our datastore.

We'll do it like this:

![Adding new storage](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen1.png)

Next, we specify the name gdrive, the directory we created, and for content, we choose VZDump File.

![Configuring new storage](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen2.png)

Click on Add, and as we can see, it adds the new directory to our datastore.

![New storage added](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen3.png)

## Using rclone for cloud mounting:

Although the directory called gdrive is in our datastore, it's obviously not yet mounted in the cloud. For this, we'll use [rclone](https://rclone.org).

One detail to keep in mind is that rclone has changed the way it authorizes the [service that links to our cloud](https://rclone.org/remote_setup/). To do this, we need to connect via our SSH client and run the following code, changing the user to your Proxmox user (which is likely root if you haven't changed it) and the corresponding Proxmox IP address:

```bash
ssh -L localhost:53682:localhost:53682 root@ip_proxmox
```

Now let's install rclone:

```bash
apt-get update
apt-get install rclone
```

Follow the steps. You can use the rclone [guide](https://rclone.org/docs/) for your cloud provider.

Important: When we reach this point, we'll say "y". It will give us a localhost-type address that we can open and authorize when creating the link with Proxmox.

```
Use web browser to automatically authenticate rclone with remote?
 * Say Y if the machine running rclone has a web browser you can use
 * Say N if running rclone on a (remote) machine without web browser access
If not sure try Y. If Y failed, try N.
y) Yes
n) No
y/n> y
```

Once we have rclone configured, we just need to mount it. We can create a folder in our personal cloud called PBC.

To mount rclone in Proxmox and link it to that folder, we'll do it like this:

```bash
rclone mount gdrive:/PBC /mnt/gdrive --allow-other --allow-non-empty
```

- gdrive:/PBC is the folder in our cloud.
- /mnt/gdrive is the Proxmox directory we added to our datastore.

## Automating rclone mounting

If we want rclone to start on each Proxmox boot, we can use a crontab to do it. Here's how:

```bash
crontab -e
```

Next, it will ask us which type of editor we want to use to edit the file. I indicate option 1, which corresponds to Nano, as it's the console editor that seems simplest and most intuitive to use.
Once inside the editor, we just need to add this line as shown in the image:

```
@reboot rclone mount gdrive:/PBC /mnt/gdrive --allow-other --allow-non-empty
```

![Crontab configuration](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen4.png)

To finish, press the key combination control + X
Indicate "Y" + enter, and with this, we now have rclone mounted in our Proxmox with automatic startup and linked to our cloud.

Now we just need to check if we make a backup and select our gdrive as the destination disk.

![Selecting backup destination](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen5.png)

We'll verify that when the backup is finished, it will be exactly where we wanted it, in our cloud.

![Backup in cloud storage](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen6.png)

## Things to keep in mind

The backups that Proxmox makes, unlike Proxmox Backup Server, are not incremental. Therefore, depending on the space we have in our cloud, the number of copies we make, and their size, we could run out of space quickly.
To avoid this, we can add a copy purge system based on the parameters we want.
For example, we can keep only the last 5 copies as shown in the image.

![Backup retention settings](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/backup_cloud/imagen7.png)



If you found this tutorial helpful and useful, you can buy me a Ko-fi! Thank you! ğŸ˜Š


================================================
FILE: guides/Kodi_LXC.md
================================================
---
title: "Install Kodi in an LXC and Connect it to a Monitor/TV Using GPU Acceleration"
description: "Install Kodi in an LXC container on Proxmox, utilize GPU acceleration, and connect it to your TV, turning your Proxmox server into an all-in-one media center."
---



We'll use the script created by user [mrrudy](https://github.com/mrrudy).

To be able to use a keyboard, mouse, or any USB controller after installation, we must install the container with privileges.

```bash
bash -c "$(wget -qLO - https://raw.githubusercontent.com/mrrudy/proxmoxHelper/main/ct/kodi-v1.sh)"
```

Be patient, it takes time to install.
Access to tty7 means we can now connect our monitor or TV.

### Keyboard, Mouse, or USB Controller

The keyboard, mouse, or USB controllers are /dev/input devices. To add them to the LXC, we need to know their code:

```bash
ls -l /dev/input
```

![Input devices list](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/kodi/kodi1.png)

In my case, the code is 13.

We add to our LXC configuration:
For example, 102 is the id of my Kodi container

```bash
nano /etc/pve/lxc/102.conf
```

Add these lines:

```
lxc.cgroup2.devices.allow = c 13:* rwm 
lxc.mount.entry: /dev/input dev/input none bind,optional,create=dir
```

![LXC configuration](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/kodi/kodi2.png)

When we're done, we restart Proxmox:

```bash
reboot
```

### Updating Kodi

Inside the container's console:

```bash
sudo add-apt-repository ppa:team-xbmc/ppa
```

```bash
sudo apt install kodi kodi-bin
```

When it's finished, we restart, and when it boots up, we'll have Kodi updated.

### Images

![Kodi interface 1](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/kodi/kodi3.png)

![Kodi interface 2](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/kodi/kodi4.jpeg)

We can learn more about configuring an LXC with Intel GPU on [Konpat's blog](https://blog.konpat.me/dev/2019/03/11/setting-up-lxc-for-intel-gpu-proxmox.html).



<div style="display: flex; justify-content: center; align-items: center;">
  <a href="https://ko-fi.com/G2G313ECAN" target="_blank" style="display: flex; align-items: center; text-decoration: none;">
    <img src="https://raw.githubusercontent.com/MacRimi/HWEncoderX/main/images/kofi.png" alt="Support me on Ko-fi" style="width:175px; margin-right:65px;"/>
  </a>
</div>

If you found this tutorial helpful and useful, you can buy me a Ko-fi! Thank you! ğŸ˜Š



================================================
FILE: guides/lxc_samba.md
================================================
---
title: "How to Add a Hard Drive or USB Memory to an LXC for Use and Network Sharing"
description: "Add a USB hard drive to an LXC in Proxmox, set up Samba for network sharing, and utilize the added storage for various purposes."
---


Sometimes, it can be useful to add a hard drive or USB memory to our Proxmox setup, especially if we have a mini PC with limited expansion possibilities.

We'll see how to add a USB hard drive to an LXC where we'll use it and also share its content via Samba.

#### Note: The LXC must have privileges for us to add the disk.

There can be various uses, such as:
- Hosting Torrent files and making them available on the network
- Using it with our media server
- Using it to host documents that are auto-scanned with Paperless
- And many more...

We will:
1. Add the USB disk to the LXC
2. Install Samba
3. Configure the disk sharing

## 1. Adding USB disk to our LXC

### 1.1 Identify the USB disk or memory

To do this, it's as simple as looking at the disk section we have on our server before and after connecting the USB disk.

Before adding our disk:

![Before adding USB disk](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/lxc_samba/lxc_3.png)

After adding our USB disk:

![After adding USB disk](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/lxc_samba/lxc_4.png)

### 1.2 Format the disk

For us to use it, we have to format it in a compatible file system, for example ext4 in the case of a hard drive. We do this from the Proxmox console:

```bash
mkfs.ext4 /dev/sdb1
```

### 1.3 Create the mount directory in the LXC

We can name the directory whatever we want:

```bash
mkdir /mnt/lxc_USB
```

### 1.4 Create a mount point in our LXC

To do this, we go to the Proxmox console (not in the LXC), and edit the LXC's configuration file. Change the id (100) to the corresponding one for your LXC:

```bash
nano /etc/pve/lxc/100.conf
```

Add this line to the file:

```
mp0: /dev/sdb1,mp=/mnt/lxc_USB,backup=0
```

### 1.5 Start the LXC and set permissions

Start the LXC, log in, and give permissions to the mount directory:

```bash
chmod -R 777 /mnt/lxc_USB
```

## 2. Install Samba

Now that we have our disk mounted, let's install Samba to share it over the network.

### 2.1 Install Samba inside the LXC:

```bash
apt-get install samba -y
```

Confirm the service is running:

```bash
systemctl status smbd.service
```

### 2.2 Create a new user

Create a new user with the name we want, add a password for the user and confirm everything:

```bash
adduser proxmenux
```

Now let's add the new user to Samba:

```bash
smbpasswd -a proxmenux
```

### 2.3 Set permissions

Set the permissions for the proxmenux user to the path where we mounted the disk:

```bash
apt-get install acl
setfacl -R -m "u:proxmenux:rwx" /mnt/lxc_USB
```

## 3. Configure Samba sharing

### 3.1 Edit the Samba configuration file

Edit the smb.conf file to share the disk directory:

```bash
nano /etc/samba/smb.conf
```

At the end of the file add:

```
[lxc_usb]
    comment = shared folder
    path = /mnt/lxc_USB
    read only = no
    writable = yes
    browseable = yes
    guest ok = no
    valid users = @proxmenux
```

## 4. Verify access and usage

We now have our Samba server installed and our USB drive shared. Let's verify that we can access it:

![Samba server access 1](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/lxc_samba/lxc_1.png)

![Samba server access 2](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/lxc_samba/lxc_2.png)

Now we can use our hard drive, use it inside the container and also share its content:

![Using the USB drive](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/lxc_samba/lxc_5.png)

---

<div style="display: flex; justify-content: center; align-items: center;">
  <a href="https://ko-fi.com/G2G313ECAN" target="_blank" style="display: flex; align-items: center; text-decoration: none;">
    <img src="https://raw.githubusercontent.com/MacRimi/HWEncoderX/main/images/kofi.png" alt="Support me on Ko-fi" style="width:175px; margin-right:65px;"/>
  </a>
</div>

If you found this tutorial helpful and useful, you can buy me a Ko-fi! Thank you! ğŸ˜Š



================================================
FILE: guides/nvidia.md
================================================
---
title: "Installing NVIDIA Graphics Card Drivers on Proxmox (PVE 8)"
description: "Install and config NVIDIA drivers on Proxmox VE host and enable GPU usage in LXC containers."
---



Before we begin, I want to thank my colleague @juanlu13 for providing the [original source](https://forums.plex.tv/t/plex-hw-acceleration-in-lxc-container-anyone-with-success/219289/34?utm_source=pocket_mylist) on which this manual is based.

In this guide, we will install the Nvidia drivers, the persistent service, and an optional patch to remove the maximum encoding sessions limit.

- We will install Nvidia drivers on the Proxmox host.
- We will configure the drivers for use in any LXC.

To perform the installation, we must:

1. Blacklist the "nouveau" driver if we haven't already. If we have already done this, we can skip this step.

We can check it like this:
```
cat /etc/modprobe.d/blacklist.conf
```
The example image shows that "blacklist nouveau" is already added to the blacklist.

![Blacklist check](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-2.png)

If in our case it doesn't show: blacklist nouveau

We add it like this so it's not used and we can install the Nvidia driver.

```
echo "blacklist nouveau" >> /etc/modprobe.d/blacklist.conf
```
```
reboot
```

2. Make sure we have these repositories added:

(*If we have installed the post-installation script from [tteck](https://tteck.github.io/Proxmox/) or [xshok](https://github.com/extremeshok/xshok-proxmox), we can skip this step as it's not necessary since these repositories are already added.*)

```
nano /etc/apt/sources.list
```

## Proxmox 7
```
deb http://ftp.debian.org/debian bullseye main contrib
deb http://ftp.debian.org/debian bullseye-updates main contrib
deb http://security.debian.org/debian-security bullseye-security main contrib
deb http://download.proxmox.com/debian/pve bullseye pve-no-subscription
```

## Proxmox 8
```
deb http://ftp.debian.org/debian bookworm main contrib
deb http://ftp.debian.org/debian bookworm-updates main contrib
deb http://security.debian.org/debian-security bookworm-security main contrib
deb http://deb.debian.org/debian bookworm main contrib non-free-firmware
deb http://deb.debian.org/debian bookworm-updates main contrib non-free-firmware
# security updates
deb http://security.debian.org/debian-security bookworm-security main contrib non-free-firmware
```

Update the packages and Proxmox

```
apt update && apt dist-upgrade -y
```

Before we start, let's install two packages we'll need, git and the kernel headers to install the drivers:

```
apt-get install git
```
```
apt-get install -qqy pve-headers-`uname -r` gcc make 
```

## 1 - Install Nvidia drivers on the Proxmox host

### - Driver:

To begin, we need to know what the latest stable driver available is:*

(*If we're going to install the patch to bypass the maximum encoding limit, we need to make sure that patch is available for the driver version we're going to install.*) We can check it [here](https://github.com/keylase/nvidia-patch).
```
https://download.nvidia.com/XFree86/Linux-x86_64/latest.txt 
```

We can check the complete list of Drivers [here](https://download.nvidia.com/XFree86/Linux-x86_64/)

When it shows us the result, we copy the number and replace "/latest.txt" with it.

For example, like this:

```
https://download.nvidia.com/XFree86/Linux-x86_64/525.116.03/
```

Once inside the directory, we copy the link of the installer that ends with the .run extension

![NVIDIA driver download](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-1.png)

For example:
```
https://download.nvidia.com/XFree86/Linux-x86_64/525.116.03/NVIDIA-Linux-x86_64-525.116.03.run
```

#### Let's start with the installation:

```
mkdir /opt/nvidia
```
```
cd /opt/nvidia
```
We download the driver we copied earlier.
```
wget https://download.nvidia.com/XFree86/Linux-x86_64/525.116.03/NVIDIA-Linux-x86_64-525.116.03.run
```
We give it execution permissions.
```
chmod +x NVIDIA-Linux-x86_64-525.116.03.run
```
We execute.
```
./NVIDIA-Linux-x86_64-525.116.03.run --no-questions --ui=none --disable-nouveau
```
Once finished, we reboot.
```
reboot
```
After Proxmox has rebooted, we continue with the installation. We execute:
```
/opt/nvidia/NVIDIA-Linux-x86_64-525.116.03.run --no-questions --ui=none
```

Now we add to etc/modules:
```
nano /etc/modules-load.d/modules.conf
```
```
vfio
vfio_iommu_type1
vfio_pci
vfio_virqfd
nvidia
nvidia_uvm
```
We save:
ctrl + x.

We update initramfs:
```
update-initramfs -u -k all
```
Next, we create rules to load the drivers at boot for nvidia and nvidia_uvm:
```
nano /etc/udev/rules.d/70-nvidia.rules
```
We paste:
```
# /etc/udev/rules.d/70-nvidia.rules
# Create /nvidia0, /dev/nvidia1 â€¦ and /nvidiactl when nvidia module is loaded
KERNEL=="nvidia", RUN+="/bin/bash -c '/usr/bin/nvidia-smi -L'"
#
# Create the CUDA node when nvidia_uvm CUDA module is loaded
KERNEL=="nvidia_uvm", RUN+="/bin/bash -c '/usr/bin/nvidia-modprobe -c0 -u'"
```
We save: ctrl + x

### - NVIDIA driver persistence:

Now we install NVIDIA driver persistence:
```
cd /opt/nvidia
git clone https://github.com/NVIDIA/nvidia-persistenced.git
cd nvidia-persistenced/init
./install.sh
```
```
reboot
```

We check that the driver is installed and the service is running:
```
nvidia-smi
```
![NVIDIA SMI output](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-3.png)
```
systemctl status nvidia-persistenced
```
![NVIDIA persistence service status](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-4.png)

### - Patch:

Now as an option, we patch the nvidia driver to remove the maximum encoding sessions. According to the developer, the NVENC patch removes the restriction on the maximum number of simultaneous NVENC video encoding sessions imposed by Nvidia on consumer-level GPUs.

```
cd /opt/nvidia
git clone https://github.com/keylase/nvidia-patch.git
cd nvidia-patch
./patch.sh
```
![NVIDIA patch application](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-5.png)

## 2- Configure the drivers to be able to use them in any LXC.

First, we need to obtain this data:
```
ls -l /dev/nv*
```
![NVIDIA device list](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-6.png)

Let's say, for example, that we're going to use the Plex LXC from tteck's script with ID100. If we have it running, we turn it off.
```
nano /etc/pve/lxc/100.conf
```
If there are any, we comment out all lines where it appears:
- lxc.cgroup2.devices.allow...
- /dev/dri...

and we paste this inside the LXC configuration file, which corresponds to the data we obtained with: ls -l /dev/nv*

(*the numbers may vary from one system to another*)

```
lxc.cgroup2.devices.allow: c 195:* rwm
lxc.cgroup2.devices.allow: c 509:* rwm
lxc.cgroup2.devices.allow: c 10:* rwm
lxc.cgroup2.devices.allow: c 238:* rwm
lxc.mount.entry: /dev/nvidia0 dev/nvidia0 none bind,optional,create=file
lxc.mount.entry: /dev/nvidiactl dev/nvidiactl none bind,optional,create=file
lxc.mount.entry: /dev/nvidia-uvm dev/nvidia-uvm none bind,optional,create=file
lxc.mount.entry: /dev/nvidia-modeset dev/nvidia-modeset none bind,optional,create=file
lxc.mount.entry: /dev/nvidia-uvm-tools dev/nvidia-uvm-tools none bind,optional,create=file
lxc.mount.entry: /dev/nvram dev/nvram none bind,optional,create=file
```

![LXC configuration](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-7.png)

We save:
ctrl + x.

We run the LXC and we're going to install the Nvidia driver inside it.
**IMPORTANT: we do this installation from the LXC console, not from Proxmox**

```
mkdir /opt/nvidia
```
```
cd /opt/nvidia
```
```
wget https://download.nvidia.com/XFree86/Linux-x86_64/525.116.03/NVIDIA-Linux-x86_64-525.116.03.run
```
```
chmod +x NVIDIA-Linux-x86_64-525.116.03.run
```
```
./NVIDIA-Linux-x86_64-525.116.03.run --no-kernel-module
```

When this screen appears, we select everything by default, each time it asks us.

![NVIDIA driver installation](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-8.png)

Once the installation is finished, we check that everything is correct

```
nvidia-smi
```

![NVIDIA SMI in LXC](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-9.png)

```
ls -l /dev/nv*
```

![NVIDIA devices in LXC](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-10.png)

## We check that Plex uses the graphics card.

As we can see, the Plex LXC container makes use of the Nvidia graphics card from our Proxmox host.

![Plex using NVIDIA GPU 1](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-11.png)

![Plex using NVIDIA GPU 2](https://raw.githubusercontent.com/MacRimi/ProxMenux/main/guides/nvidia/nvidia-12.png)

If we want any LXC to use our graphics card, we simply follow the same steps.

If we want to use the Nvidia graphics card in Docker, we need to install nvidia-docker2 as an extra.

Inside the LXC where we have Docker, we can do it with this simple script:
```
wget https://raw.githubusercontent.com/MacRimi/manuales/main/NVIDIA/nvidia-docker.sh
```
```
chmod +x nvidia-docker.sh
```
```
./nvidia-docker.sh
```

---

<div style="display: flex; justify-content: center; align-items: center;">
  <a href="https://ko-fi.com/G2G313ECAN" target="_blank" style="display: flex; align-items: center; text-decoration: none;">
    <img src="https://raw.githubusercontent.com/MacRimi/HWEncoderX/main/images/kofi.png" alt="Support me on Ko-fi" style="width:175px; margin-right:65px;"/>
  </a>
</div>

If you found this tutorial helpful and useful, you can buy me a Ko-fi! Thank you! ğŸ˜Š



================================================
FILE: guides/nvidia/nvidia-docker.sh
================================================
#!/bin/bash

curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | \
  apt-key add -
distribution=$(. /etc/os-release;echo $ID$VERSION_ID)
curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \
  tee /etc/apt/sources.list.d/nvidia-docker.list
apt-get update

# Install nvidia-docker2 and reload the Docker daemon configuration
apt-get install -y nvidia-docker2
pkill -SIGHUP dockerd

reboot



================================================
FILE: images/logos_txt/Helper_Scripts.txt
================================================
[0m[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m              [48;2;1;6;9mâ”ˆ[38;2;4;105;159;48;2;2;11;16mâ–„[38;2;9;95;141;48;2;5;7;8mâ–[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m            [38;2;7;41;60;48;2;0;1;2mâ–[38;2;4;107;161;48;2;2;12;18mâ–„[38;2;1;123;188;48;2;6;70;102mâ–‡[38;2;0;128;196;48;2;0;127;195mâ•´[38;2;7;124;186;48;2;6;9;9mâ–[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [38;2;9;44;61;48;2;0;1;2mâ–[38;2;4;108;163;48;2;2;13;19mâ–„[38;2;1;124;189;48;2;6;74;108mâ–‡[38;2;0;127;195;48;2;0;127;196mâ–‡[38;2;0;128;196;48;2;0;128;195mâ”ˆ[48;2;0;127;195mâ”Š[38;2;6;124;185;48;2;6;9;10mâ–[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m        [38;2;7;46;67;48;2;0;2;2mâ–[38;2;4;109;165;48;2;3;14;21mâ–„[38;2;59;134;171;48;2;27;69;91mâ–‡[38;2;129;148;150;48;2;31;110;147mâ–„[38;2;75;117;136;48;2;12;104;149mâ–[38;2;11;89;125;48;2;0;126;193mâ–„[38;2;11;43;58;48;2;2;122;185mâ–‚[38;2;3;13;18;48;2;5;107;161mâ–…[38;2;0;0;0;48;2;0;2;3mâ”ˆ[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m      [38;2;8;49;70;48;2;1;2;3mâ–[38;2;4;111;167;48;2;3;16;22mâ–„[38;2;5;125;189;48;2;8;77;114mâ–‡[38;2;35;134;184;48;2;5;128;194mâ––[38;2;13;129;189;48;2;137;154;157mâ–‹[38;2;139;154;154;48;2;140;153;152mâ–‡[38;2;140;153;152;48;2;134;151;151mâ”ˆ[38;2;15;46;58;48;2;108;132;138mâ–[38;2;74;81;81;48;2;7;8;9mâ–[48;2;0;0;0m             [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m    [38;2;8;50;72;48;2;0;2;3mâ–[38;2;4;112;169;48;2;3;17;24mâ–„[38;2;7;126;189;48;2;9;81;119mâ–‡[38;2;36;134;184;48;2;14;130;190mâ”Œ[38;2;60;138;176;48;2;18;131;189mâ•´[38;2;0;127;195;48;2;2;127;194mâ•´[38;2;26;56;70;48;2;58;135;173mâ–[38;2;141;154;154;48;2;139;153;153mâ•´[38;2;140;154;154;48;2;139;154;154mâ”Š[48;2;139;153;153mâ”ˆ[48;2;135;148;148mâ”ˆ[38;2;120;132;131;48;2;16;17;17mâ–…[38;2;76;83;83;48;2;7;7;7mâ–[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m  [38;2;7;53;77;48;2;1;3;4mâ–[38;2;4;113;171;48;2;3;18;25mâ–„[38;2;9;126;189;48;2;9;83;121mâ–‡[38;2;40;134;182;48;2;20;131;189mâ”Š[38;2;47;135;180;48;2;17;131;190mâ”™[38;2;0;128;196;48;2;3;128;194mâ”Š[38;2;8;46;66;48;2;2;121;184mâ–‚[38;2;2;7;10;48;2;7;95;142mâ–…[38;2;0;0;0;48;2;0;1;1mâ”ˆ[38;2;3;4;4;48;2;88;96;96mâ–…[38;2;53;57;57;48;2;136;150;149mâ–ƒ[38;2;140;154;154;48;2;139;153;153mâ•´[48;2;139;154;154m [48;2;139;153;153mâ”ˆ[48;2;135;149;149mâ”ˆ[38;2;121;133;133;48;2;17;18;18mâ–…[38;2;61;67;67;48;2;1;1;1mâ–‚[48;2;0;0;0m         [0m
[7m[38;2;0;0;0m [0m[38;2;7;55;79;48;2;1;3;4mâ–[38;2;4;114;172;48;2;4;19;27mâ–„[38;2;9;127;189;48;2;7;85;124mâ–‡[38;2;47;135;180;48;2;21;131;188mâ•Œ[38;2;7;129;193;48;2;53;137;178mâ–‡[38;2;0;128;196;48;2;2;128;194mâ”Š[38;2;8;41;59;48;2;2;119;182mâ–‚[38;2;1;6;8;48;2;7;91;135mâ–…[48;2;0;0;0m     [38;2;3;3;3;48;2;88;95;95mâ–…[38;2;52;56;56;48;2;136;149;149mâ–ƒ[38;2;139;154;154;48;2;139;154;153mâ”ˆ[38;2;140;154;154;48;2;139;154;154mâ”ˆ[48;2;139;153;153mâ”ˆ[48;2;136;149;149mâ”ˆ[38;2;122;134;134;48;2;18;20;19mâ–…[38;2;64;69;68;48;2;2;2;2mâ–‚[48;2;0;0;0m       [0m
[38;2;8;97;144;48;2;5;20;29mâ–—[38;2;3;125;191;48;2;8;87;129mâ–‡[38;2;54;137;178;48;2;18;131;189mâ•º[38;2;10;129;192;48;2;50;136;179mâ–†[38;2;0;128;196;48;2;2;128;195mâ”ˆ[38;2;11;110;162;48;2;1;126;194mâ•¶[38;2;7;101;152;48;2;5;31;46mâ–˜[48;2;0;0;0m         [38;2;3;3;3;48;2;87;94;94mâ–…[38;2;51;55;55;48;2;135;149;149mâ–ƒ[38;2;140;154;154;48;2;139;154;153mâ”ˆ[48;2;139;154;154mâ”Š[48;2;140;154;154m [48;2;136;150;150mâ•´[38;2;123;135;135;48;2;20;22;21mâ–…[38;2;67;72;72;48;2;2;2;2mâ–‚[48;2;0;0;0m     [0m
[7m[38;2;0;0;0m [0m[38;2;1;3;4;48;2;8;80;120mâ–…[38;2;7;48;69;48;2;1;123;189mâ–ƒ[38;2;0;127;196;48;2;0;127;195mâ”ˆ[38;2;0;128;196mâ”ˆ [38;2;0;127;196;48;2;1;123;188mâ”ˆ[38;2;4;110;168;48;2;4;16;22mâ–…[38;2;8;56;82;48;2;0;1;2mâ––[48;2;0;0;0m         [38;2;3;3;3;48;2;86;94;93mâ–…[38;2;51;54;54;48;2;135;149;149mâ–ƒ[38;2;139;154;154;48;2;139;153;153mâ”„[38;2;140;154;154;48;2;139;154;154mâ”ˆ[48;2;140;154;154m [48;2;136;150;150mâ”ˆ[38;2;125;137;136;48;2;22;24;24mâ–…[38;2;69;75;75;48;2;2;3;3mâ–‚[48;2;0;0;0m   [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m  [38;2;2;10;14;48;2;7;94;140mâ–†[38;2;7;44;65;48;2;2;123;188mâ–ƒ[38;2;0;127;194;48;2;0;127;195mâ•´[48;2;0;128;196m [38;2;0;128;196;48;2;0;128;195mâ–‰[48;2;1;124;189mâ”ˆ[38;2;3;112;170;48;2;4;18;25mâ–…[38;2;8;62;90;48;2;0;2;3mâ–‚[48;2;0;0;0m         [38;2;11;11;11;48;2;103;113;112mâ–†[38;2;50;54;54;48;2;135;149;149mâ–ƒ[38;2;140;154;154;48;2;139;153;153mâ”ˆ[48;2;139;154;154mâ”Š[48;2;139;153;153mâ”ˆ[48;2;137;151;150mâ”ˆ[38;2;126;138;138;48;2;23;25;25mâ–…[38;2;72;78;77;48;2;3;3;3mâ–‚[48;2;0;0;0m [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m    [38;2;2;9;13;48;2;8;91;135mâ–†[38;2;7;43;62;48;2;2;122;186mâ–ƒ[48;2;0;127;195m [38;2;0;128;196mâ”ˆ[38;2;0;128;194;48;2;0;128;196mâ”Š[38;2;1;127;195;48;2;1;124;191mâ”Š[38;2;3;114;173;48;2;4;20;29mâ–…[38;2;9;65;96;48;2;1;3;3mâ–‚[48;2;0;0;0m        [38;2;0;0;0;48;2;2;2;2mâ”ˆ[38;2;42;45;45;48;2;109;120;120mâ–[38;2;139;153;153;48;2;140;154;154mâ–  [38;2;140;154;154;48;2;139;153;153mâ”ˆ[38;2;89;97;97;48;2;135;148;148mâ–[38;2;124;135;134;48;2;15;16;16mâ•¸[0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m      [38;2;2;8;12;48;2;8;89;132mâ–†[38;2;7;40;58;48;2;2;122;186mâ–ƒ[48;2;0;127;195m [38;2;0;127;195;48;2;0;128;196mâ–[38;2;0;128;196;48;2;0;127;195mâ”ˆ[48;2;1;125;191mâ”ˆ[38;2;3;115;175;48;2;5;23;33mâ–…[38;2;8;69;102;48;2;1;3;4mâ–‚[48;2;0;0;0m    [38;2;0;0;0;48;2;2;2;2mâ”ˆ[38;2;117;128;128;48;2;14;15;15mâ–ƒ[38;2;136;150;150;48;2;69;75;75mâ–†[38;2;140;154;154;48;2;139;154;153mâ–…[38;2;139;154;153;48;2;140;154;154mâ–[38;2;140;154;154;48;2;139;153;153mâ”ˆ[38;2;87;95;94;48;2;137;150;150mâ–[38;2;17;18;18;48;2;122;134;134mâ–„[38;2;2;2;2;48;2;54;58;57mâ–‡[48;2;0;0;0m [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m        [38;2;2;7;10;48;2;9;86;127mâ–†[38;2;7;38;54;48;2;2;121;185mâ–ƒ[48;2;0;127;195m [48;2;0;128;196m  [48;2;1;126;193m [38;2;3;117;178;48;2;5;26;38mâ–…[38;2;7;74;109;48;2;1;4;6mâ–‚[38;2;0;0;0;48;2;2;3;3mâ”ˆ[38;2;118;129;129;48;2;15;16;16mâ–ƒ[38;2;137;150;150;48;2;71;77;77mâ–†[48;2;139;154;153m [48;2;140;154;154m  [38;2;84;91;90;48;2;136;150;150mâ–[38;2;16;17;17;48;2;121;133;132mâ–„[38;2;2;2;2;48;2;51;55;55mâ–‡[48;2;0;0;0m   [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [38;2;8;84;124;48;2;2;7;10mâ–[38;2;7;36;51;48;2;3;121;184mâ–ƒ[38;2;0;127;196;48;2;0;127;194mâ”ˆ[38;2;0;128;196;48;2;0;127;195mâ”ˆ [48;2;0;126;193mâ”ˆ[38;2;98;142;160;48;2;56;64;64mâ–‡[38;2;139;154;154;48;2;140;153;153mâ”Š[38;2;140;154;154;48;2;139;154;153mâ”ˆ[48;2;139;154;154mâ”ˆ[38;2;81;88;88;48;2;136;150;149mâ–[38;2;15;16;16;48;2;119;131;131mâ–„[38;2;2;2;2;48;2;49;52;52mâ–‡[48;2;0;0;0m     [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m            [38;2;5;9;12;48;2;8;82;120mâ–†[38;2;18;65;88;48;2;22;110;157mâ•´[38;2;0;127;195;48;2;1;127;194mâ”Š[38;2;0;128;196;48;2;0;127;195mâ–‰[38;2;6;125;187;48;2;130;153;158mâ–[38;2;140;154;153;48;2;140;154;154mâ–[38;2;79;86;86;48;2;136;149;149mâ–[38;2;14;14;14;48;2;119;130;129mâ–„[38;2;1;1;1;48;2;46;49;49mâ–‡[48;2;0;0;0m       [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [48;2;4;4;4mâ”ˆ[38;2;123;135;135;48;2;18;20;20mâ–ƒ[38;2;130;142;142;48;2;51;52;54mâ–†[38;2;133;147;147;48;2;83;90;89mâ–„[38;2;99;113;116;48;2;33;110;150mâ–†[38;2;77;111;127;48;2;6;123;186mâ–ƒ[38;2;42;70;83;48;2;95;141;160mâ–[38;2;12;13;13;48;2;117;128;128mâ–„[38;2;1;1;1;48;2;44;47;47mâ–‡[48;2;0;0;0m         [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [38;2;12;13;13;48;2;140;153;152mâ–‹[38;2;139;154;153;48;2;139;154;154mâ–[48;2;140;154;154mâ–[38;2;139;153;153mâ–[38;2;75;81;81;48;2;135;148;148mâ–[38;2;12;13;13;48;2;115;126;126mâ–„[38;2;0;0;0;48;2;5;6;6mâ”ˆ[48;2;0;0;0m           [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [38;2;12;13;13;48;2;140;153;153mâ–‹[48;2;140;154;154m [38;2;72;78;77;48;2;134;148;147mâ–[38;2;11;11;11;48;2;114;125;125mâ–„[38;2;0;0;0;48;2;6;6;6mâ”ˆ[48;2;0;0;0m             [0m
[7m[38;2;0;0;0m [0m[38;2;0;0;0;48;2;0;0;0m          [38;2;10;11;11;48;2;109;119;118mâ–‹[38;2;10;10;10;48;2;113;123;123mâ–„[38;2;0;0;0;48;2;5;6;6mâ”ˆ[48;2;0;0;0m               [0m



================================================
FILE: images/logos_txt/home_labsclub.txt
================================================
[0m [38;2;0;0;0m               [0m [38;2;108;108;108mâ–„[38;2;124;124;124;48;2;17;17;17mâ–‡[0m[38;2;122;122;122mâ–…[38;2;86;86;86mâ––              [0m
 [38;2;0;0;0m           [38;2;245;245;245mâ–—[38;2;250;250;250mâ–‡[38;2;255;255;255;48;2;175;175;175mâ–‡[0m[7m[38;2;182;182;182mâ–[0m [7m[38;2;117;117;117mâ–„[38;2;124;124;124mâ–…[38;2;118;118;118mâ–ƒ[0m[38;2;128;128;128;48;2;126;126;126mâ”ˆ[0m[38;2;121;121;121mâ–…[38;2;83;83;83mâ––            [0m
 [38;2;0;0;0m           [38;2;130;130;130mâ–[7m[38;2;229;229;229mâ–ƒ[38;2;247;247;247mâ–ƒ[0m[38;2;221;221;221mâ–˜[7m[38;2;6;145;181mâ–‹[0m[38;2;0;203;254;48;2;1;202;252mâ”Š[38;2;0;204;255;48;2;0;203;254mâ”ˆ[0m[38;2;8;155;193mâ–Œ[38;2;76;76;76mâ–[7m[38;2;119;119;119mâ–ƒ[0m[38;2;32;32;32;48;2;127;127;127m [0m[38;2;122;122;122mâ–…[38;2;116;116;116mâ–†[38;2;127;127;127mâ–†â–†â–†â–†â–†[38;2;117;117;117mâ–†[0m [38;2;61;61;61m   [0m
 [38;2;0;0;0m           [0m [38;2;112;179;2mâ–…[38;2;124;197;2mâ–†[38;2;110;175;2mâ–…[0m [7m[38;2;4;186;232mâ–†[38;2;3;198;248mâ–†[0m [38;2;0;0;0m  [38;2;80;80;80mâ–[7m[38;2;121;121;121mâ–ƒ[0m[38;2;128;128;128;48;2;127;127;127mâ”ˆ[0m[38;2;124;124;124mâ–Š[7m[38;2;128;128;128mâ–†â–†â–†[38;2;127;127;127mâ–[0m[38;2;39;39;39;48;2;128;128;128m [0m[38;2;96;96;96mâ–   [0m
 [38;2;0;0;0m           [0m [7m[38;2;126;201;0mâ–‚[0m[38;2;53;84;3;48;2;128;204;1m [0m[7m[38;2;124;198;0mâ–‚[0m [38;2;62;99;3m       [7m[38;2;93;93;93mâ–‡[0m [38;2;0;0;0m   [7m[38;2;127;127;127mâ–[0m[38;2;4;4;4;48;2;128;128;128m [0m[38;2;96;96;96mâ–   [0m
 [38;2;0;0;0m     [0m [38;2;112;112;112mâ–ƒ[38;2;127;127;127mâ–…[38;2;105;105;105mâ–– [38;2;9;160;200mâ–[38;2;0;204;255mâ–â–â–â–â–â–â–â–[38;2;3;186;232mâ–[0m [38;2;0;0;0m       [7m[38;2;127;127;127mâ–[0m[38;2;4;4;4;48;2;128;128;128m [0m[38;2;96;96;96mâ–   [0m
 [38;2;0;0;0m   [0m [38;2;110;110;110mâ–ƒ[38;2;71;71;71;48;2;126;126;126mâ–˜[38;2;76;76;76;48;2;125;125;125mâ–[0m[7m[38;2;109;109;109mâ–„[0m [7m[38;2;5;124;154mâ–Š[38;2;3;196;245mâ–[0m[38;2;0;204;255;48;2;0;199;249mâ”ˆ[48;2;0;204;255m [0m[7m[38;2;0;204;255mâ–â–â–â–[0m[38;2;4;35;43;48;2;0;204;255m [38;2;0;204;255;48;2;0;203;253mâ”ˆ[0m[7m[38;2;1;202;252mâ–[0m[38;2;5;143;179mâ–       [7m[38;2;101;101;101mâ–[0m[38;2;128;128;128;48;2;127;127;127mâ”ˆ[0m[7m[38;2;110;110;110mâ–[0m[38;2;65;65;65mâ––  [0m
 [38;2;0;0;0m [0m [38;2;108;108;108mâ–ƒ[38;2;67;67;67;48;2;125;125;125mâ–˜[38;2;80;80;80mâ–[0m[7m[38;2;111;111;111mâ–„[0m [38;2;1;1;1m    [7m[38;2;1;203;255mâ–[0m[38;2;0;204;255;48;2;1;203;254mâ–‰[0m[38;2;8;182;228mâ–[38;2;3;203;254mâ–[38;2;9;163;203mâ–[7m[38;2;25;100;121mâ–‰[0m[38;2;5;203;255;48;2;0;204;255mâ–[38;2;1;203;254;48;2;23;122;151mâ–‰[0m[38;2;1;203;254m          [38;2;94;94;94mâ–[7m[38;2;117;117;117mâ––[0m[38;2;128;128;128;48;2;125;125;125mâ”ˆ[0m[38;2;114;114;114mâ–…[0m [0m
 [38;2;0;0;0m [7m[38;2;111;111;111mâ–‹[0m[38;2;0;0;0;48;2;128;128;128m [0m[38;2;127;127;127mâ–‹[0m [38;2;2;2;2m   [0m [38;2;5;171;213mâ–ƒ[38;2;2;184;229mâ–…[38;2;2;139;173;48;2;1;198;248mâ–[38;2;1;203;254;48;2;0;203;254mâ–[0m[38;2;6;184;230mâ–[7m[38;2;2;203;254mâ–‡[38;2;5;165;206mâ–‡[38;2;24;100;121mâ–‰[0m[38;2;9;203;254;48;2;0;203;254mâ–[38;2;0;204;255;48;2;2;202;252mâ”ˆ[0m[38;2;2;192;240mâ–…[38;2;3;184;230mâ–ƒ[38;2;6;113;141mâ–         [38;2;100;100;100mâ–[48;2;128;128;128m [38;2;128;128;128;48;2;105;105;105mâ•´[0m
 [38;2;0;0;0m [38;2;84;84;84mâ–[7m[38;2;127;127;127mâ–‚[0m[38;2;128;128;128mâ–˜  [38;2;5;115;143mâ–—[38;2;2;188;235mâ–…[38;2;0;204;255;48;2;2;196;245mâ”ˆ[0m[7m[38;2;1;201;252mâ–‚[38;2;2;195;244mâ–„[38;2;4;199;248mâ–†[38;2;10;185;232mâ–‡[0m [38;2;0;0;0m   [7m[38;2;11;164;205mâ–‡[38;2;6;190;238mâ–†[38;2;3;190;238mâ–„[38;2;1;198;247mâ–‚[0m[38;2;0;204;255;48;2;1;201;251mâ”ˆ[0m[38;2;2;197;246mâ–…[38;2;6;129;161mâ–ƒ       [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[38;2;87;138;3mâ–‚[38;2;118;187;5mâ–ƒ[38;2;112;178;2mâ–ƒ[38;2;111;177;1mâ–ƒ[38;2;111;177;2mâ–ƒ[38;2;111;177;3mâ–ƒ[38;2;111;177;2mâ–ƒ[38;2;67;107;1;48;2;4;164;205mâ–…[38;2;56;105;22;48;2;0;204;255mâ–†[0m[7m[38;2;5;157;196mâ–†[0m[38;2;122;191;8mâ–ƒâ–ƒ[38;2;116;183;4mâ–ƒ[38;2;111;177;2mâ–ƒ[38;2;111;176;2mâ–ƒ[38;2;107;170;4mâ–‚      [7m[38;2;4;126;157mâ–†[38;2;2;179;223mâ––[0m[38;2;0;204;255;48;2;1;203;254mâ”ˆ[0m[7m[38;2;3;174;217mâ–[0m [38;2;0;0;0m     [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;127;203;2mâ–[0m[38;2;10;14;5;48;2;129;206;0m         [38;2;245;250;238;48;2;147;212;41mâ•º[38;2;225;242;196;48;2;145;210;38mâ–†[38;2;225;242;197;48;2;144;211;35mâ–†[38;2;225;242;196;48;2;144;211;33mâ–†[38;2;206;235;159;48;2;140;208;29mâ–†[38;2;128;206;0;48;2;128;205;0mâ”ˆ[0m [38;2;15;21;6m       [38;2;4;194;242mâ–[38;2;0;204;255;48;2;1;201;251mâ”Š[0m[7m[38;2;3;198;248mâ–[0m [38;2;0;0;0m    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;79;125;4mâ”[38;2;128;204;1mâ”[38;2;128;205;0mâ”â”[38;2;127;203;0mâ”[38;2;126;201;1mâ”[38;2;126;201;0mâ”â”[38;2;126;202;0mâ”[38;2;126;201;0mâ”â”[38;2;126;202;0mâ”[38;2;126;201;0mâ”[38;2;126;202;0mâ”[38;2;126;201;2mâ”[38;2;94;150;4mâ”[0m[38;2;0;0;0m         [7m[38;2;4;175;219mâ–Œ[0m[38;2;0;204;255;48;2;0;203;254mâ”ˆ[0m[38;2;4;185;232mâ–Œ    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;128;205;0mâ–[0m[38;2;34;51;6;48;2;129;206;0m         [38;2;240;247;228;48;2;145;212;36mâ•º[38;2;139;209;26;48;2;219;240;184mâ–‚[38;2;142;210;31;48;2;220;241;188mâ–‚[38;2;143;211;34;48;2;220;241;186mâ–‚[38;2;231;245;207;48;2;170;221;87mâ”[38;2;129;206;1;48;2;128;205;0mâ”Š[0m [38;2;44;69;6m        [7m[38;2;7;159;199mâ–‰[0m[38;2;4;203;253;48;2;0;203;254mâ–[0m[38;2;1;198;248mâ–‰    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;76;121;3mâ”[38;2;123;196;1mâ”[38;2;127;202;4mâ”[38;2;125;200;3mâ”[38;2;125;200;2mâ”â”[38;2;125;200;1mâ”[38;2;125;200;2mâ”[38;2;125;200;3mâ”[38;2;126;200;4mâ”[38;2;126;200;5mâ”[38;2;126;200;4mâ”[38;2;125;199;1mâ”[38;2;127;202;2mâ”[38;2;128;204;2mâ”[38;2;96;153;4mâ”[0m[38;2;0;0;0m         [7m[38;2;8;176;219mâ–‰[0m[38;2;0;204;255;48;2;1;203;254mâ”Š[0m[38;2;1;195;244mâ–‰    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;128;205;0mâ–[0m[38;2;254;254;254;48;2;151;213;48mâ•º[38;2;252;253;249;48;2;144;211;35mâ•¸[38;2;254;253;252;48;2;157;216;61mâ•º[38;2;237;246;220;48;2;140;210;27mâ•¸[48;2;129;206;0m          [38;2;129;206;0;48;2;128;205;0mâ”ˆ[0m [38;2;53;83;6m        [7m[38;2;3;184;230mâ–Œ[0m[38;2;0;204;255;48;2;0;203;254mâ”ˆ[0m[38;2;3;175;219mâ–Œ    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
[7m[38;2;89;142;3mâ–†[38;2;117;187;1mâ–…[38;2;120;190;4mâ–…[38;2;122;192;7mâ–…â–…[38;2;115;183;3mâ–…[38;2;113;180;2mâ–…[38;2;106;169;2mâ––[38;2;117;187;2mâ–—[38;2;113;180;2mâ–…â–…[38;2;115;183;3mâ–…[38;2;120;190;4mâ–…[38;2;119;189;3mâ–…[38;2;116;184;3mâ–…[38;2;111;177;3mâ–†[0m[38;2;5;8;0m       [0m [38;2;2;203;254mâ–—[38;2;0;204;255;48;2;0;203;254mâ”ˆ[0m[7m[38;2;3;189;236mâ–—[0m [38;2;0;0;0m    [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
 [38;2;103;163;6mâ–[38;2;87;138;6mâ–˜[38;2;118;188;7mâ–˜[7m[38;2;102;163;5mâ–„[38;2;127;202;5mâ–„[38;2;127;203;5mâ–„[38;2;117;187;3mâ–ƒ[38;2;121;194;2mâ–ƒ[38;2;124;198;4mâ–„[38;2;128;204;5mâ–„[38;2;120;191;5mâ–„[0m[38;2;114;181;7mâ–[7m[38;2;67;106;5mâ–…[0m[38;2;118;188;5mâ–˜      [0m [38;2;6;166;207mâ–‚[7m[38;2;3;191;239mâ–˜[0m[38;2;0;204;255;48;2;2;201;251mâ•´[0m[7m[38;2;3;180;225mâ–„[0m [38;2;0;0;0m     [7m[38;2;128;128;128mâ–‰[0m[38;2;2;2;2;48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
 [38;2;0;0;0m      [0m [7m[38;2;5;153;192mâ–ƒ[38;2;2;191;238mâ–[0m[38;2;2;200;250mâ–‡[38;2;2;195;244mâ–…[38;2;3;196;245mâ–ƒ[38;2;4;180;225mâ–‚[38;2;4;184;230mâ–[38;2;3;110;137mâ–[38;2;2;105;131mâ–[38;2;8;176;221mâ–[38;2;4;170;212mâ–‚[38;2;3;190;238mâ–ƒ[38;2;2;188;235mâ–…[38;2;1;196;245mâ–‡[38;2;7;131;163;48;2;1;202;253mâ–[0m[7m[38;2;4;184;231mâ–ƒ[0m[38;2;7;115;143mâ–˜[38;2;128;128;128mâ–â–â–â–â–â–â–â–[48;2;128;128;128m [38;2;124;124;124;48;2;0;0;0mâ–‰[0m
 [38;2;0;0;0m        [0m [7m[38;2;6;166;207mâ–†[38;2;3;185;232mâ–„[38;2;1;201;251mâ–ƒ[38;2;1;203;254mâ–‚[38;2;1;202;253mâ–[0m[38;2;11;98;121;48;2;0;203;254mâ–[38;2;11;104;129mâ–[0m[7m[38;2;1;203;254mâ–â–‚â–ƒ[38;2;1;195;244mâ–„[38;2;4;187;233mâ–†[0m [7m[38;2;79;79;79mâ–Š[38;2;127;127;127mâ–‚[0m[38;2;0;0;0;48;2;123;123;123mâ–â–â–â–â–â–â–â–â–[38;2;9;9;9;48;2;98;98;98mâ–‚[0m



================================================
FILE: images/logos_txt/logo.txt
================================================
[0m[38;2;61;61;61mâ–†[38;2;60;60;60mâ–„[38;2;54;54;54mâ–‚[0m [38;2;0;0;0m                            [0m [38;2;54;54;54mâ–‚[38;2;60;60;60mâ–„[38;2;61;61;61mâ–†[0m
[38;2;57;57;57;48;2;62;62;62mâ–  [38;2;61;61;61;48;2;39;39;39mâ–‡[0m[38;2;60;60;60mâ–…[38;2;57;57;57mâ–ƒ[38;2;40;40;40mâ–                      [38;2;39;39;39mâ–[38;2;57;57;57mâ–ƒ[38;2;60;60;60mâ–…[38;2;61;61;61;48;2;38;38;38mâ–‡[48;2;62;62;62m  [38;2;62;62;62;48;2;58;58;58mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–     [38;2;62;62;62;48;2;61;61;61mâ”ˆ[0m[38;2;61;61;61mâ–†[38;2;58;58;58mâ–„[38;2;50;50;50mâ–‚                â–‚[38;2;58;58;58mâ–„[38;2;60;60;60mâ–†[38;2;62;62;62;48;2;61;61;61mâ”ˆ[48;2;62;62;62m     [48;2;57;57;57mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–         [38;2;61;61;61;48;2;33;32;32mâ–‡[0m[38;2;59;59;59mâ–…[38;2;55;55;55mâ–ƒ[38;2;33;33;33mâ–        [38;2;32;32;32mâ–[38;2;54;54;54mâ–ƒ[38;2;59;59;59mâ–…[38;2;61;61;61;48;2;32;31;31mâ–‡[48;2;62;62;62m      [38;2;62;62;62;48;2;60;60;60mâ”ˆ[0m[7m[38;2;58;58;58mâ–‚[38;2;53;53;53mâ–„[38;2;38;38;38mâ–†[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[7m[38;2;61;61;61mâ–ƒ[38;2;60;60;60mâ–[0m[38;2;28;28;28;48;2;62;62;62m      [38;2;62;62;62;48;2;61;61;61mâ”ˆ[0m[38;2;60;60;60mâ–†[38;2;57;57;57mâ–„[38;2;46;46;46mâ–‚  [38;2;45;45;45mâ–‚[38;2;56;56;56mâ–„[38;2;60;60;60mâ–†[38;2;62;62;62;48;2;61;61;61mâ”ˆ[48;2;62;62;62m      [0m[7m[38;2;60;60;60mâ–[38;2;57;57;57mâ–ƒ[38;2;51;51;51mâ–…[0m [38;2;0;0;0m   [0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ– [7m[38;2;48;48;48mâ–†[38;2;57;57;57mâ–„[38;2;60;60;60mâ–‚[0m[38;2;62;62;62;48;2;61;61;61mâ”ˆ[48;2;62;62;62m      [0m[38;2;60;60;60mâ–‡â–‡[48;2;62;62;62m      [38;2;62;62;62;48;2;61;61;61mâ”ˆ[0m[7m[38;2;60;60;60mâ–‚[38;2;57;57;57mâ–„[38;2;46;46;46mâ–†[0m[38;2;1;1;1m   [0m [38;2;211;65;2mâ–‚[38;2;206;64;2mâ–…[38;2;218;68;2mâ–‡[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–    [7m[38;2;35;35;35mâ–‡[38;2;55;55;55mâ–…[38;2;60;60;60mâ–ƒ[0m[38;2;34;34;34;48;2;61;61;61mâ–[48;2;62;62;62m        [48;2;61;61;61mâ–[0m[7m[38;2;59;59;59mâ–ƒ[38;2;55;55;55mâ–…[38;2;34;34;34mâ–‡[0m[38;2;1;1;1m   [38;2;165;51;1mâ–[38;2;219;68;2mâ–ƒ[38;2;211;65;2mâ–†[38;2;230;71;2;48;2;161;49;1mâ–‡[48;2;231;72;3m  [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–  [38;2;215;66;2mâ–—[38;2;201;62;2mâ–‚[0m [38;2;0;0;0m  [0m [7m[38;2;52;52;52mâ–†[38;2;59;59;59mâ–„[38;2;61;61;61mâ–‚[0m[38;2;62;62;62;48;2;61;61;61mâ”ˆâ”ˆ[0m[7m[38;2;61;61;61mâ–‚[38;2;59;59;59mâ–„[38;2;52;52;52mâ–†[0m [38;2;0;0;0m  [0m [38;2;198;61;2mâ–‚[38;2;222;69;2mâ–„[38;2;228;71;2mâ–†[38;2;231;72;3;48;2;230;71;3mâ”ˆ[48;2;231;72;3m     [48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–  [7m[38;2;230;71;2mâ–Œ[0m[38;2;17;5;0;48;2;231;72;3m [38;2;229;71;2;48;2;140;43;1mâ–‡[0m[38;2;225;70;2mâ–…[38;2;212;65;2mâ–ƒ[38;2;143;44;1mâ–   [7m[38;2;42;42;42mâ–‡[38;2;43;43;43mâ–‡[0m[38;2;2;2;2m   [38;2;139;43;1mâ–[38;2;210;65;2mâ–ƒ[38;2;225;70;2mâ–…[38;2;229;71;2;48;2;136;42;1mâ–‡[48;2;231;72;3m         [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–  [7m[38;2;230;71;2mâ–Œ[0m[38;2;17;5;0;48;2;231;72;3m    [38;2;231;72;3;48;2;230;71;2mâ”ˆ[0m[38;2;227;70;2mâ–†[38;2;218;67;2mâ–„[38;2;186;57;1mâ–‚[0m  [38;2;183;56;2mâ–‚[38;2;217;67;2mâ–„[38;2;226;70;2mâ–†[38;2;231;72;3;48;2;229;71;2mâ”ˆ[48;2;231;72;3m      [0m[7m[38;2;225;70;2mâ–[38;2;226;70;2mâ–ƒ[0m[38;2;78;24;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–  [38;2;229;71;2mâ–[7m[38;2;223;69;2mâ–‚[0m[38;2;231;72;3;48;2;228;71;2mâ”ˆ[48;2;231;72;3m      [0m[38;2;227;70;2mâ–‡â–‡[48;2;231;72;3m      [38;2;231;72;3;48;2;228;71;2mâ”ˆ[0m[7m[38;2;223;69;2mâ–‚[38;2;211;65;2mâ–„[38;2;170;52;1mâ–†[0m [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–    [7m[38;2;117;36;1mâ–‡[38;2;202;62;2mâ–…[38;2;220;68;2mâ–ƒ[38;2;227;70;2mâ–[0m[38;2;114;35;1;48;2;231;72;3m        [38;2;118;36;1;48;2;228;71;2mâ–[0m[7m[38;2;221;68;2mâ–ƒ[38;2;203;63;2mâ–…[38;2;122;37;1mâ–‡[0m[38;2;3;1;0m    [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–       [0m [7m[38;2;185;57;2mâ–†[38;2;217;67;2mâ–„[38;2;226;70;2mâ–‚[0m[38;2;231;72;3;48;2;229;71;2mâ”ˆ[48;2;230;71;2mâ”ˆ[0m[7m[38;2;227;70;2mâ–‚[38;2;218;68;2mâ–„[38;2;188;58;2mâ–†[0m [38;2;0;0;0m       [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–           [7m[38;2;142;44;1mâ–‡[38;2;146;45;1mâ–‡[0m[38;2;6;2;0m           [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[38;2;57;57;57;48;2;62;62;62mâ–    [0m[38;2;59;59;59mâ–                        [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m    [38;2;231;72;3;48;2;221;68;2mâ–‰[0m
[7m[38;2;57;57;57mâ–ƒ[38;2;60;60;60mâ–[0m[38;2;24;24;24;48;2;62;62;62m   [0m[38;2;59;59;59mâ–                        [7m[38;2;218;67;2mâ–Š[0m[38;2;3;1;0;48;2;231;72;3m   [0m[7m[38;2;225;70;2mâ–[38;2;215;67;2mâ–ƒ[0m
 [38;2;0;0;0m [7m[38;2;44;44;44mâ–†[38;2;56;56;56mâ–„[38;2;59;59;59mâ–‚[0m[38;2;55;55;55mâ–                        [7m[38;2;205;63;2mâ–Š[38;2;222;69;2mâ–‚[38;2;210;65;2mâ–„[38;2;167;52;1mâ–†[0m [38;2;0;0;0m [0m



================================================
FILE: images/logos_txt/ProxMenux.txt
================================================
[0m[38;2;43;43;43mâ–†[38;2;47;47;47mâ–ƒ[0m [38;2;19;19;19m                              [0m [38;2;47;47;47mâ–ƒ[38;2;43;43;43mâ–†[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m [38;2;51;51;51;48;2;48;48;48mâ”ˆ[0m[38;2;46;46;46mâ–…[38;2;37;37;37mâ–‚                          â–‚[38;2;46;46;46mâ–…[38;2;51;51;51;48;2;48;48;48mâ”ˆ[48;2;51;51;51m [0m[38;2;49;49;49mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m   [38;2;51;51;51;48;2;50;50;50mâ”ˆ[0m[38;2;49;49;49mâ–†[38;2;46;46;46mâ–ƒ[0m [38;2;18;18;18m                    [0m [38;2;46;46;46mâ–ƒ[38;2;49;49;49mâ–†[38;2;51;51;51;48;2;50;50;50mâ”ˆ[48;2;51;51;51m   [0m[38;2;49;49;49mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m      [38;2;50;50;50;48;2;34;34;34mâ–‡[0m[38;2;46;46;46mâ–…[38;2;35;35;35mâ–‚                â–‚[38;2;46;46;46mâ–…[38;2;50;50;50;48;2;34;34;34mâ–‡[48;2;51;51;51m      [0m[38;2;49;49;49mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m         [0m[38;2;49;49;49mâ–†[38;2;45;45;45mâ–ƒ[0m [38;2;17;17;17m          [0m [38;2;45;45;45mâ–ƒ[38;2;49;49;49mâ–†[48;2;51;51;51m       [38;2;51;51;51;48;2;48;48;48mâ”ˆ[0m[7m[38;2;46;46;46mâ–ƒ[38;2;33;33;33mâ–†[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m           [38;2;50;50;50;48;2;33;33;33mâ–‡[0m[38;2;45;45;45mâ–…[38;2;33;33;33mâ–‚      â–‚[38;2;45;45;45mâ–…[38;2;50;50;50;48;2;33;33;33mâ–‡[48;2;51;51;51m      [38;2;51;51;51;48;2;50;50;50mâ”ˆ[0m[7m[38;2;49;49;49mâ–‚[38;2;46;46;46mâ–…[0m [38;2;0;0;0m [0m [0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [38;2;38;38;38mâ–[38;2;51;51;51;48;2;49;49;49mâ”ˆ[48;2;51;51;51m      [48;2;50;50;50mâ”ˆ[0m[38;2;48;48;48mâ–†[38;2;45;45;45mâ–ƒ[0m  [38;2;45;45;45mâ–ƒ[38;2;48;48;48mâ–†[38;2;51;51;51;48;2;50;50;50mâ”ˆ[48;2;51;51;51m      [48;2;49;49;49mâ”ˆ[0m[7m[38;2;46;46;46mâ–ƒ[38;2;37;37;37mâ–†[0m[38;2;2;2;2m  [38;2;144;55;24mâ–‚[38;2;224;86;39mâ–„[38;2;213;82;37mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;47;47;47mâ–[0m [7m[38;2;41;41;41mâ–„[38;2;49;49;49mâ–‚[0m[38;2;20;20;20;48;2;51;51;51m       [38;2;51;51;51;48;2;42;42;42mâ–‡â–‡[48;2;51;51;51m       [0m[7m[38;2;49;49;49mâ–‚[38;2;47;47;47mâ–…[0m [38;2;0;0;0m [0m [38;2;200;77;34mâ–ƒ[38;2;221;85;38mâ–†[38;2;235;91;41;48;2;234;90;40mâ”ˆ[48;2;235;91;41m [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–   [7m[38;2;38;38;38mâ–†[38;2;47;47;47mâ–ƒ[0m[38;2;51;51;51;48;2;49;49;49mâ”ˆ[48;2;51;51;51m          [48;2;49;49;49mâ”ˆ[0m[7m[38;2;47;47;47mâ–ƒ[38;2;39;39;39mâ–†[0m[38;2;3;3;3m  [38;2;133;51;22mâ–‚[38;2;221;85;38mâ–„[38;2;231;89;40;48;2;135;52;23mâ–‡[48;2;235;91;41m    [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–  [38;2;138;53;23mâ–ƒ[0m [38;2;0;0;0m [0m [7m[38;2;42;42;42mâ–„[38;2;50;50;50mâ–‚[0m[38;2;21;21;21;48;2;51;51;51m      [0m[7m[38;2;50;50;50mâ–‚[38;2;42;42;42mâ–„[0m [38;2;0;0;0m [0m [38;2;193;74;33mâ–ƒ[38;2;218;84;37mâ–†[38;2;235;91;41;48;2;234;90;40mâ”ˆ[48;2;235;91;41m      [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–  [7m[38;2;228;88;39mâ–[0m[38;2;230;89;40;48;2;120;46;20mâ–‡[0m[38;2;219;84;38mâ–„[38;2;128;49;22mâ–‚  [7m[38;2;40;40;40mâ–†[38;2;47;47;47mâ–ƒ[0m[38;2;51;51;51;48;2;49;49;49mâ”ˆâ”ˆ[0m[7m[38;2;47;47;47mâ–ƒ[38;2;40;40;40mâ–†[0m[38;2;3;3;3m  [38;2;128;49;22mâ–‚[38;2;219;84;38mâ–„[38;2;229;88;39;48;2;120;46;20mâ–‡[48;2;235;91;41m         [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–  [7m[38;2;228;88;39mâ–[0m[38;2;25;10;4;48;2;235;91;41m  [38;2;235;91;41;48;2;233;90;40mâ”ˆ[0m[38;2;217;84;37mâ–†[38;2;192;74;33mâ–ƒ[0m [38;2;0;0;0m [0m  [38;2;0;0;0m [0m [38;2;192;74;33mâ–ƒ[38;2;217;84;37mâ–†[38;2;235;91;41;48;2;233;90;40mâ”ˆ[48;2;235;91;41m           [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–  [7m[38;2;228;88;39mâ–[0m[38;2;25;10;4;48;2;235;91;41m     [38;2;228;88;39;48;2;120;46;20mâ–‡[0m[38;2;219;84;38mâ–„[38;2;146;56;25mâ–‚[38;2;143;55;24mâ–‚[38;2;219;84;38mâ–„[38;2;228;88;39mâ–‡[48;2;235;91;41m       [38;2;127;49;22;48;2;233;90;40mâ–[38;2;150;59;27mâ–[48;2;235;91;41m     [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–  [7m[38;2;178;68;30mâ–[0m[38;2;235;91;41;48;2;233;90;40mâ”ˆ[48;2;235;91;41m              [48;2;233;90;40mâ”ˆ[0m[7m[38;2;216;83;37mâ–‚[38;2;192;74;33mâ–…[0m [7m[38;2;211;81;36mâ–Œ[0m[38;2;5;1;0;48;2;235;91;41m     [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–   [7m[38;2;130;50;22mâ–†[38;2;221;85;38mâ–„[0m[38;2;121;46;20;48;2;229;88;39mâ–[48;2;235;91;41m          [38;2;125;48;21;48;2;229;88;40mâ–[0m[7m[38;2;221;85;38mâ–„[38;2;130;50;22mâ–†[0m[38;2;4;1;0m   [7m[38;2;208;80;36mâ–Œ[0m[38;2;4;1;0;48;2;235;91;41m     [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–     [0m [7m[38;2;193;74;33mâ–…[38;2;219;84;38mâ–‚[0m[38;2;48;18;8;48;2;234;90;40m [48;2;235;91;41m    [38;2;235;91;41;48;2;233;90;40mâ”ˆ[0m[7m[38;2;219;84;38mâ–‚[38;2;194;75;33mâ–…[0m [38;2;0;0;0m     [7m[38;2;208;80;36mâ–Œ[0m[38;2;4;1;0;48;2;235;91;41m     [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;49;49;49mâ–[0m[38;2;11;11;11;48;2;51;51;51m     [0m[38;2;46;46;46mâ–        [7m[38;2;134;51;23mâ–†[38;2;224;87;39mâ–„[0m[38;2;127;49;21;48;2;230;89;40mâ–â–[0m[7m[38;2;224;86;39mâ–„[38;2;130;50;22mâ–†[0m[38;2;4;1;0m        [7m[38;2;208;80;36mâ–Œ[0m[38;2;4;1;0;48;2;235;91;41m     [0m[38;2;230;89;40mâ–‰[0m
[7m[38;2;39;39;39mâ–ƒ[0m[38;2;29;29;29;48;2;50;50;50mâ–[48;2;51;51;51m    [0m[38;2;46;46;46mâ–          [0m  [38;2;0;0;0m          [7m[38;2;208;80;36mâ–Œ[0m[38;2;4;1;0;48;2;235;91;41m    [38;2;162;62;28;48;2;233;90;40mâ–[0m[7m[38;2;189;73;32mâ–ƒ[0m
  [7m[38;2;43;43;43mâ–…[38;2;48;48;48mâ–‚[0m[38;2;51;51;51;48;2;50;50;50mâ”ˆ[48;2;51;51;51m [0m[38;2;46;46;46mâ–                      [7m[38;2;208;80;36mâ–Œ[0m[38;2;4;1;0;48;2;235;91;41m  [0m[7m[38;2;227;88;39mâ–‚[38;2;215;83;37mâ–…[0m [38;2;2;1;0m [0m
 [38;2;0;0;0m   [7m[38;2;32;32;32mâ–†[38;2;44;44;44mâ–ƒ[0m[38;2;39;39;39mâ–                      [7m[38;2;185;71;32mâ–Œ[38;2;215;83;37mâ–ƒ[38;2;172;66;29mâ–†[0m[38;2;11;4;1m    [0m



================================================
FILE: images/logos_txt/proxmology.txt
================================================
[0m [38;2;0;0;0m          [0m [38;2;10;152;204mâ–‚[38;2;9;147;198mâ–„[38;2;10;157;210mâ–…[38;2;10;159;213mâ–†[38;2;10;157;211mâ–‡[38;2;10;163;219mâ–‡[38;2;10;162;218;48;2;11;125;167mâ–‡[38;2;10;163;219;48;2;10;160;216mâ”Š[38;2;8;150;204;48;2;10;162;217mâ–[38;2;10;162;218;48;2;11;125;167mâ–‡[0m[38;2;10;163;219mâ–‡[38;2;10;157;211mâ–‡[38;2;10;159;213mâ–†[38;2;10;157;210mâ–…[38;2;9;147;198mâ–„[38;2;10;152;204mâ–‚[0m [38;2;7;75;100m           [0m
 [38;2;0;0;0m       [38;2;8;107;143mâ–‚[38;2;9;152;204mâ–„[38;2;10;160;214mâ–†[38;2;10;163;219;48;2;9;160;215mâ”ˆ[38;2;5;98;148;48;2;9;162;218mâ–‚[38;2;4;78;126;48;2;9;157;213mâ–ƒ[38;2;4;82;131;48;2;9;162;218mâ–…[38;2;4;79;127;48;2;9;161;217mâ–†[48;2;9;162;218mâ–‡[38;2;4;75;123;48;2;7;130;183mâ–‡[48;2;4;88;137mâ–‡[48;2;4;75;123m  [48;2;4;88;137mâ–‡[48;2;7;130;183mâ–‡[38;2;4;79;127;48;2;9;162;218mâ–‡[48;2;9;161;217mâ–†[38;2;4;82;131;48;2;9;162;218mâ–…[38;2;4;78;126;48;2;9;157;213mâ–ƒ[38;2;5;98;148;48;2;9;162;218mâ–‚[38;2;10;163;219;48;2;9;160;215mâ”ˆ[0m[38;2;10;160;214mâ–†[38;2;9;152;204mâ–„[38;2;8;107;143mâ–‚        [0m
 [38;2;0;0;0m    [0m [38;2;9;138;186mâ–ƒ[38;2;9;157;210mâ–†[38;2;10;163;219;48;2;9;160;216mâ”ˆ[38;2;5;92;142;48;2;9;160;215mâ–ƒ[38;2;4;78;127;48;2;9;150;205mâ–…[38;2;4;75;124;48;2;6;117;169mâ–‡[48;2;4;75;123m                [48;2;6;117;169mâ–‡[38;2;4;78;127;48;2;9;150;205mâ–…[38;2;5;92;142;48;2;9;160;215mâ–ƒ[38;2;10;163;219;48;2;9;160;216mâ”ˆ[0m[38;2;9;157;210mâ–†[38;2;9;138;186mâ–ƒ[0m [38;2;0;0;0m     [0m
 [38;2;0;0;0m   [38;2;9;145;194mâ–—[7m[38;2;10;160;215mâ–˜[0m[38;2;7;134;187;48;2;9;161;217mâ–[38;2;4;87;136;48;2;9;153;209mâ–„[38;2;4;77;126;48;2;6;119;172mâ–‡[38;2;4;75;123;48;2;3;73;120mâ”ˆ[38;2;0;11;18mâ–„[38;2;0;0;0;48;2;3;65;107mâ–…[48;2;3;73;121mâ–†[38;2;0;2;4;48;2;3;74;122mâ–†[38;2;0;1;2;48;2;3;64;106mâ–„[38;2;0;18;31;48;2;3;70;115mâ–‚[48;2;4;75;123m        [38;2;0;20;33;48;2;3;71;116mâ–‚[38;2;0;1;2;48;2;3;65;107mâ–„[38;2;0;3;5;48;2;3;74;122mâ–†[38;2;0;0;0;48;2;3;73;121mâ–†[48;2;3;64;106mâ–…[38;2;0;9;16;48;2;3;72;119mâ–„[38;2;4;75;123mâ”ˆ[38;2;4;77;126;48;2;6;119;172mâ–‡[38;2;4;87;136;48;2;9;153;209mâ–„[38;2;7;134;187;48;2;9;161;217mâ–[0m[7m[38;2;10;160;215mâ–[0m[38;2;9;145;194mâ––    [0m
 [38;2;0;0;0m [0m [7m[38;2;9;137;184mâ–˜[0m[38;2;10;163;219;48;2;10;162;218mâ”ˆ[38;2;4;81;129;48;2;8;150;204mâ–—[38;2;5;106;157;48;2;6;75;122mâ–˜[38;2;99;90;69;48;2;4;75;123mâ–[38;2;54;82;94mâ– [38;2;1;22;37;48;2;3;70;116mâ–[38;2;2;56;92;48;2;0;5;8mâ––[48;2;0;0;0m    [38;2;3;61;101;48;2;0;7;12mâ–[38;2;1;28;46;48;2;3;72;118mâ––[48;2;4;75;123m    [38;2;1;30;50;48;2;3;72;119mâ–—[38;2;3;62;103;48;2;0;7;13mâ–˜[48;2;0;0;0m    [38;2;2;53;87;48;2;0;4;7mâ–—[38;2;0;19;32;48;2;3;70;115mâ–˜[48;2;4;75;123m [38;2;51;82;96mâ–[38;2;100;90;69mâ–[38;2;6;78;125;48;2;6;114;166mâ–‡[38;2;4;81;129;48;2;8;150;204mâ––[38;2;10;163;219;48;2;10;162;218mâ”ˆ[0m[7m[38;2;9;137;184mâ–[0m [38;2;0;0;0m  [0m
  [7m[38;2;10;158;212mâ–˜[0m[38;2;10;163;219;48;2;9;162;218mâ”ˆ[38;2;165;95;23;48;2;26;133;171mâ–—[38;2;222;110;3;48;2;50;82;96mâ–†[38;2;229;112;0;48;2;222;110;3mâ”ˆ[48;2;229;112;0m [48;2;228;111;0mâ”ˆ[38;2;222;110;3;48;2;53;82;95mâ–‡[38;2;204;107;13;48;2;23;77;112mâ–…[38;2;119;93;59;48;2;8;75;120mâ–‚[38;2;0;9;15;48;2;3;65;107mâ–[38;2;2;41;67;48;2;0;1;2mâ––[48;2;0;0;0m   [38;2;0;0;0;48;2;0;0;1mâ”ˆ[38;2;0;8;13;48;2;3;61;100mâ–…[38;2;2;42;69;48;2;3;74;122mâ––[38;2;1;37;62;48;2;3;71;117mâ–[38;2;0;9;14;48;2;3;62;102mâ–…[38;2;0;0;0;48;2;0;0;1mâ”ˆ[48;2;0;0;0m   [38;2;1;38;63;48;2;0;1;2mâ–—[38;2;3;69;113;48;2;0;18;30mâ–…[38;2;110;92;63;48;2;7;75;120mâ–—[38;2;201;107;14;48;2;20;77;113mâ–…[38;2;221;110;4;48;2;47;81;98mâ–‡[38;2;229;112;0;48;2;228;111;0mâ”ˆ[48;2;229;112;0m [48;2;223;110;3mâ”ˆ[38;2;224;111;2;48;2;55;83;94mâ–†[38;2;179;99;20;48;2;30;135;171mâ––[38;2;10;163;219;48;2;10;162;218mâ”ˆ[0m[7m[38;2;10;158;212mâ–[0m [38;2;0;0;0m [0m
 [7m[38;2;9;149;200mâ–˜[0m[38;2;3;24;32;48;2;10;163;219m [38;2;3;51;84;48;2;8;128;176mâ–—[48;2;3;51;84m [38;2;186;100;16;48;2;24;56;76mâ–[38;2;86;73;53;48;2;220;109;3mâ––[48;2;229;112;0m    [38;2;229;112;0;48;2;224;111;2mâ”ˆ[38;2;196;106;17;48;2;33;79;106mâ–…[38;2;105;91;67;48;2;11;74;116mâ–[38;2;3;70;115;48;2;0;17;29mâ–„[38;2;1;34;56;48;2;0;2;4mâ–[48;2;0;0;0m   [38;2;0;0;0;48;2;0;1;3mâ”ˆ[48;2;0;2;3mâ”ˆ[48;2;0;0;0m   [38;2;1;31;52;48;2;0;2;3mâ–[38;2;3;69;113;48;2;0;16;26mâ–„[38;2;97;90;71;48;2;10;74;116mâ–[38;2;210;108;9;48;2;51;82;96mâ–„[38;2;229;112;0;48;2;223;111;3mâ”ˆ[48;2;229;112;0m    [38;2;100;78;50;48;2;223;110;2mâ–—[38;2;197;104;13;48;2;29;58;75mâ–˜[38;2;3;51;84;48;2;3;51;83mâ”ˆ[48;2;9;130;179mâ––[48;2;10;163;219m [0m[7m[38;2;9;149;200mâ–[0m [0m
[7m[38;2;9;131;176mâ–‹[0m[38;2;1;14;19;48;2;10;163;219m [38;2;5;86;126;48;2;9;157;212mâ–—[38;2;3;51;84;48;2;3;52;85mâ”ˆ[48;2;3;51;84m  [48;2;5;51;83mâ”ˆ[38;2;27;57;75;48;2;186;100;16mâ–…[38;2;130;85;36;48;2;227;111;0mâ––[48;2;229;112;0m    [38;2;225;111;1;48;2;157;99;38mâ–‡[38;2;194;106;18;48;2;31;79;107mâ–„[38;2;4;75;123;48;2;13;72;110mâ”ˆ[38;2;3;63;104;48;2;0;9;15mâ–„[38;2;0;0;0;48;2;0;3;5mâ”ˆ[48;2;0;0;0m    [48;2;0;2;4mâ”ˆ[38;2;3;62;102;48;2;0;8;13mâ–„[38;2;4;75;123;48;2;11;71;110mâ”ˆ[38;2;190;105;20;48;2;28;78;109mâ–„[38;2;224;111;2;48;2;149;98;43mâ–‡[48;2;229;112;0m    [38;2;122;84;42;48;2;219;109;3mâ–[38;2;33;59;73;48;2;195;103;13mâ–…[48;2;6;52;83m [48;2;3;51;84m  [38;2;3;51;84;48;2;3;52;85mâ”ˆ[38;2;8;90;130;48;2;10;158;213mâ––[48;2;10;163;219m [0m[38;2;9;131;176mâ–[0m
[7m[38;2;10;156;210mâ–[0m[38;2;4;31;41;48;2;10;163;219m [38;2;9;145;197;48;2;3;56;90mâ–[48;2;3;51;84m     [38;2;3;51;84;48;2;11;53;80mâ”ˆ[38;2;27;57;74;48;2;191;101;14mâ–„[38;2;150;90;29;48;2;225;111;1mâ–[48;2;229;112;0m    [38;2;218;110;5;48;2;117;93;60mâ–‡[38;2;192;105;19;48;2;31;79;107mâ–ƒ[38;2;4;75;123;48;2;6;67;107mâ”ˆ[38;2;3;62;102;48;2;0;9;14mâ–ƒ[38;2;0;0;0;48;2;0;0;1mâ”ˆâ”ˆ[38;2;3;60;99;48;2;0;7;13mâ–ƒ[38;2;2;42;69;48;2;6;74;120mâ–˜[38;2;186;104;22;48;2;27;78;109mâ–ƒ[38;2;130;95;53;48;2;227;111;0mâ–˜[48;2;229;112;0m    [38;2;229;112;0;48;2;217;109;4mâ”ˆ[38;2;34;60;73;48;2;198;104;12mâ–„[38;2;3;51;84;48;2;14;54;80mâ”ˆ[48;2;3;51;84m     [38;2;4;57;91;48;2;10;147;200mâ–‹[48;2;10;163;219m [0m[38;2;10;156;210mâ–Š[0m
[38;2;10;163;219;48;2;10;157;211mâ”Š[48;2;10;163;219m [38;2;9;147;199;48;2;3;52;86mâ–[48;2;3;51;84m       [38;2;9;52;81;48;2;98;76;48mâ–‡[38;2;51;64;66;48;2;211;107;6mâ–„[38;2;229;112;0;48;2;224;110;2mâ”ˆ[48;2;229;112;0m    [38;2;96;89;72;48;2;222;110;3mâ–[38;2;194;105;18;48;2;27;78;109mâ––[38;2;1;30;50;48;2;3;72;119mâ–[38;2;1;28;46;48;2;3;72;118mâ–˜[38;2;187;104;22;48;2;24;78;111mâ–—[38;2;87;88;76;48;2;220;110;4mâ–˜[48;2;229;112;0m    [38;2;229;112;0;48;2;225;111;1mâ”ˆ[38;2;37;61;72;48;2;199;104;11mâ–ƒ[38;2;12;53;80;48;2;111;81;46mâ–‡[48;2;3;51;84m       [38;2;4;53;87;48;2;14;158;212mâ–‰[48;2;10;163;219m [38;2;10;163;219;48;2;10;157;211mâ”ˆ[0m
[38;2;9;150;202;48;2;10;158;212mâ”ˆ[48;2;10;163;219m [38;2;9;147;199;48;2;3;52;86mâ–[48;2;3;51;84m       [38;2;105;78;46;48;2;11;53;81mâ–[38;2;196;103;12;48;2;33;59;72mâ–…[48;2;225;111;1m [48;2;229;112;0m    [38;2;89;88;75;48;2;220;110;4mâ–—[38;2;188;105;21;48;2;25;78;111mâ–˜[38;2;1;28;46;48;2;3;72;118mâ–—[38;2;1;25;42;48;2;3;71;117mâ––[38;2;180;103;25;48;2;21;77;113mâ–[38;2;80;87;80;48;2;218;110;5mâ––[48;2;229;112;0m    [38;2;229;112;0;48;2;226;111;1mâ”ˆ[38;2;202;105;10;48;2;42;62;71mâ–…[38;2;118;83;43;48;2;14;54;80mâ–[48;2;3;51;84m       [38;2;4;53;87;48;2;14;158;212mâ–‰[48;2;10;163;219m [38;2;10;163;219;48;2;10;157;211mâ”ˆ[0m
[7m[38;2;10;156;210mâ–[0m[38;2;4;31;40;48;2;10;163;219m [38;2;9;145;197;48;2;3;56;90mâ–[48;2;3;51;84m     [38;2;3;51;84;48;2;13;53;80mâ”ˆ[38;2;195;102;12;48;2;31;58;73mâ–„[38;2;226;111;1;48;2;157;92;26mâ–‡[48;2;229;112;0m    [38;2;112;92;63;48;2;217;110;6mâ–[38;2;29;79;108;48;2;188;105;21mâ–…[38;2;4;75;123;48;2;5;66;106mâ”ˆ[38;2;0;8;13;48;2;3;60;100mâ–…[38;2;0;0;0;48;2;0;0;1mâ”ˆ[48;2;0;0;0m [38;2;0;6;11;48;2;2;58;96mâ–…[38;2;1;39;65;48;2;5;74;120mâ––[38;2;25;78;110;48;2;182;104;24mâ–…[38;2;126;94;55;48;2;226;111;1mâ––[48;2;229;112;0m    [38;2;229;112;0;48;2;219;109;3mâ”ˆ[38;2;202;105;11;48;2;38;61;72mâ–„[38;2;78;72;58;48;2;6;52;83mâ–[48;2;3;51;84m     [38;2;4;57;91;48;2;10;147;200mâ–‹[48;2;10;163;219m [0m[38;2;10;156;210mâ–Š[0m
[7m[38;2;9;131;176mâ–‹[0m[38;2;1;14;19;48;2;10;163;219m [38;2;5;86;126;48;2;9;157;212mâ–[38;2;3;51;84;48;2;3;52;85mâ”ˆ[48;2;3;51;84m  [48;2;6;51;83mâ”ˆ[38;2;191;101;13;48;2;30;58;73mâ–ƒ[38;2;218;109;3;48;2;115;81;42mâ–‡[48;2;229;112;0m    [38;2;153;99;40;48;2;225;111;1mâ–[38;2;30;79;108;48;2;193;105;19mâ–„[38;2;4;75;123;48;2;12;71;110mâ”ˆ[38;2;0;8;13;48;2;3;62;102mâ–„[38;2;0;0;0;48;2;0;2;4mâ”ˆ[48;2;0;0;0m    [48;2;0;2;3mâ”ˆ[38;2;0;7;11;48;2;3;60;99mâ–„[38;2;4;75;123;48;2;11;70;109mâ”ˆ[38;2;26;78;110;48;2;188;105;21mâ–„[38;2;145;98;45;48;2;224;111;2mâ–[48;2;229;112;0m    [38;2;221;110;3;48;2;130;86;39mâ–‡[38;2;177;98;20;48;2;18;55;79mâ–„[38;2;3;51;84;48;2;7;52;82mâ”ˆ[48;2;3;51;84m  [48;2;3;52;85mâ”ˆ[38;2;8;90;130;48;2;10;158;213mâ–˜[48;2;10;163;219m [0m[38;2;9;131;176mâ–[0m
 [7m[38;2;9;149;200mâ––[0m[38;2;3;24;32;48;2;10;163;219m [38;2;3;51;84;48;2;8;128;176mâ–[48;2;3;51;83mâ”ˆ[38;2;192;102;13;48;2;27;57;75mâ–—[38;2;94;75;50;48;2;221;110;2mâ–˜[48;2;229;112;0m    [38;2;229;112;0;48;2;224;111;2mâ”ˆ[38;2;55;83;94;48;2;213;109;8mâ–„[38;2;11;74;115;48;2;102;90;68mâ–‡[38;2;0;16;26;48;2;3;69;113mâ–„[38;2;0;2;3;48;2;1;31;52mâ–‡[48;2;0;0;0m   [38;2;0;0;0;48;2;0;2;4mâ”ˆâ”ˆ[48;2;0;0;0m   [38;2;0;1;2;48;2;1;29;48mâ–‡[38;2;0;14;23;48;2;3;68;111mâ–„[38;2;9;73;115;48;2;94;89;73mâ–‡[38;2;49;82;97;48;2;209;108;10mâ–„[38;2;229;112;0;48;2;223;110;3mâ”ˆ[48;2;229;112;0m    [38;2;108;80;47;48;2;224;110;2mâ–[38;2;202;105;11;48;2;33;59;73mâ––[38;2;3;51;84;48;2;3;51;83mâ”ˆ[48;2;9;130;179mâ–˜[48;2;10;163;219m [0m[7m[38;2;9;149;200mâ–—[0m [0m
  [7m[38;2;10;158;212mâ––[0m[38;2;10;163;219;48;2;9;162;218mâ”ˆ[38;2;173;97;21;48;2;25;132;172mâ–[38;2;46;81;99;48;2;222;110;3mâ–‚[38;2;173;102;29;48;2;229;112;0mâ– [38;2;229;112;0;48;2;228;111;0mâ”ˆ[38;2;53;82;94;48;2;222;110;3mâ–[38;2;23;78;112;48;2;204;107;13mâ–ƒ[38;2;119;93;59;48;2;8;75;120mâ–˜[38;2;0;18;30;48;2;3;69;113mâ–ƒ[38;2;1;38;63;48;2;0;1;2mâ–˜[48;2;0;0;0m   [38;2;0;0;0;48;2;0;0;1mâ”ˆ[38;2;3;62;102;48;2;0;8;14mâ–ƒ[38;2;3;71;117;48;2;1;37;61mâ–‡[38;2;3;72;118;48;2;2;40;66mâ–‡[38;2;3;64;106;48;2;0;10;17mâ–ƒ[38;2;0;0;0;48;2;0;1;2mâ”ˆ[48;2;0;0;0m   [38;2;1;35;58;48;2;0;0;1mâ–[38;2;0;16;27;48;2;3;68;112mâ–ƒ[38;2;111;92;63;48;2;7;75;120mâ–[38;2;20;77;113;48;2;201;107;14mâ–ƒ[38;2;47;82;98;48;2;221;110;3mâ–[38;2;229;112;0;48;2;228;111;0mâ”ˆ[48;2;229;112;0m [48;2;222;110;3mâ”ˆ[38;2;51;82;96;48;2;223;111;2mâ–‚[38;2;186;101;18;48;2;30;135;172mâ–˜[38;2;10;163;219;48;2;10;162;218mâ”ˆ[0m[7m[38;2;10;158;212mâ–—[0m [38;2;0;0;0m [0m
 [38;2;0;0;0m [0m [7m[38;2;9;137;184mâ––[0m[38;2;10;163;219;48;2;10;162;218mâ”ˆ[38;2;4;81;129;48;2;8;150;204mâ–[38;2;6;114;166;48;2;5;78;125mâ–[38;2;4;75;123;48;2;96;90;71mâ–‡[48;2;51;82;96mâ–‡[48;2;4;75;123m [38;2;0;20;33;48;2;3;70;115mâ–—[38;2;2;53;87;48;2;0;4;7mâ–˜[48;2;0;0;0m    [38;2;3;62;102;48;2;0;7;12mâ–—[38;2;1;30;49;48;2;3;72;119mâ–˜[48;2;4;75;123m    [38;2;1;34;56;48;2;3;73;120mâ–[38;2;3;65;108;48;2;0;9;16mâ––[48;2;0;0;0m    [38;2;2;50;83;48;2;0;3;6mâ–[38;2;0;17;28;48;2;3;69;113mâ––[48;2;4;75;123m [38;2;4;75;123;48;2;47;81;98mâ–‡[48;2;98;90;71mâ–‡[38;2;5;106;157;48;2;6;75;121mâ–—[38;2;4;81;129;48;2;8;150;204mâ–˜[38;2;10;163;219;48;2;10;162;218mâ”ˆ[0m[7m[38;2;9;137;184mâ–—[0m [38;2;0;0;0m  [0m
 [38;2;0;0;0m   [38;2;9;145;194mâ–[7m[38;2;10;160;215mâ––[0m[38;2;9;161;217;48;2;7;134;187mâ–‡[38;2;9;153;209;48;2;4;87;136mâ–„[38;2;6;119;172;48;2;4;77;125mâ–[38;2;4;75;123;48;2;3;73;120mâ”ˆ[38;2;3;73;121;48;2;0;12;21mâ–„[38;2;3;68;111;48;2;0;1;1mâ–ƒ[38;2;4;75;123;48;2;0;1;3mâ–‚[48;2;0;4;7mâ–‚[38;2;3;66;109;48;2;0;1;3mâ–„[38;2;3;71;116;48;2;0;20;33mâ–†[48;2;4;75;123m        [38;2;3;71;117;48;2;1;24;40mâ–†[38;2;3;67;110;48;2;0;2;4mâ–„[38;2;4;75;123;48;2;0;4;7mâ–‚[48;2;0;1;3mâ–‚[38;2;3;67;110;48;2;0;0;1mâ–ƒ[38;2;3;73;120;48;2;0;11;19mâ–„[38;2;4;75;123;48;2;3;72;119mâ”ˆ[38;2;6;119;172;48;2;4;77;125mâ–[38;2;9;153;209;48;2;4;87;136mâ–„[38;2;9;161;217;48;2;7;134;187mâ–‡[0m[7m[38;2;10;160;215mâ–—[0m[38;2;9;145;194mâ–˜    [0m
 [38;2;0;0;0m    [0m [7m[38;2;9;138;186mâ–…[38;2;9;157;210mâ–‚[0m[38;2;10;163;219;48;2;9;160;216mâ”ˆ[38;2;9;160;215;48;2;5;92;142mâ–…[38;2;9;150;205;48;2;4;78;127mâ–ƒ[38;2;6;117;169;48;2;4;75;124mâ–[48;2;4;75;123m                [48;2;4;75;124mâ–[38;2;9;150;205;48;2;4;78;127mâ–ƒ[38;2;9;160;215;48;2;5;92;142mâ–…[38;2;10;163;219;48;2;9;160;216mâ”ˆ[0m[7m[38;2;9;157;210mâ–‚[38;2;9;138;186mâ–…[0m [38;2;0;0;0m     [0m
 [38;2;0;0;0m       [7m[38;2;8;107;143mâ–†[38;2;9;152;204mâ–„[38;2;10;160;214mâ–‚[0m[38;2;10;163;219;48;2;9;160;215mâ”ˆ[38;2;9;162;218;48;2;5;98;148mâ–†[38;2;9;157;213;48;2;4;78;126mâ–…[38;2;9;162;218;48;2;4;82;131mâ–ƒ[38;2;9;161;217;48;2;4;79;127mâ–‚[38;2;9;162;218mâ–[38;2;7;130;183;48;2;4;75;123mâ–[38;2;4;87;137mâ–  â–[38;2;7;130;183mâ–[38;2;9;162;218;48;2;4;79;127mâ–[38;2;9;161;217mâ–‚[38;2;9;162;218;48;2;4;82;131mâ–ƒ[38;2;9;157;213;48;2;4;78;126mâ–…[38;2;9;162;218;48;2;5;98;148mâ–†[38;2;10;163;219;48;2;9;160;215mâ”ˆ[0m[7m[38;2;10;160;215mâ–‚[38;2;9;152;204mâ–„[38;2;8;107;143mâ–†[0m[38;2;0;3;4m        [0m
 [38;2;0;0;0m          [0m [7m[38;2;10;152;204mâ–†[38;2;9;147;198mâ–„[38;2;10;157;210mâ–ƒ[38;2;10;159;213mâ–‚[38;2;10;157;211mâ–[38;2;10;163;219mâ–[0m[38;2;11;126;167;48;2;10;162;218mâ–[38;2;10;162;218;48;2;8;149;204mâ–‡[38;2;10;163;219;48;2;10;160;216mâ”ˆ[38;2;11;126;168;48;2;10;162;218mâ–[0m[7m[38;2;10;163;219mâ–[38;2;10;157;211mâ–[38;2;10;159;213mâ–‚[38;2;10;157;210mâ–ƒ[38;2;9;147;198mâ–„[38;2;10;152;204mâ–†[0m [38;2;0;0;1m           [0m



================================================
FILE: lang/cache.json
================================================
{
  "Language changed to": {
    "es": "Idioma cambiado a",
    "fr": "Langue changÃ©e en",
    "de": "Sprache geÃ¤ndert zu",
    "it": "Lingua cambiata in",
    "pt": "Idioma alterado para"
  },
  "Main Menu": {
    "es": "MenÃº principal",
    "fr": "Menu principal",
    "de": "HauptmenÃ¼",
    "it": "Menu principale",
    "pt": "Menu principal"
  },
  "Select an option:": {
    "es": "Seleccione una opciÃ³n:",
    "fr": "SÃ©lectionnez une option :",
    "de": "WÃ¤hlen Sie eine Option aus:",
    "it": "Selezionare un'opzione:",
    "pt": "Selecione uma opÃ§Ã£o:"
  },
  "GPUs and Coral-TPU": {
    "es": "GPUs y Coral-TPU",
    "fr": "GPUs et Coral-TPU",
    "de": "GPUs und Coral-TPU",
    "it": "GPUs e Coral-TPU",
    "pt": "GPUs e Coral-TPU"
  },
  "Hard Drives, Disk Images, and Storage": {
    "es": "Discos duros, imÃ¡genes de disco y almacenamiento",
    "fr": "Disques durs, images disque et stockage",
    "de": "Festplatten, Festplattenabbilder und Speicherplatz",
    "it": "Dischi rigidi, immagini del disco e archiviazione",
    "pt": "Discos rÃ­gidos, imagens de disco e armazenamento"
  },
  "Network": {
    "es": "Red",
    "fr": "RÃ©seau",
    "de": "Netzwerk",
    "it": "Rete",
    "pt": "Rede"
  },
  "Settings": {
    "es": "ConfiguraciÃ³n",
    "fr": "ParamÃ¨tres",
    "de": "Einstellungen",
    "it": "Impostazioni",
    "pt": "ConfiguraÃ§Ãµes"
  },
  "Exit": {
    "es": "Salir",
    "fr": "Quitter",
    "de": "Beenden",
    "it": "Esci",
    "pt": "Sair"
  },
  "HW: GPUs and Coral": {
    "es": "HW: GPUs y Coral",
    "fr": "HW: GPUs et Coral",
    "de": "HW: GPUs und Coral",
    "it": "HW: GPUs e Coral",
    "pt": "HW: GPUs e Coral"
  },
  "Return to Main Menu": {
    "es": "Volver al menÃº principal",
    "fr": "Retour au menu principal",
    "de": "Zum HauptmenÃ¼ zurÃ¼ckkehren",
    "it": "Torna al menu principale",
    "pt": "Retornar ao menu principal"
  },
  "Disk and Storage Menu": {
    "es": "MenÃº de discos y almacenamiento",
    "fr": "Menu des disques et stockage",
    "de": "DatentrÃ¤ger- und SpeichermenÃ¼",
    "it": "Menu dischi e archiviazione",
    "pt": "Menu de discos e armazenamento"
  },
  "Add Disk Passthrough to a VM": {
    "es": "AÃ±adir disco Passthrough a una VM",
    "fr": "Ajouter un disque Passthrough Ã  une VM",
    "de": "Disk-Passthrough zu einer VM hinzufÃ¼gen",
    "it": "Aggiungi passthrough del disco a una VM",
    "pt": "Adicionar passthrough de disco a uma VM"
  },
  "Network Menu": {
    "es": "MenÃº de red",
    "fr": "Menu rÃ©seau",
    "de": "NetzwerkmenÃ¼",
    "it": "Menu di rete",
    "pt": "Menu de rede"
  },
  "Repair Network": {
    "es": "Reparar red",
    "fr": "RÃ©parer le rÃ©seau",
    "de": "Netzwerk reparieren",
    "it": "Riparare la rete",
    "pt": "Reparar rede"
  },
  "Configuration Menu": {
    "es": "MenÃº de configuraciÃ³n",
    "fr": "Menu de configuration",
    "de": "KonfigurationsmenÃ¼",
    "it": "Menu di configurazione",
    "pt": "Menu de configuraÃ§Ã£o"
  },
  "Change Language": {
    "es": "Cambiar idioma",
    "fr": "Changer de langue",
    "de": "Sprache Ã¤ndern",
    "it": "Cambia lingua",
    "pt": "Alterar idioma"
  },
  "Show Version Information": {
    "es": "Mostrar informaciÃ³n de la versiÃ³n",
    "fr": "Afficher les informations de version",
    "de": "Versionsinformationen anzeigen",
    "it": "Mostra informazioni sulla versione",
    "pt": "Mostrar informaÃ§Ãµes da versÃ£o"
  },
  "Uninstall ProxMenu": {
    "es": "Desinstalar ProxMenu",
    "fr": "DÃ©sinstaller ProxMenu",
    "de": "ProxMenu deinstallieren",
    "it": "Disinstallare ProxMenu",
    "pt": "Desinstalar ProxMenu"
  },
  "Select a new language for the menu:": {
    "es": "Seleccione un nuevo idioma para el menÃº:",
    "fr": "SÃ©lectionnez une nouvelle langue pour le menu :",
    "de": "WÃ¤hlen Sie eine neue Sprache fÃ¼r das MenÃ¼:",
    "it": "Seleziona una nuova lingua per il menu:",
    "pt": "Selecione um novo idioma para o menu:"
  },
  "English (Recommended)": {
    "es": "InglÃ©s (recomendado)",
    "fr": "Anglais (recommandÃ©)",
    "de": "Englisch (empfohlen)",
    "it": "Inglese (consigliato)",
    "pt": "InglÃªs (recomendado)"
  },
  "Spanish": {
    "es": "EspaÃ±ol",
    "fr": "Espagnol",
    "de": "Spanisch",
    "it": "Spagnolo",
    "pt": "Espanhol"
  },
  "French": {
    "es": "FrancÃ©s",
    "fr": "FranÃ§ais",
    "de": "FranzÃ¶sisch",
    "it": "Francese",
    "pt": "FrancÃªs"
  },
  "German": {
    "es": "AlemÃ¡n",
    "fr": "Allemand",
    "de": "Deutsch",
    "it": "Tedesco",
    "pt": "AlemÃ£o"
  },
  "Italian": {
    "es": "Italiano",
    "fr": "Italien",
    "de": "Italienisch",
    "it": "Italiano",
    "pt": "Italiano"
  },
  "Portuguese": {
    "es": "PortuguÃ©s",
    "fr": "Portugais",
    "de": "Portugiesisch",
    "it": "Portoghese",
    "pt": "PortuguÃªs"
  },
  "Simplified Chinese": {
    "es": "Chino simplificado",
    "fr": "Chinois simplifiÃ©",
    "de": "Vereinfachtes Chinesisch",
    "it": "Cinese semplificato",
    "pt": "ChinÃªs simplificado"
  },
  "Japanese": {
    "es": "JaponÃ©s",
    "fr": "Japonais",
    "de": "Japanisch",
    "it": "Giapponese",
    "pt": "JaponÃªs"
  },
  "Thank you for using ProxMenu. Goodbye!": {
  "es": "Gracias por usar ProxMenu. Â¡Hasta luego!",
  "fr": "Merci d'avoir utilisÃ© ProxMenu. Ã€ bientÃ´t !",
  "de": "Vielen Dank, dass Sie ProxMenu verwendet haben. Bis bald!",
  "it": "Grazie per aver usato ProxMenu. A presto!",
  "pt": "Obrigado por usar o ProxMenu. AtÃ© logo!"
  }
}



================================================
FILE: lang/en.lang
================================================
# General system messages
MAIN_MENU_TITLE="ProxMenux - Main Menu"
CONFIG_TITLE="ProxMenux - Configuration"
SELECT_OPTION="Select an option:"
LANG_OPTION="Change language"
UNINSTALL_OPTION="Uninstall ProxMenu"
EXIT_MENU="Exit"
EXIT_MESSAGE="Exiting menu. Goodbye!"

# Main menu options
OPTION_1="Configure iGPU + TPU"
OPTION_2="Repair network"
OPTION_3="Settings"

# Version messages
VERSION_OPTION="Show version information"
VERSION_TITLE="Version Information"
VERSION_INFO="Current version: %s\n\nFor more information, visit:\nhttps://github.com/MacRimi/ProxMenux"

# Update messages
UPDATE_CHECKING="Checking for updates..."
UPDATE_ERROR_REMOTE="Error checking remote version."
UPDATE_NEW_AVAILABLE="New version available: %s (current: %s)"
UPDATE_TITLE="Update available"
UPDATE_PROMPT="Do you want to update to the latest version %s?"
UPDATE_POSTPONED="Update postponed."
UPDATE_CURRENT="The menu is already up to date (%s)."
UPDATE_PROCESS="Updating to version %s..."
UPDATE_COMPLETE="Update completed to version %s."
UPDATE_ERROR_DOWNLOAD="Error downloading the update."

# Uninstall messages
UNINSTALL_TITLE="Uninstall ProxMenu"
UNINSTALL_CONFIRM="Are you sure you want to uninstall ProxMenu?"
UNINSTALL_COMPLETE="ProxMenu has been uninstalled successfully."
UNINSTALL_PROCESS="Uninstalling ProxMenu..."

# Script messages
SCRIPT_RUNNING="Running igpu_tpu.sh script..."
SCRIPT_SUCCESS="Script executed successfully."
SCRIPT_ERROR="Error executing the script."

# Language messages
LANG_SELECT="Select Language"
LANG_PROMPT="Choose your language:"
LANG_ERROR="No language selected. Exiting..."
LANG_SUCCESS="Selected language:"
LANG_LOADED="Language loaded:"
LANG_DOWNLOAD="Downloading language file..."
LANG_DOWNLOAD_ERROR="Error downloading language file. Check your internet connection."
LANG_EXISTS="Language file exists locally."

# Dependency messages
DEPS_INSTALLING="Installing necessary dependencies..."
DEPS_SUCCESS="Dependencies installed."
DEPS_ERROR="Error installing dependencies. Please install whiptail manually."

# Bilingual messages (first run)
INITIAL_LANG_SELECT="Select Language / Seleccionar Idioma"
INITIAL_LANG_PROMPT="Choose your language / Elige tu idioma:"
INITIAL_LANG_ERROR="No language selected. Exiting... / No se seleccionÃ³ ningÃºn idioma. Saliendo..."

# --- Messages for the network repair script (repair_network.sh) ---
REPAIR_MENU_TITLE="Network Repair Menu"
MENU_PROMPT="Please select an option:"
MENU_REPAIR="Repair network"
MENU_VERIFY="Verify network configuration"
MENU_SHOW_IP="Show IP information"
MENU_EXIT="Exit"
MENU_CANCELED="Operation canceled by user."
MENU_EXIT_MSG="Exiting network repair script. Goodbye!"
INVALID_OPTION="Invalid option. Please try again."
PRESS_ENTER="Press Enter to continue..."
RESULT_TITLE="Operation Result"
REPAIR_COMPLETED="Network repair completed."
VERIFY_COMPLETED="Network verification completed."
IP_INFO_COMPLETED="IP information displayed."
NETWORK_ERROR="ERROR"
NETWORK_SUCCESS="SUCCESS"
NETWORK_WARNING="WARNING"
NETWORK_PHYSICAL_INTERFACES="Detected physical interfaces"
NETWORK_CONFIGURED_INTERFACES="Configured interfaces"
NETWORK_CHECKING_BRIDGES="Checking bridge configuration"
NETWORK_BRIDGE_PORT_MISSING="Bridge port non-existent or not active"
NETWORK_BRIDGE_PORT_UPDATED="Bridge port updated"
NETWORK_NO_PHYSICAL_INTERFACE="No suitable physical interface found"
NETWORK_BRIDGE_PORT_OK="Bridge port correct"
NETWORK_CLEANING_INTERFACES="Cleaning configurations of non-existent interfaces"
NETWORK_INTERFACE_REMOVED="Interface removed"
NETWORK_CONFIGURING_INTERFACES="Configuring interfaces"
NETWORK_INTERFACE_ADDED="Interface added"
NETWORK_RESTARTING="Restarting network service"
NETWORK_RESTART_SUCCESS="Network service restarted successfully"
NETWORK_RESTART_FAILED="Failed to restart network service"
NETWORK_CONNECTIVITY_OK="Network connectivity OK"
NETWORK_CONNECTIVITY_FAILED="Network connectivity failed"
NETWORK_IP_INFO="IP Information"
NETWORK_NO_IP="No IP"
NETWORK_REPAIR_STARTED="Starting network repair"
NETWORK_REPAIR_COMPLETED="Network repair completed"
NETWORK_REPAIR_FAILED="Network repair failed"
NETWORK_REPAIR_PROCESS_FINISHED="Network repair process finished"
NETWORK_VERIFY_STARTED="Starting network verification"
NETWORK_VERIFY_FINISHED="Network verification finished"
NETWORK_REPAIR_RUNNING="Running network repair..."
NETWORK_REPAIR_SUCCESS="Network repair executed successfully."
NETWORK_REPAIR_ERROR="Error executing network repair."
NETWORK_VERIFY_RUNNING="Running network verification..."
NETWORK_VERIFY_SUCCESS="Network verification completed successfully."
NETWORK_VERIFY_ERROR="Error executing network verification."
NETWORK_IP_INFO_RUNNING="Obtaining IP information..."
NETWORK_IP_INFO_SUCCESS="IP information obtained successfully."
NETWORK_IP_INFO_ERROR="Error obtaining IP information."



================================================
FILE: lang/es.lang
================================================
# Mensajes generales del sistema
MAIN_MENU_TITLE="ProxMenux - MenÃº Principal"
CONFIG_TITLE="ProxMenux - ConfiguraciÃ³n"
SELECT_OPTION="Selecciona una opciÃ³n:"
LANG_OPTION="Cambiar idioma"
UNINSTALL_OPTION="Desinstalar ProxMenu"
EXIT_MENU="Salir"
EXIT_MESSAGE="Saliendo del menÃº. Â¡Hasta luego!"

# Opciones del menÃº principal
OPTION_1="Configurar iGPU + TPU"
OPTION_2="Reparar red"
OPTION_3="ConfiguraciÃ³n"

# Mensajes de versiÃ³n
VERSION_OPTION="Mostrar informaciÃ³n de versiÃ³n"
VERSION_TITLE="InformaciÃ³n de versiÃ³n"
VERSION_INFO="VersiÃ³n actual: %s\n\nPara mÃ¡s informaciÃ³n, visita:\nhttps://github.com/MacRimi/ProxMenux"

# Mensajes de actualizaciÃ³n
UPDATE_CHECKING="Comprobando actualizaciones..."
UPDATE_ERROR_REMOTE="Error al comprobar la versiÃ³n remota."
UPDATE_NEW_AVAILABLE="Nueva versiÃ³n disponible: %s (actual: %s)"
UPDATE_TITLE="ActualizaciÃ³n disponible"
UPDATE_PROMPT="Â¿Deseas actualizar a la Ãºltima versiÃ³n %s?"
UPDATE_POSTPONED="ActualizaciÃ³n pospuesta."
UPDATE_CURRENT="El menÃº ya estÃ¡ actualizado (%s)."
UPDATE_PROCESS="Actualizando a la versiÃ³n %s..."
UPDATE_COMPLETE="ActualizaciÃ³n completada a la versiÃ³n %s."
UPDATE_ERROR_DOWNLOAD="Error al descargar la actualizaciÃ³n."


# Mensajes de desinstalaciÃ³n
UNINSTALL_TITLE="Desinstalar ProxMenu"
UNINSTALL_CONFIRM="Â¿EstÃ¡s seguro de que quieres desinstalar ProxMenu?"
UNINSTALL_COMPLETE="ProxMenu ha sido desinstalado correctamente."
UNINSTALL_PROCESS="Desinstalando ProxMenu..."

# Mensajes de script
SCRIPT_RUNNING="Ejecutando script igpu_tpu.sh..."
SCRIPT_SUCCESS="Script ejecutado correctamente."
SCRIPT_ERROR="Error al ejecutar el script."

# Mensajes de idioma
LANG_SELECT="Seleccionar Idioma"
LANG_PROMPT="Elige tu idioma:"
LANG_ERROR="No se seleccionÃ³ ningÃºn idioma. Saliendo..."
LANG_SUCCESS="Idioma seleccionado:"
LANG_LOADED="Idioma cargado:"
LANG_DOWNLOAD="Descargando archivo de idioma..."
LANG_DOWNLOAD_ERROR="Error al descargar el archivo de idioma. Verifica tu conexiÃ³n a internet."
LANG_EXISTS="Archivo de idioma existe localmente."

# Mensajes de dependencias
DEPS_INSTALLING="Instalando dependencias necesarias..."
DEPS_SUCCESS="Dependencias instaladas."
DEPS_ERROR="Error al instalar dependencias. Por favor, instala whiptail manualmente."

# Mensajes bilingÃ¼es (primera ejecuciÃ³n)
INITIAL_LANG_SELECT="Seleccionar Idioma / Select Language"
INITIAL_LANG_PROMPT="Elige tu idioma / Choose your language:"
INITIAL_LANG_ERROR="No se seleccionÃ³ ningÃºn idioma. Saliendo... / No language selected. Exiting..."

# --- Mensajes para el script de reparaciÃ³n de red (repair_network.sh) ---
REPAIR_MENU_TITLE="MenÃº de ReparaciÃ³n de Red"
MENU_PROMPT="Por favor, seleccione una opciÃ³n:"
MENU_REPAIR="Reparar la red"
MENU_VERIFY="Verificar la configuraciÃ³n de red"
MENU_SHOW_IP="Mostrar informaciÃ³n de IP"
MENU_EXIT="Salir"
MENU_CANCELED="OperaciÃ³n cancelada por el usuario."
MENU_EXIT_MSG="Saliendo del script de reparaciÃ³n de red. Â¡Hasta luego!"
INVALID_OPTION="OpciÃ³n no vÃ¡lida. Por favor, intente de nuevo."
PRESS_ENTER="Presione Enter para continuar..."
RESULT_TITLE="Resultado de la OperaciÃ³n"
REPAIR_COMPLETED="ReparaciÃ³n de red completada."
VERIFY_COMPLETED="VerificaciÃ³n de red completada."
IP_INFO_COMPLETED="InformaciÃ³n de IP mostrada."
NETWORK_ERROR="ERROR"
NETWORK_SUCCESS="Ã‰XITO"
NETWORK_WARNING="ADVERTENCIA"
NETWORK_PHYSICAL_INTERFACES="Interfaces fÃ­sicas detectadas"
NETWORK_CONFIGURED_INTERFACES="Interfaces configuradas"
NETWORK_CHECKING_BRIDGES="Verificando configuraciÃ³n de puentes"
NETWORK_BRIDGE_PORT_MISSING="Puerto de puente no existente o no activo"
NETWORK_BRIDGE_PORT_UPDATED="Puerto de puente actualizado"
NETWORK_NO_PHYSICAL_INTERFACE="No se encontrÃ³ una interfaz fÃ­sica adecuada"
NETWORK_BRIDGE_PORT_OK="Puerto de puente correcto"
NETWORK_CLEANING_INTERFACES="Limpiando configuraciones de interfaces no existentes"
NETWORK_INTERFACE_REMOVED="Interfaz eliminada"
NETWORK_CONFIGURING_INTERFACES="Configurando interfaces"
NETWORK_INTERFACE_ADDED="Interfaz aÃ±adida"
NETWORK_RESTARTING="Reiniciando el servicio de red"
NETWORK_RESTART_SUCCESS="Servicio de red reiniciado con Ã©xito"
NETWORK_RESTART_FAILED="Error al reiniciar el servicio de red"
NETWORK_CONNECTIVITY_OK="Conectividad de red OK"
NETWORK_CONNECTIVITY_FAILED="Fallo en la conectividad de red"
NETWORK_IP_INFO="InformaciÃ³n de IP"
NETWORK_NO_IP="No IP"
NETWORK_REPAIR_STARTED="Iniciando reparaciÃ³n de red"
NETWORK_REPAIR_COMPLETED="ReparaciÃ³n de red completada"
NETWORK_REPAIR_FAILED="Fallo en la reparaciÃ³n de red"
NETWORK_REPAIR_PROCESS_FINISHED="Proceso de reparaciÃ³n de red finalizado"
NETWORK_VERIFY_STARTED="Iniciando verificaciÃ³n de red"
NETWORK_VERIFY_FINISHED="VerificaciÃ³n de red finalizada"
NETWORK_REPAIR_RUNNING="Ejecutando reparaciÃ³n de red..."
NETWORK_REPAIR_SUCCESS="ReparaciÃ³n de red ejecutada con Ã©xito."
NETWORK_REPAIR_ERROR="Error al ejecutar la reparaciÃ³n de red."
NETWORK_VERIFY_RUNNING="Ejecutando verificaciÃ³n de red..."
NETWORK_VERIFY_SUCCESS="VerificaciÃ³n de red completada con Ã©xito."
NETWORK_VERIFY_ERROR="Error al ejecutar la verificaciÃ³n de red."
NETWORK_IP_INFO_RUNNING="Obteniendo informaciÃ³n de IP..."
NETWORK_IP_INFO_SUCCESS="InformaciÃ³n de IP obtenida con Ã©xito."
NETWORK_IP_INFO_ERROR="Error al obtener informaciÃ³n de IP."
# --- Fin de mensajes para repair_network.sh ---



================================================
FILE: scripts/auto_post_install.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Complete Post-Installation Script with Registration
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 06/07/2025
# ==========================================================
# Description:
#
# The script performs system optimizations including:
# - Repository configuration and system upgrades
# - Subscription banner removal and UI enhancements  
# - Advanced memory management and kernel optimizations
# - Network stack tuning and security hardening
# - Storage optimizations including log2ram for SSD protection
# - System limits increases and entropy generation improvements
# - Journald and logrotate optimizations for better log management
# - Security enhancements including RPC disabling and time synchronization
# - Bash environment customization and system monitoring setup
#
# Key Features:
# - Zero-interaction automation: Runs completely unattended
# - Intelligent hardware detection: Automatically detects SSD/NVMe for log2ram
# - RAM-aware configurations: Adjusts settings based on available system memory
# - Comprehensive error handling: Robust installation with fallback mechanisms
# - Registration system: Tracks installed optimizations for easy management
# - Reboot management: Intelligently handles reboot requirements
# - Translation support: Multi-language compatible through ProxMenux framework
# - Rollback compatibility: All optimizations can be reversed using the uninstall script
#
# This script is based on the post-install script customizable
# ==========================================================


# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Global variables
OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
RAM_SIZE_GB=$(( $(vmstat -s | grep -i "total memory" | xargs | cut -d" " -f 1) / 1024 / 1000))
NECESSARY_REBOOT=0
SCRIPT_TITLE="Customizable post-installation optimization script"

# ==========================================================
# Tool registration system
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

# ==========================================================
lvm_repair_check() {
    msg_info "$(translate "Checking and repairing old LVM PV headers (if needed)...")"
    pvs_output=$(LC_ALL=C pvs -v 2>&1 | grep "old PV header")
    if [ -z "$pvs_output" ]; then
        msg_ok "$(translate "No PVs with old headers found.")"
        register_tool "lvm_repair" true
        return
    fi
    
    declare -A vg_map
    while read -r line; do
        pv=$(echo "$line" | grep -o '/dev/[^ ]*')
        vg=$(pvs -o vg_name --noheadings "$pv" | awk '{print $1}')
        if [ -n "$vg" ]; then
            vg_map["$vg"]=1
        fi
    done <<< "$pvs_output"
    
    for vg in "${!vg_map[@]}"; do
        msg_warn "$(translate "Old PV header(s) found in VG $vg. Updating metadata...")"
        vgck --updatemetadata "$vg"
        vgchange -ay "$vg"
        if [ $? -ne 0 ]; then
            msg_warn "$(translate "Metadata update failed for VG $vg. Review manually.")"
        else
            msg_ok "$(translate "Metadata updated successfully for VG $vg")"
        fi
    done
    
    msg_ok "$(translate "LVM PV headers check completed")"
    register_tool "lvm_repair" true
}

# ==========================================================
cleanup_duplicate_repos() {
    local sources_file="/etc/apt/sources.list"
    local temp_file=$(mktemp)
    local cleaned_count=0
    declare -A seen_repos
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            echo "$line" >> "$temp_file"
            continue
        fi
        
        if [[ "$line" =~ ^deb ]]; then
            read -r _ url dist components <<< "$line"
            local key="${url}_${dist}"
            if [[ -v "seen_repos[$key]" ]]; then
                echo "# $line" >> "$temp_file"
                cleaned_count=$((cleaned_count + 1))
            else
                echo "$line" >> "$temp_file"
                seen_repos[$key]="$components"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$sources_file"
    
    mv "$temp_file" "$sources_file"
    chmod 644 "$sources_file"
    

    local pve_files=(/etc/apt/sources.list.d/*proxmox*.list /etc/apt/sources.list.d/*pve*.list)
    local pve_content="deb http://download.proxmox.com/debian/pve ${OS_CODENAME} pve-no-subscription"
    local pve_public_repo="/etc/apt/sources.list.d/pve-public-repo.list"
    local pve_public_repo_exists=false
    
    if [ -f "$pve_public_repo" ] && grep -q "^deb.*pve-no-subscription" "$pve_public_repo"; then
        pve_public_repo_exists=true
    fi
    
    for file in "${pve_files[@]}"; do
        if [ -f "$file" ] && grep -q "^deb.*pve-no-subscription" "$file"; then
            if ! $pve_public_repo_exists && [[ "$file" == "$pve_public_repo" ]]; then
                sed -i 's/^# *deb/deb/' "$file"
                pve_public_repo_exists=true
            elif [[ "$file" != "$pve_public_repo" ]]; then
                sed -i 's/^deb/# deb/' "$file"
                cleaned_count=$((cleaned_count + 1))
            fi
        fi
    done
    
    apt update

}



apt_upgrade() {


    NECESSARY_REBOOT=1 


    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ] && grep -q "^deb" /etc/apt/sources.list.d/pve-enterprise.list; then
        msg_info "$(translate "Disabling enterprise Proxmox repository...")"
        sed -i "s/^deb/#deb/g" /etc/apt/sources.list.d/pve-enterprise.list
        msg_ok "$(translate "Enterprise Proxmox repository disabled")"
    fi


    if [ -f /etc/apt/sources.list.d/ceph.list ] && grep -q "^deb" /etc/apt/sources.list.d/ceph.list; then
        msg_info "$(translate "Disabling enterprise Proxmox Ceph repository...")"
        sed -i "s/^deb/#deb/g" /etc/apt/sources.list.d/ceph.list
        msg_ok "$(translate "Enterprise Proxmox Ceph repository disabled")"
    fi


    if [ ! -f /etc/apt/sources.list.d/pve-public-repo.list ] || ! grep -q "pve-no-subscription" /etc/apt/sources.list.d/pve-public-repo.list; then
        msg_info "$(translate "Enabling free public Proxmox repository...")"
        echo "deb http://download.proxmox.com/debian/pve ${OS_CODENAME} pve-no-subscription" > /etc/apt/sources.list.d/pve-public-repo.list
        msg_ok "$(translate "Free public Proxmox repository enabled")"
    fi



    sources_file="/etc/apt/sources.list"
    need_update=false


    sed -i 's|ftp.es.debian.org|deb.debian.org|g' "$sources_file"


    if grep -q "^deb http://security.debian.org ${OS_CODENAME}-security main contrib" "$sources_file"; then
        sed -i "s|^deb http://security.debian.org ${OS_CODENAME}-security main contrib|deb http://security.debian.org/debian-security ${OS_CODENAME}-security main contrib non-free non-free-firmware|" "$sources_file"
        msg_ok "$(translate "Replaced security repository with full version")"
        need_update=true
    fi


    if ! grep -q "deb http://security.debian.org/debian-security ${OS_CODENAME}-security" "$sources_file"; then
        echo "deb http://security.debian.org/debian-security ${OS_CODENAME}-security main contrib non-free non-free-firmware" >> "$sources_file"
        need_update=true
    fi


    if ! grep -q "deb http://deb.debian.org/debian ${OS_CODENAME} " "$sources_file"; then
        echo "deb http://deb.debian.org/debian ${OS_CODENAME} main contrib non-free non-free-firmware" >> "$sources_file"
        need_update=true
    fi


    if ! grep -q "deb http://deb.debian.org/debian ${OS_CODENAME}-updates" "$sources_file"; then
        echo "deb http://deb.debian.org/debian ${OS_CODENAME}-updates main contrib non-free non-free-firmware" >> "$sources_file"
        need_update=true
    fi

        msg_ok "$(translate "Debian repositories configured correctly")"

# ===================================================


    if [ ! -f /etc/apt/apt.conf.d/no-bookworm-firmware.conf ]; then
        msg_info "$(translate "Disabling non-free firmware warnings...")"
        echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' > /etc/apt/apt.conf.d/no-bookworm-firmware.conf
        msg_ok "$(translate "Non-free firmware warnings disabled")"
    fi


    msg_info "$(translate "Updating package lists...")"
    if apt-get update > /dev/null 2>&1; then
        msg_ok "$(translate "Package lists updated")"
    else
        msg_error "$(translate "Failed to update package lists")"
        return 1
    fi


    msg_info "$(translate "Removing conflicting utilities...")"
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' purge ntp openntpd systemd-timesyncd > /dev/null 2>&1; then
        msg_ok "$(translate "Conflicting utilities removed")"
    else
        msg_error "$(translate "Failed to remove conflicting utilities")"
    fi

    

    msg_info "$(translate "Performing packages upgrade...")"
    apt-get install pv -y > /dev/null 2>&1
    total_packages=$(apt-get -s dist-upgrade | grep "^Inst" | wc -l)
    
    if [ "$total_packages" -eq 0 ]; then
        total_packages=1  
    fi
    msg_ok "$(translate "Packages upgrade successful")"
    tput civis  
    tput sc     

    
    (
        /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' dist-upgrade 2>&1 | \
        while IFS= read -r line; do
            if [[ "$line" =~ ^(Setting up|Unpacking|Preparing to unpack|Processing triggers for) ]]; then
              
                package_name=$(echo "$line" | sed -E 's/.*(Setting up|Unpacking|Preparing to unpack|Processing triggers for) ([^ ]+).*/\2/')

                
                [ -z "$package_name" ] && package_name="$(translate "Unknown")"

               
                tput rc
                tput ed

               
                row=$(( $(tput lines) - 6 ))
                tput cup $row 0; echo "$(translate "Installing packages...")"
                tput cup $((row + 1)) 0; echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                tput cup $((row + 2)) 0; echo "Package: $package_name"
                tput cup $((row + 3)) 0; echo "Progress: [                                                  ] 0%"
                tput cup $((row + 4)) 0; echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

               
                for i in $(seq 1 10); do
                    progress=$((i * 10))
                    tput cup $((row + 3)) 9 
                    printf "[%-50s] %3d%%" "$(printf "#%.0s" $(seq 1 $((progress/2))))" "$progress"
                      
                done
            fi
        done
    )

    if [ $? -eq 0 ]; then
        tput rc
        tput ed
        msg_ok "$(translate "System upgrade completed")"
    fi

   

    msg_info "$(translate "Installing additional Proxmox packages...")"
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install zfsutils-linux proxmox-backup-restore-image chrony > /dev/null 2>&1; then
        msg_ok "$(translate "Additional Proxmox packages installed")"
    else
        msg_error "$(translate "Failed to install additional Proxmox packages")"
    fi

    lvm_repair_check

    cleanup_duplicate_repos

    msg_ok "$(translate "Proxmox update completed")"

}

# ==========================================================
remove_subscription_banner() {
    msg_info "$(translate "Removing Proxmox subscription nag banner...")"
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    local APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
    
    if [[ ! -f "$APT_HOOK" ]]; then
        cat <<'EOF' > "$APT_HOOK"
DPkg::Post-Invoke { "dpkg -V proxmox-widget-toolkit | grep -q '/proxmoxlib\.js$'; if [ $? -eq 1 ]; then { echo 'Removing subscription nag from UI...'; sed -i '/.*data\.status.*{/{s/\!//;s/active/NoMoreNagging/;s/Active/NoMoreNagging/}' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; rm -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz; }; fi"; };
EOF
    fi
    
    if [[ -f "$JS_FILE" ]]; then
        sed -i '/.*data\.status.*{/{s/\!//;s/active/NoMoreNagging/;s/Active/NoMoreNagging/}' "$JS_FILE"
        [[ -f "$GZ_FILE" ]] && rm -f "$GZ_FILE"
        touch "$JS_FILE"
    fi
    
    apt --reinstall install proxmox-widget-toolkit -y > /dev/null 2>&1
    
    msg_ok "$(translate "Subscription nag banner removed successfully")"
    register_tool "subscription_banner" true
}

# ==========================================================


configure_time_sync() {
    msg_info "$(translate "Configuring system time settings...")"

    this_ip=$(dig +short myip.opendns.com @resolver1.opendns.com)
    if [ -z "$this_ip" ]; then
        msg_warn "$(translate "Failed to obtain public IP address")"
        timezone="UTC"
    else

        timezone=$(curl -s "https://ipapi.co/${this_ip}/timezone")
        if [ -z "$timezone" ]; then
            msg_warn "$(translate "Failed to determine timezone from IP address")"
            timezone="UTC"
        else
            msg_ok "$(translate "Found timezone $timezone for IP $this_ip")"
        fi
    fi

    msg_info "$(translate "Enabling automatic time synchronization...")"
    if timedatectl set-ntp true; then
        msg_ok "$(translate "Time settings configured - Timezone:") $timezone"
        register_tool "time_sync" true
    else
        msg_error "$(translate "Failed to enable automatic time synchronization")"
    fi

}

# ==========================================================
skip_apt_languages() {
    msg_info "$(translate "Configuring APT to skip downloading additional languages...")"
    local default_locale=""
    
    if [ -f /etc/default/locale ]; then
        default_locale=$(grep '^LANG=' /etc/default/locale | cut -d= -f2 | tr -d '"')
    elif [ -f /etc/environment ]; then
        default_locale=$(grep '^LANG=' /etc/environment | cut -d= -f2 | tr -d '"')
    fi
    
    default_locale="${default_locale:-en_US.UTF-8}"
    local normalized_locale=$(echo "$default_locale" | tr 'A-Z' 'a-z' | sed 's/utf-8/utf8/;s/-/_/')
    
    if ! locale -a | grep -qi "^$normalized_locale$"; then
        if ! grep -qE "^${default_locale}[[:space:]]+UTF-8" /etc/locale.gen; then
            echo "$default_locale UTF-8" >> /etc/locale.gen
        fi
        locale-gen "$default_locale" > /dev/null 2>&1
    fi
    
    echo 'Acquire::Languages "none";' > /etc/apt/apt.conf.d/99-disable-translations
    
    msg_ok "$(translate "APT configured to skip additional languages")"
    register_tool "apt_languages" true
}

# ==========================================================
optimize_journald() {
    msg_info "$(translate "Limiting size and optimizing journald...")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/systemd/journald.conf
[Journal]
Storage=persistent
SplitMode=none
RateLimitInterval=0
RateLimitIntervalSec=0
RateLimitBurst=0
ForwardToSyslog=no
ForwardToWall=yes
Seal=no
Compress=yes
SystemMaxUse=64M
RuntimeMaxUse=60M
MaxLevelStore=warning
MaxLevelSyslog=warning
MaxLevelKMsg=warning
MaxLevelConsole=notice
MaxLevelWall=crit
EOF
    
    systemctl restart systemd-journald.service > /dev/null 2>&1
    journalctl --vacuum-size=64M --vacuum-time=1d > /dev/null 2>&1
    journalctl --rotate > /dev/null 2>&1
    
    msg_ok "$(translate "Journald optimized - Max size: 64M")"
    register_tool "journald" true
}

# ==========================================================
optimize_logrotate() {
    msg_info "$(translate "Optimizing logrotate configuration...")"
    local logrotate_conf="/etc/logrotate.conf"
    local backup_conf="${logrotate_conf}.bak"
    
    if ! grep -q "# ProxMenux optimized configuration" "$logrotate_conf"; then
        cp "$logrotate_conf" "$backup_conf"
        cat <<EOF > "$logrotate_conf"
# ProxMenux optimized configuration
daily
su root adm
rotate 7
create
compress
size=10M
delaycompress
copytruncate
include /etc/logrotate.d
EOF
        systemctl restart logrotate > /dev/null 2>&1
    fi
    
    msg_ok "$(translate "Logrotate optimization completed")"
    register_tool "logrotate" true
}

# ==========================================================
increase_system_limits() {
    msg_info "$(translate "Increasing various system limits...")"
    NECESSARY_REBOOT=1
    

    cat > /etc/sysctl.d/99-maxwatches.conf << EOF
# ProxMenux configuration
fs.inotify.max_user_watches = 1048576
fs.inotify.max_user_instances = 1048576
fs.inotify.max_queued_events = 1048576
EOF
    
 
    cat > /etc/security/limits.d/99-limits.conf << EOF
# ProxMenux configuration
* soft     nproc          1048576
* hard     nproc          1048576
* soft     nofile         1048576
* hard     nofile         1048576
root soft     nproc          unlimited
root hard     nproc          unlimited
root soft     nofile         unlimited
root hard     nofile         unlimited
EOF
    
 
    cat > /etc/sysctl.d/99-maxkeys.conf << EOF
# ProxMenux configuration
kernel.keys.root_maxkeys=1000000
kernel.keys.maxkeys=1000000
EOF
    
   
    for file in /etc/systemd/system.conf /etc/systemd/user.conf; do
        if ! grep -q "^DefaultLimitNOFILE=" "$file"; then
            echo "DefaultLimitNOFILE=256000" >> "$file"
        fi
    done
    

    for file in /etc/pam.d/common-session /etc/pam.d/runuser-l; do
        if ! grep -q "^session required pam_limits.so" "$file"; then
            echo 'session required pam_limits.so' >> "$file"
        fi
    done
    

    if ! grep -q "ulimit -n 256000" /root/.profile; then
        echo "ulimit -n 256000" >> /root/.profile
    fi
    

    cat > /etc/sysctl.d/99-swap.conf << EOF
# ProxMenux configuration
vm.swappiness = 10
vm.vfs_cache_pressure = 100
EOF
    
 
    cat > /etc/sysctl.d/99-fs.conf << EOF
# ProxMenux configuration
fs.nr_open = 12000000
fs.file-max = 9223372036854775807
fs.aio-max-nr = 1048576
EOF
    
    msg_ok "$(translate "System limits increase completed.")"
    register_tool "system_limits" true
}

# ==========================================================
configure_entropy() {
    msg_info "$(translate "Configuring entropy generation to prevent slowdowns...")"
    
    /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install haveged > /dev/null 2>&1
    
    cat <<EOF > /etc/default/haveged
#   -w sets low entropy watermark (in bits)
DAEMON_ARGS="-w 1024"
EOF
    
    systemctl daemon-reload > /dev/null 2>&1
    systemctl enable haveged > /dev/null 2>&1
    
    msg_ok "$(translate "Entropy generation configuration completed")"
    register_tool "entropy" true
}

# ==========================================================
optimize_memory_settings() {
    msg_info "$(translate "Optimizing memory settings...")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/sysctl.d/99-memory.conf
# Balanced Memory Optimization
vm.swappiness = 10
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
vm.overcommit_memory = 1
vm.max_map_count = 65530
EOF
    
    if [ -f /proc/sys/vm/compaction_proactiveness ]; then
        echo "vm.compaction_proactiveness = 20" >> /etc/sysctl.d/99-memory.conf
    fi
    
    msg_ok "$(translate "Memory optimization completed.")"
    register_tool "memory_settings" true
}

# ==========================================================
configure_kernel_panic() {
    msg_info "$(translate "Configuring kernel panic behavior")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/sysctl.d/99-kernelpanic.conf
# Enable restart on kernel panic, kernel oops and hardlockup
kernel.core_pattern = /var/crash/core.%t.%p
kernel.panic = 10
kernel.panic_on_oops = 1
kernel.hardlockup_panic = 1
EOF
    
    msg_ok "$(translate "Kernel panic behavior configuration completed")"
    register_tool "kernel_panic" true
}

# ==========================================================
force_apt_ipv4() {
    msg_info "$(translate "Configuring APT to use IPv4...")"
    
    echo 'Acquire::ForceIPv4 "true";' > /etc/apt/apt.conf.d/99-force-ipv4
    
    msg_ok "$(translate "APT IPv4 configuration completed")"
    register_tool "apt_ipv4" true
}

# ==========================================================
apply_network_optimizations() {
    msg_info "$(translate "Optimizing network settings...")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/sysctl.d/99-network.conf
net.core.netdev_max_backlog=8192
net.core.optmem_max=8192
net.core.rmem_max=16777216
net.core.somaxconn=8151
net.core.wmem_max=16777216
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.all.log_martians = 0
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.default.log_martians = 0
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.tcp_base_mss = 1024
net.ipv4.tcp_challenge_ack_limit = 999999999
net.ipv4.tcp_fin_timeout=10
net.ipv4.tcp_keepalive_intvl=30
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_time=240
net.ipv4.tcp_limit_output_bytes=65536
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets = 1440000
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_rfc1337=1
net.ipv4.tcp_rmem=8192 87380 16777216
net.ipv4.tcp_sack=1
net.ipv4.tcp_slow_start_after_idle=0
net.ipv4.tcp_syn_retries=3
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_tw_reuse = 0
net.ipv4.tcp_wmem=8192 65536 16777216
net.netfilter.nf_conntrack_generic_timeout = 60
net.netfilter.nf_conntrack_helper=0
net.netfilter.nf_conntrack_max = 524288
net.netfilter.nf_conntrack_tcp_timeout_established = 28800
net.unix.max_dgram_qlen = 4096
EOF
    
    sysctl --system > /dev/null 2>&1
    
    local interfaces_file="/etc/network/interfaces"
    if ! grep -q 'source /etc/network/interfaces.d/*' "$interfaces_file"; then
        echo "source /etc/network/interfaces.d/*" >> "$interfaces_file"
    fi
    
    msg_ok "$(translate "Network optimization completed")"
    register_tool "network_optimization" true
}

# ==========================================================
disable_rpc() {
    msg_info "$(translate "Disabling portmapper/rpcbind for security...")"
    
    systemctl disable rpcbind > /dev/null 2>&1
    systemctl stop rpcbind > /dev/null 2>&1
    
    msg_ok "$(translate "portmapper/rpcbind has been disabled and removed")"
    register_tool "disable_rpc" true
}

# ==========================================================
customize_bashrc() {
    msg_info "$(translate "Customizing bashrc for root user...")"
    local bashrc="/root/.bashrc"
    local bash_profile="/root/.bash_profile"
    
    if [ ! -f "${bashrc}.bak" ]; then
        cp "$bashrc" "${bashrc}.bak"
    fi
    
 
    cat >> "$bashrc" << 'EOF'

# ProxMenux customizations
export HISTTIMEFORMAT="%d/%m/%y %T "
export PS1="\[\e[31m\][\[\e[m\]\[\e[38;5;172m\]\u\[\e[m\]@\[\e[38;5;153m\]\h\[\e[m\] \[\e[38;5;214m\]\W\[\e[m\]\[\e[31m\]]\[\e[m\]\\$ "
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
source /etc/profile.d/bash_completion.sh
EOF
    
    if ! grep -q "source /root/.bashrc" "$bash_profile"; then
        echo "source /root/.bashrc" >> "$bash_profile"
    fi
    
    msg_ok "$(translate "Bashrc customization completed")"
    register_tool "bashrc_custom" true
}

# ==========================================================

install_log2ram_auto() {
    msg_info "$(translate "Checking if system disk is SSD or M.2...")"

    ROOT_PART=$(lsblk -no NAME,MOUNTPOINT | grep ' /$' | awk '{print $1}')
    SYSTEM_DISK=$(lsblk -no PKNAME /dev/$ROOT_PART 2>/dev/null)
    SYSTEM_DISK=${SYSTEM_DISK:-sda}

    if [[ "$SYSTEM_DISK" == nvme* || "$(cat /sys/block/$SYSTEM_DISK/queue/rotational 2>/dev/null)" == "0" ]]; then
        msg_ok "$(translate "System disk ($SYSTEM_DISK) is SSD or M.2. Proceeding with log2ram setup.")"
    else
        msg_warn "$(translate "System disk ($SYSTEM_DISK) is not SSD/M.2. Skipping log2ram installation.")"
        return 0
    fi

    # Clean up previous state
    rm -rf /tmp/log2ram
    rm -f /etc/systemd/system/log2ram*
    rm -f /etc/systemd/system/log2ram-daily.*
    rm -f /etc/cron.d/log2ram*
    rm -f /usr/sbin/log2ram
    rm -f /etc/log2ram.conf
    rm -f /usr/local/bin/log2ram-check.sh
    rm -rf /var/log.hdd
    systemctl daemon-reexec >/dev/null 2>&1
    systemctl daemon-reload >/dev/null 2>&1

    msg_info "$(translate "Installing log2ram from GitHub...")"

    git clone https://github.com/azlux/log2ram.git /tmp/log2ram >/dev/null 2>>/tmp/log2ram_install.log
    cd /tmp/log2ram || return 1
    bash install.sh >>/tmp/log2ram_install.log 2>&1

    if [[ -f /etc/log2ram.conf ]] && systemctl list-units --all | grep -q log2ram; then
        msg_ok "$(translate "log2ram installed successfully")"
    else
        msg_error "$(translate "Failed to install log2ram. See /tmp/log2ram_install.log")"
        return 1
    fi

    # Detect RAM (in MB first for better accuracy)
    RAM_SIZE_MB=$(free -m | awk '/^Mem:/{print $2}')
    RAM_SIZE_GB=$((RAM_SIZE_MB / 1024))
    [[ -z "$RAM_SIZE_GB" || "$RAM_SIZE_GB" -eq 0 ]] && RAM_SIZE_GB=4

    if (( RAM_SIZE_GB <= 8 )); then
        LOG2RAM_SIZE="128M"
        CRON_HOURS=1
    elif (( RAM_SIZE_GB <= 16 )); then
        LOG2RAM_SIZE="256M"
        CRON_HOURS=3
    else
        LOG2RAM_SIZE="512M"
        CRON_HOURS=6
    fi

    msg_ok "$(translate "Detected RAM:") $RAM_SIZE_GB GB â€” $(translate "log2ram size set to:") $LOG2RAM_SIZE"

    sed -i "s/^SIZE=.*/SIZE=$LOG2RAM_SIZE/" /etc/log2ram.conf
    rm -f /etc/cron.hourly/log2ram
    echo "0 */$CRON_HOURS * * * root /usr/sbin/log2ram write" > /etc/cron.d/log2ram
    msg_ok "$(translate "log2ram write scheduled every") $CRON_HOURS $(translate "hour(s)")"

    cat << 'EOF' > /usr/local/bin/log2ram-check.sh
#!/bin/bash
CONF_FILE="/etc/log2ram.conf"
SIZE_VALUE=$(grep '^SIZE=' "$CONF_FILE" | cut -d'=' -f2)
# Convert to KB: handle M (megabytes) and G (gigabytes)
if [[ "$SIZE_VALUE" == *"G" ]]; then
    LIMIT_KB=$(($(echo "$SIZE_VALUE" | tr -d 'G') * 1024 * 1024))
else
    LIMIT_KB=$(($(echo "$SIZE_VALUE" | tr -d 'M') * 1024))
fi
USED_KB=$(df /var/log --output=used | tail -1)
THRESHOLD=$(( LIMIT_KB * 90 / 100 ))
if (( USED_KB > THRESHOLD )); then
    /usr/sbin/log2ram write
fi
EOF

    chmod +x /usr/local/bin/log2ram-check.sh
    echo "*/5 * * * * root /usr/local/bin/log2ram-check.sh" > /etc/cron.d/log2ram-auto-sync
    msg_ok "$(translate "Auto-sync enabled when /var/log exceeds 90% of") $LOG2RAM_SIZE"


    register_tool "log2ram" true
}

# ==========================================================

run_complete_optimization() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "ProxMenux Optimization Post-Installation")"
    
    ensure_tools_json
    
    apt_upgrade
    remove_subscription_banner
    configure_time_sync
    skip_apt_languages
    optimize_journald
    optimize_logrotate
    increase_system_limits
    configure_entropy
    optimize_memory_settings
    configure_kernel_panic
    force_apt_ipv4
    apply_network_optimizations
    disable_rpc
    customize_bashrc
    install_log2ram_auto
    

    echo -e
    msg_success "$(translate "Complete post-installation optimization finished!")"
    
    if [[ "$NECESSARY_REBOOT" -eq 1 ]]; then
        whiptail --title "Reboot Required" \
            --yesno "$(translate "Some changes require a reboot to take effect. Do you want to restart now?")" 10 60
        if [[ $? -eq 0 ]]; then
        msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
        apt-get -y autoremove >/dev/null 2>&1
        apt-get -y autoclean >/dev/null 2>&1
        msg_ok "$(translate "Cleanup finished")"
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        msg_warn "$(translate "Rebooting the system...")"
        reboot
        else
        msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
        apt-get -y autoremove >/dev/null 2>&1
        apt-get -y autoclean >/dev/null 2>&1
        msg_ok "$(translate "Cleanup finished")"
        msg_info2 "$(translate "You can reboot later manually.")"
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        exit 0
        fi
    fi

    msg_success "$(translate "All changes applied. No reboot required.")"
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
    clear
}


if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    run_complete_optimization
fi


================================================
FILE: scripts/configure_igpu_lxc.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 17/08/2025
# ==========================================================
# Description:
# This script automates the process of enabling and configuring Intel Integrated GPU (iGPU) support in Proxmox VE LXC containers.
# Its goal is to simplify the configuration of hardware-accelerated graphical capabilities within containers, allowing for efficient
# use of Intel iGPUs for tasks such as transcoding, rendering, and accelerating graphics-intensive applications.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================




select_container() {

    CONTAINERS=$(pct list | awk 'NR>1 {print $1, $3}' | xargs -n2)
    if [ -z "$CONTAINERS" ]; then
        msg_error "$(translate 'No containers available in Proxmox.')"
        exit 1
    fi

    CONTAINER_ID=$(whiptail --title "$(translate 'Select Container')" \
        --menu "$(translate 'Select the LXC container:')" 20 70 10 $CONTAINERS 3>&1 1>&2 2>&3)

    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'No container selected. Exiting.')"
        exit 1
    fi

    if ! pct list | awk 'NR>1 {print $1}' | grep -qw "$CONTAINER_ID"; then
        msg_error "$(translate 'Container with ID') $CONTAINER_ID $(translate 'does not exist. Exiting.')"
        exit 1
    fi

    msg_ok "$(translate 'Container selected:') $CONTAINER_ID"
}




validate_container_id() {
    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'Container ID not defined. Make sure to select a container first.')"
        exit 1
    fi


    if pct status "$CONTAINER_ID" | grep -q "running"; then
        msg_info "$(translate 'Stopping the container before applying configuration...')"
        pct stop "$CONTAINER_ID"
        msg_ok "$(translate 'Container stopped.')"
    fi
}



configure_lxc_for_igpu() {
  validate_container_id

  CONFIG_FILE="/etc/pve/lxc/${CONTAINER_ID}.conf"
  [[ -f "$CONFIG_FILE" ]] || { msg_error "$(translate 'Configuration file for container') $CONTAINER_ID $(translate 'not found.')"; exit 1; }

  
  if [[ ! -d /dev/dri ]]; then
    modprobe i915 2>/dev/null || true
    for _ in {1..5}; do
      [[ -d /dev/dri ]] && break
      sleep 1
    done
  fi

  CT_TYPE=$(pct config "$CONTAINER_ID" | awk '/^unprivileged:/ {print $2}')
  [[ -z "$CT_TYPE" ]] && CT_TYPE="0"  

  msg_info "$(translate 'Configuring Intel iGPU passthrough for container...')"

    for rn in /dev/dri/renderD*; do
    [[ -e "$rn" ]] || continue
    chmod 660 "$rn" 2>/dev/null || true
    chgrp render "$rn" 2>/dev/null || true
    done

    mapfile -t RENDER_NODES < <(find /dev/dri -maxdepth 1 -type c -name 'renderD*' 2>/dev/null || true)
    mapfile -t CARD_NODES   < <(find /dev/dri -maxdepth 1 -type c -name 'card*'    2>/dev/null || true)
    FB_NODE=""
    [[ -e /dev/fb0 ]] && FB_NODE="/dev/fb0"

    if [[ ${#RENDER_NODES[@]} -eq 0 && ${#CARD_NODES[@]} -eq 0 && -z "$FB_NODE" ]]; then
        msg_warn "$(translate 'No VA-API devices found on host (/dev/dri*, /dev/fb0). Is i915 loaded?')"
        return 0
    fi

    if grep -q '^features:' "$CONFIG_FILE"; then
        grep -Eq '^features:.*(^|,)\s*nesting=1(\s|,|$)' "$CONFIG_FILE" || sed -i 's/^features:\s*/&nesting=1, /' "$CONFIG_FILE"
    else
        echo "features: nesting=1" >> "$CONFIG_FILE"
    fi



  if [[ "$CT_TYPE" == "0" ]]; then

        sed -i '/^lxc\.cgroup2\.devices\.allow:\s*c\s*226:/d' "$CONFIG_FILE"
        sed -i '\|^lxc\.mount\.entry:\s*/dev/dri|d' "$CONFIG_FILE"
        sed -i '\|^lxc\.mount\.entry:\s*/dev/fb0|d' "$CONFIG_FILE"

        echo "lxc.cgroup2.devices.allow: c 226:* rwm" >> "$CONFIG_FILE"
        echo "lxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dir" >> "$CONFIG_FILE"
        [[ -n "$FB_NODE" ]] && echo "lxc.mount.entry: /dev/fb0 dev/fb0 none bind,optional,create=file" >> "$CONFIG_FILE"


    else
        sed -i '/^dev[0-9]\+:/d' "$CONFIG_FILE"

        idx=0
        for c in "${CARD_NODES[@]}"; do
        echo "dev${idx}: $c,gid=44" >> "$CONFIG_FILE"
        idx=$((idx+1))
        done
        for r in "${RENDER_NODES[@]}"; do
        echo "dev${idx}: $r,gid=104" >> "$CONFIG_FILE"
        idx=$((idx+1))
        done

  fi
  msg_ok "$(translate 'iGPU configuration added to container') $CONTAINER_ID."

}





install_igpu_in_container() {

    msg_info2 "$(translate 'Installing iGPU drivers inside the container...')"
    tput sc
    LOG_FILE=$(mktemp)


    pct start "$CONTAINER_ID" >/dev/null 2>&1

    script -q -c "pct exec \"$CONTAINER_ID\" -- bash -c '
    set -e
    getent group video  >/dev/null || groupadd -g 44  video
    getent group render >/dev/null || groupadd -g 104 render
    usermod -aG video,render root || true

    apt-get update >/dev/null 2>&1
    apt-get install -y va-driver-all ocl-icd-libopencl1 intel-opencl-icd vainfo intel-gpu-tools

    chgrp video /dev/dri 2>/dev/null || true
    chmod 755 /dev/dri 2>/dev/null || true
    '" "$LOG_FILE"

    if [ $? -eq 0 ]; then
        tput rc 
        tput ed 
        rm -f "$LOG_FILE"  
        msg_ok "$(translate 'iGPU drivers installed inside the container.')"
    else
        tput rc  
        tput ed  
        msg_error "$(translate 'Failed to install iGPU drivers inside the container.')"
        cat "$LOG_FILE"  
        rm -f "$LOG_FILE"
        exit 1
    fi
}


select_container 
show_proxmenux_logo
msg_title "$(translate "Add HW iGPU acceleration to an LXC")"
configure_lxc_for_igpu
install_igpu_in_container


msg_success "$(translate 'iGPU configuration completed in container') $CONTAINER_ID."
echo -e
msg_success "$(translate "Press Enter to return to menu...")"
read -r



================================================
FILE: scripts/disk-passthrough.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks to existing
# Proxmox virtual machines (VMs) through an interactive menu.
# - Detects the system disk and excludes it from selection.
# - Lists all available VMs for the user to choose from.
# - Identifies and displays unassigned physical disks.
# - Allows the user to select multiple disks and attach them to a VM.
# - Supports interface types: SATA, SCSI, VirtIO, and IDE.
# - Ensures that disks are not already assigned to active VMs.
# - Warns about disk sharing between multiple VMs to avoid data corruption.
# - Configures the selected disks for the VM and verifies the assignment.
#
# The goal of this script is to simplify the process of assigning
# physical disks to Proxmox VMs, reducing manual configurations
# and preventing potential errors.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
show_proxmenux_logo
# ==========================================================



get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}


VM_LIST=$(qm list | awk 'NR>1 {print $1, $2}')
if [ -z "$VM_LIST" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VMs available in the system.")" 8 40
    exit 1
fi


VMID=$(whiptail --title "$(translate "Select VM")" --menu "$(translate "Select the VM to which you want to add disks:")" 15 60 8 $VM_LIST 3>&1 1>&2 2>&3)

if [ -z "$VMID" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VM was selected.")" 8 40
    exit 1
fi

VMID=$(echo "$VMID" | tr -d '"')


msg_ok "$(translate "VM selected successfully.")"


VM_STATUS=$(qm status "$VMID" | awk '{print $2}')
if [ "$VM_STATUS" == "running" ]; then
    whiptail --title "$(translate "Warning")" --msgbox "$(translate "The VM is powered on. Turn it off before adding disks.")" 12 60
    exit 1
fi


##########################################

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do

    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi


    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)


is_disk_in_use() {
    local disk="$1"


    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac

        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)


    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi

    return 1
}




FREE_DISKS=()

LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)
RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do

    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi



    USED_BY=""
    REAL_PATH=$(readlink -f "$DISK")
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi




    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi


    if $IS_ZFS; then
        SHOW_DISK=false
    fi


    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi


    if qm config "$VMID" | grep -vE '^\s*#|^description:' | grep -q "$DISK"; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"

        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)



if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks available for this VM.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"



######################################################




MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))

if [ $TOTAL_WIDTH -lt 50 ]; then
    TOTAL_WIDTH=50
fi


SELECTED=$(whiptail --title "$(translate "Select Disks")" --checklist \
    "$(translate "Select the disks you want to add:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 64
    clear
    exit 1
fi

msg_ok "$(translate "Disks selected successfully.")"


INTERFACE=$(whiptail --title "$(translate "Interface Type")" --menu "$(translate "Select the interface type for all disks:")" 15 40 4 \
    "sata" "$(translate "Add as SATA")" \
    "scsi" "$(translate "Add as SCSI")" \
    "virtio" "$(translate "Add as VirtIO")" \
    "ide" "$(translate "Add as IDE")" 3>&1 1>&2 2>&3)

if [ -z "$INTERFACE" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No interface type was selected for the disks.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Interface type selected: $INTERFACE")"

DISKS_ADDED=0
ERROR_MESSAGES=""
SUCCESS_MESSAGES=""



msg_info "$(translate "Processing selected disks...")"

for DISK in $SELECTED; do
    DISK=$(echo "$DISK" | tr -d '"')
    DISK_INFO=$(get_disk_info "$DISK")

    ASSIGNED_TO=""
    RUNNING_VMS=""
    RUNNING_CTS=""

  
    while read -r VM_ID VM_NAME; do
        if [[ "$VM_ID" =~ ^[0-9]+$ ]] && qm config "$VM_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="VM $VM_ID $VM_NAME\n"
            VM_STATUS=$(qm status "$VM_ID" | awk '{print $2}')
            if [ "$VM_STATUS" == "running" ]; then
                RUNNING_VMS+="VM $VM_ID $VM_NAME\n"
            fi
        fi
    done < <(qm list | awk 'NR>1 {print $1, $2}')


    while read -r CT_ID CT_NAME; do
        if [[ "$CT_ID" =~ ^[0-9]+$ ]] && pct config "$CT_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="CT $CT_ID $CT_NAME\n"
            CT_STATUS=$(pct status "$CT_ID" | awk '{print $2}')
            if [ "$CT_STATUS" == "running" ]; then
                RUNNING_CTS+="CT $CT_ID $CT_NAME\n"
            fi
        fi
    done < <(pct list | awk 'NR>1 {print $1, $2}')

    if [ -n "$RUNNING_VMS" ] || [ -n "$RUNNING_CTS" ]; then
        ERROR_MESSAGES+="$(translate "The disk") $DISK_INFO $(translate "is currently in use by the following running VM(s) or CT(s):")\\n$RUNNING_VMS$RUNNING_CTS\\n\\n$(translate "You cannot add this disk while the VM or CT is running.")\\n$(translate "Please shut it down first and run this script again to add the disk.")\\n\\n"
        continue
    fi

    if [ -n "$ASSIGNED_TO" ]; then
        cleanup
        whiptail --title "$(translate "Disk Already Assigned")" --yesno "$(translate "The disk") $DISK_INFO $(translate "is already assigned to the following VM(s) or CT(s):")\\n$ASSIGNED_TO\\n\\n$(translate "Do you want to continue anyway?")" 15 70
        if [ $? -ne 0 ]; then
            sleep 1
            exec "$0"
        fi
    fi


    INDEX=0
    while qm config "$VMID" | grep -q "${INTERFACE}${INDEX}"; do
        ((INDEX++))
    done

    RESULT=$(qm set "$VMID" -${INTERFACE}${INDEX} "$DISK" 2>&1)

    if [ $? -eq 0 ]; then
        MESSAGE="$(translate "The disk") $DISK_INFO $(translate "has been successfully added to VM") $VMID."
        if [ -n "$ASSIGNED_TO" ]; then
            MESSAGE+="\\n\\n$(translate "WARNING: This disk is also assigned to the following VM(s):")\\n$ASSIGNED_TO"
            MESSAGE+="\\n$(translate "Make sure not to start VMs that share this disk at the same time to avoid data corruption.")"
        fi
        SUCCESS_MESSAGES+="$MESSAGE\\n\\n"
        ((DISKS_ADDED++))
    else
        ERROR_MESSAGES+="$(translate "Could not add disk") $DISK_INFO $(translate "to VM") $VMID.\\n$(translate "Error:") $RESULT\\n\\n"
    fi
done

msg_ok "$(translate "Disk processing completed.")"



if [ -n "$SUCCESS_MESSAGES" ]; then
    MSG_LINES=$(echo "$SUCCESS_MESSAGES" | wc -l)
    whiptail --title "$(translate "Successful Operations")" --msgbox "$SUCCESS_MESSAGES" 16 70
fi

if [ -n "$ERROR_MESSAGES" ]; then
    whiptail --title "$(translate "Warnings and Errors")" --msgbox "$ERROR_MESSAGES" 16 70
fi



exit 0



================================================
FILE: scripts/disk-passthrough_ct.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks to existing
# Proxmox containers (CTs) through an interactive menu.
# - Detects the system disk and excludes it from selection.
# - Lists all available CTs for the user to choose from.
# - Identifies and displays unassigned physical disks.
# - Allows the user to select multiple disks and attach them to a CT.
# - Configures the selected disks for the CT and verifies the assignment.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache

# ==========================================================



get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}



CT_LIST=$(pct list | awk 'NR>1 {print $1, $3}')
if [ -z "$CT_LIST" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No CTs available in the system.")" 8 40
    exit 1
fi


CTID=$(whiptail --title "$(translate "Select CT")" --menu "$(translate "Select the CT to which you want to add disks:")" 15 60 8 $CT_LIST 3>&1 1>&2 2>&3)

if [ -z "$CTID" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No CT was selected.")" 8 40
    exit 1
fi

CTID=$(echo "$CTID" | tr -d '"')

msg_ok "$(translate "CT selected successfully.")"




CT_STATUS=$(pct status "$CTID" | awk '{print $2}')
if [ "$CT_STATUS" != "running" ]; then
    msg_info "$(translate "Starting CT") $CTID..."
    pct start "$CTID"
    sleep 2
    if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
        msg_error "$(translate "Failed to start the CT.")"
        exit 1
    fi
    msg_ok "$(translate "CT started successfully.")"
fi




CONF_FILE="/etc/pve/lxc/$CTID.conf"

if grep -q '^unprivileged: 1' "$CONF_FILE"; then
    if whiptail --title "$(translate "Privileged Container")" \
        --yesno "$(translate "The selected container is unprivileged. A privileged container is required for direct device passthrough.")\\n\\n$(translate "Do you want to convert it to a privileged container now?")" 12 70; then

        msg_info "$(translate "Stopping container") $CTID..."
        pct shutdown "$CTID" &
        for i in {1..10}; do
            sleep 1
            if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
                break
            fi
        done

        if [ "$(pct status "$CTID" | awk '{print $2}')" == "running" ]; then
            msg_error "$(translate "Failed to stop the container.")"
            exit 1
        fi

        msg_ok "$(translate "Container stopped.")"

        cp "$CONF_FILE" "$CONF_FILE.bak"
        sed -i '/^unprivileged: 1/d' "$CONF_FILE"
        echo "unprivileged: 0" >> "$CONF_FILE"

        msg_ok "$(translate "Container successfully converted to privileged.")"

        msg_info "$(translate "Starting container") $CTID..."
        pct start "$CTID"
        sleep 2
        if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
            msg_error "$(translate "Failed to start the container.")"
            exit 1
        fi
        msg_ok "$(translate "Container started successfully.")"

    else
        whiptail --title "$(translate "Aborted")" \
            --msgbox "$(translate "Operation cancelled. Cannot continue with an unprivileged container.")" 10 60
        exit 1
    fi
fi





##########################################





msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi

    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done


ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)

is_disk_in_use() {
    local disk="$1"

    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac

        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)

    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi

    return 1
}

FREE_DISKS=()

LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -r -n1 readlink -f | sort -u)

if [[ -n "$LVM_DEVICES" ]] && echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
    IS_MOUNTED=true
fi

RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi


    USED_BY=""
    REAL_PATH=$(readlink -f "$DISK")
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi



    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi

    if $IS_ZFS; then
        SHOW_DISK=false
    fi

    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi

    if pct config "$CTID" | grep -vE '^\s*#|^description:' | grep -q "$DISK"; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"

        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)

if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks available for this CT.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"





######################################################





MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))

if [ $TOTAL_WIDTH -lt 50 ]; then
    TOTAL_WIDTH=50
fi

SELECTED=$(whiptail --title "$(translate "Select Disks")" --radiolist \
    "$(translate "Select the disks you want to add:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 64
    clear
    exit 1
fi

msg_ok "$(translate "Disks selected successfully.")"

DISKS_ADDED=0
ERROR_MESSAGES=""
SUCCESS_MESSAGES=""

msg_info "$(translate "Processing selected disks...")"

for DISK in $SELECTED; do
    DISK=$(echo "$DISK" | tr -d '"')
    DISK_INFO=$(get_disk_info "$DISK")

    ASSIGNED_TO=""
    RUNNING_CTS=""
    RUNNING_VMS=""

    # Comprobar CTs
    while read -r CT_ID CT_NAME; do
        if [[ "$CT_ID" =~ ^[0-9]+$ ]] && pct config "$CT_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="CT $CT_ID $CT_NAME\n"
            CT_STATUS=$(pct status "$CT_ID" | awk '{print $2}')
            if [ "$CT_STATUS" == "running" ]; then
                RUNNING_CTS+="CT $CT_ID $CT_NAME\n"
            fi
        fi
    done < <(pct list | awk 'NR>1 {print $1, $3}')

    # Comprobar VMs
    while read -r VM_ID VM_NAME; do
        if [[ "$VM_ID" =~ ^[0-9]+$ ]] && qm config "$VM_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="VM $VM_ID $VM_NAME\n"
            VM_STATUS=$(qm status "$VM_ID" | awk '{print $2}')
            if [ "$VM_STATUS" == "running" ]; then
                RUNNING_VMS+="VM $VM_ID $VM_NAME\n"
            fi
        fi
    done < <(qm list | awk 'NR>1 {print $1, $2}')

    if [ -n "$RUNNING_CTS" ] || [ -n "$RUNNING_VMS" ]; then
        ERROR_MESSAGES+="$(translate "The disk") $DISK_INFO $(translate "is in use by the following running VM(s) or CT(s):")\\n$RUNNING_CTS$RUNNING_VMS\\n\\n"
        continue
    fi

    if [ -n "$ASSIGNED_TO" ]; then
        cleanup
        whiptail --title "$(translate "Disk Already Assigned")" --yesno "$(translate "The disk") $DISK_INFO $(translate "is already assigned to the following VM(s) or CT(s):")\\n$ASSIGNED_TO\\n\\n$(translate "Do you want to continue anyway?")" 15 70
        if [ $? -ne 0 ]; then
            sleep 1
            exec "$0"
        fi
    fi
    
    cleanup




    if lsblk "$DISK" | grep -q "raid" || grep -q "${DISK##*/}" /proc/mdstat; then
        whiptail --title "$(translate "RAID Detected")" --msgbox "$(translate "The disk") $DISK_INFO $(translate "appears to be part of a") RAID. $(translate "For security reasons, the system cannot format it.")\\n\\n$(translate "If you are sure you want to use it, please remove the") RAID metadata $(translate "or format it manually using external tools.")\\n\\n$(translate "After that, run this script again to add it.")" 18 70
        exit
    fi




    MOUNT_POINT=$(whiptail --title "$(translate "Mount Point")" --inputbox "$(translate "Enter the mount point for the disk (e.g., /mnt/disk_passthrough):")" 10 60 "/mnt/disk_passthrough" 3>&1 1>&2 2>&3)

    if [ -z "$MOUNT_POINT" ]; then
        whiptail --title "$(translate "Error")" --msgbox "$(translate "No mount point was specified.")" 8 40
        continue
    fi

    msg_ok "$(translate "Mount point specified: $MOUNT_POINT")"






    PARTITION=$(lsblk -rno NAME "$DISK" | awk -v disk="$(basename "$DISK")" '$1 != disk {print $1; exit}')
    SKIP_FORMAT=false

    if [ -n "$PARTITION" ]; then
        PARTITION="/dev/$PARTITION"
        CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)

        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION."
        else
            whiptail --title "$(translate "Unsupported Filesystem")" --yesno "$(translate "The partition") $PARTITION $(translate "has an unsupported filesystem ($CURRENT_FS).\\nDo you want to format it?")" 10 70
            if [ $? -ne 0 ]; then
                continue
            fi
        fi
    else

        CURRENT_FS=$(lsblk -no FSTYPE "$DISK" | xargs)

        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            PARTITION="$DISK"
            msg_ok "$(translate "Detected filesystem") $CURRENT_FS $(translate "directly on disk") $DISK.)"
        else

            whiptail --title "$(translate "No Valid Partitions")" --yesno "$(translate "The disk has no partitions and no valid filesystem. Do you want to create a new partition and format it?")" 10 70
            if [ $? -ne 0 ]; then
                continue
            fi

            echo -e "$(translate "Creating partition table and partition...")"
            parted -s "$DISK" mklabel gpt
            parted -s "$DISK" mkpart primary 0% 100%
            sleep 2
            partprobe "$DISK"
            sleep 2

            PARTITION=$(lsblk -rno NAME "$DISK" | awk -v disk="$(basename "$DISK")" '$1 != disk {print $1; exit}')
            if [ -n "$PARTITION" ]; then
                PARTITION="/dev/$PARTITION"
            else
                whiptail --title "$(translate "Partition Error")" --msgbox "$(translate "Failed to create partition on disk") $DISK_INFO." 8 70
                continue
            fi
        fi
    fi





    if [ "$SKIP_FORMAT" != true ]; then
        CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION. $(translate "Skipping format.")"
        else

            FORMAT_TYPE=$(whiptail --title "$(translate "Select Format Type")" --menu "$(translate "Select the filesystem type for") $DISK_INFO:" 15 60 6 \
                "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
                "xfs" "$(translate "XFS Filesystem")" \
                "btrfs" "$(translate "Btrfs Filesystem")" 3>&1 1>&2 2>&3)

            if [ -z "$FORMAT_TYPE" ]; then
                whiptail --title "$(translate "Format Cancelled")" --msgbox "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
                continue
            fi

            whiptail --title "$(translate "WARNING")" --yesno "$(translate "WARNING: This operation will FORMAT the disk") $DISK_INFO $(translate "with") $FORMAT_TYPE.\\n\\n$(translate "ALL DATA ON THIS DISK WILL BE PERMANENTLY LOST!")\\n\\n$(translate "Are you sure you want to continue")" 15 70
            if [ $? -ne 0 ]; then
                whiptail --title "$(translate "Format Cancelled")" --msgbox "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
                continue
            fi
        fi
    fi





    if [ "$SKIP_FORMAT" != true ]; then
        echo -e "$(translate "Formatting partition") $PARTITION $(translate "with") $FORMAT_TYPE..."

        case "$FORMAT_TYPE" in
            "ext4") mkfs.ext4 -F "$PARTITION" ;;
            "xfs") mkfs.xfs -f "$PARTITION" ;;
            "btrfs") mkfs.btrfs -f "$PARTITION" ;;
        esac

        if [ $? -ne 0 ]; then
            whiptail --title "$(translate "Format Failed")" --msgbox "$(translate "Failed to format partition") $PARTITION $(translate "with") $FORMAT_TYPE.\\n\\n$(translate "The disk may be in use by the system or have hardware issues.")" 12 70
            continue
        else
            msg_ok "$(translate "Partition") $PARTITION $(translate "successfully formatted with") $FORMAT_TYPE."
            partprobe "$DISK"
            sleep 2
        fi
    fi




    INDEX=0
    while pct config "$CTID" | grep -q "mp${INDEX}:"; do
        ((INDEX++))
    done




    ##############################################################################

    RESULT=$(pct set "$CTID" -mp${INDEX} "$PARTITION,mp=$MOUNT_POINT,backup=0,ro=0,acl=1" 2>&1)

    pct exec "$CTID" -- chmod -R 775 "$MOUNT_POINT"

    ##############################################################################




    if [ $? -eq 0 ]; then
        MESSAGE="$(translate "The disk") $DISK_INFO $(translate "has been successfully added to CT") $CTID $(translate "as a mount point at") $MOUNT_POINT."
        if [ -n "$ASSIGNED_TO" ]; then
            MESSAGE+="\\n\\n$(translate "WARNING: This disk is also assigned to the following CT(s):")\\n$ASSIGNED_TO"
            MESSAGE+="\\n$(translate "Make sure not to start CTs that share this disk at the same time to avoid data corruption.")"
        fi
        SUCCESS_MESSAGES+="$MESSAGE\\n\\n"
        ((DISKS_ADDED++))
    else
        ERROR_MESSAGES+="$(translate "Could not add disk") $DISK_INFO $(translate "to CT") $CTID.\\n$(translate "Error:") $RESULT\\n\\n"
    fi
done



msg_ok "$(translate "Disk processing completed.")"

if [ -n "$SUCCESS_MESSAGES" ]; then
    MSG_LINES=$(echo "$SUCCESS_MESSAGES" | wc -l)
    whiptail --title "$(translate "Successful Operations")" --msgbox "$SUCCESS_MESSAGES" 16 70
fi

if [ -n "$ERROR_MESSAGES" ]; then
    whiptail --title "$(translate "Warnings and Errors")" --msgbox "$ERROR_MESSAGES" 16 70
fi

exit 0



================================================
FILE: scripts/emergency_repair.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Network Management and Repair Tool
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 2.0
# Last Updated: 07/01/2025
# ==========================================================

# Description:
# Advanced network management and troubleshooting tool for Proxmox VE.
# Features include interface detection, bridge management, connectivity testing,
# network diagnostics, configuration backup/restore, and automated repairs.

# Configuration ============================================
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
BACKUP_DIR="/var/backups/proxmenux"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# Utility Functions
create_backup_dir() {
    [ ! -d "$BACKUP_DIR" ] && mkdir -p "$BACKUP_DIR"
}

backup_network_config() {
    create_backup_dir
    local timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    local backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"
    cp /etc/network/interfaces "$backup_file"
    echo "$backup_file"
}

# ==========================================================
# Network Detection Functions

detect_network_method() {
    # Detect Netplan
    if compgen -G "/etc/netplan/*.yaml" > /dev/null; then
        echo "netplan"
        return 0
    fi

    # Detect systemd-networkd
    if systemctl is-active --quiet systemd-networkd 2>/dev/null; then
        echo "systemd-networkd"
        return 0
    fi

    # Detect NetworkManager
    if systemctl is-active --quiet NetworkManager 2>/dev/null; then
        echo "networkmanager"
        return 0
    fi

    # Default: Debian/Proxmox classic
    echo "classic"
}


detect_physical_interfaces() {
    ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|bond|tap|tun|docker|br-)/ && $2 !~ /vmbr/ {print $2}' | sort
}

detect_bridge_interfaces() {
    ip -o link show | awk -F': ' '$2 ~ /^vmbr/ {print $2}' | sort
}

detect_all_interfaces() {
    ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|tap|tun)/ {print $2}' | sort
}

get_interface_info() {
    local interface="$1"
    local info=""
    
    # Get IP address
    local ip=$(ip -4 addr show "$interface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
    [ -z "$ip" ] && ip="$(translate "No IP")"
    
    # Get status
    local status=$(ip link show "$interface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
    [ -z "$status" ] && status="UNKNOWN"
    
    # Get MAC address
    local mac=$(ip link show "$interface" 2>/dev/null | grep -o "link/ether [a-f0-9:]*" | cut -d' ' -f2)
    [ -z "$mac" ] && mac="$(translate "No MAC")"
    
    echo "$interface|$ip|$status|$mac"
}




# ==========================================================
# Network Testing Functions
test_connectivity() {
    local test_results=""
    local tests=(
        "8.8.8.8|Google DNS"
        "1.1.1.1|Cloudflare DNS"
        "$(ip route | grep default | awk '{print $3}' | head -1)|Gateway"
    )
    show_proxmenux_logo
    msg_info "$(translate "Test Connectivity")"
    test_results+="$(translate "Connectivity Test Results")\n"
    test_results+="$(printf '=%.0s' {1..35})\n\n"
    
    for test in "${tests[@]}"; do
        IFS='|' read -r target name <<< "$test"
        if [ -n "$target" ] && [ "$target" != "" ]; then
            if ping -c 2 -W 3 "$target" >/dev/null 2>&1; then
                test_results+="âœ“ $name ($target): $(translate "OK")\n"
            else
                test_results+="âœ— $name ($target): $(translate "FAILED")\n"
            fi
        fi
    done
    
    # DNS Resolution test
    if nslookup google.com >/dev/null 2>&1; then
        test_results+="âœ“ $(translate "DNS Resolution"): $(translate "OK")\n"
    else
        test_results+="âœ— $(translate "DNS Resolution"): $(translate "FAILED")\n"
    fi
    cleanup
    dialog --backtitle "ProxMenux" --title "$(translate "Connectivity Test")" \
           --msgbox "$test_results" 15 60
}

advanced_network_diagnostics() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi


    show_proxmenux_logo
    msg_info "$(translate "Advanced Diagnostics")"
    sleep 1
    
    local diag_info=""
    
    diag_info+="$(translate "Advanced Network Diagnostics")\n"
    diag_info+="$(printf '=%.0s' {1..40})\n\n"
    
    # Network statistics
    diag_info+="$(translate "Active Connections"): $(ss -tuln | wc -l)\n"
    diag_info+="$(translate "Listening Ports"): $(ss -tln | grep LISTEN | wc -l)\n"
    diag_info+="$(translate "Network Interfaces"): $(ip link show | grep -c "^[0-9]")\n\n"
    
    # Check for common issues
    diag_info+="$(translate "Common Issues Check"):\n"

    # Check if NetworkManager is running (shouldn't be on Proxmox)
    if systemctl is-active --quiet NetworkManager 2>/dev/null; then
        diag_info+="âš  $(translate "NetworkManager is running (may cause conflicts)")\n"

        if dialog --title "$(translate "NetworkManager Detected")" \
                --yesno "$(translate "NetworkManager is running, which may conflict with Proxmox.")\n\n$(translate "Do you want to disable and remove it now?")" 10 70; then

            dialog --infobox "$(translate "Disabling and removing NetworkManager...")" 6 60
            systemctl stop NetworkManager >/dev/null 2>&1
            systemctl disable NetworkManager >/dev/null 2>&1
            apt-get purge -y network-manager >/dev/null 2>&1

            diag_info+="âœ“ $(translate "NetworkManager has been removed successfully")\n"
        else
            diag_info+="â„¹ï¸  $(translate "User chose not to remove NetworkManager")\n"
        fi
    else
        diag_info+="âœ“ $(translate "NetworkManager not running")\n"
    fi

    # Check for duplicate IPs
    local ips=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sort | uniq -d))
    if [ ${#ips[@]} -gt 0 ]; then
        diag_info+="âš  $(translate "Duplicate IP addresses found"): ${ips[*]}\n"
    else
        diag_info+="âœ“ $(translate "No duplicate IP addresses")\n"
    fi

    cleanup 

    dialog --backtitle "ProxMenux" --title "$(translate "Network Diagnostics")" \
           --msgbox "$diag_info" 18 70
}


# ==========================================================
# SAFE Network Analysis Functions (NO AUTO-REPAIR)
# ==========================================================

analyze_bridge_configuration() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    msg_info "$(translate "Analyzing Bridge Configuration - READ ONLY MODE")"
    sleep 1
    
    local physical_interfaces=($(detect_physical_interfaces))
    local bridges=($(detect_bridge_interfaces))
    local analysis_report=""
    local issues_found=0
    local suggestions=""
    
    analysis_report+="ğŸ” $(translate "BRIDGE CONFIGURATION ANALYSIS")\n"
    analysis_report+="$(printf '=%.0s' {1..50})\n\n"
    cleanup
    if [ ${#bridges[@]} -eq 0 ]; then
        analysis_report+="â„¹ï¸  $(translate "No bridges found in system")\n"
        dialog --backtitle "ProxMenux" --title "$(translate "Bridge Analysis")" --msgbox "$analysis_report" 10 60
        return
    fi
    
    # Analyze each bridge
    for bridge in "${bridges[@]}"; do
        analysis_report+="ğŸŒ‰ $(translate "Bridge"): $bridge\n"
        
        # Get current configuration
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        local bridge_ip=$(ip -4 addr show "$bridge" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
        local bridge_status=$(ip link show "$bridge" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
        
        analysis_report+="   ğŸ“ $(translate "Status"): ${bridge_status:-UNKNOWN}\n"
        analysis_report+="   ğŸŒ $(translate "IP"): ${bridge_ip:-$(translate "No IP assigned")}\n"
        analysis_report+="   ğŸ”Œ $(translate "Configured Ports"): ${current_ports:-$(translate "None")}\n"
        
        if [ -n "$current_ports" ]; then
            local invalid_ports=""
            local valid_ports=""
            
            # Check each configured port
            for port in $current_ports; do
                if ip link show "$port" >/dev/null 2>&1; then
                    valid_ports+="$port "
                    analysis_report+="   âœ… $(translate "Port") $port: $(translate "EXISTS")\n"
                else
                    invalid_ports+="$port "
                    analysis_report+="   âŒ $(translate "Port") $port: $(translate "NOT FOUND")\n"
                    ((issues_found++))
                fi
            done
            
            # Generate suggestions for invalid ports
            if [ -n "$invalid_ports" ]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $bridge:\n"
                if [ ${#physical_interfaces[@]} -gt 0 ]; then
                    suggestions+="   $(translate "Replace invalid port(s)") '$invalid_ports' $(translate "with"): ${physical_interfaces[0]}\n"
                    suggestions+="   $(translate "Command"): sed -i 's/bridge-ports.*/bridge-ports ${physical_interfaces[0]}/' /etc/network/interfaces\n"
                else
                    suggestions+="   $(translate "Remove invalid port(s)") '$invalid_ports'\n"
                    suggestions+="   $(translate "Command"): sed -i 's/bridge-ports.*/bridge-ports none/' /etc/network/interfaces\n"
                fi
                suggestions+="\n"
            fi
        else
            analysis_report+="   âš ï¸  $(translate "No ports configured")\n"
            if [ ${#physical_interfaces[@]} -gt 0 ]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $bridge:\n"
                suggestions+="   $(translate "Consider adding physical interface"): ${physical_interfaces[0]}\n"
                suggestions+="   $(translate "Command"): sed -i '/iface $bridge/a\\    bridge-ports ${physical_interfaces[0]}' /etc/network/interfaces\n\n"
            fi
        fi
        analysis_report+="\n"
    done
    
    # Summary
    analysis_report+="ğŸ“Š $(translate "ANALYSIS SUMMARY")\n"
    analysis_report+="$(printf '=%.0s' {1..25})\n"
    analysis_report+="$(translate "Bridges analyzed"): ${#bridges[@]}\n"
    analysis_report+="$(translate "Issues found"): $issues_found\n"


    local auto_only=$(grep "^auto" /etc/network/interfaces | awk '{print $2}' | while read i; do
        grep -q "^iface $i" /etc/network/interfaces || echo "$i"
    done)

    if [ -n "$auto_only" ]; then
        analysis_report+="âš ï¸  $(translate "Interfaces defined with 'auto' but no 'iface' block"): $auto_only\n"
        ((issues_found++))
    fi

    analysis_report+="$(translate "Physical interfaces available"): ${#physical_interfaces[@]}\n\n"
    
    if [ $issues_found -gt 0 ]; then
        analysis_report+="$suggestions"
        analysis_report+="âš ï¸  $(translate "IMPORTANT"): $(translate "No changes have been made to your system")\n"
        analysis_report+="$(translate "Use the Guided Repair option to fix issues safely")\n"
    else
        analysis_report+="âœ… $(translate "No bridge configuration issues found")\n"
    fi
    
    # Show analysis in scrollable dialog
    local temp_file=$(mktemp)
    echo -e "$analysis_report" > "$temp_file"
    dialog --backtitle "ProxMenux" --title "$(translate "Bridge Configuration Analysis")" \
           --textbox "$temp_file" 25 80
    rm -f "$temp_file"
   
    # Offer guided repair if issues found
    if [ $issues_found -gt 0 ]; then
        if dialog --backtitle "ProxMenux" --title "$(translate "Guided Repair Available")" \
                  --yesno "$(translate "Issues were found. Would you like to use the Guided Repair Assistant?")" 8 60; then
            guided_bridge_repair
        fi
    fi
}

guided_bridge_repair() {
    local step=1
    local total_steps=5


    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local preview_backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"


    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Safety Backup")" \
                --yesno "$(translate "Before making any changes, we'll create a safety backup.")\n\n$(translate "Backup location"): $preview_backup_file\n\n$(translate "Continue?")" 12 70; then
        return
    fi
    ((step++))

    
    show_proxmenux_logo
    local backup_file=$(backup_network_config)
    sleep 1

    dialog --backtitle "ProxMenux" --title "$(translate "Backup Created")" \
           --msgbox "$(translate "Safety backup created"): $backup_file\n\n$(translate "You can restore it anytime with"):\ncp $backup_file /etc/network/interfaces" 10 70
    
    # Step 2: Show current configuration
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Current Configuration")" \
                --yesno "$(translate "Let's review your current network configuration.")\n\n$(translate "Would you like to see the current") /etc/network/interfaces $(translate "file?")" 10 70; then
        return
    fi
    ((step++))
    
    # Show current config
    local temp_config=$(mktemp)
    cat /etc/network/interfaces > "$temp_config"
    dialog --backtitle "ProxMenux" --title "$(translate "Current Network Configuration")" \
           --textbox "$temp_config" 20 80
    rm -f "$temp_config"
    
    # Step 3: Identify specific changes needed
    local physical_interfaces=($(detect_physical_interfaces))
    local bridges=($(detect_bridge_interfaces))
    local changes_needed=""
    
    for bridge in "${bridges[@]}"; do
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        
        if [ -n "$current_ports" ]; then
            for port in $current_ports; do
                if ! ip link show "$port" >/dev/null 2>&1; then
                    if [ ${#physical_interfaces[@]} -gt 0 ]; then
                        changes_needed+="$(translate "Bridge") $bridge: $(translate "Replace") '$port' $(translate "with") '${physical_interfaces[0]}'\n"
                    else
                        changes_needed+="$(translate "Bridge") $bridge: $(translate "Remove invalid port") '$port'\n"
                    fi
                fi
            done
        fi
    done
    
    if [ -z "$changes_needed" ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Changes Needed")" \
               --msgbox "$(translate "After detailed analysis, no changes are needed.")" 8 50
        return
    fi
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Proposed Changes")" \
                --yesno "$(translate "These are the changes that will be made"):\n\n$changes_needed\n$(translate "Do you want to proceed?")" 15 70; then
        return
    fi
    ((step++))
    
    # Step 4: Apply changes with verification
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Applying Changes")" \
           --infobox "$(translate "Applying changes safely...")\n\n$(translate "This may take a few seconds...")" 8 50
    
    # Apply the changes
    for bridge in "${bridges[@]}"; do
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        
        if [ -n "$current_ports" ]; then
            local new_ports=""
            for port in $current_ports; do
                if ip link show "$port" >/dev/null 2>&1; then
                    new_ports+="$port "
                fi
            done
            
            # If no valid ports and we have physical interfaces, use the first one
            if [ -z "$new_ports" ] && [ ${#physical_interfaces[@]} -gt 0 ]; then
                new_ports="${physical_interfaces[0]}"
            fi
            
            # Apply the change
            if [ "$new_ports" != "$current_ports" ]; then
                sed -i "/iface $bridge/,/bridge-ports/ s/bridge-ports.*/bridge-ports $new_ports/" /etc/network/interfaces
            fi
        fi
    done
    ((step++))
    
    # Step 5: Verification
    local verification_report=""
    verification_report+="âœ… $(translate "CHANGES APPLIED SUCCESSFULLY")\n\n"
    verification_report+="$(translate "Verification"):\n"
    
    for bridge in "${bridges[@]}"; do
        local new_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        verification_report+="$(translate "Bridge") $bridge: $new_ports\n"
        
        # Verify each port exists
        for port in $new_ports; do
            if ip link show "$port" >/dev/null 2>&1; then
                verification_report+="  âœ… $port: $(translate "EXISTS")\n"
            else
                verification_report+="  âŒ $port: $(translate "NOT FOUND")\n"
            fi
        done
    done
    
    verification_report+="\n$(translate "Backup available at"): $backup_file\n"
    verification_report+="$(translate "To restore"): cp $backup_file /etc/network/interfaces"
    
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Repair Complete")" \
           --msgbox "$verification_report" 18 70
    
    # Ask about network restart
    if dialog --backtitle "ProxMenux" --title "$(translate "Network Restart")" \
              --yesno "$(translate "Changes have been applied to the configuration file.")\n\n$(translate "Do you want to restart the network service to apply changes?")\n\n$(translate "WARNING: This may cause a brief disconnection.")" 12 70; then
        
        clear
        msg_info "$(translate "Restarting network service...")"
        
        if systemctl restart networking; then
            msg_ok "$(translate "Network service restarted successfully")"
        else
            msg_error "$(translate "Failed to restart network service")"
            msg_warn "$(translate "You can restore the backup with"): cp $backup_file /etc/network/interfaces"
        fi
        
        msg_success "$(translate "Press ENTER to continue...")"
        read -r
    fi
}

analyze_network_configuration() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    msg_info "$(translate "Analyzing Network Configuration - READ ONLY MODE")"
    sleep 1
    
    local configured_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    local analysis_report=""
    local issues_found=0
    local suggestions=""
    
    analysis_report+="ğŸ” $(translate "NETWORK CONFIGURATION ANALYSIS")\n"
    analysis_report+="$(printf '=%.0s' {1..50})\n\n"
    
    cleanup
    if [ ${#configured_interfaces[@]} -eq 0 ]; then
        analysis_report+="â„¹ï¸  $(translate "No network interfaces configured (besides loopback)")\n"
        dialog --title "$(translate "Configuration Analysis")" --msgbox "$analysis_report" 10 60
        return
    fi
    
    analysis_report+="ğŸ“‹ $(translate "CONFIGURED INTERFACES")\n"
    analysis_report+="$(printf '=%.0s' {1..30})\n"
    
    # Analyze each configured interface
    for iface in "${configured_interfaces[@]}"; do
        analysis_report+="ğŸ”Œ $(translate "Interface"): $iface\n"
        
        # Check if interface exists physically
        if ip link show "$iface" >/dev/null 2>&1; then
            local status=$(ip link show "$iface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
            local ip=$(ip -4 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
            
            analysis_report+="   âœ… $(translate "Status"): $(translate "EXISTS") ($status)\n"
            analysis_report+="   ğŸŒ $(translate "IP"): ${ip:-$(translate "No IP assigned")}\n"
            
            # Check if it's a bridge or bond (these are virtual, so it's normal they exist)
            if [[ $iface =~ ^(vmbr|bond) ]]; then
                analysis_report+="   â„¹ï¸  $(translate "Type"): $(translate "Virtual interface (normal)")\n"
            else
                analysis_report+="   â„¹ï¸  $(translate "Type"): $(translate "Physical interface")\n"
            fi
        else
            analysis_report+="   âŒ $(translate "Status"): $(translate "NOT FOUND")\n"
            analysis_report+="   âš ï¸  $(translate "Issue"): $(translate "Configured but doesn't exist")\n"
            ((issues_found++))
            
            # Only suggest removal for non-virtual interfaces
            if [[ ! $iface =~ ^(vmbr|bond) ]]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $iface:\n"
                suggestions+="   $(translate "This interface is configured but doesn't exist physically")\n"
                suggestions+="   $(translate "Consider removing its configuration")\n"
                suggestions+="   $(translate "Command"): sed -i '/iface $iface/,/^$/d' /etc/network/interfaces\n\n"
            fi
        fi
        analysis_report+="\n"
    done
    
    # Summary
    analysis_report+="ğŸ“Š $(translate "ANALYSIS SUMMARY")\n"
    analysis_report+="$(printf '=%.0s' {1..25})\n"
    analysis_report+="$(translate "Interfaces configured"): ${#configured_interfaces[@]}\n"
    analysis_report+="$(translate "Issues found"): $issues_found\n\n"
    
    if [ $issues_found -gt 0 ]; then
        analysis_report+="$suggestions"
        analysis_report+="âš ï¸  $(translate "IMPORTANT"): $(translate "No changes have been made to your system")\n"
        analysis_report+="$(translate "Use the Guided Cleanup option to fix issues safely")\n"
    else
        analysis_report+="âœ… $(translate "No configuration issues found")\n"
    fi
    
    # Show analysis in scrollable dialog
    local temp_file=$(mktemp)
    echo -e "$analysis_report" > "$temp_file"
    dialog --backtitle "ProxMenux" --title "$(translate "Network Configuration Analysis")" \
           --textbox "$temp_file" 25 80
    rm -f "$temp_file"
    
    # Offer guided cleanup if issues found
    if [ $issues_found -gt 0 ]; then
        if dialog --backtitle "ProxMenux" --title "$(translate "Guided Cleanup Available")" \
                  --yesno "$(translate "Issues were found. Would you like to use the Guided Cleanup Assistant?")" 8 60; then
            guided_configuration_cleanup
        fi
    fi
}

guided_configuration_cleanup() {
    local step=1
    local total_steps=5

    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local preview_backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"


    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Safety Backup")" \
                --yesno "$(translate "Before making any changes, we'll create a safety backup.")\n\n$(translate "Backup location"): $preview_backup_file\n\n$(translate "Continue?")" 12 70; then
        return
    fi
    ((step++))

    
    show_proxmenux_logo
    local backup_file=$(backup_network_config)
    sleep 1
    
    dialog --backtitle "ProxMenux" --title "$(translate "Backup Created")" \
           --msgbox "$(translate "Safety backup created"): $backup_file\n\n$(translate "You can restore it anytime with"):\ncp $backup_file /etc/network/interfaces" 10 70
    
    # Step 2: Identify interfaces to remove
    local configured_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    local interfaces_to_remove=""
    local removal_list=""
    
    for iface in "${configured_interfaces[@]}"; do
        if [[ ! $iface =~ ^(vmbr|bond) ]] && ! ip link show "$iface" >/dev/null 2>&1; then
            interfaces_to_remove+="$iface "
            removal_list+="âŒ $iface: $(translate "Configured but doesn't exist")\n"
        fi
    done
    
    if [ -z "$interfaces_to_remove" ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Cleanup Needed")" \
               --msgbox "$(translate "After detailed analysis, no cleanup is needed.")" 8 50
        return
    fi
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Interfaces to Remove")" \
                --yesno "$(translate "These interface configurations will be removed"):\n\n$removal_list\n$(translate "Do you want to proceed?")" 15 70; then
        return
    fi
    ((step++))
    
    # Step 3: Show what will be removed
    local temp_preview=$(mktemp)
    echo "$(translate "Configuration sections that will be REMOVED"):" > "$temp_preview"
    echo "=================================================" >> "$temp_preview"
    echo "" >> "$temp_preview"
    
    for iface in $interfaces_to_remove; do
        echo "# Interface: $iface" >> "$temp_preview"
        sed -n "/^iface $iface/,/^$/p" /etc/network/interfaces >> "$temp_preview"
        echo "" >> "$temp_preview"
    done
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Preview Changes")" \
                --yesno "$(translate "Review what will be removed"):\n\n$(translate "Press OK to see the preview, then confirm")" 10 60; then
        rm -f "$temp_preview"
        return
    fi
    
    dialog --backtitle "ProxMenux" --title "$(translate "Configuration to be Removed")" \
           --textbox "$temp_preview" 20 80
    rm -f "$temp_preview"
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Final Confirmation")" \
                --yesno "$(translate "Are you sure you want to remove these configurations?")" 8 60; then
        return
    fi
    ((step++))
    
    # Step 4: Apply changes
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Applying Changes")" \
           --infobox "$(translate "Removing invalid configurations...")\n\n$(translate "This may take a few seconds...")" 8 50
    
    for iface in $interfaces_to_remove; do
        sed -i "/^iface $iface/,/^$/d" /etc/network/interfaces
    done
    ((step++))
    
    # Step 5: Verification
    local verification_report=""
    verification_report+="âœ… $(translate "CLEANUP COMPLETED SUCCESSFULLY")\n\n"
    verification_report+="$(translate "Removed configurations for"):\n"
    
    for iface in $interfaces_to_remove; do
        verification_report+="âŒ $iface\n"
    done
    
    verification_report+="\n$(translate "Verification"): $(translate "Checking remaining interfaces")\n"
    local remaining_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    
    for iface in "${remaining_interfaces[@]}"; do
        if ip link show "$iface" >/dev/null 2>&1; then
            verification_report+="âœ… $iface: $(translate "OK")\n"
        else
            verification_report+="âš ï¸  $iface: $(translate "Still has issues")\n"
        fi
    done
    
    verification_report+="\n$(translate "Backup available at"): $backup_file\n"
    verification_report+="$(translate "To restore"): cp $backup_file /etc/network/interfaces"
    
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Cleanup Complete")" \
           --msgbox "$verification_report" 18 70
}

# ==========================================================
# Configuration Management
show_network_config() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    local config_content
    config_content=$(cat /etc/network/interfaces)
    show_proxmenux_logo
    echo -e
    echo -e
    echo "========== $(translate "Network Configuration File") =========="
    echo
    cat /etc/network/interfaces
    echo
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}





restore_network_backup() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    local backups=($(ls -1 "$BACKUP_DIR"/interfaces_backup_* 2>/dev/null | sort -r))
    
    if [ ${#backups[@]} -eq 0 ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Backups")" \
               --msgbox "\n$(translate "No network configuration backups found.")" 14 60
        return
    fi

    local menu_items=()
    local counter=1

    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local timestamp=$(basename "$backup" | sed 's/interfaces_backup_//')
        menu_items+=("$counter" "$timestamp")
        ((counter++))
    done

    local selection=$(dialog --backtitle "ProxMenux" --title "$(translate "Restore Backup")" \
                            --menu "$(translate "Select backup to restore:"):" 15 60 8 \
                            "${menu_items[@]}" 3>&1 1>&2 2>&3)

    if [ -n "$selection" ] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#backups[@]} ]; then
        local selected_backup="${backups[$((selection-1))]}"


        if dialog --backtitle "ProxMenux" --title "$(translate "Preview Backup")" \
                  --yesno "\n$(translate "Do you want to view the selected backup before restoring?")" 8 60; then
            dialog --backtitle "ProxMenux" --title "$(translate "Backup Preview")" \
                   --textbox "$selected_backup" 22 80
        fi

        if dialog --backtitle "ProxMenux" --title "$(translate "Confirm Restore")" \
            --yesno "\n$(translate "Are you sure you want to restore this backup?\nCurrent configuration will be overwritten.")\n\n$(translate "For your safety, a backup of the current configuration will be created automatically before restoring.")" 14 70; then

            local pre_restore_backup=$(backup_network_config)
            cp "$selected_backup" /etc/network/interfaces


            dialog --backtitle "ProxMenux" --title "$(translate "Backup Restored")" \
                   --msgbox "\n$(translate "Network configuration has been restored from backup.")" 8 60


            if dialog --backtitle "ProxMenux" --title "$(translate "Restart Network")" \
                      --yesno "\n$(translate "Do you want to restart the network service now to apply changes?")" 8 60; then
                if systemctl restart networking; then
                    dialog --backtitle "ProxMenux" --title "$(translate "Network Restarted")" \
                           --msgbox "\n$(translate "Network service restarted successfully.")" 8 50
                fi
            fi
        fi
    fi
}



# ==========================================================
# Emergency System Repair Functions
# ==========================================================


emergency_proxmox_repair() {
    clear
    show_proxmenux_logo
    echo -e
    echo "=========================================="
    echo "    $(translate "EMERGENCY PROXMOX SYSTEM REPAIR")"
    echo "=========================================="
    echo
    
    msg_warn "$(translate "This will reinstall core Proxmox packages and regenerate certificates")"
    echo "$(translate "This operation may take several minutes and requires internet connectivity.")"
    echo
    echo -n "$(translate "Do you want to continue?") (y/N): "
    read -r confirm
    
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        msg_info2 "$(translate "Operation cancelled by user.")"
        return
    fi
    
    msg_info2 "$(translate "Starting Proxmox system repair...")"
    echo
    
    # Step 1: Update package lists
    msg_success "$(translate "Step") 1/3: $(translate "Updating package lists...")"
    if apt-get update; then
        msg_ok "$(translate "Package lists updated successfully")"
    else
        msg_error "$(translate "Failed to update package lists")"
        echo "$(translate "This might indicate network connectivity issues.")"
        echo
        echo "$(translate "Press ENTER to continue...")"
        read -r
        return 1
    fi
    echo
    
    # Step 2: Reinstall core Proxmox packages
    msg_success "$(translate "Step") 2/3: $(translate "Reinstalling core Proxmox packages...")"
    echo "$(translate "This may take several minutes...")"
    
    if apt-get install --reinstall proxmox-widget-toolkit pve-manager -y; then
        msg_ok "$(translate "Core Proxmox packages reinstalled successfully")"
    else
        msg_error "$(translate "Failed to reinstall Proxmox packages")"
        echo "$(translate "Check the error messages above for details.")"
        echo
        echo "$(translate "Press ENTER to continue...")"
        read -r
        return 1
    fi
    echo
    
    # Step 3: Regenerate certificates and restart services
    msg_success "$(translate "Step") 3/3: $(translate "Regenerating certificates and restarting services...")"
    
    # Update certificates
    if command -v pvecm >/dev/null 2>&1; then
        msg_info "$(translate "Updating cluster certificates...")"
        if pvecm updatecerts -f; then
            msg_ok "$(translate "Cluster certificates updated")"
        else
            msg_warn "$(translate "Failed to update cluster certificates (might not be in a cluster)")"
        fi
    else
        msg_warn "$(translate "pvecm command not found (might not be in a cluster)")"
    fi
    
    # Restart Proxmox services
    msg_success "$(translate "Restarting Proxmox services...")"
    local services_restarted=0
    local services_failed=0
    
    for service in pveproxy pvedaemon; do
        if systemctl restart "$service"; then
            msg_ok "  $service $(translate "restarted successfully")"
            ((services_restarted++))
        else
            msg_error "  $(translate "Failed to restart") $service"
            ((services_failed++))
        fi
    done
    
    echo
    echo "$(translate "REPAIR SUMMARY"):"
    echo "==============="
    echo "  $(translate "Package lists"): $(translate "Updated")"
    echo "  $(translate "Core packages"): $(translate "Reinstalled")"
    echo "  $(translate "Services restarted"): $services_restarted"
    echo "  $(translate "Services failed"): $services_failed"
    
    if [ $services_failed -eq 0 ]; then
        msg_ok "$(translate "Proxmox system repair completed successfully!")"
        echo
        echo "$(translate "You should now be able to access the Proxmox web interface.")"
        echo "$(translate "Try accessing"): https://$(hostname -I | awk '{print $1}'):8006"
    else
        msg_warn "$(translate "Proxmox system repair completed with some issues.")"
        echo "$(translate "Check the service status manually if needed.")"
    fi
    
    echo
    echo "$(translate "Press ENTER to continue...")"
    read -r
}



restart_network_service() {
    if dialog --title "$(translate "Restart Network")" \
              --yesno "$(translate "This will restart the network service and may cause a brief disconnection. Continue?")" 10 60; then

        show_proxmenux_logo
        msg_info "$(translate "Restarting network service...")"

        if systemctl restart networking; then
            msg_ok "$(translate "Network service restarted successfully")"
        else
            msg_error "$(translate "Failed to restart network service")"
            msg_warn "$(translate "If you lose connectivity, you can restore from backup using the console.")"
        fi

        msg_success "$(translate "Press ENTER to continue...")"
        read -r
    fi
}



# ==========================================================
# Main Menu
show_main_menu() {
    while true; do
        local selection=$(dialog --clear \
                                --backtitle "ProxMenux" \
                                --title "$(translate "Network Management - SAFE MODE")" \
                                --menu "$(translate "Select an option:"):" 20 70 12 \
                                "1" "$(translate "Test Connectivity")" \
                                "2" "$(translate "Advanced Diagnostics")" \
                                "3" "$(translate "Analyze Bridge Configuration")" \
                                "4" "$(translate "Analyze Network Configuration")" \
                                "5" "$(translate "Restart Network Service")" \
                                "6" "$(translate "Show Network Config File")" \
                                "7" "$(translate "Emergency Proxmox System Repair")" \
                                "8" "$(translate "Restore Network Backup")" \
                                "0" "$(translate "Exit")" \
                                3>&1 1>&2 2>&3)
        
        case $selection in

            1) test_connectivity ;;
            2) advanced_network_diagnostics ;;
            3) analyze_bridge_configuration ;;
            4) analyze_network_configuration ;;
            5) restart_network_service ;;
            6) show_network_config ;;
            7) emergency_proxmox_repair ;;
            8) restore_network_backup ;;
            0|"") exit ;;
        esac
    done
}

# ==========================================================
show_main_menu



================================================
FILE: scripts/help_info_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script provides an interactive command reference menu
# for Proxmox VE via dialog-based UI.
# - Categorized and translated lists of common and advanced commands.
# - Covers system, network, storage, VM/CT, updates, GPU passthrough,
#   ZFS, backup/restore, and essential CLI tools.
# - Allows users to view or execute commands directly from the menu.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache
# ===============================================================

# Colores
YELLOW="\033[0;33m"
GREEN="\033[0;32m"
NC="\033[0m"

if ! command -v dialog &>/dev/null; then
    apt update -qq >/dev/null 2>&1
    apt install -y dialog >/dev/null 2>&1
fi


# ===============================================================
# 01 Useful System Commands
# ===============================================================
show_system_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'Useful System Commands')${NC}"
        echo "----------------------------------------"
        echo -e " 1) ${GREEN}pveversion${NC}                         - $(translate 'Show Proxmox version')"
        echo -e " 2) ${GREEN}pveversion -v${NC}                      - $(translate 'Detailed Proxmox version info')"
        echo -e " 3) ${GREEN}systemctl status pveproxy${NC}          - $(translate 'Check Proxmox Web UI status')"
        echo -e " 4) ${GREEN}systemctl restart pveproxy${NC}         - $(translate 'Restart Web UI proxy')"
        echo -e " 5) ${GREEN}journalctl -xe${NC}                     - $(translate 'System errors and logs')"
        echo -e " 6) ${GREEN}uptime${NC}                             - $(translate 'System uptime')"
        echo -e " 7) ${GREEN}hostnamectl${NC}                        - $(translate 'System hostname and kernel info')"
        echo -e " 8) ${GREEN}free -h${NC}                            - $(translate 'RAM and swap usage')"
        echo -e " 9) ${GREEN}uptime -p${NC}                          - $(translate 'Pretty uptime format')"
        echo -e "10) ${GREEN}who -b${NC}                             - $(translate 'Last system boot time')"
        echo -e "11) ${GREEN}last -x | grep shutdown${NC}            - $(translate 'Previous shutdowns')"
        echo -e "12) ${GREEN}dmesg -T | tail -n 50${NC}              - $(translate 'Last 50 kernel log lines')"
        echo -e "13) ${GREEN}cat /etc/os-release${NC}                - $(translate 'OS release details')"
        echo -e "14) ${GREEN}uname -a${NC}                           - $(translate 'Kernel and architecture info')"
        echo -e "15) ${GREEN}uptime && w${NC}                        - $(translate 'Uptime and who is logged in')"
        echo -e "16) ${GREEN}whoami${NC}                             - $(translate 'Current user')"
        echo -e "17) ${GREEN}id${NC}                                 - $(translate 'Current user UID, GID and groups')"
        echo -e "18) ${GREEN}who${NC}                                - $(translate 'Logged-in users')"
        echo -e "19) ${GREEN}w${NC}                                  - $(translate 'User activity and uptime')"
        echo -e "20) ${GREEN}cut -d: -f1,3,4 /etc/passwd${NC}        - $(translate 'All users with UID and GID')"
        echo -e "21) ${GREEN}getent passwd | column -t -s :${NC}     - $(translate 'Readable user table (UID, shell, etc.)')"
		echo -e "22) ${GREEN}lynis audit system${NC}                 - $(translate 'Run a full security audit')"
		echo -e "23) ${GREEN}fastfetch${NC}                          - $(translate 'Display system summary in ASCII format')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            0) break ;;
            [1-9]|1[0-9]|2[0-3])
                case "$user_input" in
                    1) cmd="pveversion" ;;
                    2) cmd="pveversion -v" ;;
                    3) cmd="systemctl status pveproxy" ;;
                    4) cmd="systemctl restart pveproxy" ;;
                    5) cmd="journalctl -xe" ;;
                    6) cmd="uptime" ;;
                    7) cmd="hostnamectl" ;;
                    8) cmd="free -h" ;;
                    9) cmd="uptime -p" ;;
                    10) cmd="who -b" ;;
                    11) cmd="last -x | grep shutdown" ;;
                    12) cmd="dmesg -T | tail -n 50" ;;
                    13) cmd="cat /etc/os-release" ;;
                    14) cmd="uname -a" ;;
                    15) cmd="uptime && w" ;;
                    16) cmd="whoami" ;;
                    17) cmd="id" ;;
                    18) cmd="who" ;;
                    19) cmd="w" ;;
                    20) cmd="cut -d: -f1,3,4 /etc/passwd" ;;
                    21) cmd="getent passwd | column -t -s :" ;;
					22)
						if ! command -v lynis &>/dev/null; then
							echo -e "\n${RED}$(translate 'Lynis is not installed. Run: apt install lynis')${NC}\n"
							msg_success "$(translate 'Press ENTER to continue...')"
							read -r tmp
							continue
						fi
						cmd="lynis audit system"
						;;
					23)
						if ! command -v fastfetch &>/dev/null; then
							echo -e "\n${RED}$(translate 'Fastfetch is not installed. Run: apt install fastfetch')${NC}\n"
							msg_success "$(translate 'Press ENTER to continue...')"
							read -r tmp
							continue
						fi
						cmd="fastfetch"
						;;

                esac
                echo -e "\n${GREEN}> $cmd${NC}\n"
                bash -c "$cmd"
                echo
                msg_success "$(translate 'Press ENTER to continue...')"
                read -r tmp
                ;;
            *)
                if [[ -n "$user_input" ]]; then
                    echo -e "\n${GREEN}> $user_input${NC}\n"
                    bash -c "$user_input"
                    echo
                    msg_success "$(translate 'Press ENTER to continue...')"
                    read -r tmp
                fi
                ;;
        esac
    done
}


# ===============================================================
# 02 VM and CT Management Commands
# ===============================================================
show_vm_ct_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'VM and CT Management Commands')${NC}"
        echo "---------------------------------------------------"
        echo -e " 1) ${GREEN}qm list${NC}                  - $(translate 'List all virtual machines')"
        echo -e " 2) ${GREEN}pct list${NC}                 - $(translate 'List all LXC containers')"
        echo -e " 3) ${GREEN}qm start <vmid>${NC}          - $(translate 'Start a virtual machine. Use the correct <vmid>')"
        echo -e " 4) ${GREEN}pct start <ctid>${NC}         - $(translate 'Start a container. Use the correct <ctid>')"
        echo -e " 5) ${GREEN}qm stop <vmid>${NC}           - $(translate 'Force stop a virtual machine. Use the correct <vmid>')"
        echo -e " 6) ${GREEN}pct stop <ctid>${NC}          - $(translate 'Force stop a container. Use the correct <ctid>')"
        echo -e " 7) ${GREEN}qm config <vmid>${NC}         - $(translate 'Show VM configuration. Use the correct <vmid>')"
        echo -e " 8) ${GREEN}pct config <ctid>${NC}        - $(translate 'Show container configuration. Use the correct <ctid>')"
        echo -e " 9) ${GREEN}qm destroy <vmid>${NC}        - $(translate 'Delete a VM (irreversible). Use the correct <vmid>')"
        echo -e "10) ${GREEN}pct destroy <ctid>${NC}       - $(translate 'Delete a CT (irreversible). Use the correct <ctid>')"
        echo -e "11) ${GN}[Only with menu] Show CT users for permission mapping${NC} - $(translate 'root and real users only')"
        echo -e "12) ${GREEN}pct exec <ctid> -- getent passwd | column -t -s :${NC}     - $(translate 'Show CT users in table format')"
        echo -e "13) ${GREEN}pct exec <ctid> -- ps aux --sort=-%mem | head${NC}         - $(translate 'Top memory processes in CT')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="qm list" ;;
            2) cmd="pct list" ;;
            3) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"; read -r id; cmd="qm start $id" ;;
            4) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"; read -r id; cmd="pct start $id" ;;
            5) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"; read -r id; cmd="qm stop $id" ;;
            6) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"; read -r id; cmd="pct stop $id" ;;
            7) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"; read -r id; cmd="qm config $id" ;;
            8) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"; read -r id; cmd="pct config $id" ;;
            9) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"; read -r id; cmd="qm destroy $id" ;;
            10) echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"; read -r id; cmd="pct destroy $id" ;;
            11)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"
                read -r id

                echo -e "\n${YELLOW}$(translate 'Listing relevant CT users and their mapped UID/GID on host...')${NC}\n"


                UID_SHIFT=$(grep "^lxc.idmap" /etc/pve/lxc/"$id".conf | grep 'u 0' | awk '{print $5}')
                UID_SHIFT=${UID_SHIFT:-100000}

                pct exec "$id" -- getent passwd | while IFS=: read -r username _ uid gid _ home _; do
                    if [ "$uid" -eq 0 ] || [ "$uid" -eq 65534 ] || [ "$uid" -ge 30 ]; then
                        real_uid=$((UID_SHIFT + uid))
                        real_gid=$((UID_SHIFT + gid))
                        echo -e "${GREEN}$(translate 'User')${NC}: $username"
                        echo -e "  $(translate 'UID in CT'): $uid"
                        echo -e "  $(translate 'GID in CT'): $gid"
                        echo -e "  $(translate 'Mapped UID on host'): $real_uid"
                        echo -e "  $(translate 'Mapped GID on host'): $real_gid"
                        echo
                    fi
                done
                ;;

            12)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"
                read -r id
                cmd="pct exec $id -- getent passwd | column -t -s :"
                ;; 

            13)
            
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"
                read -r id
                cmd="pct exec $id -- ps aux --sort=-%mem | head"
                ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}



# ===============================================================
# 03 Storage and Disks Commands
# ===============================================================
show_storage_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'Storage and Disks Commands')${NC}"
        echo "--------------------------------------------------"
        echo -e " 1) ${GREEN}lsblk${NC}                       - $(translate 'List block devices and partitions')"
        echo -e " 2) ${GREEN}fdisk -l${NC}                    - $(translate 'List disks with detailed info')"
        echo -e " 3) ${GREEN}blkid${NC}                       - $(translate 'Show UUID and filesystem type of block devices')"
        echo -e " 4) ${GREEN}ls -lh /dev/disk/by-id/${NC}     - $(translate 'List disk persistent identifiers')"
        echo -e " 5) ${GREEN}parted -l${NC}                   - $(translate 'Detailed partition layout with GPT info')"
        echo -e " 6) ${GREEN}df -h${NC}                       - $(translate 'Show disk usage by mount point')"
        echo -e " 7) ${GREEN}du -sh /path${NC}                - $(translate 'Show size of a directory')"
        echo -e " 8) ${GREEN}mount | grep ^/dev${NC}          - $(translate 'Show mounted storage devices')"
        echo -e " 9) ${GREEN}cat /proc/mounts${NC}            - $(translate 'Show all active mounts from the kernel')"
        echo -e "10) ${GREEN}pvdisplay${NC}                   - $(translate 'Display physical volumes (LVM)')"
        echo -e "11) ${GREEN}vgdisplay${NC}                   - $(translate 'Display volume groups (LVM)')"
        echo -e "12) ${GREEN}lvdisplay${NC}                   - $(translate 'Display logical volumes (LVM)')"
        echo -e "13) ${GREEN}pvs${NC}                         - $(translate 'Concise output of physical volumes')"
        echo -e "14) ${GREEN}vgs${NC}                         - $(translate 'Concise output of volume groups')"
        echo -e "15) ${GREEN}lvs${NC}                         - $(translate 'Concise output of logical volumes')"
        echo -e "16) ${GREEN}cat /etc/pve/storage.cfg${NC}    - $(translate 'Show Proxmox storage configuration')"
        echo -e "17) ${GREEN}pvesm status${NC}                - $(translate 'Show status of all storage pools')"
        echo -e "18) ${GREEN}pvesm list <storage>${NC}        - $(translate 'List content of specific storage')"
        echo -e "19) ${GREEN}pvesm scan <storage>${NC}        - $(translate 'Scan storage for new content')"
        echo -e "20) ${GREEN}qm importdisk <vmid> <img> <storage>${NC}  - $(translate 'Import disk image to VM')"
        echo -e "21) ${GREEN}qm set <vmid> -<bus><index> <disk>${NC}    - $(translate 'Add physical disk to VM via') passthrough"
        echo -e "22) ${GREEN}qemu-img convert -O <format> <input> <output>${NC} - $(translate 'Convert disk image format')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Esc key exit
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="lsblk" ;;
            2) cmd="fdisk -l" ;;
            3) cmd="blkid" ;;
            4) cmd="ls -lh /dev/disk/by-id/" ;;
            5) cmd="parted -l" ;;
            6) cmd="df -h" ;;
            7)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter path to analyze: ')${CL}"
                read -r path
                cmd="du -sh $path"
                ;;
            8) cmd="mount | grep ^/dev" ;;
            9) cmd="cat /proc/mounts" ;;
            10) cmd="pvdisplay" ;;
            11) cmd="vgdisplay" ;;
            12) cmd="lvdisplay" ;;
            13) cmd="pvs" ;;
            14) cmd="vgs" ;;
            15) cmd="lvs" ;;
            16) cmd="cat /etc/pve/storage.cfg" ;;
            17) cmd="pvesm status" ;;
            19)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter storage ID: ')${CL}"
                read -r store
                cmd="pvesm list $store"
                ;;
            19)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter storage ID: ')${CL}"
                read -r store
                cmd="pvesm scan $store"
                ;;
            20)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"
                read -r vmid

                echo -e "\n${YELLOW}$(translate 'Available images in /var/lib/vz/images/:')${NC}"
                images=$(find /var/lib/vz/images/ -type f \( -iname "*.img" -o -iname "*.qcow2" -o -iname "*.vmdk" -o -iname "*.raw" \))

                if [[ -z "$images" ]]; then
                    echo -e "${RED}$(translate 'No disk images found in /var/lib/vz/images/. Please add an image first.')${NC}"
                    echo
                    msg_success "$(translate 'Press ENTER to return to the menu...')"
                    read -r
                    continue
                else
                    echo "$images"
                fi

                echo -en "\n${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter full path to the disk image (e.g., /var/lib/vz/images/xyz.img): ')${CL}"
                read -r image_path

                echo -e "\n${YELLOW}$(translate 'Available storage volumes:')${NC}"
                pvesm status | awk 'NR>1 {print " - "$1}'

                echo -en "\n${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter target storage name (e.g., local-lvm): ')${CL}"
                read -r storage

                cmd1="qm importdisk $vmid $image_path $storage"
                bash -c "$cmd1"
                echo

                disk_name=$(basename "$image_path")
                imported_volume="${storage}:vm-${vmid}-disk-0"

                echo -e "\n${YELLOW}$(translate 'Select disk interface type:')${NC}"
                echo " 1) sata"
                echo " 2) scsi"
                echo " 3) virtio"
                echo " 4) ide"
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter the number or type the interface name: ')${CL}"
                read -r iface_type

                case "$iface_type" in
                    1) iface="sata" ;;
                    2) iface="scsi" ;;
                    3) iface="virtio" ;;
                    4) iface="ide" ;;
                    *) iface="sata" ;;
                esac

                index=$(qm config "$vmid" | grep -oP "$iface\d+" | awk -F"$iface" '{print $2}' | sort -n | tail -n1)
                index=$((index + 1))

                echo -e "\n${YELLOW}$(translate 'Assigning imported disk to VM using the generated command')${NC}"
                sleep 1
                echo
                echo -e "\n${GREEN}> $cmd1${NC}\n"
                cmd="qm set $vmid -$iface$index $imported_volume"    
                ;;
            21)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"
                read -r vmid

                echo -e "\n${YELLOW}$(translate 'Scanning available physical disks...')${NC}"
                sleep 1

                echo -e "\n${YELLOW}$(translate 'Available physical disks for passthrough:')${NC}"
                printf "\n"

                lsblk -dno NAME,SIZE,MODEL | grep -vE 'boot|rpmb|loop|dm-|zd' | while read -r name size model; do
                disk_path="/dev/$name"
                by_id=$(find /dev/disk/by-id/ -lname "*$name" | grep -vE 'part[0-9]+$' | head -n1)
                if [[ -n "$by_id" ]]; then
                        printf "  %-60s (%s %s)\n" "$by_id" "$size" "$model"
                fi
                done

                echo
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter full disk path as shown above (starting with /dev/disk/by-id/xxx...): ')${CL}"
                read -r disk_path

                echo -e "\n${YELLOW}$(translate 'Select disk interface type:')${NC}"
                echo " 1) sata"
                echo " 2) scsi"
                echo " 3) virtio"
                echo " 4) ide"
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter the number or type the interface name: ')${CL}"
                read -r iface_type

                case "$iface_type" in
                        1) iface="sata" ;;
                        2) iface="scsi" ;;
                        3) iface="virtio" ;;
                        4) iface="ide" ;;
                        *) iface="sata" ;;
                esac

                index=$(qm config "$vmid" | grep -oP "$iface\d+" | awk -F"$iface" '{print $2}' | sort -n | tail -n1)
                                index=$((index + 1))

                echo -e "\n${YELLOW}$(translate 'Adding disk using the generated command to the selected VM')${NC}"
                sleep 1

                cmd="qm set $vmid -$iface$index $disk_path"
               ;;
            22)
                echo -e "\n${YELLOW}$(translate 'Convert disk image format using QEMU-IMG')${NC}"
                sleep 1

                echo -e "\n${YELLOW}$(translate 'Available images in /var/lib/vz/images/:')${NC}"
                images=$(find /var/lib/vz/images/ -type f \( -iname "*.img" -o -iname "*.qcow2" -o -iname "*.vmdk" -o -iname "*.raw" -o -iname "*.vdi" -o -iname "*.vpc" -o -iname "*.qed" \))

                if [[ -z "$images" ]]; then
                    echo -e "${RED}$(translate 'No disk images found in /var/lib/vz/images/. Please add an image first.')${NC}"
                    echo
                    msg_success "$(translate 'Press ENTER to return to the menu...')"
                    read -r
                    continue
                else
                    echo "$images"
                fi

                echo -en "\n${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter full path to the input image (e.g., /var/lib/vz/images/disk.vmdk): ')${CL}"
                read -r input_image

                echo -e "\n${YELLOW}$(translate 'Available output formats include:')${NC} qcow2, raw, qed"

                echo -en "\n${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter the full path to the output image (e.g., /var/lib/vz/images/output.qcow2): ')${CL}"
                read -r output_image
                valid_formats=("qcow2" "raw" "qed")
                output_format=$(echo "$output_image" | awk -F. '{print tolower($NF)}')

                if ! [[ " ${valid_formats[*]} " =~ " ${output_format} " ]]; then
                    echo -e "\n${RED}$(translate 'Unsupported output format:') .$output_format${NC}"
                    msg_success "$(translate 'Press ENTER to return...')"
                    read -r
                    continue
                fi
                echo -e "\n${YELLOW}$(translate 'Converting image using command:')${NC}"
                cmd="qemu-img convert -O $output_format $input_image $output_image"
               ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}



# ===============================================================
# 04 Network Commands
# ===============================================================
show_network_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'Network Commands')${NC}"
        echo "------------------------------------------"
        echo -e " 1) ${GREEN}ip a${NC}                           - $(translate 'Show network interfaces and IPs')"
        echo -e " 2) ${GREEN}ip r${NC}                           - $(translate 'Show routing table')"
        echo -e " 3) ${GREEN}ping <host>${NC}                    - $(translate 'Check connectivity with another host')"
        echo -e " 4) ${GREEN}brctl show${NC}                     - $(translate 'Show configured network bridges')"
        echo -e " 5) ${GREEN}ifreload -a${NC}                    - $(translate 'Reload network configuration (ifupdown2)')"
        echo -e " 6) ${GREEN}cat /etc/network/interfaces${NC}    - $(translate 'Show raw network configuration')"
        echo -e " 7) ${GREEN}ip -s link${NC}                     - $(translate 'Show traffic statistics per interface')"
        echo -e " 8) ${GREEN}ethtool <iface>${NC}                - $(translate 'Show Ethernet device info')"
        echo -e " 9) ${GREEN}resolvectl status${NC}              - $(translate 'Show DNS resolution status')"
        echo -e "10) ${GREEN}dig <domain>${NC}                   - $(translate 'DNS lookup for a domain')"
        echo -e "11) ${GREEN}ss -tuln${NC}                       - $(translate 'Show listening ports (TCP/UDP)')"
        echo -e "12) ${GREEN}iptables -L -n -v${NC}              - $(translate 'Show active firewall rules (iptables)')"
        echo -e "13) ${GREEN}nft list ruleset${NC}               - $(translate 'Show nftables rules')"
        echo -e "14) ${GREEN}pve-firewall status${NC}            - $(translate 'Check Proxmox firewall status')"
        echo -e "15) ${GREEN}pve-firewall compile${NC}           - $(translate 'Compile firewall rules for all nodes')"
        echo -e "16) ${GREEN}pve-firewall reload${NC}            - $(translate 'Reload Proxmox firewall rules')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="ip a" ;;
            2) cmd="ip r" ;;
            3)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter host or IP: ')${CL}"
                read -r host
                cmd="ping $host"
                ;;
            4) cmd="brctl show" ;;
            5) cmd="ifreload -a" ;;
            6) cmd="cat /etc/network/interfaces" ;;
            7) cmd="ip -s link" ;;
            8)
                echo -e "\n${YELLOW}$(translate 'Available network interfaces:')${NC}"
                ip -o link show | awk -F': ' '{print " - " $2}' | grep -v '^ - lo' | sort
                echo
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter interface name (e.g. eth0): ')${CL}"
                read -r iface
                cmd="ethtool $iface"
                ;;

            9) cmd="resolvectl status" ;;
            10)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter domain name: ')${CL}"
                read -r domain
                cmd="dig $domain"
                ;;
            11) cmd="ss -tuln" ;;
            12) cmd="iptables -L -n -v" ;;
            13) cmd="nft list ruleset" ;;
            14) cmd="pve-firewall status" ;;
            15) cmd="pve-firewall compile" ;;
            16) cmd="pve-firewall reload" ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}




# ===============================================================
# 05 Updates and Packages Commands
# ===============================================================
show_update_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'Updates and Packages Commands')${NC}"
        echo "----------------------------------------------------"
        echo -e " 1) ${GREEN}apt update && apt upgrade -y${NC}   - $(translate 'Update and upgrade all system packages')"
        echo -e " 2) ${GREEN}apt dist-upgrade -y${NC}            - $(translate 'Full system upgrade, including dependencies')"
        echo -e " 3) ${GREEN}pveupdate${NC}                      - $(translate 'Update Proxmox package lists')"
        echo -e " 4) ${GREEN}pveupgrade${NC}                     - $(translate 'Show available Proxmox upgrades')"
        echo -e " 5) ${GREEN}apt autoremove --purge${NC}         - $(translate 'Remove unused packages and their config')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="apt update && apt upgrade -y" ;;
            2) cmd="apt dist-upgrade -y" ;;
            3) cmd="pveupdate" ;;
            4) cmd="pveupgrade" ;;
            5) cmd="apt autoremove --purge" ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}


# ===============================================================
# 06 GPU Passthrough Commands
# ===============================================================
show_gpu_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'GPU Passthrough Commands')${NC}"
        echo "------------------------------------------------"
        echo -e " 1) ${GREEN}lspci -nn | grep -i nvidia${NC}       - $(translate 'List NVIDIA PCI devices')"
        echo -e " 2) ${GREEN}lspci -nn | grep -i vga${NC}          - $(translate 'List all VGA compatible devices')"
        echo -e " 3) ${GREEN}dmesg | grep -i vfio${NC}             - $(translate 'Check VFIO module messages')"
        echo -e " 4) ${GREEN}cat /etc/modprobe.d/vfio.conf${NC}    - $(translate 'Review VFIO passthrough configuration')"
        echo -e " 5) ${GREEN}update-initramfs -u${NC}              - $(translate 'Apply initramfs changes (VFIO)')"
        echo -e " 6) ${GREEN}cat /etc/default/grub${NC}            - $(translate 'Review GRUB options for IOMMU')"
        echo -e " 7) ${GREEN}update-grub${NC}                      - $(translate 'Apply GRUB changes')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="lspci -nn | grep -i nvidia" ;;
            2) cmd="lspci -nn | grep -i vga" ;;
            3) cmd="dmesg | grep -i vfio" ;;
            4) cmd="cat /etc/modprobe.d/vfio.conf" ;;
            5) cmd="update-initramfs -u" ;;
            6) cmd="cat /etc/default/grub" ;;
            7) cmd="update-grub" ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}



# ===============================================================
# 07 ZFS Management Commands
# ===============================================================
show_zfs_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'ZFS Management Commands')${NC}"
        echo "------------------------------------------------"
        echo -e " 1) ${GREEN}zpool status${NC}                   - $(translate 'Show ZFS pool status')"
        echo -e " 2) ${GREEN}zpool list${NC}                     - $(translate 'List all ZFS pools')"
        echo -e " 3) ${GREEN}zfs list${NC}                       - $(translate 'List ZFS datasets and snapshots')"
        echo -e " 4) ${GREEN}zpool scrub <pool>${NC}             - $(translate 'Start scrub for a ZFS pool')"
        echo -e " 5) ${GREEN}zfs create <pool>/dataset${NC}      - $(translate 'Create a new dataset in a ZFS pool')"
        echo -e " 6) ${GREEN}zfs destroy <pool>/dataset${NC}     - $(translate 'Destroy a ZFS dataset (irreversible)')"
        echo -e " 7) ${GREEN}zpool import${NC}                   - $(translate 'List importable ZFS pools')"
        echo -e " 8) ${GREEN}zpool import <pool>${NC}            - $(translate 'Import a ZFS pool')"
        echo -e " 9) ${GREEN}zpool export <pool>${NC}            - $(translate 'Export a ZFS pool')"
        echo -e "10) ${GREEN}zfs mount -a${NC}                   - $(translate 'Mount all datasets')"
        echo -e "11) ${GREEN}zfs mount <pool/dataset>${NC}       - $(translate 'Mount specific dataset')"
        echo -e "12) ${GREEN}zpool status -v${NC}                - $(translate 'Verbose pool status')"
        echo -e "13) ${GREEN}zpool history${NC}                  - $(translate 'ZFS command history')"
        echo -e "14) ${GREEN}zpool clear <pool>${NC}             - $(translate 'Clear pool error state')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Detect ESC
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="zpool status" ;;
            2) cmd="zpool list" ;;
            3) cmd="zfs list" ;;
            4)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool name: ')${CL}"
                read -r pool
                cmd="zpool scrub $pool"
                ;;
            5)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool/dataset name: ')${CL}"
                read -r dataset
                cmd="zfs create $dataset"
                ;;
            6)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool/dataset to destroy: ')${CL}"
                read -r dataset
                cmd="zfs destroy $dataset"
                ;;
            7) cmd="zpool import" ;;
            8)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool name to import: ')${CL}"
                read -r pool
                cmd="zpool import $pool"
                ;;
            9)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool name to export: ')${CL}"
                read -r pool
                cmd="zpool export $pool"
                ;;
            10) cmd="zfs mount -a" ;;
            11)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool/dataset to mount: ')${CL}"
                read -r dataset
                cmd="zfs mount $dataset"
                ;;
            12) cmd="zpool status -v" ;;
            13) cmd="zpool history" ;;
            14)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter pool name to clear errors: ')${CL}"
                read -r pool
                cmd="zpool clear $pool"
                ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}




# ===============================================================
# 08 Backup and Restore Commands
# ===============================================================
show_backup_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'Backup and Restore Commands')${NC}"
        echo "------------------------------------------------------"
        echo -e " 1) ${GREEN}vzdump <vmid>${NC}                            - $(translate 'Manual backup of a VM or CT')"
        echo -e " 2) ${GREEN}vzdump <vmid> --dumpdir /path${NC}            - $(translate 'Backup to a specific directory')"
        echo -e " 3) ${GREEN}vzdump --all${NC}                             - $(translate 'Backup all VMs and CTs')"
        echo -e " 4) ${GREEN}qmrestore /path/backup.vma.zst <vmid>${NC}    - $(translate 'Restore a VM from backup')"
        echo -e " 5) ${GREEN}pct restore <vmid> /path/backup.tar.zst${NC}  - $(translate 'Restore a CT from backup')"
        echo -e " 6) ${GREEN}ls /var/lib/vz/dump${NC}                      - $(translate 'List local backups')"
        echo -e " 7) ${GREEN}pvesm list <storage>${NC}                     - $(translate 'List backups in a specific storage')"
        echo -e " 8) ${GREEN}cat /etc/vzdump.conf${NC}                     - $(translate 'Show vzdump backup configuration')"
        echo -e " 9) ${GREEN}zstd -d <backup>.zst${NC}                     - $(translate 'Decompress backup manually')"
        echo -e "10) ${GREEN}vzdump --stdexcludes${NC}                     - $(translate 'Show standard exclude patterns')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM/CT ID: ')${CL}"
                read -r id
                cmd="vzdump $id"
                ;;
            2)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM/CT ID: ')${CL}"
                read -r id
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter destination path: ')${CL}"
                read -r path
                cmd="vzdump $id --dumpdir $path"
                ;;
            3) cmd="vzdump --all" ;;
            4)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter backup path (.vma.zst): ')${CL}"
                read -r backup
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter VM ID: ')${CL}"
                read -r id
                cmd="qmrestore $backup $id"
                ;;
            5)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter backup path (.tar.zst): ')${CL}"
                read -r backup
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter CT ID: ')${CL}"
                read -r id
                cmd="pct restore $id $backup"
                ;;
            6) cmd="ls /var/lib/vz/dump" ;;
            7)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter storage name: ')${CL}"
                read -r storage
                cmd="pvesm list $storage"
                ;;
            8) cmd="cat /etc/vzdump.conf" ;;
            9)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter backup file (.zst): ')${CL}"
                read -r file
                cmd="zstd -d $file"
                ;;
            10) cmd="vzdump --stdexcludes" ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}




# ===============================================================
# 09 System CLI Tools Commands
# ===============================================================
show_tools_commands() {
    while true; do
        clear
        echo -e "${YELLOW}$(translate 'System CLI Tools')${NC}"
        echo "--------------------------------------------"
        echo -e " 1) ${GREEN}htop${NC}              - $(translate 'Interactive process viewer (press q to exit)')"
        echo -e " 2) ${GREEN}btop${NC}              - $(translate 'Modern resource monitor (press q to exit)')"
        echo -e " 3) ${GREEN}iftop${NC}             - $(translate 'Real-time bandwidth usage (press q to exit)')"
        echo -e " 4) ${GREEN}iotop${NC}             - $(translate 'Monitor disk I/O usage (press q to exit)')"
        echo -e " 5) ${GREEN}tmux${NC}              - $(translate 'Terminal multiplexer (Ctrl+b then d to detach, or type exit)')"
        echo -e " 6) ${GREEN}iperf3${NC}            - $(translate 'Network throughput test (client/server)')"
        echo -e " 7) ${GREEN}iptraf-ng${NC}         - $(translate 'Real-time network monitoring (press q to exit)')"
        echo -e " 8) ${GREEN}msr-tools${NC}         - $(translate 'Read/write CPU model-specific registers')"
        echo -e " 9) ${GREEN}net-tools${NC}         - $(translate 'Legacy network tools (e.g., ifconfig)')"
        echo -e "10) ${GREEN}whois${NC}             - $(translate 'Lookup domain registration info')"
        echo -e "11) ${GREEN}libguestfs-tools${NC}  - $(translate 'Manage and inspect VM disk images')"
        echo -e " ${DEF}0) $(translate ' Back to previous menu or Esc + Enter')"
        echo
        echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter a number, or write or paste a command: ') ${CL}"
        read -r user_input

        # Check for Esc key press
        if [[ "$user_input" == $'\x1b' ]]; then
            break
        fi

        case "$user_input" in
            1) cmd="htop" ;;
            2) cmd="btop" ;;
            3) cmd="iftop" ;;
            4) cmd="iotop" ;;
            5) cmd="tmux" ;;
            6)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Run as server or client? [s/c]: ')${CL}"
                read -r mode
                if [[ "$mode" == "s" ]]; then
                    cmd="iperf3 -s"
                elif [[ "$mode" == "c" ]]; then
                    echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter server IP: ')${CL}"
                    read -r server_ip
                    cmd="iperf3 -c $server_ip"
                else
                    msg_info2 "$(translate 'Invalid option. Skipping.')"
                    read -r
                    continue
                fi
                ;;
            7) cmd="iptraf-ng" ;;
            8)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter MSR register (e.g. 0x10): ')${CL}"
                read -r reg
                cmd="rdmsr $reg"
                ;;
            9) cmd="ifconfig -a" ;;
            10)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter domain: ')${CL}"
                read -r domain
                cmd="whois $domain"
                ;;
            11)
                echo -en "${TAB}${BOLD}${YW}${HOLD}$(translate 'Enter disk image path: ')${CL}"
                read -r path
                cmd="virt-inspector $path"
                ;;
            0) break ;;
            *) cmd="$user_input" ;;
        esac

        if ! command -v $(echo "$cmd" | awk '{print $1}') &>/dev/null; then
            if whiptail --yesno "$(translate "$cmd is not installed. Do you want to install it now?")" 10 60; then
                msg_info "$(translate "Installing") $cmd..."
                apt update -qq >/dev/null 2>&1
                apt install -y $(echo "$cmd" | awk '{print $1}') >/dev/null 2>&1
                msg_ok "$(translate "$cmd installed successfully")"
                sleep 2
            else
                msg_info2 "$(translate 'Skipping installation.')"
                read -r
                continue
            fi
        fi

        echo -e "\n${GREEN}> $cmd${NC}\n"
        bash -c "$cmd"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r tmp
    done
}




# ===============================================================
# Help and Info Menu
# ===============================================================
while true; do
    OPTION=$(dialog --stdout \
        --title "$(translate 'Help and Info')" \
        --menu "\n$(translate 'Select a category of useful commands:')" 20 70 9 \
        1 "$(translate 'Useful System Commands')" \
        2 "$(translate 'VM and CT Management Commands')" \
        3 "$(translate 'Storage and Disks Commands')" \
        4 "$(translate 'Network Commands')" \
        5 "$(translate 'Updates and Packages Commands')" \
        6 "$(translate 'GPU Passthrough Commands')" \
        7 "$(translate 'ZFS Management Commands')" \
        8 "$(translate 'Backup and Restore Commands')" \
        9 "$(translate 'System CLI Tools')" \
        0 "$(translate 'Exit')")

    EXIT_STATUS=$?

    if [[ $EXIT_STATUS -ne 0 ]]; then

        break
    fi

    case $OPTION in
        1) show_system_commands ;;
        2) show_vm_ct_commands ;;
        3) show_storage_commands ;;
        4) show_network_commands ;;
        5) show_update_commands ;;
        6) show_gpu_commands ;;
        7) show_zfs_commands ;;
        8) show_backup_commands ;;
        9) show_tools_commands ;;
        0) clear; break ;;  
        *)
            msg_info2 "$(translate 'Invalid option, please try again.')"
            read -r
            ;;
    esac
done





================================================
FILE: scripts/import-disk-image.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 29/05/2025
# ==========================================================
# Description:
# This script automates the process of importing disk images into Proxmox VE virtual machines (VMs), 
# making it easy to attach pre-existing disk files without manual configuration.
#
# Before running the script, ensure that disk images are available in /var/lib/vz/template/images/. 
# The script scans this directory for compatible formats (.img, .qcow2, .vmdk, .raw) and lists the available files.
#
# Using an interactive menu, you can:
# - Select a VM to attach the imported disk.
# - Choose one or multiple disk images for import.
# - Pick a storage volume in Proxmox for disk placement.
# - Assign a suitable interface (SATA, SCSI, VirtIO, or IDE).
# - Enable optional settings like SSD emulation or bootable disk configuration.
#
# Once completed, the script ensures the selected images are correctly attached and ready to use.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"
load_language
initialize_cache
# Configuration ============================================


detect_image_dir() {
  for store in $(pvesm status -content images | awk 'NR>1 {print $1}'); do
    path=$(pvesm path "${store}:template" 2>/dev/null)
    if [[ -d "$path" ]]; then
      for ext in raw img qcow2 vmdk; do
        if compgen -G "$path/*.$ext" > /dev/null; then
          echo "$path"
          return 0
        fi
      done
      for sub in images iso; do
        dir="$path/$sub"
        if [[ -d "$dir" ]]; then
          for ext in raw img qcow2 vmdk; do
            if compgen -G "$dir/*.$ext" > /dev/null; then
              echo "$dir"
              return 0
            fi
          done
        fi
      done
    fi
  done
  for fallback in /var/lib/vz/template/images /var/lib/vz/template/iso; do
    if [[ -d "$fallback" ]]; then
      for ext in raw img qcow2 vmdk; do
        if compgen -G "$fallback/*.$ext" > /dev/null; then
          echo "$fallback"
          return 0
        fi
      done
    fi
  done
  return 1
}




IMAGES_DIR=$(detect_image_dir)
if [[ -z "$IMAGES_DIR" ]]; then
  dialog --title "$(translate 'No Images Found')" \
         --msgbox "$(translate 'Could not find any directory containing disk images')\n\n$(translate 'Make sure there is at least one file with extension .img, .qcow2, .vmdk or .raw')" 15 60
  exit 1
fi

IMAGES=$(ls -A "$IMAGES_DIR" | grep -E "\.(img|qcow2|vmdk|raw)$")
if [ -z "$IMAGES" ]; then
  dialog --title "$(translate 'No Disk Images Found')" \
         --msgbox "$(translate 'No compatible disk images found in:')\n\n$IMAGES_DIR\n\n$(translate 'Supported formats: .img, .qcow2, .vmdk, .raw')" 15 60
  exit 1
fi


# === Select VM
msg_info "$(translate 'Getting VM list')"
VM_LIST=$(qm list | awk 'NR>1 {print $1" "$2}')
[[ -z "$VM_LIST" ]] && { msg_error "$(translate 'No VMs available in the system')"; exit 1; }
msg_ok "$(translate 'VM list obtained')"

VMID=$(whiptail --title "$(translate 'Select VM')" \
        --menu "$(translate 'Select the VM where you want to import the disk image:')" 20 70 10 $VM_LIST 3>&1 1>&2 2>&3)
[[ -z "$VMID" ]] && exit 1




# === Select storage
msg_info "$(translate 'Getting storage volumes')"
STORAGE_LIST=$(pvesm status -content images | awk 'NR>1 {print $1}')
[[ -z "$STORAGE_LIST" ]] && { msg_error "$(translate 'No storage volumes available')"; exit 1; }
msg_ok "$(translate 'Storage volumes obtained')"

STORAGE_OPTIONS=()
while read -r storage; do STORAGE_OPTIONS+=("$storage" ""); done <<< "$STORAGE_LIST"
STORAGE=$(whiptail --title "$(translate 'Select Storage')" \
         --menu "$(translate 'Select the storage volume for disk import:')" 20 70 10 "${STORAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
[[ -z "$STORAGE" ]] && exit 1



# === Select images
IMAGE_OPTIONS=()
while read -r img; do IMAGE_OPTIONS+=("$img" "" "OFF"); done <<< "$IMAGES"
SELECTED_IMAGES=$(whiptail --title "$(translate 'Select Disk Images')" \
                 --checklist "$(translate 'Select the disk images to import:')" 20 70 12 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
[[ -z "$SELECTED_IMAGES" ]] && exit 1



# === Import each selected image
for IMAGE in $SELECTED_IMAGES; do
  IMAGE=$(echo "$IMAGE" | tr -d '"')
  INTERFACE=$(whiptail --title "$(translate 'Interface Type')" --menu "$(translate 'Select the interface type for the image:') $IMAGE" 15 40 4 \
    "sata" "SATA" "scsi" "SCSI" "virtio" "VirtIO" "ide" "IDE" 3>&1 1>&2 2>&3)
  [[ -z "$INTERFACE" ]] && { msg_error "$(translate 'No interface type selected for') $IMAGE"; continue; }

  FULL_PATH="$IMAGES_DIR/$IMAGE"
  msg_info "$(translate 'Importing image:') $IMAGE"
  TEMP_DISK_FILE=$(mktemp)

  qm importdisk "$VMID" "$FULL_PATH" "$STORAGE" 2>&1 | while read -r line; do
    if [[ "$line" =~ transferred ]]; then
      PERCENT=$(echo "$line" | grep -oP "\(\d+\.\d+%\)" | tr -d '()%')
      echo -ne "\r${TAB}${BL}-$(translate 'Importing image:') $IMAGE-${CL} ${PERCENT}%"
    elif [[ "$line" =~ successfully\ imported\ disk ]]; then
      echo "$line" | grep -oP "(?<=successfully imported disk ').*(?=')" > "$TEMP_DISK_FILE"
    fi
  done
  echo -ne "\n"
  IMPORT_STATUS=${PIPESTATUS[0]}



  if [ "$IMPORT_STATUS" -eq 0 ]; then
    msg_ok "$(translate 'Image imported successfully')"
    IMPORTED_DISK=$(cat "$TEMP_DISK_FILE")
    rm -f "$TEMP_DISK_FILE"

    if [ -n "$IMPORTED_DISK" ]; then
      EXISTING_DISKS=$(qm config "$VMID" | grep -oP "${INTERFACE}\d+" | sort -n)
      NEXT_SLOT=0
      [[ -n "$EXISTING_DISKS" ]] && NEXT_SLOT=$(( $(echo "$EXISTING_DISKS" | tail -n1 | sed "s/${INTERFACE}//") + 1 ))

      SSD_OPTION=""
      if [ "$INTERFACE" != "virtio" ]; then
        whiptail --yesno "$(translate 'Do you want to use SSD emulation for this disk?')" 10 60 && SSD_OPTION=",ssd=1"
      fi

      msg_info "$(translate 'Configuring disk')"
      if qm set "$VMID" --${INTERFACE}${NEXT_SLOT} "$IMPORTED_DISK${SSD_OPTION}" &>/dev/null; then
        msg_ok "$(translate 'Image') $IMAGE $(translate 'configured as') ${INTERFACE}${NEXT_SLOT}"
        whiptail --yesno "$(translate 'Do you want to make this disk bootable?')" 10 60 && {
          msg_info "$(translate 'Configuring disk as bootable')"
          if qm set "$VMID" --boot c --bootdisk ${INTERFACE}${NEXT_SLOT} &>/dev/null; then
            msg_ok "$(translate 'Disk configured as bootable')"
          else
            msg_error "$(translate 'Could not configure the disk as bootable')"
          fi
        }
      else
        msg_error "$(translate 'Could not configure disk') ${INTERFACE}${NEXT_SLOT} $(translate 'for VM') $VMID"
      fi
    else
      msg_error "$(translate 'Could not find the imported disk')"
    fi
  else
    msg_error "$(translate 'Could not import') $IMAGE"
  fi
done

msg_ok "$(translate 'All selected images have been processed')"
msg_success "$(translate "Press Enter to return to menu...")"
read -r


================================================
FILE: scripts/install_coral_lxc.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Revision    : @Blaspt (USB passthrough via udev rule with persistent /dev/coral)
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 16/05/2025
# ==========================================================
# Description:
# This script automates the configuration and installation of
# Coral TPU and iGPU support in Proxmox VE containers. It:
# - Configures a selected LXC container for hardware acceleration
# - Installs and sets up Coral TPU drivers on the Proxmox host
# - Installs necessary drivers inside the container
# - Manages required system and container restarts
#
# Supports Coral USB and Coral M.2 (PCIe) devices.
# Includes USB passthrough enhancement using persistent udev alias (/dev/coral).
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

select_container() {
    CONTAINERS=$(pct list | awk 'NR>1 {print $1, $3}' | xargs -n2)
    if [ -z "$CONTAINERS" ]; then
        msg_error "$(translate 'No containers available in Proxmox.')"
        exit 1
    fi

    CONTAINER_ID=$(whiptail --title "$(translate 'Select Container')" \
        --menu "$(translate 'Select the LXC container:')" 20 70 10 $CONTAINERS 3>&1 1>&2 2>&3)

    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'No container selected. Exiting.')"
        exit 1
    fi

    if ! pct list | awk 'NR>1 {print $1}' | grep -qw "$CONTAINER_ID"; then
        msg_error "$(translate 'Container with ID') $CONTAINER_ID $(translate 'does not exist. Exiting.')"
        exit 1
    fi

    msg_ok "$(translate 'Container selected:') $CONTAINER_ID"
}

validate_container_id() {
    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'Container ID not defined. Make sure to select a container first.')"
        exit 1
    fi

    if pct status "$CONTAINER_ID" | grep -q "running"; then
        msg_info "$(translate 'Stopping the container before applying configuration...')"
        pct stop "$CONTAINER_ID"
        msg_ok "$(translate 'Container stopped.')"
    fi
}


add_udev_rule_for_coral_usb_() {
    RULE_FILE="/etc/udev/rules.d/99-coral-usb.rules"
    RULE_CONTENT='SUBSYSTEM=="usb", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="9302", MODE="0666", TAG+="uaccess"'

    if [[ ! -f "$RULE_FILE" ]] || ! grep -qF "$RULE_CONTENT" "$RULE_FILE"; then
        echo "$RULE_CONTENT" > "$RULE_FILE"
        udevadm control --reload-rules && udevadm trigger
        msg_ok "$(translate 'Udev rule for Coral USB added and rules reloaded.')"
    else
        msg_ok "$(translate 'Udev rule for Coral USB already exists.')"
    fi
}


add_udev_rule_for_coral_usb() {
    RULE_FILE="/etc/udev/rules.d/99-coral-usb.rules"
    RULE_CONTENT='# Coral USB Accelerator
SUBSYSTEM=="usb", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="9302", MODE="0666", TAG+="uaccess", SYMLINK+="coral"
# Coral Dev Board / Mini PCIe
SUBSYSTEM=="usb", ATTRS{idVendor}=="1a6e", ATTRS{idProduct}=="089a", MODE="0666", TAG+="uaccess", SYMLINK+="coral"'

    if [[ ! -f "$RULE_FILE" ]] || ! grep -q "18d1.*9302\|1a6e.*089a" "$RULE_FILE"; then
        echo "$RULE_CONTENT" > "$RULE_FILE"
        udevadm control --reload-rules && udevadm trigger
        msg_ok "$(translate 'Udev rules for Coral USB devices added and rules reloaded.')"
    else
        msg_ok "$(translate 'Udev rules for Coral USB devices already exist.')"
    fi
}


add_mount_if_needed() {
    local DEVICE="$1"
    local DEST="$2"
    local CONFIG_FILE="$3"
    if [ -e "$DEVICE" ] && ! grep -q "lxc.mount.entry: $DEVICE" "$CONFIG_FILE"; then
        echo "lxc.mount.entry: $DEVICE $DEST none bind,optional,create=$( [ -c "$DEVICE" ] && echo file || echo dir )" >> "$CONFIG_FILE"
    fi
}



configure_lxc_hardware() {
    validate_container_id
    CONFIG_FILE="/etc/pve/lxc/${CONTAINER_ID}.conf"
    if [ ! -f "$CONFIG_FILE" ]; then
        msg_error "$(translate 'Configuration file for container') $CONTAINER_ID $(translate 'not found.')"
        exit 1
    fi

    # Privileged container
    if grep -q "^unprivileged: 1" "$CONFIG_FILE"; then
        msg_info "$(translate 'The container is unprivileged. Changing to privileged...')"
        sed -i "s/^unprivileged: 1/unprivileged: 0/" "$CONFIG_FILE"
        STORAGE_TYPE=$(pct config "$CONTAINER_ID" | grep "^rootfs:" | awk -F, '{print $2}' | cut -d'=' -f2)
        if [[ "$STORAGE_TYPE" == "dir" ]]; then
            STORAGE_PATH=$(pct config "$CONTAINER_ID" | grep "^rootfs:" | awk '{print $2}' | cut -d',' -f1)
            chown -R root:root "$STORAGE_PATH"
        fi
        msg_ok "$(translate 'Container changed to privileged.')"
    else
        msg_ok "$(translate 'The container is already privileged.')"
    fi
    

    sed -i '/^dev[0-9]\+:/d' "$CONFIG_FILE"

    # Enable nesting feature
    if ! grep -q "features: nesting=1" "$CONFIG_FILE"; then
        echo "features: nesting=1" >> "$CONFIG_FILE"
    fi

    # iGPU support
    if ! grep -q "c 226:0 rwm" "$CONFIG_FILE"; then
        echo "lxc.cgroup2.devices.allow: c 226:0 rwm # iGPU" >> "$CONFIG_FILE"
        echo "lxc.cgroup2.devices.allow: c 226:128 rwm # iGPU" >> "$CONFIG_FILE"
    fi


    add_mount_if_needed "/dev/dri" "dev/dri" "$CONFIG_FILE"
    add_mount_if_needed "/dev/dri/renderD128" "dev/dri/renderD128" "$CONFIG_FILE"
    add_mount_if_needed "/dev/dri/card0" "dev/dri/card0" "$CONFIG_FILE"

    # Framebuffer support
    if ! grep -q "c 29:0 rwm # Framebuffer" "$CONFIG_FILE"; then
        echo "lxc.cgroup2.devices.allow: c 29:0 rwm # Framebuffer" >> "$CONFIG_FILE"
    fi
    add_mount_if_needed "/dev/fb0" "dev/fb0" "$CONFIG_FILE"


     # ----------------------------------------------------------
    # Coral USB passthrough (via udev + /dev/coral)
    # ----------------------------------------------------------
    add_udev_rule_for_coral_usb
    if ! grep -Pq "^lxc.cgroup2.devices.allow: c 189:\* rwm # Coral USB$" "$CONFIG_FILE"; then
        echo "lxc.cgroup2.devices.allow: c 189:* rwm # Coral USB" >> "$CONFIG_FILE"
    fi
    add_mount_if_needed "/dev/coral" "dev/coral" "$CONFIG_FILE"


    # ----------------------------------------------------------
    # Coral M.2 (PCIe) support
    # ----------------------------------------------------------
    if lspci | grep -iq "Global Unichip"; then
        if ! grep -Pq "^lxc.cgroup2.devices.allow: c 245:0 rwm # Coral M2 Apex$" "$CONFIG_FILE"; then
            echo "lxc.cgroup2.devices.allow: c 245:0 rwm # Coral M2 Apex" >> "$CONFIG_FILE"
        fi
        add_mount_if_needed "/dev/apex_0" "dev/apex_0" "$CONFIG_FILE"
    fi


    msg_ok "$(translate 'Coral TPU and iGPU configuration added to container') $CONTAINER_ID."
}

install_coral_in_container() {
    msg_info2 "$(translate 'Installing iGPU and Coral TPU drivers inside the container...')"
    tput sc
    LOG_FILE=$(mktemp)

    pct start "$CONTAINER_ID"

    CORAL_M2=$(lspci | grep -i "Global Unichip")
    if [[ -n "$CORAL_M2" ]]; then
        DRIVER_OPTION=$(whiptail --title "$(translate 'Select driver version')" \
            --menu "$(translate 'Choose the driver version for Coral M.2:\n\nCaution: Maximum mode generates more heat.')" 15 60 2 \
            1 "libedgetpu1-std ($(translate 'standard performance'))" \
            2 "libedgetpu1-max ($(translate 'maximum performance'))" 3>&1 1>&2 2>&3)

        case "$DRIVER_OPTION" in
            1) DRIVER_PACKAGE="libedgetpu1-std" ;;
            2) DRIVER_PACKAGE="libedgetpu1-max" ;;
            *) DRIVER_PACKAGE="libedgetpu1-std" ;;
        esac
    else
        DRIVER_PACKAGE="libedgetpu1-std"
    fi

    script -q -c "pct exec \"$CONTAINER_ID\" -- bash -c '
    set -e
    echo \"- Updating package lists...\"
    apt-get update
    echo \"- Installing iGPU drivers...\"
    apt-get install -y va-driver-all ocl-icd-libopencl1 intel-opencl-icd vainfo intel-gpu-tools
    chgrp video /dev/dri && chmod 755 /dev/dri
    adduser root video && adduser root render

    echo \"- Installing Coral TPU dependencies...\"
    apt-get install -y gnupg python3 python3-pip python3-venv

    echo \"- Adding Coral TPU repository...\"
    curl -fsSL https://packages.cloud.google.com/apt/doc/apt-key.gpg | gpg --dearmor -o /usr/share/keyrings/coral-edgetpu.gpg
    echo \"deb [signed-by=/usr/share/keyrings/coral-edgetpu.gpg] https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | tee /etc/apt/sources.list.d/coral-edgetpu.list

    echo \"- Updating package lists again...\"
    apt-get update
    echo \"- Installing Coral TPU driver ($DRIVER_PACKAGE)...\"
    apt-get install -y $DRIVER_PACKAGE
    '" "$LOG_FILE"

    if [ $? -eq 0 ]; then
        tput rc
        tput ed
        rm -f "$LOG_FILE"
        msg_ok "$(translate 'iGPU and Coral TPU drivers installed inside the container.')"
    else
        msg_error "$(translate 'Failed to install iGPU and Coral TPU drivers inside the container.')"
        cat "$LOG_FILE"
        rm -f "$LOG_FILE"
        exit 1
    fi
}

select_container
show_proxmenux_logo
configure_lxc_hardware
install_coral_in_container

msg_ok "$(translate 'Configuration completed.')"
echo -e
msg_success "$(translate "Press Enter to return to menu...")"
read -r



================================================
FILE: scripts/install_coral_pve.sh
================================================
#!/bin/bash


# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script installs the Coral TPU drivers on the Proxmox VE host.
# It ensures that necessary packages are installed and compiles the
# Coral TPU drivers for proper functionality.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================


# Prompt before installation
pre_install_prompt() {
    if ! whiptail --title "$(translate 'Coral TPU Installation')" --yesno "$(translate 'Installing Coral TPU drivers requires rebooting the server after installation. Do you want to proceed?')" 10 70; then
        msg_warn "$(translate 'Installation cancelled by user.')"
        exit 0
    fi
}

# Verify and configure repositories on the host
verify_and_add_repos() {
    msg_info "$(translate 'Configuring necessary repositories on the host...')"
    sleep 2

    if ! grep -q "pve-no-subscription" /etc/apt/sources.list /etc/apt/sources.list.d/* 2>/dev/null; then
        echo "deb http://download.proxmox.com/debian/pve $(lsb_release -sc) pve-no-subscription" | tee /etc/apt/sources.list.d/pve-no-subscription.list
        msg_ok "$(translate 'pve-no-subscription repository added.')"
    fi

    if ! grep -q "non-free-firmware" /etc/apt/sources.list; then
        echo "deb http://deb.debian.org/debian $(lsb_release -sc) main contrib non-free-firmware
        deb http://deb.debian.org/debian $(lsb_release -sc)-updates main contrib non-free-firmware
        deb http://security.debian.org/debian-security $(lsb_release -sc)-security main contrib non-free-firmware" | tee -a /etc/apt/sources.list
        msg_ok "$(translate 'non-free-firmware repositories added.')"
    fi

    msg_ok "$(translate 'Added repositories')"
    sleep 2

    msg_info "$(translate 'Verifying repositories...')"
    apt-get update &>/dev/null

    msg_ok "$(translate 'Verified and updated repositories.')"
}

# Function to install Coral TPU drivers on the host
install_coral_host() {
    show_proxmenux_logo
    verify_and_add_repos

    apt-get install -y git devscripts dh-dkms dkms pve-headers-$(uname -r) >/dev/null 2>&1

    cd /tmp
    rm -rf gasket-driver
    git clone https://github.com/google/gasket-driver.git
    if [ $? -ne 0 ]; then
        msg_error "$(translate 'Error: Could not clone the repository.')"
        exit 1
    fi

    cd gasket-driver/
    debuild -us -uc -tc -b
    if [ $? -ne 0 ]; then
        msg_error "$(translate 'Error: Failed to build driver packages.')"
        exit 1
    fi

    dpkg -i ../gasket-dkms_*.deb
    if [ $? -ne 0 ]; then
        msg_error "$(translate 'Error: Failed to install the driver packages.')"
        exit 1
    fi

    msg_success "$(translate 'Coral TPU drivers installed successfully on the host.')"
    echo -e
}

# Prompt for reboot after installation
    restart_prompt() {
    if whiptail --title "$(translate 'Coral TPU Installation')" --yesno "$(translate 'The installation requires a server restart to apply changes. Do you want to restart now?')" 10 70; then
        msg_warn "$(translate 'Restarting the server...')"
        reboot
    else
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
    fi
}


pre_install_prompt
install_coral_host
restart_prompt



================================================
FILE: scripts/repair_network.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks for passthrough to existing
# Proxmox virtual machines (VMs) through an interactive menu.
# - Detects and lists physical and network interfaces.
# - Verifies and repairs bridge configurations.
# - Ensures network connectivity by checking IP assignments.
# - Provides options to manually repair or verify network settings.
# - Offers interactive menus for user-friendly operation.
#
# The script aims to simplify network troubleshooting and ensure
# that Proxmox systems maintain stable connectivity.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

# Function to detect physical network interfaces
detect_physical_interfaces() {

    physical_interfaces=$(ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|bond)/ {print $2}')
    whiptail --title "$(translate 'Network Interfaces')" --msgbox "$physical_interfaces" 10 78
}


# Function to get all relevant network interfaces (physical and bridges)
get_relevant_interfaces() {
    echo $(ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy)/ {print $2}')
}



# Function to check and fix bridge configuration
check_and_fix_bridges() {

    local output=""
    output+="$(translate 'Checking bridges')\\n\\n"
    bridges=$(grep "^auto vmbr" /etc/network/interfaces | awk '{print $2}')
    for bridge in $bridges; do
        old_port=$(grep -A1 "iface $bridge" /etc/network/interfaces | grep "bridge-ports" | awk '{print $2}')
        if ! ip link show "$old_port" &>/dev/null; then
            output+="$(translate 'Bridge port missing'): $bridge - $old_port\\n"
            new_port=$(echo "$physical_interfaces" | tr ' ' '\n' | grep -v "vmbr" | head -n1)
            if [ -n "$new_port" ]; then
                sed -i "/iface $bridge/,/bridge-ports/ s/bridge-ports.*/bridge-ports $new_port/" /etc/network/interfaces
                output+="$(translate 'Bridge port updated'): $bridge - $old_port -> $new_port\\n"
            else
                output+="$(translate 'No physical interface available')\\n"
            fi
        else
            output+="$(translate 'Bridge port OK'): $bridge - $old_port\\n"
        fi
    done
    whiptail --title "$(translate 'Checking Bridges')" --msgbox "$output" 20 78
}


clean_nonexistent_interfaces() {

    local output=""
    output+="$(translate 'Cleaning interfaces')\\n\\n"
    configured_interfaces=$(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo")
    for iface in $configured_interfaces; do
        if [[ ! $iface =~ ^(vmbr|bond) ]] && ! ip link show "$iface" &>/dev/null; then
            sed -i "/iface $iface/,/^$/d" /etc/network/interfaces
            output+="$(translate 'Interface removed'): $iface\\n"
        fi
    done
    whiptail --title "$(translate 'Cleaning Interfaces')" --msgbox "$output" 15 78
}


# Update other functions to use physical_interfaces or get_relevant_interfaces as appropriate
configure_physical_interfaces() {

    local output=""
    output+="$(translate 'Configuring interfaces')\\n\\n"
    for iface in $physical_interfaces; do
        if ! grep -q "iface $iface" /etc/network/interfaces; then
            echo -e "\niface $iface inet manual" >> /etc/network/interfaces
            output+="$(translate 'Interface added'): $iface\\n"
        fi
    done
    whiptail --title "$(translate 'Configuring Interfaces')" --msgbox "$output" 15 78
}

# Function to restart networking service
restart_networking() {
    if (whiptail --title "$(translate 'Restarting Network')" --yesno "$(translate 'Do you want to restart the network service?')" 10 60); then
        clear
        msg_info "$(translate 'The network service is about to restart. You may experience a brief disconnection.')"
        systemctl restart networking
        if [ $? -eq 0 ]; then
            msg_ok "$(translate 'Network service restarted successfully')"
        else
            msg_error "$(translate 'Failed to restart network service')"
        fi
    else
        msg_ok "$(translate 'Network restart canceled')"
    fi
}

# Function to check network connectivity
check_network_connectivity() {
    if ping -c 4 8.8.8.8 &> /dev/null; then
        msg_ok "$(translate 'Network connectivity OK')"
        return 0
    else
        msg_error "$(translate 'Network connectivity failed')"
        return 1
    fi
}


# Update the show_ip_info function to use the new get_relevant_interfaces function
show_ip_info() {
    whiptail --title "$(translate 'IP Information')" --infobox "$(translate 'Gathering IP information...')" 8 78
    local ip_info=""
    ip_info+="$(translate 'IP Information')\\n\\n"

    local interfaces=$(get_relevant_interfaces)

    for interface in $interfaces; do
        local interface_ip=$(ip -4 addr show $interface 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
        if [ -n "$interface_ip" ]; then
            ip_info+="$interface: $interface_ip\\n"
        else
            ip_info+="$interface: $(translate 'No IP assigned')\\n"
        fi
    done

    whiptail --title "$(translate 'Result')" --msgbox "${ip_info}\\n\\n$(translate 'IP information gathering completed')\\n\\n$(translate 'Press Enter to continue')" 20 78
}


# Function to repair network
repair_network() {
    whiptail --title "$(translate 'Network Repair Started')" --infobox "$(translate 'Repairing network...')" 8 78
    echo -ne "${TAB}${YW}-$(translate 'Repairing network...') ${CL}"
    sleep 3
    detect_physical_interfaces
    clean_nonexistent_interfaces
    check_and_fix_bridges
    configure_physical_interfaces
    restart_networking
    if check_network_connectivity; then
        show_ip_info
        msg_ok "$(translate 'Network repair completed successfully')"
    else
        msg_error "$(translate 'Network repair failed')"
    fi
    whiptail --title "$(translate 'Result')" --msgbox "$(translate 'Repair process completed')\\n\\n$(translate 'Press Enter to continue')" 10 78
}

# Function to verify network configuration
verify_network() {
    whiptail --title "$(translate 'Network Verification Started')" --infobox "$(translate 'Verifying network...')" 8 78
    echo -ne "${TAB}${YW}-$(translate 'Verifying network...') ${CL}"
    detect_physical_interfaces
    show_ip_info
    if check_network_connectivity; then
        msg_ok "$(translate 'Network verification completed successfully')"
    else
        msg_error "$(translate 'Network verification failed')"
    fi
    whiptail --title "$(translate 'Result')" --msgbox "$(translate 'Verification process completed')\\n\\n$(translate 'Press Enter to continue')" 10 78
}

# Function to show main menu
show_main_menu() {
    while true; do
        OPTION=$(whiptail --title "$(translate 'Network Repair Menu')" --menu "$(translate 'Choose an option:')" 15 60 4 \
        "1" "$(translate 'Verify Network')" \
        "2" "$(translate 'Show IP Information')" \
        "3" "$(translate "Return to Main Menu")" 3>&1 1>&2 2>&3)

        case $OPTION in
            1)
                verify_network
                ;;
            2)
                show_ip_info
                ;;
            3) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
            *) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
            
        esac
    done
}


    clear
    #show_proxmenux_logo
    show_main_menu



================================================
FILE: scripts/utils.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script provides a set of utility functions used across
# ProxMenux to facilitate Proxmox VE management.
#
# - Defines color codes for consistent output formatting.
# - Implements a spinner-based loading animation.
# - Provides standardized message functions (info, success, error, warning).
# - Handles translation with caching to reduce API requests.
# - Initializes and manages a local cache for improved performance.
# - Loads language settings from a configuration file.
#
# These utilities ensure a streamlined and uniform user experience
# across different ProxMenux scripts.
#
# This script incorporates elements from the 
# Proxmox VE Post Install script from Proxmox VE Helper-Scripts.
#
# Copyright (c) Proxmox VE Helper-Scripts Community
# Script updates can be found at: https://github.com/community-scripts/ProxmoxVE
#
# License: MIT | https://github.com/community-scripts/ProxmoxVE/raw/main/LICENSE
#
# ==========================================================

# Repository and directory structure
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
INSTALL_DIR="/usr/local/bin"
BASE_DIR="/usr/local/share/proxmenux"
CONFIG_FILE="$BASE_DIR/config.json"
CACHE_FILE="$BASE_DIR/cache.json"
LOCAL_VERSION_FILE="$BASE_DIR/version.txt"
MENU_SCRIPT="menu"
VENV_PATH="/opt/googletrans-env"
COMPONENTS_STATUS_FILE="$BASE_DIR/components_status.json"


# Translation context
TRANSLATION_CONTEXT="Context: Technical message for Proxmox and IT. Translate:"

# Color and style definitions
NEON_PURPLE_BLUE="\033[38;5;99m"
WHITE="\033[38;5;15m" 
RESET="\033[0m"  
DARK_GRAY="\033[38;5;244m"
ORANGE="\033[38;5;208m"
YW="\033[33m"
YWB="\033[1;33m"
GN="\033[1;92m"
RD="\033[01;31m"
CL="\033[m"
BL="\033[36m"
DGN="\e[32m"
BGN="\e[1;32m"
DEF="\e[1;36m"
CUS="\e[38;5;214m"
BOLD="\033[1m"
BFR="\\r\\033[K"
HOLD="-"
BOR=" | "
CM="${GN}âœ“ ${CL}"
TAB="    "   


# Create and display spinner
spinner() {
    local frames=('â ‹' 'â ™' 'â ¹' 'â ¸' 'â ¼' 'â ´' 'â ¦' 'â §' 'â ‡' 'â ')
    local spin_i=0
    local interval=0.1
    printf "\e[?25l"
    
    local color="${YW}"
    
    while true; do
        printf "\r ${color}%s${CL}" "${frames[spin_i]}"
        spin_i=$(( (spin_i + 1) % ${#frames[@]} ))
        sleep "$interval"
    done
}


# Function to simulate typing effect
type_text() {
    local text="$1"
    local delay=0.05
    for ((i=0; i<${#text}; i++)); do
        echo -n "${text:$i:1}"
        sleep $delay
    done
    echo
}


# Stop the spinner if it is active
cleanup() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    sleep 1
    if [[ "$LANGUAGE" != "en" ]]; then
        printf "\r\033[K"    
        printf "\e[?25h"
    fi
}

# Display trnaslate message with spinner
msg_lang() {
    local msg="$1"
    echo -ne "${TAB}${YW}${HOLD}${msg}"
    spinner &
    SPINNER_PID=$!
}


# Display info message with spinner
msg_info() {
    local msg="$1"
    echo -ne "${TAB}${YW}${HOLD}${msg}"
    spinner &
    SPINNER_PID=$!
}


# Display info2 message
msg_info2() {
    local msg="$1"
    echo -e "${TAB}${BOLD}${YW}${HOLD} ${msg}${CL}"
}

# Display info message with spinner
msg_info3() {
    local msg="$1"
    echo -ne "${TAB}${YW}${HOLD}${msg}${CL}"
}

# Display success message
msg_success() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${TAB}${BOLD}${BL}${HOLD}${msg}${CL}"
    echo -e ""
}


# Display title script
msg_title() {
    local msg="$1"
    echo -e "\n"
    echo -e "${TAB}${BOLD}${HOLD}${BOR}${msg}${BOR}${HOLD}${CL}"
    echo -e "\n"
}


# Display warning or highlighted information message
msg_warn() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${CL} ${YWB}${msg}${CL}"
}


# Display success message
msg_ok() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${CM}${GN}${msg}${CL}"
}

msg_ok2() {
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${CM}${GN}${msg}${CL}"
}


# Display error message
msg_error() {
    if [ -n "$SPINNER_PID" ] && ps -p $SPINNER_PID > /dev/null; then 
        kill $SPINNER_PID > /dev/null
    fi
    printf "\e[?25h"
    local msg="$1"
    echo -e "${BFR}${TAB}${RD}[ERROR] ${msg}${CL}"
}
    

# Initialize cache
initialize_cache() {
    if [[ "$LANGUAGE" != "en" ]]; then
        if [ ! -f "$CACHE_FILE" ]; then
            mkdir -p "$(dirname "$CACHE_FILE")"
            echo "{}" > "$CACHE_FILE"
        fi
    fi
}

# Load language
load_language() {
    LANGUAGE="en"
    if [ -f "$CONFIG_FILE" ]; then
        lang_candidate=$(jq -r '.language // empty' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$lang_candidate" && "$lang_candidate" != "null" ]]; then
            LANGUAGE="$lang_candidate"
        fi
    fi
}



########################################################



translate() {
    local text="$1"
    local dest_lang="$LANGUAGE"


    if [ "$dest_lang" = "en" ]; then
        echo "$text"
        return
    fi

    if [ ! -s "$CACHE_FILE" ] || ! jq -e . "$CACHE_FILE" > /dev/null 2>&1; then
        echo "{}" > "$CACHE_FILE"
    fi

    local cached_translation=$(jq -r --arg text "$text" --arg lang "$dest_lang" '.[$text][$lang] // .[$text]["notranslate"] // empty' "$CACHE_FILE")
    if [ -n "$cached_translation" ]; then
        echo "$cached_translation"
        return
    fi

    if [ ! -d "$VENV_PATH" ]; then
        echo "$text"
        return
    fi

    source "$VENV_PATH/bin/activate"
    local translated
    translated=$(python3 -c "
from googletrans import Translator
import sys, json, re

def translate_text(text, dest_lang, context):
    translator = Translator()
    try:
        full_text = context + ' ' + text
        result = translator.translate(full_text, dest=dest_lang).text
        translated = re.sub(r'^.*?(Translate:|Traducir:|Traduire:|Ãœbersetzen:|Tradurre:|Traduzir:|ç¿»è¯‘:|ç¿»è¨³:)', '', result, flags=re.IGNORECASE | re.DOTALL).strip()
        translated = re.sub(r'^.*?(Context:|Contexto:|Contexte:|Kontext:|Contesto:|ä¸Šä¸‹æ–‡ï¼š|ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼š).*?:', '', translated, flags=re.IGNORECASE | re.DOTALL).strip()
        print(json.dumps({'success': True, 'text': translated}))
    except Exception as e:
        print(json.dumps({'success': False, 'error': str(e)}))

translate_text(
    json.loads(sys.argv[1]),
    sys.argv[2],
    json.loads(sys.argv[3])
)
" "$(jq -Rn --arg t "$text" '$t')" "$dest_lang" "$(jq -Rn --arg ctx "$TRANSLATION_CONTEXT" '$ctx')")
    deactivate

    local translation_result=$(echo "$translated" | jq -r '.')
    local success=$(echo "$translation_result" | jq -r '.success')
    
    if [ "$success" = "true" ]; then
        translated=$(echo "$translation_result" | jq -r '.text')
        
        # Additional cleaning step
        translated=$(echo "$translated" | sed -E 's/^(Context:|Contexto:|Contexte:|Kontext:|Contesto:|ä¸Šä¸‹æ–‡ï¼š|ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆï¼š).*?(Translate:|Traducir:|Traduire:|Ãœbersetzen:|Tradurre:|Traduzir:|ç¿»è¯‘:|ç¿»è¨³:)//gI' | sed 's/^ *//; s/ *$//')
        
        # Only cache if the language is not English
        if [ "$dest_lang" != "en" ]; then
            local temp_cache=$(mktemp)
            jq --arg text "$text" --arg lang "$dest_lang" --arg translated "$translated" '
                if .[$text] == null then .[$text] = {} else . end |
                .[$text][$lang] = $translated
            ' "$CACHE_FILE" > "$temp_cache" && mv "$temp_cache" "$CACHE_FILE"
        fi
        
        echo "$translated"
    else
        local error=$(echo "$translation_result" | jq -r '.error')
        echo "$text"
    fi
}



########################################################




show_proxmenux_logo() {
clear

if [[ -z "$SSH_TTY" && -z "$(who am i | awk '{print $NF}' | grep -E '([0-9]{1,3}\.){3}[0-9]{1,3}')" ]]; then

# Logo for terminal noVNC

LOGO=$(cat << "EOF"
\e[0m\e[38;2;61;61;61mâ–†\e[38;2;60;60;60mâ–„\e[38;2;54;54;54mâ–‚\e[0m \e[38;2;0;0;0m             \e[0m \e[38;2;54;54;54mâ–‚\e[38;2;60;60;60mâ–„\e[38;2;61;61;61mâ–†\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[38;2;61;61;61;48;2;37;37;37mâ–‡\e[0m\e[38;2;60;60;60mâ–…\e[38;2;56;56;56mâ–ƒ\e[38;2;37;37;37mâ–       \e[38;2;36;36;36mâ–\e[38;2;56;56;56mâ–ƒ\e[38;2;60;60;60mâ–…\e[38;2;61;61;61;48;2;37;37;37mâ–‡\e[48;2;62;62;62m  \e[0m\e[7m\e[38;2;60;60;60mâ–\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[7m\e[38;2;61;61;61mâ–‚\e[0m\e[38;2;62;62;62;48;2;61;61;61mâ”ˆ\e[48;2;62;62;62m \e[48;2;61;61;61mâ”ˆ\e[0m\e[38;2;60;60;60mâ–†\e[38;2;57;57;57mâ–„\e[38;2;48;48;48mâ–‚\e[0m \e[38;2;47;47;47mâ–‚\e[38;2;57;57;57mâ–„\e[38;2;60;60;60mâ–†\e[38;2;62;62;62;48;2;61;61;61mâ”ˆ\e[48;2;62;62;62m \e[48;2;61;61;61mâ”ˆ\e[0m\e[7m\e[38;2;60;60;60mâ–‚\e[38;2;57;57;57mâ–„\e[38;2;47;47;47mâ–†\e[0m \e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[7m\e[38;2;39;39;39mâ–‡\e[38;2;57;57;57mâ–…\e[38;2;60;60;60mâ–ƒ\e[0m\e[38;2;40;40;40;48;2;61;61;61mâ–\e[48;2;62;62;62m  \e[38;2;54;54;54;48;2;61;61;61mâ”Š\e[48;2;62;62;62m  \e[38;2;39;39;39;48;2;61;61;61mâ–\e[0m\e[7m\e[38;2;60;60;60mâ–ƒ\e[38;2;57;57;57mâ–…\e[38;2;38;38;38mâ–‡\e[0m \e[38;2;193;60;2mâ–ƒ\e[38;2;217;67;2mâ–…\e[38;2;225;70;2mâ–‡\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[0m \e[38;2;203;63;2mâ–„\e[38;2;147;45;1mâ–‚\e[0m \e[7m\e[38;2;55;55;55mâ–†\e[38;2;60;60;60mâ–„\e[38;2;61;61;61mâ–‚\e[38;2;60;60;60mâ–„\e[38;2;55;55;55mâ–†\e[0m \e[38;2;144;44;1mâ–‚\e[38;2;202;62;2mâ–„\e[38;2;219;68;2mâ–†\e[38;2;231;72;3;48;2;226;70;2mâ”ˆ\e[48;2;231;72;3m  \e[48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[7m\e[38;2;121;37;1mâ–‰\e[0m\e[38;2;0;0;0;48;2;231;72;3m  \e[0m\e[38;2;221;68;2mâ–‡\e[38;2;208;64;2mâ–…\e[38;2;212;66;2mâ–‚\e[38;2;123;37;0mâ–\e[38;2;211;65;2mâ–‚\e[38;2;207;64;2mâ–…\e[38;2;220;68;2mâ–‡\e[48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ”ˆ\e[0m\e[7m\e[38;2;221;68;2mâ–‚\e[0m\e[38;2;44;13;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–\e[0m \e[7m\e[38;2;190;59;2mâ–…\e[38;2;216;67;2mâ–ƒ\e[38;2;225;70;2mâ–\e[0m\e[38;2;95;29;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;230;71;2mâ”ˆ\e[48;2;231;72;3m  \e[0m\e[7m\e[38;2;225;70;2mâ–\e[38;2;216;67;2mâ–ƒ\e[38;2;191;59;2mâ–…\e[0m  \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–   \e[0m \e[7m\e[38;2;172;53;1mâ–†\e[38;2;213;66;2mâ–„\e[38;2;219;68;2mâ–‚\e[38;2;213;66;2mâ–„\e[38;2;174;54;2mâ–†\e[0m \e[38;2;0;0;0m   \e[0m \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[38;2;59;59;59;48;2;62;62;62mâ–  \e[0m\e[38;2;32;32;32mâ–             \e[0m \e[38;2;0;0;0;48;2;231;72;3m  \e[38;2;231;72;3;48;2;225;70;2mâ–‰\e[0m
\e[7m\e[38;2;52;52;52mâ–†\e[38;2;59;59;59mâ–„\e[38;2;61;61;61mâ–‚\e[0m\e[38;2;31;31;31mâ–             \e[0m \e[7m\e[38;2;228;71;2mâ–‚\e[38;2;221;69;2mâ–„\e[38;2;196;60;2mâ–†\e[0m
EOF
)


TEXT=(
    ""
    ""
    "${BOLD}ProxMenux${RESET}"
    ""
    "${BOLD}${NEON_PURPLE_BLUE}An Interactive Menu for${RESET}"
    "${BOLD}${NEON_PURPLE_BLUE}Proxmox VE management${RESET}"
    ""
    ""
    ""
    ""
)


mapfile -t logo_lines <<< "$LOGO"

for i in {0..9}; do
    echo -e "${TAB}${logo_lines[i]}  ${WHITE}â”‚${RESET}  ${TEXT[i]}"
done
echo -e

else


# Logo for terminal SSH     
TEXT=(
    ""
    ""
    ""
    ""
    "${BOLD}ProxMenux${RESET}"
    ""
    "${BOLD}${NEON_PURPLE_BLUE}An Interactive Menu for${RESET}"
    "${BOLD}${NEON_PURPLE_BLUE}Proxmox VE management${RESET}"
    ""
    ""
    ""
    ""
    ""
    ""
)

LOGO=(
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     â–‘â–‘â–‘â–‘${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘â–‘â–‘â–‘               â–‘â–‘â–‘â–‘â–‘â–‘ ${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘       â–‘â–‘â–‘â–‘â–‘â–‘â–‘    ${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘    â–‘â–‘â–‘â–‘â–‘â–‘ â–‘â–‘â–‘â–‘â–‘â–‘      ${ORANGE}â–‘â–‘${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘       â–‘â–‘â–‘â–‘â–‘â–‘â–‘      ${ORANGE}â–‘â–‘â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘         â–‘â–‘â–‘     ${ORANGE}â–‘â–’â–’â–’â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘   ${ORANGE}â–’â–’â–’â–‘       â–‘â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘   ${ORANGE}â–‘â–’â–’â–’â–’â–’   â–’â–’â–’â–’â–’â–‘â–‘  â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘     ${ORANGE}â–‘â–‘â–’â–’â–’â–’â–’â–’â–’â–‘â–‘     â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘         ${ORANGE}â–‘â–‘â–‘         â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     ${ORANGE}â–’â–’â–’â–’${RESET}"
    "${DARK_GRAY}â–‘â–‘â–‘â–‘                     ${ORANGE}â–’â–’â–’â–‘${RESET}"
    "${DARK_GRAY}  â–‘â–‘                     ${ORANGE}â–‘â–‘  ${RESET}"
)

for i in {0..12}; do
    echo -e "${TAB}${LOGO[i]}  â”‚${RESET}  ${TEXT[i]}"
done
echo -e
fi

}


########################################################


ensure_components_status_file() {
  mkdir -p "$BASE_DIR"
  if [[ ! -f "$COMPONENTS_STATUS_FILE" ]] || ! jq empty "$COMPONENTS_STATUS_FILE" >/dev/null 2>&1; then
    echo '{}' > "$COMPONENTS_STATUS_FILE"
  fi
}

update_component_status() {
  local comp="$1"
  local stat="$2"
  local ver="$3"
  local category="$4"
  local extra_json="$5"
  if [ -z "$extra_json" ]; then
    extra_json="{}"
  fi

  ensure_components_status_file

  local ts
  ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  local tmp_file
  tmp_file=$(mktemp)

  if jq --arg comp "$comp" \
        --arg stat "$stat" \
        --arg ver "$ver" \
        --arg category "$category" \
        --arg time "$ts" \
        --argjson extra "$extra_json" \
        '.[$comp] = ({status:$stat, version:$ver, category:$category, timestamp:$time} + $extra)' \
        "$COMPONENTS_STATUS_FILE" > "$tmp_file" 2>/dev/null; then
    mv "$tmp_file" "$COMPONENTS_STATUS_FILE"
  else
    rm -f "$tmp_file"
    echo '{}' > "$COMPONENTS_STATUS_FILE"
  fi
}


# ============================================
# Hybrid Dialog Functions (Web/Terminal)
# ============================================

# Detect if running in web mode
is_web_mode() {
    [[ "$EXECUTION_MODE" == "web" ]]
}

# Generate unique interaction ID
generate_interaction_id() {
    echo "$(date +%s%N)_$$"
}

# Wait for web response with timeout
wait_for_web_response() {
    local interaction_id="$1"
    local response_file="/tmp/proxmenux_response_${interaction_id}"
    local timeout=300  # 5 minutes
    local elapsed=0
    
    while [[ ! -f "$response_file" ]] && [[ $elapsed -lt $timeout ]]; do
        sleep 0.1
        elapsed=$((elapsed + 1))
    done
    
    if [[ -f "$response_file" ]]; then
        cat "$response_file"
        rm -f "$response_file"
        return 0
    else
        echo ""
        return 1
    fi
}

# Hybrid menu function
hybrid_menu() {
    local title="$1"
    local text="$2"
    local height="${3:-20}"
    local width="${4:-70}"
    local menu_height="${5:-10}"
    shift 5
    local items=("$@")
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        local clean_text=$(echo -e "$text" | sed 's/\\Z[0-9bn]//g')
        local options_json="["
        for ((i=0; i<${#items[@]}; i+=2)); do
            if [ $i -gt 0 ]; then options_json+=","; fi
            options_json+="{\"value\":\"${items[i]}\",\"label\":\"${items[i+1]}\"}"
        done
        options_json+="]"
        
        echo "WEB_INTERACTION:menu:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$clean_text" | base64 -w0):$options_json" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        wait_for_web_response "$interaction_id"
    else
        dialog --colors --title "$title" --menu "$text" "$height" "$width" "$menu_height" "${items[@]}" 3>&1 1>&2 2>&3
    fi
}

# Hybrid yes/no prompt
hybrid_yesno() {
    local title="$1"
    local text="$2"
    local height="${3:-10}"
    local width="${4:-60}"
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        local clean_text=$(echo -e "$text" | sed 's/\\Z[0-9bn]//g')
        echo "WEB_INTERACTION:yesno:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$clean_text" | base64 -w0)" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        local response=$(wait_for_web_response "$interaction_id")
        [[ "$response" == "yes" ]] && return 0 || return 1
    else
        dialog --colors --title "$title" --yesno "$text" "$height" "$width"
    fi
}

# Hybrid message box
hybrid_msgbox() {
    local title="$1"
    local text="$2"
    local height="${3:-10}"
    local width="${4:-60}"
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        local clean_text=$(echo -e "$text" | sed 's/\\Z[0-9bn]//g')
        echo "WEB_INTERACTION:msgbox:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$clean_text" | base64 -w0)" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        wait_for_web_response "$interaction_id" > /dev/null
    else
        dialog --colors --title "$title" --msgbox "$text" "$height" "$width"
    fi
}

# Hybrid input box
hybrid_inputbox() {
    local title="$1"
    local text="$2"
    local height="${3:-10}"
    local width="${4:-60}"
    local default="${5:-}"
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        echo "WEB_INTERACTION:inputbox:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$text" | base64 -w0):$(echo -n "$default" | base64 -w0)" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        wait_for_web_response "$interaction_id"
    else
        dialog --title "$title" --inputbox "$text" "$height" "$width" "$default" 3>&1 1>&2 2>&3
    fi
}

# Hybrid whiptail menu (used during installation - doesn't hide terminal output)
hybrid_whiptail_menu() {
    local title="$1"
    local text="$2"
    local height="${3:-20}"
    local width="${4:-70}"
    local menu_height="${5:-10}"
    shift 5
    local items=("$@")
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        local options_json="["
        for ((i=0; i<${#items[@]}; i+=2)); do
            if [ $i -gt 0 ]; then options_json+=","; fi
            options_json+="{\"value\":\"${items[i]}\",\"label\":\"${items[i+1]}\"}"
        done
        options_json+="]"
        
        echo "WEB_INTERACTION:menu:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$text" | base64 -w0):$options_json" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        wait_for_web_response "$interaction_id"
    else
        whiptail --title "$title" --menu "$text" "$height" "$width" "$menu_height" "${items[@]}" 3>&1 1>&2 2>&3
    fi
}

# Hybrid whiptail yes/no (used during installation)
hybrid_whiptail_yesno() {
    local title="$1"
    local text="$2"
    local height="${3:-10}"
    local width="${4:-70}"
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        echo "WEB_INTERACTION:yesno:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$text" | base64 -w0)" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        local response=$(wait_for_web_response "$interaction_id")
        [[ "$response" == "yes" ]] && return 0 || return 1
    else
        whiptail --title "$title" --yesno "$text" "$height" "$width"
    fi
}

# Hybrid whiptail message box (used during installation)
hybrid_whiptail_msgbox() {
    local title="$1"
    local text="$2"
    local height="${3:-10}"
    local width="${4:-70}"
    
    if is_web_mode; then
        local interaction_id=$(generate_interaction_id)
        echo "WEB_INTERACTION:msgbox:${interaction_id}:$(echo -n "$title" | base64 -w0):$(echo -n "$text" | base64 -w0)" >> "${WEB_LOG:-/tmp/proxmenux_web.log}"
        wait_for_web_response "$interaction_id" > /dev/null
    else
        whiptail --title "$title" --msgbox "$text" "$height" "$width"
    fi
}


================================================
FILE: scripts/backup_restore/backup_host.sh
================================================
#!/usr/bin/env bash

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


get_external_backup_mount_point() {
    local BACKUP_MOUNT_FILE="/usr/local/share/proxmenux/last_backup_mount.txt"
    local STORAGE_REPO="$LOCAL_SCRIPTS/backup_restore"
    local MOUNT_POINT

    if [[ -f "$BACKUP_MOUNT_FILE" ]]; then
        MOUNT_POINT=$(head -n1 "$BACKUP_MOUNT_FILE" | tr -d '\r\n' | xargs)
        >&2 echo "DEBUG: Valor MOUNT_POINT='$MOUNT_POINT'"
        if [[ ! -d "$MOUNT_POINT" ]]; then
            msg_error "Mount point does not exist: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
        if ! mountpoint -q "$MOUNT_POINT"; then
            msg_error "Mount point is not mounted: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
 
        echo "$MOUNT_POINT"
        return 0
    else
        source "$STORAGE_REPO/mount_disk_host_bk.sh"
       MOUNT_POINT=$(mount_disk_host_bk)
        [[ -z "$MOUNT_POINT" ]] && msg_error "$(translate "No disk mounted.")" && return 1
        echo "$MOUNT_POINT"
        return 0
    fi
}



# === Host Backup Main Menu ===
host_backup_menu() {
    while true; do
        local CHOICE
        CHOICE=$(dialog --backtitle "ProxMenux" \
            --title "$(translate 'Host Backup')" \
            --menu "\n$(translate 'Select backup option:')" 22 70 12 \
            ""         "$(translate '--- FULL BACKUP ---')" \
            1 "$(translate 'Full backup to Proxmox Backup Server (PBS)')" \
            2 "$(translate 'Full backup with BorgBackup')" \
            3 "$(translate 'Full backup to local .tar.gz')" \
            ""         "$(translate '--- CUSTOM BACKUP ---')" \
            4 "$(translate 'Custom backup to PBS')" \
            5 "$(translate 'Custom backup with BorgBackup')" \
            6 "$(translate 'Custom backup to local .tar.gz')" \
            0 "$(translate 'Return')" \
            3>&1 1>&2 2>&3) || return 0

        case "$CHOICE" in
            1) backup_full_pbs_root ;;
            2) backup_with_borg "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            3) backup_to_local_tar "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            4) custom_backup_menu backup_to_pbs ;;
            5) custom_backup_menu backup_with_borg ;;
            6) custom_backup_menu backup_to_local_tar ;;
            0) break ;;
        esac
    done
}



# === Menu checklist for custom backup ===
custom_backup_menu() {
    declare -A BACKUP_PATHS=(
        [etc-pve]="/etc/pve"
        [etc-network]="/etc/network"
        [var-lib-pve-cluster]="/var/lib/pve-cluster"
        [root-dir]="/root"
        [etc-ssh]="/etc/ssh"
        [home]="/home"
        [local-bin]="/usr/local/bin"
        [cron]="/etc/cron.d"
        [custom-systemd]="/etc/systemd/system"
        [var-lib-vz]="/var/lib/vz"
    )
    local CHECKLIST_OPTIONS=()
    for KEY in "${!BACKUP_PATHS[@]}"; do
        DIR="${BACKUP_PATHS[$KEY]}"
        CHECKLIST_OPTIONS+=("$KEY" "$DIR" "off")
    done

    SELECTED_KEYS=$(dialog --separate-output --checklist \
        "$(translate 'Select directories to backup:')" 22 70 12 \
        "${CHECKLIST_OPTIONS[@]}" \
        3>&1 1>&2 2>&3) || return 1

    local BACKUP_DIRS=()
    for KEY in $SELECTED_KEYS; do
        BACKUP_DIRS+=("${BACKUP_PATHS[$KEY]}")
    done


#    "$1" "${BACKUP_DIRS[*]}"
     "$1" "${BACKUP_DIRS[@]}"


}


# === Configure PBS  ===
configure_pbs_repository() {
    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_MANUAL_CONFIGS="/usr/local/share/proxmenux/pbs-manual-configs.txt"
    

    [[ ! -f "$PBS_MANUAL_CONFIGS" ]] && touch "$PBS_MANUAL_CONFIGS"
    
    local PBS_CONFIGS=()
    local PBS_SOURCES=()  
    

    if [[ -f "/etc/pve/storage.cfg" ]]; then
        local current_pbs="" server="" datastore="" username=""
        
        while IFS= read -r line; do
            if [[ $line =~ ^pbs:\ (.+)$ ]]; then
                if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
                    PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                    PBS_SOURCES+=("proxmox|$current_pbs")
                fi
                current_pbs="${BASH_REMATCH[1]}"
                server="" datastore="" username=""
            elif [[ -n "$current_pbs" ]]; then
                if [[ $line =~ ^[[:space:]]*server[[:space:]]+(.+)$ ]]; then
                    server="${BASH_REMATCH[1]}"
                elif [[ $line =~ ^[[:space:]]*datastore[[:space:]]+(.+)$ ]]; then
                    datastore="${BASH_REMATCH[1]}"
                elif [[ $line =~ ^[[:space:]]*username[[:space:]]+(.+)$ ]]; then
                    username="${BASH_REMATCH[1]}"
                elif [[ $line =~ ^[a-zA-Z]+: ]]; then
                    if [[ -n "$server" && -n "$datastore" && -n "$username" ]]; then
                        PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                        PBS_SOURCES+=("proxmox|$current_pbs")
                    fi
                    current_pbs=""
                fi
            fi
        done < "/etc/pve/storage.cfg"
        

        if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
            PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
            PBS_SOURCES+=("proxmox|$current_pbs")
        fi
    fi
    

    if [[ -f "$PBS_MANUAL_CONFIGS" ]]; then
        while IFS= read -r line; do
            if [[ -n "$line" ]]; then
                PBS_CONFIGS+=("$line")
                local name="${line%%|*}"
                PBS_SOURCES+=("manual|$name")
            fi
        done < "$PBS_MANUAL_CONFIGS"
    fi
    

    local menu_options=()
    local i=1
    

    for j in "${!PBS_CONFIGS[@]}"; do
        local config="${PBS_CONFIGS[$j]}"
        local source="${PBS_SOURCES[$j]}"
        local name="${config%%|*}"
        local repo="${config##*|}"
        local source_type="${source%%|*}"


        if [[ "$source_type" == "proxmox" ]]; then
            menu_options+=("$i" " $name ($repo) [Proxmox]")
        else
            menu_options+=("$i" " $name ($repo) [Manual]")
        fi
        ((i++))
    done


    menu_options+=("" "")
    menu_options+=("$i" "\Z4\Zb $(translate 'Configure new PBS')\Zn")
    local choice
    choice=$(dialog --colors --backtitle "ProxMenux" --title "PBS Server Selection" \
    --menu "\n$(translate 'Select PBS server for this backup:')" 22 70 12 "${menu_options[@]}" 3>&1 1>&2 2>&3)
    local dialog_result=$?
    clear


    if [[ $dialog_result -ne 0 ]]; then
        return 1
    fi
    

    if [[ $choice -eq $i ]]; then
        configure_pbs_manually
    else

        local selected_config="${PBS_CONFIGS[$((choice-1))]}"
        local selected_source="${PBS_SOURCES[$((choice-1))]}"
        local pbs_name="${selected_config%%|*}"
        local source_type="${selected_source%%|*}"
        PBS_REPO="${selected_config##*|}"
        

        {
            mkdir -p "$(dirname "$PBS_REPO_FILE")"
            echo "$PBS_REPO" > "$PBS_REPO_FILE"
        } >/dev/null 2>&1
        

        local password_found=false
        if [[ "$source_type" == "proxmox" ]]; then

            local password_file="/etc/pve/priv/storage/${pbs_name}.pw"
            if [[ -f "$password_file" ]]; then
                {
                    cp "$password_file" "$PBS_PASS_FILE"
                    chmod 600 "$PBS_PASS_FILE"
                } >/dev/null 2>&1
                password_found=true

            fi
        else

            local manual_pass_file="/usr/local/share/proxmenux/pbs-pass-${pbs_name}.txt"
            if [[ -f "$manual_pass_file" ]]; then
                {
                    cp "$manual_pass_file" "$PBS_PASS_FILE"
                    chmod 600 "$PBS_PASS_FILE"
                } >/dev/null 2>&1
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using manual PBS:') $pbs_name\n\n$(translate 'Repository:') $PBS_REPO\n$(translate 'Password:') $(translate 'Previously saved')" 12 80
            fi
        fi
        

        if ! $password_found; then
            dialog --backtitle "ProxMenux" --title "Password Required" --msgbox "$(translate 'Password not found for:') $pbs_name\n$(translate 'Please enter the password.')" 10 60
            get_pbs_password "$pbs_name"
        fi
        
        clear
    fi
}


configure_pbs_manually() {
    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_MANUAL_CONFIGS="/usr/local/share/proxmenux/pbs-manual-configs.txt"
    

    local PBS_NAME
    PBS_NAME=$(dialog --backtitle "ProxMenux" --title "New PBS Configuration" --inputbox "$(translate 'Enter a name for this PBS configuration:')" 10 60 "PBS-$(date +%m%d)" 3>&1 1>&2 2>&3) || return 1
    
    PBS_USER=$(dialog --backtitle "ProxMenux" --title "New PBS Configuration" --inputbox "$(translate 'Enter PBS username:')" 10 50 "root@pam" 3>&1 1>&2 2>&3) || return 1
    PBS_HOST=$(dialog --backtitle "ProxMenux" --title "New PBS Configuration" --inputbox "$(translate 'Enter PBS host or IP:')" 10 50 "" 3>&1 1>&2 2>&3) || return 1
    PBS_DATASTORE=$(dialog --backtitle "ProxMenux" --title "New PBS Configuration" --inputbox "$(translate 'Enter PBS datastore name:')" 10 50 "" 3>&1 1>&2 2>&3) || return 1
    

    if [[ -z "$PBS_NAME" || -z "$PBS_USER" || -z "$PBS_HOST" || -z "$PBS_DATASTORE" ]]; then
        dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'All fields are required!')" 8 40
        return 1
    fi
    
    PBS_REPO="${PBS_USER}@${PBS_HOST}:${PBS_DATASTORE}"
    
 
    {
        mkdir -p "$(dirname "$PBS_REPO_FILE")"
        echo "$PBS_REPO" > "$PBS_REPO_FILE"
    } >/dev/null 2>&1
    

    local config_line="$PBS_NAME|$PBS_REPO"
    if ! grep -Fxq "$config_line" "$PBS_MANUAL_CONFIGS" 2>/dev/null; then
        echo "$config_line" >> "$PBS_MANUAL_CONFIGS"
    fi
    

    get_pbs_password "$PBS_NAME"
    
    dialog --backtitle "ProxMenux" --title "Success" --msgbox "$(translate 'PBS configuration saved:') $PBS_NAME\n\n$(translate 'Repository:') $PBS_REPO\n\n$(translate 'This configuration will appear in future backups.')" 12 80
}


get_pbs_password() {
    local PBS_NAME="$1"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_MANUAL_PASS_FILE="/usr/local/share/proxmenux/pbs-pass-${PBS_NAME}.txt"
    
    while true; do
        PBS_REPO_PASS=$(dialog --backtitle "ProxMenux" --title "PBS Password" --insecure --passwordbox "$(translate 'Enter PBS repository password for:') $PBS_NAME" 10 70 "" 3>&1 1>&2 2>&3) || return 1
        PBS_REPO_PASS2=$(dialog --backtitle "ProxMenux" --title "PBS Password" --insecure --passwordbox "$(translate 'Confirm PBS repository password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        
        if [[ "$PBS_REPO_PASS" == "$PBS_REPO_PASS2" ]]; then
            break
        else
            dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Repository passwords do not match! Please try again.')" 8 50
        fi
    done
    

    {
        echo "$PBS_REPO_PASS" > "$PBS_PASS_FILE"
        chmod 600 "$PBS_PASS_FILE"
    } >/dev/null 2>&1
    

    {
        echo "$PBS_REPO_PASS" > "$PBS_MANUAL_PASS_FILE"
        chmod 600 "$PBS_MANUAL_PASS_FILE"
    } >/dev/null 2>&1
}

# ===============================








# ========== PBS BACKUP ==========
backup_full_pbs_root() {
    local HOSTNAME PBS_REPO PBS_KEY_FILE PBS_PASS_FILE PBS_ENCRYPTION_PASS_FILE ENCRYPT_OPT=""
    HOSTNAME=$(hostname)
    

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    LOGFILE="/tmp/pbs-backup-${HOSTNAME}.log"

  
    configure_pbs_repository
    if [[ ! -f "$PBS_REPO_FILE" ]]; then
        msg_error "$(translate "Failed to configure PBS connection")"
        sleep 3
        return 1
    fi
    PBS_REPO=$(<"$PBS_REPO_FILE")


    if [[ ! -f "$PBS_PASS_FILE" ]]; then
        msg_error "$(translate "PBS password not configured")"
        sleep 3
        return 1
    fi


    dialog --backtitle "ProxMenux" --title "Encryption" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then

        if [[ ! -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
            while true; do
                PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 12 70 "" 3>&1 1>&2 2>&3) || return 1
                PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                fi
            done


            {
                echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
            } >/dev/null 2>&1
            
            dialog --backtitle "ProxMenux" --title "Success" --msgbox "$(translate 'Encryption password saved successfully!')" 8 50
        fi
        

        if [[ ! -f "$PBS_KEY_FILE" ]]; then
            PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
            
            dialog --backtitle "ProxMenux" --title "Encryption" --infobox "$(translate 'Creating encryption key...')" 5 50
            
            expect -c "
            set timeout 30
            spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
            expect {
                \"Encryption Key Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                \"Verify Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                eof
            }
            " >/dev/null 2>&1

            if [[ ! -f "$PBS_KEY_FILE" ]]; then
                dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                return 1
            fi
            
            dialog --backtitle "ProxMenux" --title "Important" --msgbox "$(translate 'IMPORTANT: Save the key file. Without it you will not be able to restore your backups!')\n\n$(translate 'Key file location:') $PBS_KEY_FILE" 12 70
        fi
        ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
    else
        ENCRYPT_OPT=""
    fi

    
    clear
    show_proxmenux_logo
    echo -e
    msg_info2 "$(translate "Starting backup to PBS")"
    echo -e
    echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
    echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
    echo -e "${BL}$(translate "Included:")${WHITE} /boot/efi /etc/pve (all root)${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
    echo -e "${BL}$(translate "Log file:")${WHITE} $LOGFILE${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
    echo ""


    PBS_REPO_PASS=$(<"$PBS_PASS_FILE")
    
    if [[ -n "$ENCRYPT_OPT" ]]; then

        PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
        echo "$(translate "Starting encrypted full backup...")"
        echo ""
        
        expect -c "
        set timeout 3600
        log_file $LOGFILE
        spawn proxmox-backup-client backup \
            --include-dev /boot/efi \
            --include-dev /etc/pve \
            root-${HOSTNAME}.pxar:/ \
            --repository \"$PBS_REPO\" \
            $ENCRYPT_OPT \
            --backup-type host \
            --backup-id \"$HOSTNAME\" \
            --backup-time \"$(date +%s)\"
        expect {
            -re \"Password for .*:\" {
                send \"$PBS_REPO_PASS\r\"
                exp_continue
            }
            \"Encryption Key Password:\" {
                send \"$PBS_ENCRYPTION_PASS\r\"
                exp_continue
            }
            eof
        }
        " | tee -a "$LOGFILE"
    else

        echo "$(translate "Starting unencrypted full backup...")"
        echo ""
        
        expect -c "
        set timeout 3600
        log_file $LOGFILE
        spawn proxmox-backup-client backup \
            --include-dev /boot/efi \
            --include-dev /etc/pve \
            root-${HOSTNAME}.pxar:/ \
            --repository \"$PBS_REPO\" \
            --backup-type host \
            --backup-id \"$HOSTNAME\" \
            --backup-time \"$(date +%s)\"
        expect {
            -re \"Password for .*:\" {
                send \"$PBS_REPO_PASS\r\"
                exp_continue
            }
            eof
        }
        " | tee -a "$LOGFILE"
    fi
    local backup_result=$?

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    if [[ $backup_result -eq 0 ]]; then
        msg_ok "$(translate "Full backup process completed successfully")"
    else
        msg_error "$(translate "Backup process finished with errors")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}




backup_to_pbs() {
    local HOSTNAME TIMESTAMP SNAPSHOT
    HOSTNAME=$(hostname)
    TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
    SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    local PBS_REPO ENCRYPT_OPT USE_ENCRYPTION
    local PBS_KEY_PASS PBS_REPO_PASS


    configure_pbs_repository
    PBS_REPO=$(<"$PBS_REPO_FILE")


    USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    [[ $? -eq 0 ]] && USE_ENCRYPTION=true


    if $USE_ENCRYPTION && ! command -v expect >/dev/null 2>&1; then
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y expect >/dev/null 2>&1
    fi

    if [[ "$#" -lt 1 ]]; then
        clear
        show_proxmenux_logo
        msg_error "$(translate "No directories specified for backup.")"
        sleep 2 
        return 1
    fi

    local TOTAL="$#"
    local COUNT=1

    for dir in "$@"; do
        local SAFE_NAME SAFE_ID PXAR_NAME
        SAFE_NAME=$(basename "$dir" | tr '.-/' '_')
        PXAR_NAME="root-custom-${SAFE_NAME}-${SNAPSHOT}.pxar"
        SAFE_ID="custom-${HOSTNAME}-${SAFE_NAME}"

        msg_info2 "$(translate "[$COUNT/$TOTAL] Backing up") $dir $(translate "as") $PXAR_NAME"

        ENCRYPT_OPT=""


        if $USE_ENCRYPTION; then
            if [[ -f "$PBS_KEY_FILE" ]]; then
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
            else

                while true; do
                    PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                    fi
                done


                {
                    echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                    chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
                } >/dev/null 2>&1


                expect -c "
                set timeout 30
                spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    \"Verify Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " >/dev/null 2>&1

                if [[ ! -f "$PBS_KEY_FILE" ]]; then
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                    return 1
                fi
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
                dialog --backtitle "ProxMenux" --msgbox "$(translate 'Encryption key generated. Save it in a safe place!')" 10 60
            fi
        fi

        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Starting backup to PBS")"
        TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
        TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")
        echo -e
        echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
        echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
        echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
        echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
        echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"

        PBS_REPO_PASS=$(<"$PBS_PASS_FILE")
        
        if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
            PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
            expect -c "
            set timeout 300
            spawn proxmox-backup-client backup \"${PXAR_NAME}:$dir\" --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$SAFE_ID\" --backup-time \"$(date +%s)\"
            expect {
                -re \"Password for .*:\" {
                    send \"$PBS_REPO_PASS\r\"
                    exp_continue
                }
                \"Encryption Key Password:\" {
                    send \"$PBS_KEY_PASS\r\"
                    exp_continue
                }
                eof
            }
            "
        else

            expect -c "
            set timeout 300
            spawn proxmox-backup-client backup \"${PXAR_NAME}:$dir\" --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$SAFE_ID\" --backup-time \"$(date +%s)\"
            expect {
                -re \"Password for .*:\" {
                    send \"$PBS_REPO_PASS\r\"
                    exp_continue
                }
                eof
            }
            "
        fi

        COUNT=$((COUNT+1))
    done

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r


}
# ===============================



# ========== BORGBACKUP ==========
backup_with_borg() {
#    local SRC="$1"
    local BORG_APPIMAGE="/usr/local/share/proxmenux/borg"
    local LOGFILE="/tmp/borg-backup.log"
    local DEST
    local TYPE
    local ENCRYPT_OPT=""
    local BORG_KEY

    if [[ ! -x "$BORG_APPIMAGE" ]]; then
        clear
        show_proxmenux_logo
        msg_info "$(translate "BorgBackup not found. Downloading AppImage...")"
        mkdir -p /usr/local/share/proxmenux
        wget -qO "$BORG_APPIMAGE" "https://github.com/borgbackup/borg/releases/download/1.2.8/borg-linux64"
        chmod +x "$BORG_APPIMAGE"
        msg_ok "$(translate "BorgBackup downloaded and ready.")"
    fi


    TYPE=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select Borg backup destination:')" 15 60 3 \
        "local"   "$(translate 'Local directory')" \
        "usb"     "$(translate 'Internal/External dedicated disk')" \
        "remote"  "$(translate 'Remote server')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter local directory for backup:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        mkdir -p "$DEST"
    elif [[ "$TYPE" == "usb" ]]; then

    while true; do
        BASE_DEST=$(get_external_backup_mount_point)
        if [[ -z "$BASE_DEST" ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'No external disk detected or mounted. Would you like to retry?')" 8 60
            [[ $? -eq 0 ]] && continue
            return 1
        fi

        DEST="$BASE_DEST/borgbackup"
        mkdir -p "$DEST"

        DISK_DEV=$(df "$BASE_DEST" | awk 'NR==2{print $1}')
        PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
        [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
        if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
            DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
        else
            DISK_MODEL="(unknown)"
        fi
        FREE_SPACE=$(df -h "$BASE_DEST" | awk 'NR==2{print $4}')

            dialog --backtitle "ProxMenux" \
                --title "$(translate "Dedicated Backup Disk")" \
                --yesno "\n$(translate "Mount point:") $DEST\n\n\
        $(translate "Disk model:") $DISK_MODEL\n\
        $(translate "Available space:") $FREE_SPACE\n\n\
        $(translate "Use this disk for backup?")" 12 70

        if [[ $? -eq 0 ]]; then
            break
        else
            return 1
        fi
    done


    elif [[ "$TYPE" == "remote" ]]; then
        REMOTE_USER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH user for remote:')" 10 60 "root" 3>&1 1>&2 2>&3) || return 1
        REMOTE_HOST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH host:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        REMOTE_PATH=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter remote path:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        DEST="ssh://$REMOTE_USER@$REMOTE_HOST:$REMOTE_PATH"
    fi


    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then
        BORG_KEY=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter Borg encryption passphrase (will be saved):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        ENCRYPT_OPT="--encryption=repokey"
        export BORG_PASSPHRASE="$BORG_KEY"
    else
        ENCRYPT_OPT="--encryption=none"
    fi

    if [[ "$TYPE" == "local" || "$TYPE" == "usb" ]]; then
        if [[ ! -f "$DEST/config" ]]; then
            "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
            if [[ $? -ne 0 ]]; then
                clear
                show_proxmenux_logo
                msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                sleep 5
                return 1
            fi
        fi
    fi


    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Borg backup will start now. This may take a while.')" 8 40

    clear
    show_proxmenux_logo
    msg_info2 "$(translate "Starting backup with BorgBackup...")"
    echo -e

    TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
    TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

    echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
    echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"


    # 6. Lanzar el backup y guardar log
#    "$BORG_APPIMAGE" create --progress "$DEST"::"root-$(hostname)-$(date +%Y%m%d_%H%M)" $SRC 2>&1 | tee "$LOGFILE"

    "$BORG_APPIMAGE" create --progress "$DEST"::"root-$(hostname)-$(date +%Y%m%d_%H%M)" "$@" 2>&1 | tee "$LOGFILE"

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================




# ========== LOCAL TAR ==========
backup_to_local_tar() {
#    local SRC="$1"
    local TYPE
    local DEST
    local LOGFILE="/tmp/tar-backup.log"


if ! command -v pv &>/dev/null; then
    apt-get update -qq && apt-get install -y pv >/dev/null 2>&1
fi



    TYPE=$(dialog --backtitle "ProxMenux"  --menu "$(translate 'Select backup destination:')" 15 60 2 \
        "local" "$(translate 'Local directory')" \
        "usb"   "$(translate 'Internal/External dedicated disk')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter directory for backup:')" 10 60 "/backup" 3>&1 1>&2 2>&3) || return 1

        mkdir -p "$DEST"


else


while true; do
    DEST=$(get_external_backup_mount_point)
    if [[ -z "$DEST" ]]; then
        dialog --backtitle "ProxMenux" --yesno "No external disk detected or mounted. Would you like to retry?" 8 60
        [[ $? -eq 0 ]] && continue
        return 1
    fi

    DISK_DEV=$(df "$DEST" | awk 'NR==2{print $1}')
    PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
    [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
    if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
        DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
    else
        DISK_MODEL="(unknown)"
    fi
    FREE_SPACE=$(df -h "$DEST" | awk 'NR==2{print $4}')



    dialog --backtitle "ProxMenux" \
    --title "$(translate "Dedicated Backup Disk")" \
    --yesno "\n$(translate "Mount point:") $DEST\n\n\
    $(translate "Disk model:") $DISK_MODEL\n\
    $(translate "Available space:") $FREE_SPACE\n\n\
    $(translate "Use this disk for backup?")" 12 70


    if [[ $? -eq 0 ]]; then
        mkdir -p "$DEST"
        break
    else
        return 1
    fi
done



fi


TAR_INPUT=""
TOTAL_SIZE=0
for src in $SRC; do
    sz=$(du -sb "$src" 2>/dev/null | awk '{print $1}')
    TOTAL_SIZE=$((TOTAL_SIZE + sz))
    TAR_INPUT="$TAR_INPUT $src"
done

local FILENAME="root-$(hostname)-$(date +%Y%m%d_%H%M).tar.gz"
clear
show_proxmenux_logo
msg_info2 "$(translate "Starting backup with tar...")"
echo -e


TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"

tar -cf - "$@" 2> >(grep -v "Removing leading \`/'" >&2) \
| pv -s "$TOTAL_SIZE" \
| gzip > "$DEST/$FILENAME"


echo -ne "\033[1A\r\033[K"

echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
msg_ok "$(translate "Backup process finished. Review log above or in /tmp/tar-backup.log")"
echo
msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

}
# ===============================


host_backup_menu


================================================
FILE: scripts/backup_restore/backup_host2.sh
================================================
#!/usr/bin/env bash

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


get_external_backup_mount_point() {
    local BACKUP_MOUNT_FILE="/usr/local/share/proxmenux/last_backup_mount.txt"
    local STORAGE_REPO="$LOCAL_SCRIPTS/backup_restore"
    local MOUNT_POINT

    if [[ -f "$BACKUP_MOUNT_FILE" ]]; then
        MOUNT_POINT=$(head -n1 "$BACKUP_MOUNT_FILE" | tr -d '\r\n' | xargs)
        >&2 echo "DEBUG: Valor MOUNT_POINT='$MOUNT_POINT'"
        if [[ ! -d "$MOUNT_POINT" ]]; then
            msg_error "Mount point does not exist: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
        if ! mountpoint -q "$MOUNT_POINT"; then
            msg_error "Mount point is not mounted: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
 
        echo "$MOUNT_POINT"
        return 0
    else
       source "$STORAGE_REPO/mount_disk_host_bk.sh"
       MOUNT_POINT=$(mount_disk_host_bk)
        [[ -z "$MOUNT_POINT" ]] && msg_error "$(translate "No disk mounted.")" && return 1
        echo "$MOUNT_POINT"
        return 0
    fi
}



# === Host Backup Main Menu ===
host_backup_menu() {
    while true; do
        local CHOICE
        CHOICE=$(dialog --backtitle "ProxMenux" \
            --title "$(translate 'Host Backup')" \
            --menu "\n$(translate 'Select backup option:')" 22 70 12 \
            ""         "$(translate '--- FULL BACKUP ---')" \
            1 "$(translate 'Full backup to Proxmox Backup Server (PBS)')" \
            2 "$(translate 'Full backup with BorgBackup')" \
            3 "$(translate 'Full backup to local .tar.gz')" \
            ""         "$(translate '--- CUSTOM BACKUP ---')" \
            4 "$(translate 'Custom backup to PBS')" \
            5 "$(translate 'Custom backup with BorgBackup')" \
            6 "$(translate 'Custom backup to local .tar.gz')" \
            0 "$(translate 'Return')" \
            3>&1 1>&2 2>&3) || return 0

        case "$CHOICE" in
            1) backup_full_pbs_root ;;
            2) backup_with_borg "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            3) backup_to_local_tar "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            4) custom_backup_menu backup_to_pbs ;;
            5) custom_backup_menu backup_with_borg ;;
            6) custom_backup_menu backup_to_local_tar ;;
            0) break ;;
        esac
    done
}



# === Menu checklist for custom backup ===
custom_backup_menu() {
    declare -A BACKUP_PATHS=(
        [etc-pve]="/etc/pve"
        [etc-network]="/etc/network"
        [var-lib-pve-cluster]="/var/lib/pve-cluster"
        [root-dir]="/root"
        [etc-ssh]="/etc/ssh"
        [home]="/home"
        [local-bin]="/usr/local/bin"
        [cron]="/etc/cron.d"
        [custom-systemd]="/etc/systemd/system"
        [var-lib-vz]="/var/lib/vz"
    )
    local CHECKLIST_OPTIONS=()
    for KEY in "${!BACKUP_PATHS[@]}"; do
        DIR="${BACKUP_PATHS[$KEY]}"
        CHECKLIST_OPTIONS+=("$KEY" "$DIR" "off")
    done

    SELECTED_KEYS=$(dialog --separate-output --checklist \
        "$(translate 'Select directories to backup:')" 22 70 12 \
        "${CHECKLIST_OPTIONS[@]}" \
        3>&1 1>&2 2>&3) || return 1

    local BACKUP_DIRS=()
    for KEY in $SELECTED_KEYS; do
        BACKUP_DIRS+=("${BACKUP_PATHS[$KEY]}")
    done


#    "$1" "${BACKUP_DIRS[*]}"
     "$1" "${BACKUP_DIRS[@]}"


}











configure_pbs_repository() {
local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
local PBS_MANUAL_CONFIGS="/usr/local/share/proxmenux/pbs-manual-configs.txt"

[[ ! -f "$PBS_MANUAL_CONFIGS" ]] && touch "$PBS_MANUAL_CONFIGS"

local PBS_CONFIGS=()
local PBS_SOURCES=()
local PBS_USERNAMES=()

if [[ -f "/etc/pve/storage.cfg" ]]; then
    local current_pbs="" server="" datastore="" username=""
    
    while IFS= read -r line; do
        if [[ $line =~ ^pbs:\ (.+)$ ]]; then
            if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
                PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                PBS_SOURCES+=("proxmox|$current_pbs")
                PBS_USERNAMES+=("$username")
            fi
            current_pbs="${BASH_REMATCH[1]}"
            server="" datastore="" username=""
        elif [[ -n "$current_pbs" ]]; then
            if [[ $line =~ ^[[:space:]]*server[[:space:]]+(.+)$ ]]; then
                server="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*datastore[[:space:]]+(.+)$ ]]; then
                datastore="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*username[[:space:]]+(.+)$ ]]; then
                username="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[a-zA-Z]+: ]]; then
                if [[ -n "$server" && -n "$datastore" && -n "$username" ]]; then
                    PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                    PBS_SOURCES+=("proxmox|$current_pbs")
                    PBS_USERNAMES+=("$username")
                fi
                current_pbs=""
            fi
        fi
    done < "/etc/pve/storage.cfg"
    
    if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
        PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
        PBS_SOURCES+=("proxmox|$current_pbs")
        PBS_USERNAMES+=("$username")
    fi
fi

if [[ -f "$PBS_MANUAL_CONFIGS" ]]; then
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            PBS_CONFIGS+=("$line")
            local name="${line%%|*}"
            PBS_SOURCES+=("manual|$name")
            PBS_USERNAMES+=("")
        fi
    done < "$PBS_MANUAL_CONFIGS"
fi

local menu_options=()
local i=1

for j in "${!PBS_CONFIGS[@]}"; do
    local config="${PBS_CONFIGS[$j]}"
    local source="${PBS_SOURCES[$j]}"
    local name="${config%%|*}"
    local repo="${config##*|}"
    local source_type="${source%%|*}"

    if [[ "$source_type" == "proxmox" ]]; then
        menu_options+=("$i" " $name ($repo) [Proxmox]")
    else
        menu_options+=("$i" " $name ($repo) [Manual]")
    fi
    ((i++))
done

menu_options+=("" "")
menu_options+=("$i" "\Z4\Zb $(translate 'Configure new PBS')\Zn")
local choice
choice=$(dialog --colors --backtitle "ProxMenux" --title "PBS Server Selection" \
--menu "$(translate 'Select PBS server for this backup:')" 22 70 12 "${menu_options[@]}" 3>&1 1>&2 2>&3) || return 1

if [[ $choice -eq $i ]]; then
    configure_pbs_manually || return 1
else
    local selected_config="${PBS_CONFIGS[$((choice-1))]}"
    local selected_source="${PBS_SOURCES[$((choice-1))]}"
    local selected_username="${PBS_USERNAMES[$((choice-1))]}"
    local pbs_name="${selected_config%%|*}"
    local source_type="${selected_source%%|*}"
    PBS_REPO="${selected_config##*|}"
    
    {
        mkdir -p "$(dirname "$PBS_REPO_FILE")"
        echo "$PBS_REPO" > "$PBS_REPO_FILE"
    } >/dev/null 2>&1
    
    local password_found=false
    if [[ "$source_type" == "proxmox" ]]; then
        local password_file="/etc/pve/priv/storage/${pbs_name}.pw"
        
        if [[ -f "$password_file" ]]; then
            local auth_content
            auth_content=$(<"$password_file")
            

            [[ -f "$PBS_PASS_FILE" ]] && rm "$PBS_PASS_FILE"
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            

            if [[ "$selected_username" == *"@pbs!"* ]]; then

                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') PBS Cloud Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
                local full_token="${selected_username}:${auth_content}"
                echo "$full_token" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" == *":"* ]]; then
                echo "$auth_content" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token (Complete)" 12 80
            else
                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') Password" 12 80
            fi
        fi
    else
        local manual_pass_file="/usr/local/share/proxmenux/pbs-pass-${pbs_name}.txt"
        if [[ -f "$manual_pass_file" ]]; then
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            
            {
                cp "$manual_pass_file" "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
            } >/dev/null 2>&1
            password_found=true
            dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using manual PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Password:') $(translate 'Previously saved')" 12 80
        fi
    fi
    
    if ! $password_found; then
        dialog --backtitle "ProxMenux" --title "Password Required" --msgbox "$(translate 'Password not found for:') $pbs_name
$(translate 'Please enter the password.')" 10 60
        get_pbs_password "$pbs_name" || return 1
    fi
    
    clear
fi
}










# ========== PBS BACKUP ==========
backup_full_pbs_root() {
    local HOSTNAME PBS_REPO PBS_KEY_FILE PBS_PASS_FILE PBS_TOKEN_FILE PBS_ENCRYPTION_PASS_FILE ENCRYPT_OPT=""
    HOSTNAME=$(hostname)
    

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    LOGFILE="/tmp/pbs-backup-${HOSTNAME}.log"


    configure_pbs_repository || return 1

    if [[ ! -f "$PBS_REPO_FILE" ]]; then
        msg_error "$(translate "Failed to configure PBS connection")"
        sleep 3
        return 1
    fi
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        sleep 3
        return 1
    fi

  
    dialog --backtitle "ProxMenux" --title "Encryption" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then

        if [[ ! -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
            while true; do
                PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 12 70 "" 3>&1 1>&2 2>&3) || return 1
                PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                fi
            done


            {
                echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
            } >/dev/null 2>&1
            
            dialog --backtitle "ProxMenux" --title "Success" --msgbox "$(translate 'Encryption password saved successfully!')" 8 50
        fi
        

        if [[ ! -f "$PBS_KEY_FILE" ]]; then
            PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
            
            dialog --backtitle "ProxMenux" --title "Encryption" --infobox "$(translate 'Creating encryption key...')" 5 50
            
            expect -c "
            set timeout 30
            spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
            expect {
                \"Encryption Key Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                \"Verify Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                eof
            }
            " >/dev/null 2>&1

            if [[ ! -f "$PBS_KEY_FILE" ]]; then
                dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                return 1
            fi
            
            dialog --backtitle "ProxMenux" --title "Important" --msgbox "$(translate 'IMPORTANT: Save the key file. Without it you will not be able to restore your backups!')\n\n$(translate 'Key file location:') $PBS_KEY_FILE" 12 70
        fi
        ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
    else
        ENCRYPT_OPT=""
    fi


    clear
    show_proxmenux_logo
    echo -e
    msg_info2 "$(translate "Starting backup to PBS")"
    echo -e
    echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
    echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
    echo -e "${BL}$(translate "Included:")${WHITE} /boot/efi /etc/pve (all root)${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
    

    case "$AUTH_TYPE" in
        "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
        "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
        "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
    esac
    
    echo -e "${BL}$(translate "Log file:")${WHITE} $LOGFILE${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
    echo ""


    local backup_cmd="proxmox-backup-client backup --include-dev /boot/efi --include-dev /etc/pve root-${HOSTNAME}.pxar:/ --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$HOSTNAME\" --backup-time \"$(date +%s)\""
    local backup_result=0
    
    case "$AUTH_TYPE" in
        "pbs_cloud")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with PBS Cloud...")"
                echo ""
                
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else

                echo "$(translate "Starting unencrypted full backup with PBS Cloud...")"
                echo ""
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "token")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with API Token...")"
                echo ""
                
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
                echo "$(translate "Starting unencrypted full backup with API Token...")"
                echo ""
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "password")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
            
                echo "$(translate "Starting unencrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
    esac

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    if [[ $backup_result -eq 0 ]]; then
        msg_ok "$(translate "Full backup process completed successfully")"
    else
        msg_error "$(translate "Backup process finished with errors")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}














backup_to_pbs() {
    local HOSTNAME TIMESTAMP SNAPSHOT
    HOSTNAME=$(hostname)
    TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
    SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    local PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    local PBS_REPO ENCRYPT_OPT USE_ENCRYPTION
    local PBS_KEY_PASS PBS_REPO_PASS

    configure_pbs_repository || return 1
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT

    USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    [[ $? -eq 0 ]] && USE_ENCRYPTION=true

    if $USE_ENCRYPTION && ! command -v expect >/dev/null 2>&1; then
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y expect >/dev/null 2>&1
    fi

    if [[ "$#" -lt 1 ]]; then
        clear
        show_proxmenux_logo
        msg_error "$(translate "No directories specified for backup.")"
        sleep 2 
        return 1
    fi

    local TOTAL="$#"
    local COUNT=1


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        return 1
    fi

    for dir in "$@"; do
        local SAFE_NAME SAFE_ID PXAR_NAME
        SAFE_NAME=$(basename "$dir" | tr '.-/' '_')
        PXAR_NAME="root-custom-${SAFE_NAME}-${SNAPSHOT}.pxar"
        SAFE_ID="custom-${HOSTNAME}-${SAFE_NAME}"

        msg_info2 "$(translate "[$COUNT/$TOTAL] Backing up") $dir $(translate "as") $PXAR_NAME"

        ENCRYPT_OPT=""

        if $USE_ENCRYPTION; then
            if [[ -f "$PBS_KEY_FILE" ]]; then
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
            else
                while true; do
                    PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                    fi
                done

                {
                    echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                    chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
                } >/dev/null 2>&1

                expect -c "
                set timeout 30
                spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    \"Verify Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " >/dev/null 2>&1

                if [[ ! -f "$PBS_KEY_FILE" ]]; then
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                    return 1
                fi
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
                dialog --backtitle "ProxMenux" --msgbox "$(translate 'Encryption key generated. Save it in a safe place!')" 10 60
            fi
        fi

        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Starting backup to PBS")"
        TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
        TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")
        echo -e
        echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
        echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
        echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
        
        case "$AUTH_TYPE" in
            "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
            "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
            "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
        esac
        
        echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
        echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"


        local backup_cmd="proxmox-backup-client backup \"${PXAR_NAME}:$dir\" --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$SAFE_ID\" --backup-time \"$(date +%s)\""
        
        case "$AUTH_TYPE" in
            "pbs_cloud")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "token")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "password")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                fi
                ;;
        esac

        COUNT=$((COUNT+1))
    done

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================







# ========== BORGBACKUP ==========
backup_with_borg() {
#    local SRC="$1"
    local BORG_APPIMAGE="/usr/local/share/proxmenux/borg"
    local LOGFILE="/tmp/borg-backup.log"
    local DEST
    local TYPE
    local ENCRYPT_OPT=""
    local BORG_KEY

    if [[ ! -x "$BORG_APPIMAGE" ]]; then
        clear
        show_proxmenux_logo
        msg_info "$(translate "BorgBackup not found. Downloading AppImage...")"
        mkdir -p /usr/local/share/proxmenux
        wget -qO "$BORG_APPIMAGE" "https://github.com/borgbackup/borg/releases/download/1.2.8/borg-linux64"
        chmod +x "$BORG_APPIMAGE"
        msg_ok "$(translate "BorgBackup downloaded and ready.")"
    fi


    TYPE=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select Borg backup destination:')" 15 60 3 \
        "local"   "$(translate 'Local directory')" \
        "usb"     "$(translate 'Internal/External dedicated disk')" \
        "remote"  "$(translate 'Remote server')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter local directory for backup:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        mkdir -p "$DEST"
    elif [[ "$TYPE" == "usb" ]]; then

    while true; do
        BASE_DEST=$(get_external_backup_mount_point)
        if [[ -z "$BASE_DEST" ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'No external disk detected or mounted. Would you like to retry?')" 8 60
            [[ $? -eq 0 ]] && continue
            return 1
        fi

        DEST="$BASE_DEST/borgbackup"
        mkdir -p "$DEST"

        DISK_DEV=$(df "$BASE_DEST" | awk 'NR==2{print $1}')
        PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
        [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
        if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
            DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
        else
            DISK_MODEL="(unknown)"
        fi
        FREE_SPACE=$(df -h "$BASE_DEST" | awk 'NR==2{print $4}')

            dialog --backtitle "ProxMenux" \
                --title "$(translate "Dedicated Backup Disk")" \
                --yesno "\n$(translate "Mount point:") $DEST\n\n\
        $(translate "Disk model:") $DISK_MODEL\n\
        $(translate "Available space:") $FREE_SPACE\n\n\
        $(translate "Use this disk for backup?")" 12 70

        if [[ $? -eq 0 ]]; then
            break
        else
            return 1
        fi
    done


    elif [[ "$TYPE" == "remote" ]]; then
        REMOTE_USER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH user for remote:')" 10 60 "root" 3>&1 1>&2 2>&3) || return 1
        REMOTE_HOST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH host:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        REMOTE_PATH=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter remote path:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        DEST="ssh://$REMOTE_USER@$REMOTE_HOST:$REMOTE_PATH"
    fi


    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then
        BORG_KEY=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter Borg encryption passphrase (will be saved):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        ENCRYPT_OPT="--encryption=repokey"
        export BORG_PASSPHRASE="$BORG_KEY"
    else
        ENCRYPT_OPT="--encryption=none"
    fi

    if [[ "$TYPE" == "local" || "$TYPE" == "usb" ]]; then
        if [[ ! -f "$DEST/config" ]]; then
            "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
            if [[ $? -ne 0 ]]; then
                clear
                show_proxmenux_logo
                msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                sleep 5
                return 1
            fi
        fi
    fi


    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Borg backup will start now. This may take a while.')" 8 40

    clear
    show_proxmenux_logo
    msg_info2 "$(translate "Starting backup with BorgBackup...")"
    echo -e

    TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
    TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

    echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
    echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"


    # 6. Lanzar el backup y guardar log
#    "$BORG_APPIMAGE" create --progress "$DEST"::"root-$(hostname)-$(date +%Y%m%d_%H%M)" $SRC 2>&1 | tee "$LOGFILE"

    "$BORG_APPIMAGE" create --progress "$DEST"::"root-$(hostname)-$(date +%Y%m%d_%H%M)" "$@" 2>&1 | tee "$LOGFILE"

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================




# ========== LOCAL TAR ==========
backup_to_local_tar() {
#    local SRC="$1"
    local TYPE
    local DEST
    local LOGFILE="/tmp/tar-backup.log"


if ! command -v pv &>/dev/null; then
    apt-get update -qq && apt-get install -y pv >/dev/null 2>&1
fi



    TYPE=$(dialog --backtitle "ProxMenux"  --menu "$(translate 'Select backup destination:')" 15 60 2 \
        "local" "$(translate 'Local directory')" \
        "usb"   "$(translate 'Internal/External dedicated disk')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter directory for backup:')" 10 60 "/backup" 3>&1 1>&2 2>&3) || return 1

        mkdir -p "$DEST"


else


while true; do
    DEST=$(get_external_backup_mount_point)
    if [[ -z "$DEST" ]]; then
        dialog --backtitle "ProxMenux" --yesno "No external disk detected or mounted. Would you like to retry?" 8 60
        [[ $? -eq 0 ]] && continue
        return 1
    fi

    DISK_DEV=$(df "$DEST" | awk 'NR==2{print $1}')
    PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
    [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
    if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
        DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
    else
        DISK_MODEL="(unknown)"
    fi
    FREE_SPACE=$(df -h "$DEST" | awk 'NR==2{print $4}')



    dialog --backtitle "ProxMenux" \
    --title "$(translate "Dedicated Backup Disk")" \
    --yesno "\n$(translate "Mount point:") $DEST\n\n\
    $(translate "Disk model:") $DISK_MODEL\n\
    $(translate "Available space:") $FREE_SPACE\n\n\
    $(translate "Use this disk for backup?")" 12 70


    if [[ $? -eq 0 ]]; then
        mkdir -p "$DEST"
        break
    else
        return 1
    fi
done



fi


TAR_INPUT=""
TOTAL_SIZE=0
for src in $SRC; do
    sz=$(du -sb "$src" 2>/dev/null | awk '{print $1}')
    TOTAL_SIZE=$((TOTAL_SIZE + sz))
    TAR_INPUT="$TAR_INPUT $src"
done

local FILENAME="root-$(hostname)-$(date +%Y%m%d_%H%M).tar.gz"
clear
show_proxmenux_logo
msg_info2 "$(translate "Starting backup with tar...")"
echo -e


TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"

tar -cf - "$@" 2> >(grep -v "Removing leading \`/'" >&2) \
| pv -s "$TOTAL_SIZE" \
| gzip > "$DEST/$FILENAME"


echo -ne "\033[1A\r\033[K"

echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
msg_ok "$(translate "Backup process finished. Review log above or in /tmp/tar-backup.log")"
echo
msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

}
# ===============================


host_backup_menu



================================================
FILE: scripts/backup_restore/backup_host3.sh
================================================
#!/usr/bin/env bash

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


get_external_backup_mount_point() {
    local BACKUP_MOUNT_FILE="/usr/local/share/proxmenux/last_backup_mount.txt"
    local STORAGE_REPO="$LOCAL_SCRIPTS/backup_restore"
    local MOUNT_POINT

    if [[ -f "$BACKUP_MOUNT_FILE" ]]; then
        MOUNT_POINT=$(head -n1 "$BACKUP_MOUNT_FILE" | tr -d '\r\n' | xargs)
        >&2 echo "DEBUG: Valor MOUNT_POINT='$MOUNT_POINT'"
        if [[ ! -d "$MOUNT_POINT" ]]; then
            msg_error "Mount point does not exist: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
        if ! mountpoint -q "$MOUNT_POINT"; then
            msg_error "Mount point is not mounted: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
 
        echo "$MOUNT_POINT"
        return 0
    else
       source "$STORAGE_REPO/mount_disk_host_bk.sh"
       MOUNT_POINT=$(mount_disk_host_bk)
        [[ -z "$MOUNT_POINT" ]] && msg_error "$(translate "No disk mounted.")" && return 1
        echo "$MOUNT_POINT"
        return 0
    fi
}



# === Host Backup Main Menu ===
host_backup_menu() {
    while true; do
        local CHOICE
        CHOICE=$(dialog --backtitle "ProxMenux" \
            --title "$(translate 'Host Backup')" \
            --menu "\n$(translate 'Select backup option:')" 22 70 12 \
            ""         "$(translate '--- FULL BACKUP ---')" \
            1 "$(translate 'Full backup to Proxmox Backup Server (PBS)')" \
            2 "$(translate 'Full backup with BorgBackup')" \
            3 "$(translate 'Full backup to local .tar.gz')" \
            ""         "$(translate '--- CUSTOM BACKUP ---')" \
            4 "$(translate 'Custom backup to PBS')" \
            5 "$(translate 'Custom backup with BorgBackup')" \
            6 "$(translate 'Custom backup to local .tar.gz')" \
            0 "$(translate 'Return')" \
            3>&1 1>&2 2>&3) || return 0

        case "$CHOICE" in
            1) backup_full_pbs_root ;;
            2) backup_with_borg "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            3) backup_to_local_tar "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            4) custom_backup_menu backup_to_pbs ;;
            5) custom_backup_menu backup_with_borg ;;
            6) custom_backup_menu backup_to_local_tar ;;
            0) break ;;
        esac
    done
}



# === Menu checklist for custom backup ===
custom_backup_menu() {
    declare -A BACKUP_PATHS=(
        [etc-pve]="/etc/pve"
        [etc-network]="/etc/network"
        [var-lib-pve-cluster]="/var/lib/pve-cluster"
        [root-dir]="/root"
        [etc-ssh]="/etc/ssh"
        [home]="/home"
        [local-bin]="/usr/local/bin"
        [cron]="/etc/cron.d"
        [custom-systemd]="/etc/systemd/system"
        [var-lib-vz]="/var/lib/vz"
    )
    local CHECKLIST_OPTIONS=()
    for KEY in "${!BACKUP_PATHS[@]}"; do
        DIR="${BACKUP_PATHS[$KEY]}"
        CHECKLIST_OPTIONS+=("$KEY" "$DIR" "off")
    done

    SELECTED_KEYS=$(dialog --separate-output --checklist \
        "$(translate 'Select directories to backup:')" 22 70 12 \
        "${CHECKLIST_OPTIONS[@]}" \
        3>&1 1>&2 2>&3) || return 1

    local BACKUP_DIRS=()
    for KEY in $SELECTED_KEYS; do
        BACKUP_DIRS+=("${BACKUP_PATHS[$KEY]}")
    done


#    "$1" "${BACKUP_DIRS[*]}"
     "$1" "${BACKUP_DIRS[@]}"


}











configure_pbs_repository() {
local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
local PBS_MANUAL_CONFIGS="/usr/local/share/proxmenux/pbs-manual-configs.txt"

[[ ! -f "$PBS_MANUAL_CONFIGS" ]] && touch "$PBS_MANUAL_CONFIGS"

local PBS_CONFIGS=()
local PBS_SOURCES=()
local PBS_USERNAMES=()

if [[ -f "/etc/pve/storage.cfg" ]]; then
    local current_pbs="" server="" datastore="" username=""
    
    while IFS= read -r line; do
        if [[ $line =~ ^pbs:\ (.+)$ ]]; then
            if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
                PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                PBS_SOURCES+=("proxmox|$current_pbs")
                PBS_USERNAMES+=("$username")
            fi
            current_pbs="${BASH_REMATCH[1]}"
            server="" datastore="" username=""
        elif [[ -n "$current_pbs" ]]; then
            if [[ $line =~ ^[[:space:]]*server[[:space:]]+(.+)$ ]]; then
                server="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*datastore[[:space:]]+(.+)$ ]]; then
                datastore="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*username[[:space:]]+(.+)$ ]]; then
                username="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[a-zA-Z]+: ]]; then
                if [[ -n "$server" && -n "$datastore" && -n "$username" ]]; then
                    PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                    PBS_SOURCES+=("proxmox|$current_pbs")
                    PBS_USERNAMES+=("$username")
                fi
                current_pbs=""
            fi
        fi
    done < "/etc/pve/storage.cfg"
    
    if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
        PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
        PBS_SOURCES+=("proxmox|$current_pbs")
        PBS_USERNAMES+=("$username")
    fi
fi

if [[ -f "$PBS_MANUAL_CONFIGS" ]]; then
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            PBS_CONFIGS+=("$line")
            local name="${line%%|*}"
            PBS_SOURCES+=("manual|$name")
            PBS_USERNAMES+=("")
        fi
    done < "$PBS_MANUAL_CONFIGS"
fi

local menu_options=()
local i=1

for j in "${!PBS_CONFIGS[@]}"; do
    local config="${PBS_CONFIGS[$j]}"
    local source="${PBS_SOURCES[$j]}"
    local name="${config%%|*}"
    local repo="${config##*|}"
    local source_type="${source%%|*}"

    if [[ "$source_type" == "proxmox" ]]; then
        menu_options+=("$i" " $name ($repo) [Proxmox]")
    else
        menu_options+=("$i" " $name ($repo) [Manual]")
    fi
    ((i++))
done

menu_options+=("" "")
menu_options+=("$i" "\Z4\Zb $(translate 'Configure new PBS')\Zn")
local choice
choice=$(dialog --colors --backtitle "ProxMenux" --title "PBS Server Selection" \
--menu "$(translate 'Select PBS server for this backup:')" 22 70 12 "${menu_options[@]}" 3>&1 1>&2 2>&3) || return 1

if [[ $choice -eq $i ]]; then
    configure_pbs_manually || return 1
else
    local selected_config="${PBS_CONFIGS[$((choice-1))]}"
    local selected_source="${PBS_SOURCES[$((choice-1))]}"
    local selected_username="${PBS_USERNAMES[$((choice-1))]}"
    local pbs_name="${selected_config%%|*}"
    local source_type="${selected_source%%|*}"
    PBS_REPO="${selected_config##*|}"
    
    {
        mkdir -p "$(dirname "$PBS_REPO_FILE")"
        echo "$PBS_REPO" > "$PBS_REPO_FILE"
    } >/dev/null 2>&1
    
    local password_found=false
    if [[ "$source_type" == "proxmox" ]]; then
        local password_file="/etc/pve/priv/storage/${pbs_name}.pw"
        
        if [[ -f "$password_file" ]]; then
            local auth_content
            auth_content=$(<"$password_file")
            

            [[ -f "$PBS_PASS_FILE" ]] && rm "$PBS_PASS_FILE"
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            

            if [[ "$selected_username" == *"@pbs!"* ]]; then

                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') PBS Cloud Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
                local full_token="${selected_username}:${auth_content}"
                echo "$full_token" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" == *":"* ]]; then
                echo "$auth_content" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token (Complete)" 12 80
            else
                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') Password" 12 80
            fi
        fi
    else
        local manual_pass_file="/usr/local/share/proxmenux/pbs-pass-${pbs_name}.txt"
        if [[ -f "$manual_pass_file" ]]; then
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            
            {
                cp "$manual_pass_file" "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
            } >/dev/null 2>&1
            password_found=true
            dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using manual PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Password:') $(translate 'Previously saved')" 12 80
        fi
    fi
    
    if ! $password_found; then
        dialog --backtitle "ProxMenux" --title "Password Required" --msgbox "$(translate 'Password not found for:') $pbs_name
$(translate 'Please enter the password.')" 10 60
        get_pbs_password "$pbs_name" || return 1
    fi
    
    clear
fi
}










# ========== PBS BACKUP ==========
backup_full_pbs_root() {
    local HOSTNAME PBS_REPO PBS_KEY_FILE PBS_PASS_FILE PBS_TOKEN_FILE PBS_ENCRYPTION_PASS_FILE ENCRYPT_OPT=""
    HOSTNAME=$(hostname)
    

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    LOGFILE="/tmp/pbs-backup-${HOSTNAME}.log"


    configure_pbs_repository || return 1

    if [[ ! -f "$PBS_REPO_FILE" ]]; then
        msg_error "$(translate "Failed to configure PBS connection")"
        sleep 3
        return 1
    fi
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        sleep 3
        return 1
    fi

  
    dialog --backtitle "ProxMenux" --title "Encryption" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then

        if [[ ! -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
            while true; do
                PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 12 70 "" 3>&1 1>&2 2>&3) || return 1
                PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                fi
            done


            {
                echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
            } >/dev/null 2>&1
            
            dialog --backtitle "ProxMenux" --title "Success" --msgbox "$(translate 'Encryption password saved successfully!')" 8 50
        fi
        

        if [[ ! -f "$PBS_KEY_FILE" ]]; then
            PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
            
            dialog --backtitle "ProxMenux" --title "Encryption" --infobox "$(translate 'Creating encryption key...')" 5 50
            
            expect -c "
            set timeout 30
            spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
            expect {
                \"Encryption Key Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                \"Verify Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                eof
            }
            " >/dev/null 2>&1

            if [[ ! -f "$PBS_KEY_FILE" ]]; then
                dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                return 1
            fi
            
            dialog --backtitle "ProxMenux" --title "Important" --msgbox "$(translate 'IMPORTANT: Save the key file. Without it you will not be able to restore your backups!')\n\n$(translate 'Key file location:') $PBS_KEY_FILE" 12 70
        fi
        ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
    else
        ENCRYPT_OPT=""
    fi


    clear
    show_proxmenux_logo
    echo -e
    msg_info2 "$(translate "Starting backup to PBS")"
    echo -e
    echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
    echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
    echo -e "${BL}$(translate "Included:")${WHITE} /boot/efi /etc/pve (all root)${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
    

    case "$AUTH_TYPE" in
        "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
        "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
        "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
    esac
    
    echo -e "${BL}$(translate "Log file:")${WHITE} $LOGFILE${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
    echo ""


    local backup_cmd="proxmox-backup-client backup --include-dev /boot/efi --include-dev /etc/pve root-${HOSTNAME}.pxar:/ --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$HOSTNAME\" --backup-time \"$(date +%s)\""
    local backup_result=0
    
    case "$AUTH_TYPE" in
        "pbs_cloud")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with PBS Cloud...")"
                echo ""
                
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else

                echo "$(translate "Starting unencrypted full backup with PBS Cloud...")"
                echo ""
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "token")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with API Token...")"
                echo ""
                
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
                echo "$(translate "Starting unencrypted full backup with API Token...")"
                echo ""
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "password")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
            
                echo "$(translate "Starting unencrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
    esac

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    if [[ $backup_result -eq 0 ]]; then
        msg_ok "$(translate "Full backup process completed successfully")"
    else
        msg_error "$(translate "Backup process finished with errors")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}














backup_to_pbs() {
    local HOSTNAME TIMESTAMP SNAPSHOT
    HOSTNAME=$(hostname)
    TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
    SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    local PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    local PBS_REPO ENCRYPT_OPT USE_ENCRYPTION
    local PBS_KEY_PASS PBS_REPO_PASS

    configure_pbs_repository || return 1
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT

    USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    [[ $? -eq 0 ]] && USE_ENCRYPTION=true

    if $USE_ENCRYPTION && ! command -v expect >/dev/null 2>&1; then
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y expect >/dev/null 2>&1
    fi

    if [[ "$#" -lt 1 ]]; then
        clear
        show_proxmenux_logo
        msg_error "$(translate "No directories specified for backup.")"
        sleep 2 
        return 1
    fi

    local TOTAL="$#"
    local COUNT=1


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        return 1
    fi

    for dir in "$@"; do
        local SAFE_NAME SAFE_ID PXAR_NAME
        SAFE_NAME=$(basename "$dir" | tr '.-/' '_')
        PXAR_NAME="root-custom-${SAFE_NAME}-${SNAPSHOT}.pxar"
        SAFE_ID="custom-${HOSTNAME}-${SAFE_NAME}"

        msg_info2 "$(translate "[$COUNT/$TOTAL] Backing up") $dir $(translate "as") $PXAR_NAME"

        ENCRYPT_OPT=""

        if $USE_ENCRYPTION; then
            if [[ -f "$PBS_KEY_FILE" ]]; then
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
            else
                while true; do
                    PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                    fi
                done

                {
                    echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                    chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
                } >/dev/null 2>&1

                expect -c "
                set timeout 30
                spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    \"Verify Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " >/dev/null 2>&1

                if [[ ! -f "$PBS_KEY_FILE" ]]; then
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                    return 1
                fi
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
                dialog --backtitle "ProxMenux" --msgbox "$(translate 'Encryption key generated. Save it in a safe place!')" 10 60
            fi
        fi

        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Starting backup to PBS")"
        TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
        TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")
        echo -e
        echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
        echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
        echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
        
        case "$AUTH_TYPE" in
            "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
            "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
            "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
        esac
        
        echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
        echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"


        local backup_cmd="proxmox-backup-client backup \"${PXAR_NAME}:$dir\" --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$SAFE_ID\" --backup-time \"$(date +%s)\""
        
        case "$AUTH_TYPE" in
            "pbs_cloud")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "token")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "password")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                fi
                ;;
        esac

        COUNT=$((COUNT+1))
    done

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================







# ========== BORGBACKUP ==========
backup_with_borg() {
    local BORG_APPIMAGE="/usr/local/share/proxmenux/borg"
    local LOGFILE="/tmp/borg-backup.log"
    local BORG_PASS_FILE="/usr/local/share/proxmenux/borg-pass.txt"
    local BORG_KEY_FILE="/usr/local/share/proxmenux/borg-key"
    local DEST
    local TYPE
    local ENCRYPT_OPT=""
    local BORG_KEY

    # Descargar BorgBackup si no existe
    if [[ ! -x "$BORG_APPIMAGE" ]]; then
        clear
        show_proxmenux_logo
        msg_info "$(translate "BorgBackup not found. Downloading AppImage...")"
        mkdir -p /usr/local/share/proxmenux
        wget -qO "$BORG_APPIMAGE" "https://github.com/borgbackup/borg/releases/download/1.2.8/borg-linux64"
        chmod +x "$BORG_APPIMAGE"
        msg_ok "$(translate "BorgBackup downloaded and ready.")"
    fi

    # Seleccionar tipo de destino
    TYPE=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select Borg backup destination:')" 15 60 4 \
        "local"   "$(translate 'Local directory')" \
        "usb"     "$(translate 'Internal/External dedicated disk')" \
        "remote"  "$(translate 'Remote server (SSH)')" \
        "pbs"     "$(translate 'remote-backups.com')" \
        3>&1 1>&2 2>&3) || return 1


    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter local directory for backup:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        mkdir -p "$DEST"
        
    elif [[ "$TYPE" == "usb" ]]; then
        while true; do
            BASE_DEST=$(get_external_backup_mount_point)
            if [[ -z "$BASE_DEST" ]]; then
                dialog --backtitle "ProxMenux" --yesno "$(translate 'No external disk detected or mounted. Would you like to retry?')" 8 60
                [[ $? -eq 0 ]] && continue
                return 1
            fi

            DEST="$BASE_DEST/borgbackup"
            mkdir -p "$DEST"

            DISK_DEV=$(df "$BASE_DEST" | awk 'NR==2{print $1}')
            PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
            [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
            if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
                DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
            else
                DISK_MODEL="(unknown)"
            fi
            FREE_SPACE=$(df -h "$BASE_DEST" | awk 'NR==2{print $4}')

            dialog --backtitle "ProxMenux" \
                --title "$(translate "Dedicated Backup Disk")" \
                --yesno "\n$(translate "Mount point:") $DEST\n\n\
            $(translate "Disk model:") $DISK_MODEL\n\
            $(translate "Available space:") $FREE_SPACE\n\n\
            $(translate "Use this disk for backup?")" 12 70

            if [[ $? -eq 0 ]]; then
                break
            else
                return 1
            fi
        done
        
    elif [[ "$TYPE" == "remote" ]]; then

        REMOTE_USER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH user for remote:')" 10 60 "root" 3>&1 1>&2 2>&3) || return 1
        REMOTE_HOST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH host:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        REMOTE_PATH=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter remote path:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        

        dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to use SSH key authentication?')" 8 60
        if [[ $? -eq 0 ]]; then
            SSH_KEY=$(dialog --backtitle "ProxMenux" --fselect "$HOME/.ssh/" 10 60 3>&1 1>&2 2>&3) || return 1
            export BORG_RSH="ssh -i $SSH_KEY"
        fi
        
        DEST="ssh://$REMOTE_USER@$REMOTE_HOST:$REMOTE_PATH"
        
    elif [[ "$TYPE" == "pbs" ]]; then

        PBS_CUSTOMER_ID=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter PBS customer ID (from Connect panel):')" 10 70 "" 3>&1 1>&2 2>&3) || return 1
        PBS_SERVER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter PBS server (from Connect panel):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        

        local SSH_KEYS=()
        local SSH_KEY_NAMES=()
        

        for key_file in ~/.ssh/id_rsa ~/.ssh/id_ed25519 ~/.ssh/pbs_host_key ~/.ssh/id_ecdsa; do
            if [[ -f "$key_file" && -f "${key_file}.pub" ]]; then
                SSH_KEYS+=("$key_file")
                local key_type=$(head -1 "${key_file}.pub" | awk '{print $1}')
                local key_comment=$(head -1 "${key_file}.pub" | awk '{print $3}')
                SSH_KEY_NAMES+=("$(basename "$key_file") ($key_type) - $key_comment")
            fi
        done
        

        if [[ ${#SSH_KEYS[@]} -eq 0 ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'No SSH keys found. Do you want to create one now?')" 8 60
            if [[ $? -eq 0 ]]; then
                clear
                show_proxmenux_logo
                echo -e
                msg_info2 "$(translate "Creating SSH key for PBS-host.de...")"
                

                ssh-keygen -t rsa -b 4096 -f ~/.ssh/pbs_host_key -N "" -C "pbs-backup-$(hostname)"
                
                if [[ $? -eq 0 ]]; then
                    SSH_KEY="$HOME/.ssh/pbs_host_key"
                    msg_ok "$(translate "SSH key created successfully!")"
                else
                    msg_error "$(translate "Failed to create SSH key")"
                    return 1
                fi
            else
                return 1
            fi
        elif [[ ${#SSH_KEYS[@]} -eq 1 ]]; then

            SSH_KEY="${SSH_KEYS[0]}"
        else

            local menu_options=()
            for i in "${!SSH_KEYS[@]}"; do
                menu_options+=("$i" "${SSH_KEY_NAMES[$i]}")
            done
            
            local choice
            choice=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select SSH key to use:')" 15 80 10 "${menu_options[@]}" 3>&1 1>&2 2>&3) || return 1
            SSH_KEY="${SSH_KEYS[$choice]}"
        fi
        
        export BORG_RSH="ssh -i $SSH_KEY"
        DEST="$PBS_CUSTOMER_ID@$PBS_SERVER:./borg"
        
  
        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "PBS-host.de Configuration")"
        echo -e "${BL}$(translate "Server:")${WHITE} $PBS_SERVER${RESET}"
        echo -e "${BL}$(translate "Customer ID:")${WHITE} $PBS_CUSTOMER_ID${RESET}"
        echo -e "${BL}$(translate "SSH Key:")${WHITE} $SSH_KEY${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
        echo ""
        

        chmod 600 "$SSH_KEY"
        

        local SSH_PUB_KEY="${SSH_KEY}.pub"
        if [[ -f "$SSH_PUB_KEY" ]]; then
            echo -e "${BL}$(translate "Your SSH Public Key:")${RESET}"
            echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}"
            echo -e "${WHITE}$(cat "$SSH_PUB_KEY")${RESET}"
            echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}"
            echo ""
            

            if command -v xclip >/dev/null 2>&1; then
                echo -e "${BL}$(translate "Copying to clipboard...")${RESET}"
                cat "$SSH_PUB_KEY" | xclip -selection clipboard
                msg_ok "$(translate "Public key copied to clipboard!")"
            elif command -v pbcopy >/dev/null 2>&1; then
                echo -e "${BL}$(translate "Copying to clipboard...")${RESET}"
                cat "$SSH_PUB_KEY" | pbcopy
                msg_ok "$(translate "Public key copied to clipboard!")"
            fi
            
            echo ""
            echo -e "${BL}$(translate "INSTRUCTIONS:")${RESET}"
            echo "1. $(translate "Copy the key above (or use clipboard if available)")"
            echo "2. $(translate "Go to PBS-host.de panel â†’ Your datastore â†’ Connect")"
            echo "3. $(translate "Select 'rsync / borg / sftp' tab")"
            echo "4. $(translate "Paste the key in 'Save SSH Key' section")"
            echo "5. $(translate "Click 'Save'")"
            echo ""
            

            msg_success "$(translate "Press Enter when you have uploaded the key to PBS-host.de panel...")"
            read -r
        fi
        

        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Testing connection to PBS-host.de...")"
        echo ""
        
        echo "$(translate "Connecting... (you may need to type 'yes' to accept the server fingerprint)")"
        echo ""
        

        if timeout 30 ssh -i "$SSH_KEY" -o ConnectTimeout=10 -o BatchMode=no "$PBS_CUSTOMER_ID@$PBS_SERVER" borg --version >/dev/null 2>&1; then
            echo ""
            msg_ok "$(translate "âœ… Connection successful! Borg is available on the server.")"
            sleep 2
        else
            echo ""
            msg_error "$(translate "âŒ Connection failed or requires manual intervention.")"
            echo ""
            echo -e "${BL}$(translate "This could be normal if:")${RESET}"
            echo "â€¢ $(translate "First time connecting (need to accept fingerprint)")"
            echo "â€¢ $(translate "Key not yet uploaded to PBS-host.de panel")"
            echo "â€¢ $(translate "Network connectivity issues")"
            echo ""
            
            dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to continue anyway? The backup will test the connection again.')" 10 70
            if [[ $? -ne 0 ]]; then
                return 1
            fi
        fi
    fi


    local USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then
        USE_ENCRYPTION=true
        ENCRYPT_OPT="--encryption=repokey"
        

        if [[ -f "$BORG_PASS_FILE" ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'A saved encryption passphrase exists. Use it?')" 8 60
            if [[ $? -eq 0 ]]; then
                BORG_KEY=$(<"$BORG_PASS_FILE")
            else

                while true; do
                    BORG_KEY=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter Borg encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    BORG_KEY2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$BORG_KEY" == "$BORG_KEY2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passphrases do not match! Please try again.')" 8 50
                    fi
                done
                

                mkdir -p "$(dirname "$BORG_PASS_FILE")"
                echo "$BORG_KEY" > "$BORG_PASS_FILE"
                chmod 600 "$BORG_PASS_FILE"
            fi
        else

            while true; do
                BORG_KEY=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter Borg encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                BORG_KEY2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$BORG_KEY" == "$BORG_KEY2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passphrases do not match! Please try again.')" 8 50
                fi
            done
            

            mkdir -p "$(dirname "$BORG_PASS_FILE")"
            echo "$BORG_KEY" > "$BORG_PASS_FILE"
            chmod 600 "$BORG_PASS_FILE"
        fi
        
        export BORG_PASSPHRASE="$BORG_KEY"
    else
        ENCRYPT_OPT="--encryption=none"
    fi


    if [[ "$TYPE" == "local" || "$TYPE" == "usb" ]]; then
        if [[ ! -f "$DEST/config" ]]; then
            dialog --backtitle "ProxMenux" --infobox "$(translate 'Initializing Borg repository...')" 5 50
            "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
            if [[ $? -ne 0 ]]; then
                clear
                show_proxmenux_logo
                msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                sleep 5
                return 1
            fi
        fi
    elif [[ "$TYPE" == "remote" || "$TYPE" == "pbs" ]]; then

        if ! "$BORG_APPIMAGE" list "$DEST" >/dev/null 2>&1; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'Repository does not exist or is not accessible. Initialize it?')" 8 60
            if [[ $? -eq 0 ]]; then
                dialog --backtitle "ProxMenux" --infobox "$(translate 'Initializing Borg repository...')" 5 50
                "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
                if [[ $? -ne 0 ]]; then
                    clear
                    show_proxmenux_logo
                    msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                    sleep 5
                    return 1
                fi
            else
                return 1
            fi
        fi
    fi


    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Borg backup will start now. This may take a while.')" 8 40


    clear
    show_proxmenux_logo
    msg_info2 "$(translate "Starting backup with BorgBackup...")"
    echo -e

    TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
    TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

    echo -e "${BL}$(translate "Destination:")${WHITE} $DEST${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $($USE_ENCRYPTION && echo "Enabled" || echo "Disabled")${RESET}"
    echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
    echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"


    local ARCHIVE_NAME="root-$(hostname)-$(date +%Y%m%d_%H%M)"
    
    "$BORG_APPIMAGE" create --progress --stats --compression zstd "$DEST"::$ARCHIVE_NAME "$@" 2>&1 | tee "$LOGFILE"
    local BACKUP_RESULT=$?

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    
    if [[ $BACKUP_RESULT -eq 0 ]]; then
        msg_ok "$(translate "Backup completed successfully!")"
        

        echo -e "\n${BL}$(translate "Backup information:")${RESET}"
        "$BORG_APPIMAGE" info "$DEST"::$ARCHIVE_NAME 2>&1 | tee -a "$LOGFILE"
        
  
        if [[ "$TYPE" == "remote" || "$TYPE" == "pbs" ]]; then
            echo -e "\n${BL}$(translate "Tip:")${RESET} $(translate "Run 'borg compact $DEST' to free up space after multiple backups.")"
        fi
    else
        msg_error "$(translate "Backup process failed with error code:") $BACKUP_RESULT"
    fi
    
    echo
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================




# ========== LOCAL TAR ==========
backup_to_local_tar() {
#    local SRC="$1"
    local TYPE
    local DEST
    local LOGFILE="/tmp/tar-backup.log"


if ! command -v pv &>/dev/null; then
    apt-get update -qq && apt-get install -y pv >/dev/null 2>&1
fi



    TYPE=$(dialog --backtitle "ProxMenux"  --menu "$(translate 'Select backup destination:')" 15 60 2 \
        "local" "$(translate 'Local directory')" \
        "usb"   "$(translate 'Internal/External dedicated disk')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter directory for backup:')" 10 60 "/backup" 3>&1 1>&2 2>&3) || return 1

        mkdir -p "$DEST"


else


while true; do
    DEST=$(get_external_backup_mount_point)
    if [[ -z "$DEST" ]]; then
        dialog --backtitle "ProxMenux" --yesno "No external disk detected or mounted. Would you like to retry?" 8 60
        [[ $? -eq 0 ]] && continue
        return 1
    fi

    DISK_DEV=$(df "$DEST" | awk 'NR==2{print $1}')
    PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
    [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
    if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
        DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
    else
        DISK_MODEL="(unknown)"
    fi
    FREE_SPACE=$(df -h "$DEST" | awk 'NR==2{print $4}')



    dialog --backtitle "ProxMenux" \
    --title "$(translate "Dedicated Backup Disk")" \
    --yesno "\n$(translate "Mount point:") $DEST\n\n\
    $(translate "Disk model:") $DISK_MODEL\n\
    $(translate "Available space:") $FREE_SPACE\n\n\
    $(translate "Use this disk for backup?")" 12 70


    if [[ $? -eq 0 ]]; then
        mkdir -p "$DEST"
        break
    else
        return 1
    fi
done



fi


TAR_INPUT=""
TOTAL_SIZE=0
for src in $SRC; do
    sz=$(du -sb "$src" 2>/dev/null | awk '{print $1}')
    TOTAL_SIZE=$((TOTAL_SIZE + sz))
    TAR_INPUT="$TAR_INPUT $src"
done

local FILENAME="root-$(hostname)-$(date +%Y%m%d_%H%M).tar.gz"
clear
show_proxmenux_logo
msg_info2 "$(translate "Starting backup with tar...")"
echo -e


TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"

tar -cf - "$@" 2> >(grep -v "Removing leading \`/'" >&2) \
| pv -s "$TOTAL_SIZE" \
| gzip > "$DEST/$FILENAME"


echo -ne "\033[1A\r\033[K"

echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
msg_ok "$(translate "Backup process finished. Review log above or in /tmp/tar-backup.log")"
echo
msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

}
# ===============================


host_backup_menu



================================================
FILE: scripts/backup_restore/backup_host4.sh
================================================
#!/usr/bin/env bash

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


get_external_backup_mount_point() {
    local BACKUP_MOUNT_FILE="/usr/local/share/proxmenux/last_backup_mount.txt"
    local STORAGE_REPO="$LOCAL_SCRIPTS/backup_restore"
    local MOUNT_POINT

    if [[ -f "$BACKUP_MOUNT_FILE" ]]; then
        MOUNT_POINT=$(head -n1 "$BACKUP_MOUNT_FILE" | tr -d '\r\n' | xargs)
        >&2 echo "DEBUG: Valor MOUNT_POINT='$MOUNT_POINT'"
        if [[ ! -d "$MOUNT_POINT" ]]; then
            msg_error "Mount point does not exist: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
        if ! mountpoint -q "$MOUNT_POINT"; then
            msg_error "Mount point is not mounted: $MOUNT_POINT"
            rm -f "$BACKUP_MOUNT_FILE"
            return 1
        fi
 
        echo "$MOUNT_POINT"
        return 0
    else
       source "$STORAGE_REPO/mount_disk_host_bk.sh"
       MOUNT_POINT=$(mount_disk_host_bk)
        [[ -z "$MOUNT_POINT" ]] && msg_error "$(translate "No disk mounted.")" && return 1
        echo "$MOUNT_POINT"
        return 0
    fi
}



# === Host Backup Main Menu ===
host_backup_menu() {
    while true; do
        local CHOICE
        CHOICE=$(dialog --backtitle "ProxMenux" \
            --title "$(translate 'Host Backup')" \
            --menu "\n$(translate 'Select backup option:')" 22 70 12 \
            ""         "$(translate '--- FULL BACKUP ---')" \
            1 "$(translate 'Full backup to Proxmox Backup Server (PBS)')" \
            2 "$(translate 'Full backup with BorgBackup')" \
            3 "$(translate 'Full backup to local .tar.gz')" \
            ""         "$(translate '--- CUSTOM BACKUP ---')" \
            4 "$(translate 'Custom backup to PBS')" \
            5 "$(translate 'Custom backup with BorgBackup')" \
            6 "$(translate 'Custom backup to local .tar.gz')" \
            0 "$(translate 'Return')" \
            3>&1 1>&2 2>&3) || return 0

        case "$CHOICE" in
            1) backup_full_pbs_root ;;
            2) backup_with_borg "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            3) backup_to_local_tar "/boot/efi /etc/pve /etc/network /var/lib/pve-cluster /root /etc/ssh /home /usr/local/bin /etc/cron.d /etc/systemd/system /var/lib/vz" ;;
            4) custom_backup_menu backup_to_pbs ;;
            5) custom_backup_menu backup_with_borg ;;
            6) custom_backup_menu backup_to_local_tar ;;
            0) break ;;
        esac
    done
}



# === Menu checklist for custom backup ===
custom_backup_menu() {
    declare -A BACKUP_PATHS=(
        [etc-pve]="/etc/pve"
        [etc-network]="/etc/network"
        [var-lib-pve-cluster]="/var/lib/pve-cluster"
        [root-dir]="/root"
        [etc-ssh]="/etc/ssh"
        [home]="/home"
        [local-bin]="/usr/local/bin"
        [cron]="/etc/cron.d"
        [custom-systemd]="/etc/systemd/system"
        [var-lib-vz]="/var/lib/vz"
    )
    local CHECKLIST_OPTIONS=()
    for KEY in "${!BACKUP_PATHS[@]}"; do
        DIR="${BACKUP_PATHS[$KEY]}"
        CHECKLIST_OPTIONS+=("$KEY" "$DIR" "off")
    done

    SELECTED_KEYS=$(dialog --separate-output --checklist \
        "$(translate 'Select directories to backup:')" 22 70 12 \
        "${CHECKLIST_OPTIONS[@]}" \
        3>&1 1>&2 2>&3) || return 1

    local BACKUP_DIRS=()
    for KEY in $SELECTED_KEYS; do
        BACKUP_DIRS+=("${BACKUP_PATHS[$KEY]}")
    done


#    "$1" "${BACKUP_DIRS[*]}"
     "$1" "${BACKUP_DIRS[@]}"


}











configure_pbs_repository() {
local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
local PBS_MANUAL_CONFIGS="/usr/local/share/proxmenux/pbs-manual-configs.txt"

[[ ! -f "$PBS_MANUAL_CONFIGS" ]] && touch "$PBS_MANUAL_CONFIGS"

local PBS_CONFIGS=()
local PBS_SOURCES=()
local PBS_USERNAMES=()

if [[ -f "/etc/pve/storage.cfg" ]]; then
    local current_pbs="" server="" datastore="" username=""
    
    while IFS= read -r line; do
        if [[ $line =~ ^pbs:\ (.+)$ ]]; then
            if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
                PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                PBS_SOURCES+=("proxmox|$current_pbs")
                PBS_USERNAMES+=("$username")
            fi
            current_pbs="${BASH_REMATCH[1]}"
            server="" datastore="" username=""
        elif [[ -n "$current_pbs" ]]; then
            if [[ $line =~ ^[[:space:]]*server[[:space:]]+(.+)$ ]]; then
                server="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*datastore[[:space:]]+(.+)$ ]]; then
                datastore="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[[:space:]]*username[[:space:]]+(.+)$ ]]; then
                username="${BASH_REMATCH[1]}"
            elif [[ $line =~ ^[a-zA-Z]+: ]]; then
                if [[ -n "$server" && -n "$datastore" && -n "$username" ]]; then
                    PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
                    PBS_SOURCES+=("proxmox|$current_pbs")
                    PBS_USERNAMES+=("$username")
                fi
                current_pbs=""
            fi
        fi
    done < "/etc/pve/storage.cfg"
    
    if [[ -n "$current_pbs" && -n "$server" && -n "$datastore" && -n "$username" ]]; then
        PBS_CONFIGS+=("$current_pbs|$username@$server:$datastore")
        PBS_SOURCES+=("proxmox|$current_pbs")
        PBS_USERNAMES+=("$username")
    fi
fi

if [[ -f "$PBS_MANUAL_CONFIGS" ]]; then
    while IFS= read -r line; do
        if [[ -n "$line" ]]; then
            PBS_CONFIGS+=("$line")
            local name="${line%%|*}"
            PBS_SOURCES+=("manual|$name")
            PBS_USERNAMES+=("")
        fi
    done < "$PBS_MANUAL_CONFIGS"
fi

local menu_options=()
local i=1

for j in "${!PBS_CONFIGS[@]}"; do
    local config="${PBS_CONFIGS[$j]}"
    local source="${PBS_SOURCES[$j]}"
    local name="${config%%|*}"
    local repo="${config##*|}"
    local source_type="${source%%|*}"

    if [[ "$source_type" == "proxmox" ]]; then
        menu_options+=("$i" " $name ($repo) [Proxmox]")
    else
        menu_options+=("$i" " $name ($repo) [Manual]")
    fi
    ((i++))
done

menu_options+=("" "")
menu_options+=("$i" "\Z4\Zb $(translate 'Configure new PBS')\Zn")
local choice
choice=$(dialog --colors --backtitle "ProxMenux" --title "PBS Server Selection" \
--menu "$(translate 'Select PBS server for this backup:')" 22 70 12 "${menu_options[@]}" 3>&1 1>&2 2>&3) || return 1

if [[ $choice -eq $i ]]; then
    configure_pbs_manually || return 1
else
    local selected_config="${PBS_CONFIGS[$((choice-1))]}"
    local selected_source="${PBS_SOURCES[$((choice-1))]}"
    local selected_username="${PBS_USERNAMES[$((choice-1))]}"
    local pbs_name="${selected_config%%|*}"
    local source_type="${selected_source%%|*}"
    PBS_REPO="${selected_config##*|}"
    
    {
        mkdir -p "$(dirname "$PBS_REPO_FILE")"
        echo "$PBS_REPO" > "$PBS_REPO_FILE"
    } >/dev/null 2>&1
    
    local password_found=false
    if [[ "$source_type" == "proxmox" ]]; then
        local password_file="/etc/pve/priv/storage/${pbs_name}.pw"
        
        if [[ -f "$password_file" ]]; then
            local auth_content
            auth_content=$(<"$password_file")
            

            [[ -f "$PBS_PASS_FILE" ]] && rm "$PBS_PASS_FILE"
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            

            if [[ "$selected_username" == *"@pbs!"* ]]; then

                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') PBS Cloud Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" =~ ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ ]]; then
                local full_token="${selected_username}:${auth_content}"
                echo "$full_token" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token
$(translate 'Token ID:') $selected_username" 15 80
            elif [[ "$auth_content" == *":"* ]]; then
                echo "$auth_content" > "$PBS_TOKEN_FILE"
                chmod 600 "$PBS_TOKEN_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') API Token (Complete)" 12 80
            else
                echo "$auth_content" > "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
                password_found=true
                dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using Proxmox PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Authentication:') Password" 12 80
            fi
        fi
    else
        local manual_pass_file="/usr/local/share/proxmenux/pbs-pass-${pbs_name}.txt"
        if [[ -f "$manual_pass_file" ]]; then
            [[ -f "$PBS_TOKEN_FILE" ]] && rm "$PBS_TOKEN_FILE"
            
            {
                cp "$manual_pass_file" "$PBS_PASS_FILE"
                chmod 600 "$PBS_PASS_FILE"
            } >/dev/null 2>&1
            password_found=true
            dialog --backtitle "ProxMenux" --title "PBS Selected" --msgbox "$(translate 'Using manual PBS:') $pbs_name

$(translate 'Repository:') $PBS_REPO
$(translate 'Password:') $(translate 'Previously saved')" 12 80
        fi
    fi
    
    if ! $password_found; then
        dialog --backtitle "ProxMenux" --title "Password Required" --msgbox "$(translate 'Password not found for:') $pbs_name
$(translate 'Please enter the password.')" 10 60
        get_pbs_password "$pbs_name" || return 1
    fi
    
    clear
fi
}










# ========== PBS BACKUP ==========
backup_full_pbs_root() {
    local HOSTNAME PBS_REPO PBS_KEY_FILE PBS_PASS_FILE PBS_TOKEN_FILE PBS_ENCRYPTION_PASS_FILE ENCRYPT_OPT=""
    HOSTNAME=$(hostname)
    

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    LOGFILE="/tmp/pbs-backup-${HOSTNAME}.log"


    configure_pbs_repository || return 1

    if [[ ! -f "$PBS_REPO_FILE" ]]; then
        msg_error "$(translate "Failed to configure PBS connection")"
        sleep 3
        return 1
    fi
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        sleep 3
        return 1
    fi

  
    dialog --backtitle "ProxMenux" --title "Encryption" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then

        if [[ ! -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
            while true; do
                PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 12 70 "" 3>&1 1>&2 2>&3) || return 1
                PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --title "Encryption Password" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                fi
            done


            {
                echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
            } >/dev/null 2>&1
            
            dialog --backtitle "ProxMenux" --title "Success" --msgbox "$(translate 'Encryption password saved successfully!')" 8 50
        fi
        

        if [[ ! -f "$PBS_KEY_FILE" ]]; then
            PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
            
            dialog --backtitle "ProxMenux" --title "Encryption" --infobox "$(translate 'Creating encryption key...')" 5 50
            
            expect -c "
            set timeout 30
            spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
            expect {
                \"Encryption Key Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                \"Verify Password:\" {
                    send \"$PBS_ENCRYPTION_PASS\r\"
                    exp_continue
                }
                eof
            }
            " >/dev/null 2>&1

            if [[ ! -f "$PBS_KEY_FILE" ]]; then
                dialog --backtitle "ProxMenux" --title "Error" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                return 1
            fi
            
            dialog --backtitle "ProxMenux" --title "Important" --msgbox "$(translate 'IMPORTANT: Save the key file. Without it you will not be able to restore your backups!')\n\n$(translate 'Key file location:') $PBS_KEY_FILE" 12 70
        fi
        ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
    else
        ENCRYPT_OPT=""
    fi


    clear
    show_proxmenux_logo
    echo -e
    msg_info2 "$(translate "Starting backup to PBS")"
    echo -e
    echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
    echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
    echo -e "${BL}$(translate "Included:")${WHITE} /boot/efi /etc/pve (all root)${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
    

    case "$AUTH_TYPE" in
        "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
        "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
        "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
    esac
    
    echo -e "${BL}$(translate "Log file:")${WHITE} $LOGFILE${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
    echo ""


    local backup_cmd="proxmox-backup-client backup --include-dev /boot/efi --include-dev /etc/pve root-${HOSTNAME}.pxar:/ --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$HOSTNAME\" --backup-time \"$(date +%s)\""
    local backup_result=0
    
    case "$AUTH_TYPE" in
        "pbs_cloud")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with PBS Cloud...")"
                echo ""
                
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else

                echo "$(translate "Starting unencrypted full backup with PBS Cloud...")"
                echo ""
                env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "token")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with API Token...")"
                echo ""
                
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
                echo "$(translate "Starting unencrypted full backup with API Token...")"
                echo ""
                env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd" | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
            
        "password")

            if [[ -n "$ENCRYPT_OPT" ]]; then
                PBS_ENCRYPTION_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                echo "$(translate "Starting encrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    \"Encryption Key Password:\" {
                        send \"$PBS_ENCRYPTION_PASS\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            else
            
                echo "$(translate "Starting unencrypted full backup with password...")"
                echo ""
                
                env -i expect -c "
                set timeout 3600
                log_file $LOGFILE
                spawn $backup_cmd
                expect {
                    -re \"Password for .*:\" {
                        send \"$PBS_AUTH_VALUE\r\"
                        exp_continue
                    }
                    -re \"Are you sure you want to continue connecting.*\" {
                        send \"y\r\"
                        exp_continue
                    }
                    eof
                }
                " | tee -a "$LOGFILE"
                backup_result=${PIPESTATUS[0]}
            fi
            ;;
    esac

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    if [[ $backup_result -eq 0 ]]; then
        msg_ok "$(translate "Full backup process completed successfully")"
    else
        msg_error "$(translate "Backup process finished with errors")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}














backup_to_pbs() {
    local HOSTNAME TIMESTAMP SNAPSHOT
    HOSTNAME=$(hostname)
    TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
    SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"

    local PBS_REPO_FILE="/usr/local/share/proxmenux/pbs-repo.conf"
    local PBS_KEY_FILE="/usr/local/share/proxmenux/pbs-key.conf"
    local PBS_PASS_FILE="/usr/local/share/proxmenux/pbs-pass.txt"
    local PBS_TOKEN_FILE="/usr/local/share/proxmenux/pbs-token.txt"
    local PBS_ENCRYPTION_PASS_FILE="/usr/local/share/proxmenux/pbs-encryption-pass.txt"
    local PBS_REPO ENCRYPT_OPT USE_ENCRYPTION
    local PBS_KEY_PASS PBS_REPO_PASS

    configure_pbs_repository || return 1
    PBS_REPO=$(<"$PBS_REPO_FILE")


    unset PBS_PASSWORD PBS_API_TOKEN PBS_API_TOKEN_ID PBS_API_TOKEN_SECRET PBS_FINGERPRINT

    USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    [[ $? -eq 0 ]] && USE_ENCRYPTION=true

    if $USE_ENCRYPTION && ! command -v expect >/dev/null 2>&1; then
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y expect >/dev/null 2>&1
    fi

    if [[ "$#" -lt 1 ]]; then
        clear
        show_proxmenux_logo
        msg_error "$(translate "No directories specified for backup.")"
        sleep 2 
        return 1
    fi

    local TOTAL="$#"
    local COUNT=1


    local AUTH_TYPE="password"  
    local PBS_AUTH_VALUE=""
    
    if [[ "$PBS_REPO" == *"@pbs!"* ]]; then

        AUTH_TYPE="pbs_cloud"
        [[ -f "$PBS_PASS_FILE" ]] && PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    elif [[ -f "$PBS_TOKEN_FILE" ]]; then

        AUTH_TYPE="token"
        PBS_AUTH_VALUE=$(<"$PBS_TOKEN_FILE")
    elif [[ -f "$PBS_PASS_FILE" ]]; then

        AUTH_TYPE="password"
        PBS_AUTH_VALUE=$(<"$PBS_PASS_FILE")
    else
        msg_error "$(translate "No PBS authentication found!")"
        return 1
    fi

    for dir in "$@"; do
        local SAFE_NAME SAFE_ID PXAR_NAME
        SAFE_NAME=$(basename "$dir" | tr '.-/' '_')
        PXAR_NAME="root-custom-${SAFE_NAME}-${SNAPSHOT}.pxar"
        SAFE_ID="custom-${HOSTNAME}-${SAFE_NAME}"

        msg_info2 "$(translate "[$COUNT/$TOTAL] Backing up") $dir $(translate "as") $PXAR_NAME"

        ENCRYPT_OPT=""

        if $USE_ENCRYPTION; then
            if [[ -f "$PBS_KEY_FILE" ]]; then
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
            else
                while true; do
                    PBS_KEY_PASS=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter encryption password (different from PBS login):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    PBS_KEY_PASS2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption password:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$PBS_KEY_PASS" == "$PBS_KEY_PASS2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passwords do not match! Please try again.')" 8 50
                    fi
                done

                {
                    echo "$PBS_KEY_PASS" > "$PBS_ENCRYPTION_PASS_FILE"
                    chmod 600 "$PBS_ENCRYPTION_PASS_FILE"
                } >/dev/null 2>&1

                expect -c "
                set timeout 30
                spawn proxmox-backup-client key create \"$PBS_KEY_FILE\"
                expect {
                    \"Encryption Key Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    \"Verify Password:\" {
                        send \"$PBS_KEY_PASS\r\"
                        exp_continue
                    }
                    eof
                }
                " >/dev/null 2>&1

                if [[ ! -f "$PBS_KEY_FILE" ]]; then
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Error creating encryption key.')" 8 40
                    return 1
                fi
                ENCRYPT_OPT="--keyfile $PBS_KEY_FILE"
                dialog --backtitle "ProxMenux" --msgbox "$(translate 'Encryption key generated. Save it in a safe place!')" 10 60
            fi
        fi

        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Starting backup to PBS")"
        TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
        TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")
        echo -e
        echo -e "${BL}$(translate "PBS Repository:")${WHITE} $PBS_REPO${RESET}"
        echo -e "${BL}$(translate "Backup ID:")${WHITE} $HOSTNAME${RESET}"
        echo -e "${BL}$(translate "Encryption:")${WHITE} $([[ -n "$ENCRYPT_OPT" ]] && echo "Enabled" || echo "Disabled")${RESET}"
        
        case "$AUTH_TYPE" in
            "pbs_cloud") echo -e "${BL}$(translate "Authentication:")${WHITE} PBS Cloud Token${RESET}" ;;
            "token") echo -e "${BL}$(translate "Authentication:")${WHITE} API Token${RESET}" ;;
            "password") echo -e "${BL}$(translate "Authentication:")${WHITE} Password${RESET}" ;;
        esac
        
        echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
        echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"


        local backup_cmd="proxmox-backup-client backup \"${PXAR_NAME}:$dir\" --repository \"$PBS_REPO\" $ENCRYPT_OPT --backup-type host --backup-id \"$SAFE_ID\" --backup-time \"$(date +%s)\""
        
        case "$AUTH_TYPE" in
            "pbs_cloud")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_PASSWORD="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "token")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i PBS_API_TOKEN="$PBS_AUTH_VALUE" bash -c "$backup_cmd"
                fi
                ;;
                
            "password")

                if $USE_ENCRYPTION && [[ -f "$PBS_ENCRYPTION_PASS_FILE" ]]; then
                    PBS_KEY_PASS=$(<"$PBS_ENCRYPTION_PASS_FILE")
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        \"Encryption Key Password:\" {
                            send \"$PBS_KEY_PASS\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                else
                    env -i expect -c "
                    set timeout 300
                    spawn $backup_cmd
                    expect {
                        -re \"Password for .*:\" {
                            send \"$PBS_AUTH_VALUE\r\"
                            exp_continue
                        }
                        -re \"Are you sure you want to continue connecting.*\" {
                            send \"y\r\"
                            exp_continue
                        }
                        eof
                    }
                    "
                fi
                ;;
        esac

        COUNT=$((COUNT+1))
    done

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    msg_ok "$(translate "Backup process finished.")"
    echo ""
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================







# ========== BORGBACKUP ==========
backup_with_borg() {
    local BORG_APPIMAGE="/usr/local/share/proxmenux/borg"
    local LOGFILE="/tmp/borg-backup.log"
    local BORG_PASS_FILE="/usr/local/share/proxmenux/borg-pass.txt"
    local BORG_KEY_FILE="/usr/local/share/proxmenux/borg-key"
    local DEST
    local TYPE
    local ENCRYPT_OPT=""
    local BORG_KEY

    # Descargar BorgBackup si no existe
    if [[ ! -x "$BORG_APPIMAGE" ]]; then
        clear
        show_proxmenux_logo
        msg_info "$(translate "BorgBackup not found. Downloading AppImage...")"
        mkdir -p /usr/local/share/proxmenux
        wget -qO "$BORG_APPIMAGE" "https://github.com/borgbackup/borg/releases/download/1.2.8/borg-linux64"
        chmod +x "$BORG_APPIMAGE"
        msg_ok "$(translate "BorgBackup downloaded and ready.")"
    fi

    # Seleccionar tipo de destino
    TYPE=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select Borg backup destination:')" 15 60 4 \
        "local"   "$(translate 'Local directory')" \
        "usb"     "$(translate 'Internal/External dedicated disk')" \
        "remote"  "$(translate 'Remote server (SSH)')" \
        "pbs"     "$(translate 'PBS-host.de Cloud')" \
        3>&1 1>&2 2>&3) || return 1

    # Configurar destino segÃºn el tipo seleccionado
    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter local directory for backup:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        mkdir -p "$DEST"
        
    elif [[ "$TYPE" == "usb" ]]; then
        while true; do
            BASE_DEST=$(get_external_backup_mount_point)
            if [[ -z "$BASE_DEST" ]]; then
                dialog --backtitle "ProxMenux" --yesno "$(translate 'No external disk detected or mounted. Would you like to retry?')" 8 60
                [[ $? -eq 0 ]] && continue
                return 1
            fi

            DEST="$BASE_DEST/borgbackup"
            mkdir -p "$DEST"

            DISK_DEV=$(df "$BASE_DEST" | awk 'NR==2{print $1}')
            PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
            [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
            if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
                DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
            else
                DISK_MODEL="(unknown)"
            fi
            FREE_SPACE=$(df -h "$BASE_DEST" | awk 'NR==2{print $4}')

            dialog --backtitle "ProxMenux" \
                --title "$(translate "Dedicated Backup Disk")" \
                --yesno "\n$(translate "Mount point:") $DEST\n\n\
            $(translate "Disk model:") $DISK_MODEL\n\
            $(translate "Available space:") $FREE_SPACE\n\n\
            $(translate "Use this disk for backup?")" 12 70

            if [[ $? -eq 0 ]]; then
                break
            else
                return 1
            fi
        done
        
    elif [[ "$TYPE" == "remote" ]]; then
        # Servidor SSH remoto genÃ©rico
        REMOTE_USER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH user for remote:')" 10 60 "root" 3>&1 1>&2 2>&3) || return 1
        REMOTE_HOST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter SSH host:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        REMOTE_PATH=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter remote path:')" 10 60 "/backup/borgbackup" 3>&1 1>&2 2>&3) || return 1
        
        # Preguntar por clave SSH
        dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to use SSH key authentication?')" 8 60
        if [[ $? -eq 0 ]]; then
            SSH_KEY=$(dialog --backtitle "ProxMenux" --fselect "$HOME/.ssh/" 10 60 3>&1 1>&2 2>&3) || return 1
            export BORG_RSH="ssh -i $SSH_KEY"
        fi
        
        DEST="ssh://$REMOTE_USER@$REMOTE_HOST:$REMOTE_PATH"
        
    elif [[ "$TYPE" == "pbs" ]]; then
        # âœ… PBS-host.de Cloud - CAMPOS LIMPIOS
        PBS_CUSTOMER_ID=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter PBS customer ID (from Connect panel):')" 10 70 "" 3>&1 1>&2 2>&3) || return 1
        PBS_SERVER=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter PBS server (from Connect panel):')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
        
        # âœ… AUTO-DETECTAR CLAVES SSH DISPONIBLES
        local SSH_KEYS=()
        local SSH_KEY_NAMES=()
        
        # Buscar claves SSH comunes
        for key_file in ~/.ssh/id_rsa ~/.ssh/id_ed25519 ~/.ssh/pbs_host_key ~/.ssh/id_ecdsa; do
            if [[ -f "$key_file" && -f "${key_file}.pub" ]]; then
                SSH_KEYS+=("$key_file")
                local key_type=$(head -1 "${key_file}.pub" | awk '{print $1}')
                local key_comment=$(head -1 "${key_file}.pub" | awk '{print $3}')
                SSH_KEY_NAMES+=("$(basename "$key_file") ($key_type) - $key_comment")
            fi
        done
        
        # Si no hay claves, ofrecer crear una
        if [[ ${#SSH_KEYS[@]} -eq 0 ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'No SSH keys found. Do you want to create one now?')" 8 60
            if [[ $? -eq 0 ]]; then
                clear
                show_proxmenux_logo
                echo -e
                msg_info2 "$(translate "Creating SSH key for PBS-host.de...")"
                
                # Crear clave SSH especÃ­fica para PBS
                ssh-keygen -t rsa -b 4096 -f ~/.ssh/pbs_host_key -N "" -C "pbs-backup-$(hostname)"
                
                if [[ $? -eq 0 ]]; then
                    SSH_KEY="$HOME/.ssh/pbs_host_key"
                    msg_ok "$(translate "SSH key created successfully!")"
                else
                    msg_error "$(translate "Failed to create SSH key")"
                    return 1
                fi
            else
                return 1
            fi
        elif [[ ${#SSH_KEYS[@]} -eq 1 ]]; then
            # Solo una clave disponible, usarla automÃ¡ticamente
            SSH_KEY="${SSH_KEYS[0]}"
        else
            # MÃºltiples claves, permitir selecciÃ³n
            local menu_options=()
            for i in "${!SSH_KEYS[@]}"; do
                menu_options+=("$i" "${SSH_KEY_NAMES[$i]}")
            done
            
            local choice
            choice=$(dialog --backtitle "ProxMenux" --menu "$(translate 'Select SSH key to use:')" 15 80 10 "${menu_options[@]}" 3>&1 1>&2 2>&3) || return 1
            SSH_KEY="${SSH_KEYS[$choice]}"
        fi
        
        export BORG_RSH="ssh -i $SSH_KEY"
        DEST="$PBS_CUSTOMER_ID@$PBS_SERVER:./borg"
        
        # âœ… MOSTRAR INFORMACIÃ“N Y CLAVE PÃšBLICA AUTOMÃTICAMENTE
        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "PBS-host.de Configuration")"
        echo -e "${BL}$(translate "Server:")${WHITE} $PBS_SERVER${RESET}"
        echo -e "${BL}$(translate "Customer ID:")${WHITE} $PBS_CUSTOMER_ID${RESET}"
        echo -e "${BL}$(translate "SSH Key:")${WHITE} $SSH_KEY${RESET}"
        echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"
        echo ""
        
        # Verificar permisos de la clave SSH
        chmod 600 "$SSH_KEY"
        
        # âœ… MOSTRAR CLAVE PÃšBLICA AUTOMÃTICAMENTE
        local SSH_PUB_KEY="${SSH_KEY}.pub"
        if [[ -f "$SSH_PUB_KEY" ]]; then
            echo -e "${BL}$(translate "Your SSH Public Key:")${RESET}"
            echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}"
            echo -e "${WHITE}$(cat "$SSH_PUB_KEY")${RESET}"
            echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}"
            echo ""
            
            # âœ… OFRECER COPIAR AL PORTAPAPELES (si xclip estÃ¡ disponible)
            if command -v xclip >/dev/null 2>&1; then
                echo -e "${BL}$(translate "Copying to clipboard...")${RESET}"
                cat "$SSH_PUB_KEY" | xclip -selection clipboard
                msg_ok "$(translate "Public key copied to clipboard!")"
            elif command -v pbcopy >/dev/null 2>&1; then
                echo -e "${BL}$(translate "Copying to clipboard...")${RESET}"
                cat "$SSH_PUB_KEY" | pbcopy
                msg_ok "$(translate "Public key copied to clipboard!")"
            fi
            
            echo ""
            echo -e "${BL}$(translate "INSTRUCTIONS:")${RESET}"
            echo "1. $(translate "Copy the key above (or use clipboard if available)")"
            echo "2. $(translate "Go to PBS-host.de panel â†’ Your datastore â†’ Connect")"
            echo "3. $(translate "Select 'rsync / borg / sftp' tab")"
            echo "4. $(translate "Paste the key in 'Save SSH Key' section")"
            echo "5. $(translate "Click 'Save'")"
            echo ""
            
            # âœ… PAUSA PARA QUE EL USUARIO PUEDA COPIAR LA CLAVE
            msg_success "$(translate "Press Enter when you have uploaded the key to PBS-host.de panel...")"
            read -r
        fi
        
        # âœ… VERIFICAR CONEXIÃ“N CON MEJOR FEEDBACK
        clear
        show_proxmenux_logo
        echo -e
        msg_info2 "$(translate "Testing connection to PBS-host.de...")"
        echo ""
        
        echo "$(translate "Connecting... (you may need to type 'yes' to accept the server fingerprint)")"
        echo ""
        
        # Test de conexiÃ³n con timeout y mejor manejo
        if timeout 30 ssh -i "$SSH_KEY" -o ConnectTimeout=10 -o BatchMode=no "$PBS_CUSTOMER_ID@$PBS_SERVER" borg --version >/dev/null 2>&1; then
            echo ""
            msg_ok "$(translate "âœ… Connection successful! Borg is available on the server.")"
            sleep 2
        else
            echo ""
            msg_error "$(translate "âŒ Connection failed or requires manual intervention.")"
            echo ""
            echo -e "${BL}$(translate "This could be normal if:")${RESET}"
            echo "â€¢ $(translate "First time connecting (need to accept fingerprint)")"
            echo "â€¢ $(translate "Key not yet uploaded to PBS-host.de panel")"
            echo "â€¢ $(translate "Network connectivity issues")"
            echo ""
            
            dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to continue anyway? The backup will test the connection again.')" 10 70
            if [[ $? -ne 0 ]]; then
                return 1
            fi
        fi
    fi

    # âœ… MANEJO DE ENCRIPTACIÃ“N CON CONTRASEÃ‘A PERSISTENTE
    local USE_ENCRYPTION=false
    dialog --backtitle "ProxMenux" --yesno "$(translate 'Do you want to encrypt the backup?')" 8 60
    if [[ $? -eq 0 ]]; then
        USE_ENCRYPTION=true
        ENCRYPT_OPT="--encryption=repokey"
        
        # Verificar si ya existe una contraseÃ±a guardada
        if [[ -f "$BORG_PASS_FILE" ]]; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'A saved encryption passphrase exists. Use it?')" 8 60
            if [[ $? -eq 0 ]]; then
                BORG_KEY=$(<"$BORG_PASS_FILE")
            else
                # Pedir nueva contraseÃ±a
                while true; do
                    BORG_KEY=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter Borg encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    BORG_KEY2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                    
                    if [[ "$BORG_KEY" == "$BORG_KEY2" ]]; then
                        break
                    else
                        dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passphrases do not match! Please try again.')" 8 50
                    fi
                done
                
                # Guardar la nueva contraseÃ±a
                mkdir -p "$(dirname "$BORG_PASS_FILE")"
                echo "$BORG_KEY" > "$BORG_PASS_FILE"
                chmod 600 "$BORG_PASS_FILE"
            fi
        else
            # No hay contraseÃ±a guardada, pedir una nueva
            while true; do
                BORG_KEY=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Enter Borg encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                BORG_KEY2=$(dialog --backtitle "ProxMenux" --insecure --passwordbox "$(translate 'Confirm encryption passphrase:')" 10 60 "" 3>&1 1>&2 2>&3) || return 1
                
                if [[ "$BORG_KEY" == "$BORG_KEY2" ]]; then
                    break
                else
                    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Passphrases do not match! Please try again.')" 8 50
                fi
            done
            
            # Guardar la contraseÃ±a
            mkdir -p "$(dirname "$BORG_PASS_FILE")"
            echo "$BORG_KEY" > "$BORG_PASS_FILE"
            chmod 600 "$BORG_PASS_FILE"
        fi
        
        export BORG_PASSPHRASE="$BORG_KEY"
    else
        ENCRYPT_OPT="--encryption=none"
    fi

    # âœ… INICIALIZAR REPOSITORIO SI ES NECESARIO
    if [[ "$TYPE" == "local" || "$TYPE" == "usb" ]]; then
        if [[ ! -f "$DEST/config" ]]; then
            dialog --backtitle "ProxMenux" --infobox "$(translate 'Initializing Borg repository...')" 5 50
            "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
            if [[ $? -ne 0 ]]; then
                clear
                show_proxmenux_logo
                msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                sleep 5
                return 1
            fi
        fi
    elif [[ "$TYPE" == "remote" || "$TYPE" == "pbs" ]]; then
        # Verificar si el repositorio existe o necesita inicializaciÃ³n
        if ! "$BORG_APPIMAGE" list "$DEST" >/dev/null 2>&1; then
            dialog --backtitle "ProxMenux" --yesno "$(translate 'Repository does not exist or is not accessible. Initialize it?')" 8 60
            if [[ $? -eq 0 ]]; then
                dialog --backtitle "ProxMenux" --infobox "$(translate 'Initializing Borg repository...')" 5 50
                "$BORG_APPIMAGE" init $ENCRYPT_OPT "$DEST"
                if [[ $? -ne 0 ]]; then
                    clear
                    show_proxmenux_logo
                    msg_error "$(translate "Failed to initialize Borg repo at") $DEST"
                    sleep 5
                    return 1
                fi
            else
                return 1
            fi
        fi
    fi

    # âœ… CONFIRMACIÃ“N ANTES DE INICIAR BACKUP
    dialog --backtitle "ProxMenux" --msgbox "$(translate 'Borg backup will start now. This may take a while.')" 8 40

    # âœ… MOSTRAR INFORMACIÃ“N DEL BACKUP
    clear
    show_proxmenux_logo
    msg_info2 "$(translate "Starting backup with BorgBackup...")"
    echo -e

    TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
    TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

    echo -e "${BL}$(translate "Destination:")${WHITE} $DEST${RESET}"
    echo -e "${BL}$(translate "Encryption:")${WHITE} $($USE_ENCRYPTION && echo "Enabled" || echo "Disabled")${RESET}"
    echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
    echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"
    echo -e "${BOLD}${NEON_PURPLE_BLUE}-------------------------------${RESET}"

    # âœ… EJECUTAR EL BACKUP
    local ARCHIVE_NAME="root-$(hostname)-$(date +%Y%m%d_%H%M)"
    
    "$BORG_APPIMAGE" create --progress --stats --compression zstd "$DEST"::$ARCHIVE_NAME "$@" 2>&1 | tee "$LOGFILE"
    local BACKUP_RESULT=$?

    echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
    
    if [[ $BACKUP_RESULT -eq 0 ]]; then
        msg_ok "$(translate "Backup completed successfully!")"
        
        # Mostrar informaciÃ³n del backup
        echo -e "\n${BL}$(translate "Backup information:")${RESET}"
        "$BORG_APPIMAGE" info "$DEST"::$ARCHIVE_NAME 2>&1 | tee -a "$LOGFILE"
        
        # Sugerir compactaciÃ³n para ahorrar espacio
        if [[ "$TYPE" == "remote" || "$TYPE" == "pbs" ]]; then
            echo -e "\n${BL}$(translate "Tip:")${RESET} $(translate "Run 'borg compact $DEST' to free up space after multiple backups.")"
        fi
    else
        msg_error "$(translate "Backup process failed with error code:") $BACKUP_RESULT"
    fi
    
    echo
    msg_success "$(translate "Press Enter to return to the main menu...")"
    read -r
}
# ===============================




# ========== LOCAL TAR ==========
backup_to_local_tar() {
#    local SRC="$1"
    local TYPE
    local DEST
    local LOGFILE="/tmp/tar-backup.log"


if ! command -v pv &>/dev/null; then
    apt-get update -qq && apt-get install -y pv >/dev/null 2>&1
fi



    TYPE=$(dialog --backtitle "ProxMenux"  --menu "$(translate 'Select backup destination:')" 15 60 2 \
        "local" "$(translate 'Local directory')" \
        "usb"   "$(translate 'Internal/External dedicated disk')" \
        3>&1 1>&2 2>&3) || return 1

    if [[ "$TYPE" == "local" ]]; then
        DEST=$(dialog --backtitle "ProxMenux" --inputbox "$(translate 'Enter directory for backup:')" 10 60 "/backup" 3>&1 1>&2 2>&3) || return 1

        mkdir -p "$DEST"


else


while true; do
    DEST=$(get_external_backup_mount_point)
    if [[ -z "$DEST" ]]; then
        dialog --backtitle "ProxMenux" --yesno "No external disk detected or mounted. Would you like to retry?" 8 60
        [[ $? -eq 0 ]] && continue
        return 1
    fi

    DISK_DEV=$(df "$DEST" | awk 'NR==2{print $1}')
    PKNAME=$(lsblk -no PKNAME "$DISK_DEV" 2>/dev/null)
    [[ -z "$PKNAME" ]] && PKNAME=$(basename "$DISK_DEV" | sed 's/[0-9]*$//')
    if [[ -n "$PKNAME" && -b /dev/$PKNAME ]]; then
        DISK_MODEL=$(lsblk -no MODEL "/dev/$PKNAME")
    else
        DISK_MODEL="(unknown)"
    fi
    FREE_SPACE=$(df -h "$DEST" | awk 'NR==2{print $4}')



    dialog --backtitle "ProxMenux" \
    --title "$(translate "Dedicated Backup Disk")" \
    --yesno "\n$(translate "Mount point:") $DEST\n\n\
    $(translate "Disk model:") $DISK_MODEL\n\
    $(translate "Available space:") $FREE_SPACE\n\n\
    $(translate "Use this disk for backup?")" 12 70


    if [[ $? -eq 0 ]]; then
        mkdir -p "$DEST"
        break
    else
        return 1
    fi
done



fi


TAR_INPUT=""
TOTAL_SIZE=0
for src in $SRC; do
    sz=$(du -sb "$src" 2>/dev/null | awk '{print $1}')
    TOTAL_SIZE=$((TOTAL_SIZE + sz))
    TAR_INPUT="$TAR_INPUT $src"
done

local FILENAME="root-$(hostname)-$(date +%Y%m%d_%H%M).tar.gz"
clear
show_proxmenux_logo
msg_info2 "$(translate "Starting backup with tar...")"
echo -e


TOTAL_SIZE=$(du -cb "$@" | awk '/total$/ {print $1}')
TOTAL_SIZE_GB=$(awk "BEGIN {printf \"%.2f\", $TOTAL_SIZE/1024/1024/1024}")

echo -e "${BL}$(translate "Included directories:")${WHITE} $*${RESET}"
echo -e "${BL}$(translate "Total size:")${WHITE} ${TOTAL_SIZE_GB} GB${RESET}"

tar -cf - "$@" 2> >(grep -v "Removing leading \`/'" >&2) \
| pv -s "$TOTAL_SIZE" \
| gzip > "$DEST/$FILENAME"


echo -ne "\033[1A\r\033[K"

echo -e "${BOLD}${NEON_PURPLE_BLUE}===============================${RESET}\n"
msg_ok "$(translate "Backup process finished. Review log above or in /tmp/tar-backup.log")"
echo
msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

}
# ===============================


host_backup_menu



================================================
FILE: scripts/backup_restore/mount_disk_host_bk.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - Mount disk on Proxmox host for backups
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 1.3-dialog
# Last Updated: 13/12/2024
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache


mount_disk_host_bk() {



get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}


is_usb_disk() {
    local disk=$1
    local disk_name=$(basename "$disk")
    

    if readlink -f "/sys/block/$disk_name/device" 2>/dev/null | grep -q "usb"; then
        return 0 
    fi
    

    if udevadm info --query=property --name="$disk" 2>/dev/null | grep -q "ID_BUS=usb"; then
        return 0  
    fi
    
    return 1
}


is_system_disk() {
    local disk=$1
    local disk_name=$(basename "$disk")
    

    local system_mounts=$(df -h | grep -E '^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(/|/boot|/usr|/var|/home)$' | awk '{print $1}')
    

    for mount_dev in $system_mounts; do
   
        local mount_disk=""
        if [[ "$mount_dev" =~ ^/dev/mapper/ ]]; then
     
            local vg_name=$(lvs --noheadings -o vg_name "$mount_dev" 2>/dev/null | xargs)
            if [[ -n "$vg_name" ]]; then
                local pvs_list=$(pvs --noheadings -o pv_name -S vg_name="$vg_name" 2>/dev/null | xargs)
                for pv in $pvs_list; do
                    if [[ -n "$pv" && -e "$pv" ]]; then
                        mount_disk=$(lsblk -no PKNAME "$pv" 2>/dev/null)
                        if [[ -n "$mount_disk" && "/dev/$mount_disk" == "$disk" ]]; then
                            return 0  
                        fi
                    fi
                done
            fi
        elif [[ "$mount_dev" =~ ^/dev/[hsv]d[a-z][0-9]* || "$mount_dev" =~ ^/dev/nvme[0-9]+n[0-9]+p[0-9]+ ]]; then
      
            mount_disk=$(lsblk -no PKNAME "$mount_dev" 2>/dev/null)
            if [[ -n "$mount_disk" && "/dev/$mount_disk" == "$disk" ]]; then
                return 0  
            fi
        fi
    done
    

    local fs_type=$(lsblk -no FSTYPE "$disk" 2>/dev/null | head -1)
    if [[ "$fs_type" == "btrfs" ]]; then

        local temp_mount=$(mktemp -d)
        if mount -o ro "$disk" "$temp_mount" 2>/dev/null; then
   
            if btrfs subvolume list "$temp_mount" 2>/dev/null | grep -qE '(@|@home|@var|@boot|@root|root)'; then
                umount "$temp_mount" 2>/dev/null
                rmdir "$temp_mount" 2>/dev/null
                return 0  
            fi
            umount "$temp_mount" 2>/dev/null
        fi
        rmdir "$temp_mount" 2>/dev/null
        

        while read -r part; do
            if [[ -n "$part" ]]; then
                local part_fs=$(lsblk -no FSTYPE "/dev/$part" 2>/dev/null)
                if [[ "$part_fs" == "btrfs" ]]; then
                    local mount_point=$(lsblk -no MOUNTPOINT "/dev/$part" 2>/dev/null)
                    if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
                        return 0  
                    fi
                fi
            fi
        done < <(lsblk -ln -o NAME "$disk" | tail -n +2)
    fi
    

    local disk_uuid=$(blkid -s UUID -o value "$disk" 2>/dev/null)
    local part_uuids=()
    while read -r part; do
        if [[ -n "$part" ]]; then
            local uuid=$(blkid -s UUID -o value "/dev/$part" 2>/dev/null)
            if [[ -n "$uuid" ]]; then
                part_uuids+=("$uuid")
            fi
        fi
    done < <(lsblk -ln -o NAME "$disk" | tail -n +2)
    
 
    for uuid in "${part_uuids[@]}" "$disk_uuid"; do
        if [[ -n "$uuid" ]] && grep -q "UUID=$uuid" /etc/fstab; then
            local mount_point=$(grep "UUID=$uuid" /etc/fstab | awk '{print $2}')
            if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
                return 0  
            fi
        fi
    done
    

    if grep -q "$disk" /etc/fstab; then
        local mount_point=$(grep "$disk" /etc/fstab | awk '{print $2}')
        if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
            return 0 
        fi
    fi
    

    local disk_count=$(lsblk -dn -e 7,11 -o PATH | wc -l)
    if [[ "$disk_count" -eq 1 ]]; then
        return 0 
    fi
    
    return 1 
}


USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi

    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)

LVM_DEVICES=$(
    pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') |
    while read -r dev; do
        [[ -n "$dev" && -e "$dev" ]] && readlink -f "$dev"
    done | sort -u
)

FREE_DISKS=()

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false
    IS_SYSTEM=false
    IS_USB=false

 
    if is_system_disk "$DISK"; then
        IS_SYSTEM=true
    fi

  
    if is_usb_disk "$DISK"; then
        IS_USB=true
    fi

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=""
    if [[ -n "$DISK" && -e "$DISK" ]]; then
        REAL_PATH=$(readlink -f "$DISK")
    fi
    if [[ -n "$REAL_PATH" ]] && echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi

    USED_BY=""
    REAL_PATH=""
    if [[ -n "$DISK" && -e "$DISK" ]]; then
        REAL_PATH=$(readlink -f "$DISK")
    fi
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            [[ -e "$SYMLINK" ]] || continue
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi

    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi
    if $IS_ZFS; then SHOW_DISK=false; fi
    if $IS_MOUNTED; then SHOW_DISK=false; fi
    if $IS_SYSTEM; then SHOW_DISK=false; fi  

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
        
        
        if $IS_USB; then
            LABEL+="  USB"
        else
            LABEL+="  $(translate "Internal")"
        fi
        
        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "off")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)

if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    dialog --title "$(translate "Error")" --msgbox "$(translate "No available disks found on the host.")" 8 60
    
    exit 1
fi


# Building the array for dialog (format: tag item on/off tag item on/off...)
DLG_LIST=()
for ((i=0; i<${#FREE_DISKS[@]}; i+=3)); do
    DLG_LIST+=("${FREE_DISKS[i]}" "${FREE_DISKS[i+1]}" "${FREE_DISKS[i+2]}")
done

SELECTED=$(dialog --clear --backtitle "ProxMenux" --title "$(translate "Select Disk")" \
    --radiolist "\n$(translate "Select the disk you want to mount on the host:")" 20 90 10 \
    "${DLG_LIST[@]}" 2>&1 >/dev/tty)

if [ -z "$SELECTED" ]; then
    dialog --title "$(translate "Error")" --msgbox "$(translate "No disk was selected.")" 8 50
    
    exit 1
fi


# ------------------- Partitions and formatting ------------------------

PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')
SKIP_FORMAT=false
DEFAULT_MOUNT="/mnt/backup"

if [ -n "$PARTITION" ]; then
    PARTITION="/dev/$PARTITION"
    CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
      
    else
        dialog --title "$(translate "Unsupported Filesystem")" --yesno \
        "$(translate "The partition") $PARTITION $(translate "has an unsupported filesystem ($CURRENT_FS).\nDo you want to format it?")" 10 70
        if [ $? -ne 0 ]; then exit 0; fi
    fi
else
    CURRENT_FS=$(lsblk -no FSTYPE "$SELECTED" | xargs)
    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
        PARTITION="$SELECTED"

    else
        dialog --title "$(translate "No Valid Partitions")" --yesno \
        "$(translate "The disk has no partitions and no valid filesystem. Do you want to create a new partition and format it?")" 10 70
        if [ $? -ne 0 ]; then exit 0; fi

        echo -e "$(translate "Creating partition table and partition...")"
        parted -s "$SELECTED" mklabel gpt
        parted -s "$SELECTED" mkpart primary 0% 100%
        sleep 2
        partprobe "$SELECTED"
        sleep 2

        PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')
        if [ -n "$PARTITION" ]; then
            PARTITION="/dev/$PARTITION"
        else
            dialog --title "$(translate "Partition Error")" --msgbox \
            "$(translate "Failed to create partition on disk") $SELECTED." 8 70
            exit 1
        fi
    fi
fi

if [ "$SKIP_FORMAT" != true ]; then
    FORMAT_TYPE=$(dialog --title "$(translate "Select Format Type")" --menu \
        "$(translate "Select the filesystem type for") $PARTITION:" 15 60 5 \
        "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
        "xfs" "XFS" \
        "btrfs" "Btrfs" 2>&1 >/dev/tty)
    if [ -z "$FORMAT_TYPE" ]; then
        dialog --title "$(translate "Format Cancelled")" --msgbox \
        "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
        exit 0
    fi

    dialog --title "$(translate "WARNING")" --yesno \
    "$(translate "WARNING: This operation will FORMAT the disk") $PARTITION $(translate "with") $FORMAT_TYPE.\n\n$(translate "ALL DATA ON THIS DISK WILL BE PERMANENTLY LOST!")\n\n$(translate "Are you sure you want to continue")" 15 70
    if [ $? -ne 0 ]; then exit 0; fi

    echo -e "$(translate "Formatting partition") $PARTITION $(translate "with") $FORMAT_TYPE..."
    case "$FORMAT_TYPE" in
        "ext4") mkfs.ext4 -F "$PARTITION" ;;
        "xfs") mkfs.xfs -f "$PARTITION" ;;
        "btrfs") mkfs.btrfs -f "$PARTITION" ;;
    esac

    if [ $? -ne 0 ]; then
        cleanup
        dialog --title "$(translate "Format Failed")" --msgbox \
        "$(translate "Failed to format partition") $PARTITION $(translate "with") $FORMAT_TYPE." 12 70
        exit 1
    else
  
        partprobe "$SELECTED"
        sleep 2
    fi
fi


# ------------------- Mount point and permissions (modular, non-blocking) -------------------



    MOUNT_POINT=$(dialog --clear --title "$(translate "Mount Point")" \
        --inputbox "$(translate "Enter the mount point for the disk (e.g., /mnt/backup):")" \
        10 60 "$DEFAULT_MOUNT" 2>&1 >/dev/tty)

    if [ -z "$MOUNT_POINT" ]; then
        >&2 echo "$(translate "No mount point was specified.")"
        return 1
    fi

    mkdir -p "$MOUNT_POINT"

    UUID=$(blkid -s UUID -o value "$PARTITION")
    FS_TYPE=$(lsblk -no FSTYPE "$PARTITION" | xargs)
    FSTAB_ENTRY="UUID=$UUID $MOUNT_POINT $FS_TYPE defaults 0 0"

    if grep -q "UUID=$UUID" /etc/fstab; then
        sed -i "s|^.*UUID=$UUID.*|$FSTAB_ENTRY|" /etc/fstab
    else
        echo "$FSTAB_ENTRY" >> /etc/fstab
    fi

    mount "$MOUNT_POINT" 2> >(grep -v "systemd still uses")
    if [ $? -eq 0 ]; then
        if ! getent group sharedfiles >/dev/null; then
            groupadd sharedfiles
        fi

        chown root:sharedfiles "$MOUNT_POINT"
        chmod 2775 "$MOUNT_POINT"
        echo "$MOUNT_POINT" > /usr/local/share/proxmenux/last_backup_mount.txt

        MOUNT_POINT=$(echo "$MOUNT_POINT" | head -n1 | tr -d '\r\n\t ')
        echo "$MOUNT_POINT"
    else
        >&2 echo "$(translate "Failed to mount the disk at") $MOUNT_POINT"
        return 1
    fi

}



================================================
FILE: scripts/global/common-functions.sh
================================================
#!/bin/bash
# ==========================================================
# Common Functions for Proxmox VE Scripts
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache


get_pve_info() {
    local pve_full_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local pve_major=$(echo "$pve_full_version" | cut -d. -f1)
    local os_codename="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
    
    if [ -z "$os_codename" ]; then
        os_codename=$(lsb_release -cs 2>/dev/null)
    fi
    

    local target_codename
    if [ "$pve_major" -ge 9 ] 2>/dev/null; then
        target_codename="trixie"
    else
        target_codename="$os_codename"
        if [ -z "$target_codename" ]; then
            target_codename="bookworm"
        fi
    fi
    
    echo "$pve_full_version|$pve_major|$os_codename|$target_codename"
}


lvm_repair_check() {
    msg_info "$(translate "Checking and repairing old LVM PV headers (if needed)...")"
    
    if ! command -v pvs >/dev/null 2>&1; then
        msg_info "$(translate "LVM tools not available, skipping LVM check")"
        return
    fi
    
    pvs_output=$(LC_ALL=C pvs -v 2>&1 | grep "old PV header" || true)
    if [ -z "$pvs_output" ]; then
        msg_ok "$(translate "No PVs with old headers found.")"
        return
    fi
    
    declare -A vg_map
    while read -r line; do
        pv=$(echo "$line" | grep -o '/dev/[^ ]*' || true)
        if [ -n "$pv" ]; then
            vg=$(pvs -o vg_name --noheadings "$pv" 2>/dev/null | awk '{print $1}' || true)
            if [ -n "$vg" ]; then
                vg_map["$vg"]=1
            fi
        fi
    done <<< "$pvs_output"
    
    for vg in "${!vg_map[@]}"; do
        msg_warn "$(translate "Old PV header(s) found in VG $vg. Updating metadata...")"
        vgck --updatemetadata "$vg" 2>/dev/null
        vgchange -ay "$vg" 2>/dev/null
        if [ $? -ne 0 ]; then
            msg_warn "$(translate "Metadata update failed for VG $vg. Review manually.")"
        else
            msg_ok "$(translate "Metadata updated successfully for VG $vg")"
        fi
    done
    
    msg_ok "$(translate "LVM PV headers check completed")"
}




cleanup_duplicate_repos_pve9() {
    msg_info "$(translate "Cleaning up duplicate repositories...")"
    
    local sources_file="/etc/apt/sources.list"
    local temp_file=$(mktemp)
    local cleaned_count=0
    declare -A seen_repos
    
    if [ ! -s "$sources_file" ]; then
        return 0
    fi

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            echo "$line" >> "$temp_file"
            continue
        fi
        
        if [[ "$line" =~ ^deb ]]; then
            read -r _ url dist components <<< "$line"
            local key="${url}_${dist}"
            if [[ -v "seen_repos[$key]" ]]; then
                echo "# $line" >> "$temp_file"
                cleaned_count=$((cleaned_count + 1))
                msg_info "$(translate "Commented duplicate: $url $dist")"
            else
                echo "$line" >> "$temp_file"
                seen_repos[$key]="$components"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$sources_file"
    
    mv "$temp_file" "$sources_file"
    chmod 644 "$sources_file"
    

    if [ -f "/etc/apt/sources.list.d/proxmox.sources" ]; then

        

        if grep -q "^deb.*download\.proxmox\.com" "$sources_file"; then
            sed -i '/^deb.*download\.proxmox\.com/s/^/# /' "$sources_file"
            cleaned_count=$((cleaned_count + 1))
        fi
        
        for list_file in /etc/apt/sources.list.d/pve-*.list; do
            if [ -f "$list_file" ] && [[ "$list_file" != "/etc/apt/sources.list.d/pve-enterprise.list" ]]; then
                if grep -q "^deb" "$list_file"; then
                    sed -i 's/^deb/# deb/g' "$list_file"
                    cleaned_count=$((cleaned_count + 1))
                fi
            fi
        done
        
        if [ -f "/etc/apt/sources.list.d/debian.sources" ]; then

            if grep -q "^deb.*deb\.debian\.org" "$sources_file"; then
                sed -i '/^deb.*deb\.debian\.org/s/^/# /' "$sources_file"
                cleaned_count=$((cleaned_count + 1))

            fi
            
            if grep -q "^deb.*security\.debian\.org" "$sources_file"; then
                sed -i '/^deb.*security\.debian\.org/s/^/# /' "$sources_file"
                cleaned_count=$((cleaned_count + 1))

            fi
        fi
    fi
    

    if [ -f "/etc/apt/sources.list.d/proxmox.sources" ]; then
        for old_file in /etc/apt/sources.list.d/pve-public-repo.list /etc/apt/sources.list.d/pve-install-repo.list; do
            if [ -f "$old_file" ]; then
                rm -f "$old_file"
                cleaned_count=$((cleaned_count + 1))

            fi
        done
    fi
    
    if [ $cleaned_count -gt 0 ]; then
        msg_ok "$(translate "Cleaned up $cleaned_count duplicate/old repositories")"
        apt-get update > /dev/null 2>&1 || true
    else
        msg_ok "$(translate "No duplicate repositories found")"
    fi
}
        


cleanup_duplicate_repos_pve9_() {
    msg_info "$(translate "Cleaning up duplicate repositories...")"
    
    local sources_file="/etc/apt/sources.list"
    local temp_file=$(mktemp)
    local cleaned_count=0
    declare -A seen_repos

    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
            echo "$line" >> "$temp_file"
            continue
        fi

        if [[ "$line" =~ ^deb ]]; then
            read -r _ url dist components <<< "$line"
            local key="${url}_${dist}"
            if [[ -v "seen_repos[$key]" ]]; then
                echo "# $line" >> "$temp_file"
                cleaned_count=$((cleaned_count + 1))
            else
                echo "$line" >> "$temp_file"
                seen_repos[$key]="$components"
            fi
        else
            echo "$line" >> "$temp_file"
        fi
    done < "$sources_file"

    mv "$temp_file" "$sources_file"
    chmod 644 "$sources_file"

    for src in proxmox debian ceph; do
        local sources_path="/etc/apt/sources.list.d/${src}.sources"
        if [ -f "$sources_path" ]; then
            case "$src" in
                proxmox)
                    url_match="download.proxmox.com"
                    ;;
                debian)
                    url_match="deb.debian.org"
                    ;;
                ceph)
                    url_match="download.proxmox.com/ceph"
                    ;;
                *)
                    url_match=""
                    ;;
            esac

            if [[ -n "$url_match" ]]; then
                if grep -q "^deb.*$url_match" "$sources_file"; then
                    sed -i "/^deb.*$url_match/s/^/# /" "$sources_file"
                    cleaned_count=$((cleaned_count + 1))
                fi
            fi

            for list_file in /etc/apt/sources.list.d/*.list; do
                [[ -f "$list_file" ]] || continue
                if grep -q "^deb.*$url_match" "$list_file"; then
                    sed -i "/^deb.*$url_match/s/^/# /" "$list_file"
                    cleaned_count=$((cleaned_count + 1))
                fi
            done
        fi
    done

    if [ $cleaned_count -gt 0 ]; then
        msg_ok "$(translate "Cleaned up $cleaned_count duplicate/old repositories")"
        apt-get update > /dev/null 2>&1 || true
    else
        msg_ok "$(translate "No duplicate repositories found")"
    fi
}





cleanup_duplicate_repos_pve8() {
    msg_info "$(translate "Cleaning up duplicate repositories...")"

    local cleaned_count=0
    local sources_file="/etc/apt/sources.list"


    if [[ -f "$sources_file" ]]; then
        local temp_file
        temp_file=$(mktemp)
        declare -A seen_repos

        while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "$line" ]]; then
                echo "$line" >> "$temp_file"
                continue
            fi

            if [[ "$line" =~ ^[[:space:]]*deb ]]; then
                read -r _ url dist components <<< "$line"
                local key="${url}_${dist}"
                if [[ -v "seen_repos[$key]" ]]; then
                    echo "# $line" >> "$temp_file"
                    cleaned_count=$((cleaned_count + 1))
                else
                    echo "$line" >> "$temp_file"
                    seen_repos[$key]="$components"
                fi
            else
                echo "$line" >> "$temp_file"
            fi
        done < "$sources_file"

        mv "$temp_file" "$sources_file"
        chmod 644 "$sources_file"
    fi


    local old_pve_files=(/etc/apt/sources.list.d/pve-*.list /etc/apt/sources.list.d/proxmox.list)

    for file in "${old_pve_files[@]}"; do
        if [[ -f "$file" ]]; then
            local base_name
            base_name=$(basename "$file" .list)
            local sources_equiv="/etc/apt/sources.list.d/${base_name}.sources"

            if [[ -f "$sources_equiv" ]] && grep -q "^Enabled: *true" "$sources_equiv"; then
                msg_info "$(translate "Removing old repository file: $(basename "$file")")"
                rm -f "$file"
                cleaned_count=$((cleaned_count + 1))
            fi
        fi
    done


    if [ "$cleaned_count" -gt 0 ]; then
        msg_ok "$(translate "Cleaned up $cleaned_count duplicate/old repositories")"
        apt-get update > /dev/null 2>&1 || true
    else
        msg_ok "$(translate "No duplicate repositories found")"
    fi
}



cleanup_duplicate_repos() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

    if [[ -z "$pve_version" ]]; then
        msg_error "Unable to detect Proxmox version."
        return 1
    fi

    if [[ "$pve_version" -ge 9 ]]; then
        cleanup_duplicate_repos_pve9
    else
        cleanup_duplicate_repos_pve8
    fi
}



================================================
FILE: scripts/global/remove-banner-pve-v3.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE (v3 - Minimal Intrusive)
# ==========================================================
# This version makes a surgical change to the checked_command function
# by changing the condition to 'if (false)' and commenting out the banner logic.
# Also patches the mobile UI to remove the subscription dialog.
# ==========================================================

set -euo pipefail

# Source utilities if available
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# File paths
JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
MOBILE_UI_FILE="/usr/share/pve-yew-mobile-gui/index.html.tpl"
BACKUP_DIR="$BASE_DIR/backups"
APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
PATCH_BIN="/usr/local/bin/pve-remove-nag-v3.sh"
MARK="/* PROXMENUX_NAG_PATCH_V3 */"
MOBILE_MARK="<!-- PROXMENUX_MOBILE_NAG_PATCH -->"

# Ensure tools JSON exists
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

# Register tool in JSON
register_tool() {
    command -v jq >/dev/null 2>&1 || return 0
    local tool="$1" state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" \
      > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

# Verify JS file integrity
verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] || return 1
    [ -s "$file" ] || return 1
    grep -Eq 'Ext|function|var|const|let' "$file" || return 1
    if LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null; then
        return 1
    fi
    return 0
}

# Create timestamped backup
create_backup() {
    local file="$1"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/$(basename "$file").backup.$timestamp"
    
    mkdir -p "$BACKUP_DIR"
    
    if [ -f "$file" ]; then
        rm -f "$BACKUP_DIR"/"$(basename "$file")".backup.* 2>/dev/null || true
        
        cp -a "$file" "$backup_file"
        echo "$backup_file"
    fi
}

# Create the patch script that will be called by APT hook
create_patch_script() {
    cat > "$PATCH_BIN" <<'EOFPATCH'
#!/usr/bin/env bash
# ==========================================================
# Proxmox Subscription Banner Patch (v3 - Minimal)
# ==========================================================
set -euo pipefail

JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
MOBILE_UI_FILE="/usr/share/pve-yew-mobile-gui/index.html.tpl"
BACKUP_DIR="/usr/local/share/proxmenux/backups"
MARK="/* PROXMENUX_NAG_PATCH_V3 */"
MOBILE_MARK="<!-- PROXMENUX_MOBILE_NAG_PATCH -->"

verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] && [ -s "$file" ] && grep -Eq 'Ext|function' "$file" && ! LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null
}

patch_checked_command() {
    [ -f "$JS_FILE" ] || return 0
    
    # Check if already patched - look for our marker
    if grep -q "$MARK" "$JS_FILE"; then
        # Verify the patch is actually applied by checking if function is simplified
        if grep -A 2 "checked_command: function" "$JS_FILE" | grep -q "orig_cmd();"; then
            return 0
        else
            # Marker exists but patch not applied - remove marker and try again
            sed -i "/$MARK/d" "$JS_FILE"
        fi
    fi
    
    # Create backup
    mkdir -p "$BACKUP_DIR"
    local backup="$BACKUP_DIR/$(basename "$JS_FILE").backup.$(date +%Y%m%d_%H%M%S)"
    cp -a "$JS_FILE" "$backup"
    
    # Set trap to restore on error
    trap "cp -a '$backup' '$JS_FILE' 2>/dev/null || true" ERR
    
    # Use Python to replace the entire checked_command function using brace counting
    python3 <<'PYTHON_END'
import sys

js_file = "/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"

try:
    with open(js_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Find the line with checked_command
    start_line = -1
    for i, line in enumerate(lines):
        if 'checked_command: function' in line or 'checked_command:function' in line:
            start_line = i
            break
    
    if start_line == -1:
        print("checked_command function not found", file=sys.stderr)
        sys.exit(1)
    
    # Count braces to find the end of the function
    brace_count = 0
    end_line = -1
    started_counting = False
    
    for i in range(start_line, len(lines)):
        line = lines[i]
        
        # Count opening and closing braces
        for char in line:
            if char == '{':
                brace_count += 1
                started_counting = True
            elif char == '}':
                brace_count -= 1
        
        # When we reach 0 and we've started counting, we found the end
        if started_counting and brace_count == 0:
            # Check if this line ends with "}," which is the function closure
            if '},' in line or '},\n' in line:
                end_line = i
                break
    
    if end_line == -1:
        print("Could not find end of checked_command function", file=sys.stderr)
        sys.exit(1)
    
    # Get the indentation of the original function
    indent = len(lines[start_line]) - len(lines[start_line].lstrip())
    indent_str = ' ' * indent
    
    # Create the replacement function (simple version that just calls orig_cmd)
    replacement = [
        f"{indent_str}checked_command: function (orig_cmd) {{\n",
        f"{indent_str}    orig_cmd();\n",
        f"{indent_str}}},\n"
    ]
    
    # Replace the function
    new_lines = lines[:start_line] + replacement + lines[end_line+1:]
    
    # Write the modified content
    with open(js_file, 'w', encoding='utf-8') as f:
        f.writelines(new_lines)
    
    #print(f"Successfully replaced lines {start_line+1} to {end_line+1}")
    sys.exit(0)

except Exception as e:
    print(f"Python patch error: {e}", file=sys.stderr)
    import traceback
    traceback.print_exc(file=sys.stderr)
    sys.exit(1)
PYTHON_END
    
    local python_result=$?
    
    if [ $python_result -ne 0 ]; then
        # Python failed, restore backup
        cp -a "$backup" "$JS_FILE"
        trap - ERR
        return 1
    fi
    
    # Verify the patch was applied
    if ! grep -A 2 "checked_command: function" "$JS_FILE" | grep -q "orig_cmd();"; then
        cp -a "$backup" "$JS_FILE"
        trap - ERR
        return 1
    fi
    
    # Add patch marker at the beginning
    sed -i "1s|^|$MARK\n|" "$JS_FILE"
    
    # Verify integrity after patch
    if ! verify_js_integrity "$JS_FILE"; then
        cp -a "$backup" "$JS_FILE"
        trap - ERR
        return 1
    fi
    
    # Clean up generated files
    rm -f "$MIN_JS_FILE" "$GZ_FILE" 2>/dev/null || true
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true
    
    trap - ERR
    return 0
}

patch_mobile_ui() {
    [ -f "$MOBILE_UI_FILE" ] || return 0
    
    # Check if already patched
    grep -q "$MOBILE_MARK" "$MOBILE_UI_FILE" && return 0
    
    # Create backup
    mkdir -p "$BACKUP_DIR"
    local backup="$BACKUP_DIR/$(basename "$MOBILE_UI_FILE").backup.$(date +%Y%m%d_%H%M%S)"
    cp -a "$MOBILE_UI_FILE" "$backup"
    
    # Set trap to restore on error
    trap "cp -a '$backup' '$MOBILE_UI_FILE' 2>/dev/null || true" ERR
    
    # Insert the script before </head> tag
    sed -i "/<\/head>/i\\
$MOBILE_MARK\\
        <!-- Script to remove subscription banner from mobile UI -->\\
        <script>\\
    function removeNoSubDialog() {\\
      const observer = new MutationObserver(() => {\\
        const diag = document.querySelector('dialog[aria-label=\"No valid subscription\"]');\\
        if (diag) {\\
          diag.remove();\\
        }\\
      });\\
      observer.observe(document.body, { childList: true, subtree: true });\\
    }\\
    window.addEventListener('load', () => {\\
      setTimeout(removeNoSubDialog, 200);\\
    });\\
  </script>" "$MOBILE_UI_FILE"
    
    trap - ERR
    return 0
}

reload_services() {
    systemctl is-active --quiet pveproxy 2>/dev/null && {
        systemctl reload pveproxy 2>/dev/null || systemctl restart pveproxy 2>/dev/null || true
    }
    systemctl is-active --quiet nginx 2>/dev/null && {
        systemctl reload nginx 2>/dev/null || true
    }
    systemctl is-active --quiet pvedaemon 2>/dev/null && {
        systemctl reload pvedaemon 2>/dev/null || true
    }
}

main() {
    patch_checked_command || return 1
    patch_mobile_ui || true
    reload_services
}

main
EOFPATCH

    chmod 755 "$PATCH_BIN"
}

# Create APT hook to reapply patch after updates
create_apt_hook() {
    cat > "$APT_HOOK" <<'EOFAPT'
/* ProxMenux: reapply minimal nag patch after upgrades */
DPkg::Post-Invoke { "/usr/local/bin/pve-remove-nag-v3.sh || true"; };
EOFAPT
    
    chmod 644 "$APT_HOOK"
    
    # Verify APT hook syntax
    apt-config dump >/dev/null 2>&1 || { 
        msg_warn "APT hook syntax issue, removing..."
        rm -f "$APT_HOOK"
    }
}

# Main function to remove subscription banner
remove_subscription_banner_v3() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1 || echo "unknown")
    
    msg_info "$(translate "Detected Proxmox VE") ${pve_version} - $(translate "applying minimal banner patch")"
    

    
    # Remove old APT hooks
    for f in /etc/apt/apt.conf.d/*nag*; do 
        [[ -e "$f" ]] && rm -f "$f"
    done
    
    # Create backup for desktop UI
    local backup_file
    backup_file=$(create_backup "$JS_FILE")
    if [ -n "$backup_file" ]; then
        msg_ok "$(translate "Desktop UI backup created")"
    fi
    
    if [ -f "$MOBILE_UI_FILE" ]; then
        local mobile_backup
        mobile_backup=$(create_backup "$MOBILE_UI_FILE")
        if [ -n "$mobile_backup" ]; then
            msg_ok "$(translate "Mobile UI backup created")"
        fi
    fi
    
    # Create patch script and APT hook
    create_patch_script
    create_apt_hook
    
    # Apply the patch
    if ! "$PATCH_BIN"; then
        msg_error "$(translate "Error applying patch. Backups preserved at"): $BACKUP_DIR"
        return 1
    fi
    
    # Register tool as applied
    register_tool "subscription_banner" true
    
    msg_ok "$(translate "Subscription banner removed successfully")"
    msg_ok "$(translate "Desktop and Mobile UI patched")"
    msg_ok "$(translate "Refresh your browser (Ctrl+Shift+R) to see changes")"

}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    remove_subscription_banner_v3
fi



================================================
FILE: scripts/global/remove-banner-pve-v3_.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE (v3 - Minimal Intrusive)
# ==========================================================
# This version makes a surgical change to the checked_command function
# by changing the condition to 'if (false)' and commenting out the banner logic.
# Also patches the mobile UI to remove the subscription dialog.
# ==========================================================

set -euo pipefail

# Source utilities if available
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# File paths
JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
MOBILE_UI_FILE="/usr/share/pve-yew-mobile-gui/index.html.tpl"
BACKUP_DIR="$BASE_DIR/backups"
APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
PATCH_BIN="/usr/local/bin/pve-remove-nag-v3.sh"
MARK="/* PROXMENUX_NAG_PATCH_V3 */"
MOBILE_MARK="<!-- PROXMENUX_MOBILE_NAG_PATCH -->"

# Ensure tools JSON exists
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

# Register tool in JSON
register_tool() {
    command -v jq >/dev/null 2>&1 || return 0
    local tool="$1" state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" \
      > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

# Verify JS file integrity
verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] || return 1
    [ -s "$file" ] || return 1
    grep -Eq 'Ext|function|var|const|let' "$file" || return 1
    if LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null; then
        return 1
    fi
    return 0
}

# Create timestamped backup
create_backup() {
    local file="$1"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/$(basename "$file").backup.$timestamp"
    
    mkdir -p "$BACKUP_DIR"
    
    if [ -f "$file" ]; then
        rm -f "$BACKUP_DIR"/"$(basename "$file")".backup.* 2>/dev/null || true
        
        cp -a "$file" "$backup_file"
        echo "$backup_file"
    fi
}

# Create the patch script that will be called by APT hook
create_patch_script() {
    cat > "$PATCH_BIN" <<'EOFPATCH'
#!/usr/bin/env bash
# ==========================================================
# Proxmox Subscription Banner Patch (v3 - Minimal)
# ==========================================================
set -euo pipefail

JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
MOBILE_UI_FILE="/usr/share/pve-yew-mobile-gui/index.html.tpl"
BACKUP_DIR="/usr/local/share/proxmenux/backups"
MARK="/* PROXMENUX_NAG_PATCH_V3 */"
MOBILE_MARK="<!-- PROXMENUX_MOBILE_NAG_PATCH -->"

verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] && [ -s "$file" ] && grep -Eq 'Ext|function' "$file" && ! LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null
}

patch_checked_command() {
    [ -f "$JS_FILE" ] || return 0
    
    # Check if already patched
    grep -q "$MARK" "$JS_FILE" && return 0
    
    # Create backup
    mkdir -p "$BACKUP_DIR"
    local backup="$BACKUP_DIR/$(basename "$JS_FILE").backup.$(date +%Y%m%d_%H%M%S)"
    cp -a "$JS_FILE" "$backup"
    
    # Set trap to restore on error
    trap "cp -a '$backup' '$JS_FILE' 2>/dev/null || true" ERR
    
    # Add patch marker at the beginning
    sed -i "1s|^|$MARK\n|" "$JS_FILE"
    
    # Surgical patch: Change the condition in checked_command function
    # This changes the if condition to 'if (false)' making the banner never show
    if grep -q "res\.data\.status\.toLowerCase() !== 'active'" "$JS_FILE"; then
        # Pattern for newer versions (8.4.5+)
        sed -i "/checked_command: function/,/},$/s/res === null || res === undefined || !res || res\.data\.status\.toLowerCase() !== 'active'/false/g" "$JS_FILE"
    elif grep -q "res\.data\.status !== 'Active'" "$JS_FILE"; then
        # Pattern for older versions
        sed -i "/checked_command: function/,/},$/s/res === null || res === undefined || !res || res\.data\.status !== 'Active'/false/g" "$JS_FILE"
    fi
    
    # Also handle the NoMoreNagging pattern if present
    if grep -q "res\.data\.status\.toLowerCase() !== 'NoMoreNagging'" "$JS_FILE"; then
        sed -i "/checked_command: function/,/},$/s/res === null || res === undefined || !res || res\.data\.status\.toLowerCase() !== 'NoMoreNagging'/false/g" "$JS_FILE"
    fi
    
    # Verify integrity after patch
    if ! verify_js_integrity "$JS_FILE"; then
        cp -a "$backup" "$JS_FILE"
        return 1
    fi
    
    # Clean up generated files
    rm -f "$MIN_JS_FILE" "$GZ_FILE" 2>/dev/null || true
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true
    
    trap - ERR
    return 0
}

patch_mobile_ui() {
    [ -f "$MOBILE_UI_FILE" ] || return 0
    
    # Check if already patched
    grep -q "$MOBILE_MARK" "$MOBILE_UI_FILE" && return 0
    
    # Create backup
    mkdir -p "$BACKUP_DIR"
    local backup="$BACKUP_DIR/$(basename "$MOBILE_UI_FILE").backup.$(date +%Y%m%d_%H%M%S)"
    cp -a "$MOBILE_UI_FILE" "$backup"
    
    # Set trap to restore on error
    trap "cp -a '$backup' '$MOBILE_UI_FILE' 2>/dev/null || true" ERR
    
    # Insert the script before </head> tag
    sed -i "/<\/head>/i\\
$MOBILE_MARK\\
        <!-- Script to remove subscription banner from mobile UI -->\\
        <script>\\
    function removeNoSubDialog() {\\
      const observer = new MutationObserver(() => {\\
        const diag = document.querySelector('dialog[aria-label=\"No valid subscription\"]');\\
        if (diag) {\\
          diag.remove();\\
        }\\
      });\\
      observer.observe(document.body, { childList: true, subtree: true });\\
    }\\
    window.addEventListener('load', () => {\\
      setTimeout(removeNoSubDialog, 200);\\
    });\\
  </script>" "$MOBILE_UI_FILE"
    
    trap - ERR
    return 0
}

reload_services() {
    systemctl is-active --quiet pveproxy 2>/dev/null && {
        systemctl reload pveproxy 2>/dev/null || systemctl restart pveproxy 2>/dev/null || true
    }
    systemctl is-active --quiet nginx 2>/dev/null && {
        systemctl reload nginx 2>/dev/null || true
    }
    systemctl is-active --quiet pvedaemon 2>/dev/null && {
        systemctl reload pvedaemon 2>/dev/null || true
    }
}

main() {
    patch_checked_command || return 1
    patch_mobile_ui || true
    reload_services
}

main
EOFPATCH

    chmod 755 "$PATCH_BIN"
}

# Create APT hook to reapply patch after updates
create_apt_hook() {
    cat > "$APT_HOOK" <<'EOFAPT'
/* ProxMenux: reapply minimal nag patch after upgrades */
DPkg::Post-Invoke { "/usr/local/bin/pve-remove-nag-v3.sh || true"; };
EOFAPT
    
    chmod 644 "$APT_HOOK"
    
    # Verify APT hook syntax
    apt-config dump >/dev/null 2>&1 || { 
        rm -f "$APT_HOOK"
    }
}

# Main function to remove subscription banner
remove_subscription_banner_v3() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1 || echo "unknown")
    
    msg_info "$(translate "Detected Proxmox VE") ${pve_version} - $(translate "applying banner patch")"
    

    
    # Remove old APT hooks
    for f in /etc/apt/apt.conf.d/*nag*; do 
        [[ -e "$f" ]] && rm -f "$f"
    done
    
    # Create backup for desktop UI
    local backup_file
    backup_file=$(create_backup "$JS_FILE")
    if [ -n "$backup_file" ]; then
        # msg_ok "$(translate "Desktop UI backup created"): $backup_file"
        :
    fi
    
    if [ -f "$MOBILE_UI_FILE" ]; then
        local mobile_backup
        mobile_backup=$(create_backup "$MOBILE_UI_FILE")
        if [ -n "$mobile_backup" ]; then
        # msg_ok "$(translate "Mobile UI backup created"): $mobile_backup"
        :
        fi
    fi
    
    # Create patch script and APT hook
    create_patch_script
    create_apt_hook
    
    # Apply the patch
    if ! "$PATCH_BIN"; then
        msg_error "$(translate "Error applying patch. Backups preserved at"): $BACKUP_DIR"
        return 1
    fi
    
    # Register tool as applied
    register_tool "subscription_banner" true
    
    msg_ok "$(translate "Subscription banner removed successfully")"
    msg_ok "$(translate "Desktop and Mobile UI patched")"
    msg_ok "$(translate "Refresh your browser (Ctrl+Shift+R) to see changes")"

}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    remove_subscription_banner_v3
fi



================================================
FILE: scripts/global/remove-banner-pve8.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE 8.4.9 
# ==========================================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache


ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

remove_subscription_banner_pve8() {
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    local APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
    local BACKUP_FILE="${JS_FILE}.bak.$(date +%F_%T)"

    local pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1)
    local pve_major=$(echo "$pve_version" | cut -d. -f1)

    if [[ "$pve_major" -ne 8 ]]; then
        msg_error "This script is only for Proxmox VE 8.x. Detected: $pve_version"
        return 1
    fi

    msg_info "Detected Proxmox VE $pve_version - Applying safe JS patch..."

    if [[ ! -f "$JS_FILE" ]]; then
        msg_error "JavaScript file not found: $JS_FILE"
        return 1
    fi

    cp "$JS_FILE" "$BACKUP_FILE"


    sed -i "s/No valid subscription/Subscription active/g" "$JS_FILE"
    sed -i "s/Ext.Msg.WARNING/Ext.Msg.INFO/g" "$JS_FILE"
    sed -i "s/res.data.status.toLowerCase() !== 'active'/false/g" "$JS_FILE"
    sed -i "s/subscriptionActive: ''/subscriptionActive: true/g" "$JS_FILE"

    [[ -f "$GZ_FILE" ]] && rm -f "$GZ_FILE"

    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true

    [[ -f "$APT_HOOK" ]] && rm -f "$APT_HOOK"


    msg_ok "Subscription banner removed successfully."

    register_tool "subscription_banner" true
}



if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    remove_subscription_banner_pve8
fi



================================================
FILE: scripts/global/remove-banner-pve9.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE 9.x 
# ==========================================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache


ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

remove_subscription_banner_pve9() {
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    local APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
    

    local pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1)
    local pve_major=$(echo "$pve_version" | cut -d. -f1)
    
    if [ "$pve_major" -lt 9 ] 2>/dev/null; then
        msg_error "This script is for PVE 9.x only. Detected PVE $pve_version"
        return 1
    fi
    
    msg_info "Detected Proxmox VE $pve_version - Applying PVE 9.x patches"
    

    if [ ! -f "$JS_FILE" ]; then
        msg_error "JavaScript file not found: $JS_FILE"
        return 1
    fi
    

    

    local backup_file="${JS_FILE}.backup.pve9.$(date +%Y%m%d_%H%M%S)"
    cp "$JS_FILE" "$backup_file"
    

    for f in /etc/apt/apt.conf.d/*nag*; do 
        [[ -e "$f" ]] && rm -f "$f"
    done
    
    [[ -f "$GZ_FILE" ]] && rm -f "$GZ_FILE"
    [[ -f "$MIN_JS_FILE" ]] && rm -f "$MIN_JS_FILE"
    
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true
    

    sed -i "s/res\.data\.status\.toLowerCase() !== 'active'/false/g" "$JS_FILE"
    sed -i "s/subscriptionActive: ''/subscriptionActive: true/g" "$JS_FILE"
    sed -i "s/title: gettext('No valid subscription')/title: gettext('Community Edition')/g" "$JS_FILE"
    

    sed -i "s/You do not have a valid subscription for this server/Community Edition - No subscription required/g" "$JS_FILE"
    sed -i "s/Enterprise repository needs valid subscription/Enterprise repository configured/g" "$JS_FILE"
    sed -i "s/icon: Ext\.Msg\.WARNING/icon: Ext.Msg.INFO/g" "$JS_FILE"
    

    sed -i "s/subscription = !(/subscription = false \&\& (/g" "$JS_FILE"
    
    if grep -q "res\.data\.status\.toLowerCase() !== 'active'" "$JS_FILE"; then
        msg_warn "Some patches may not have applied correctly, retrying..."
        sed -i "s/res\.data\.status\.toLowerCase() !== 'active'/false/g" "$JS_FILE"
    fi
    

    [[ -f "$APT_HOOK" ]] && rm -f "$APT_HOOK"
    cat > "$APT_HOOK" << 'EOF'
DPkg::Post-Invoke {
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/res\\.data\\.status\\.toLowerCase() !== '\''active'\''/false/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/subscriptionActive: '\'\'\''/subscriptionActive: true/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/title: gettext('\''No valid subscription'\'')/title: gettext('\''Community Edition'\'')/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/subscription = !(/subscription = false \\&\\& (/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "rm -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz || true";
};
EOF
    
    chmod 644 "$APT_HOOK"
    

    if ! apt-config dump >/dev/null 2>&1; then
        msg_warn "APT hook has syntax issues, removing..."
        rm -f "$APT_HOOK"
    else
        msg_ok "APT hook created successfully"
    fi
    

    
    systemctl reload nginx 2>/dev/null || true
    
    msg_ok "Subscription banner removed successfully for Proxmox VE $pve_version"
    msg_ok "Banner removal process completed - refresh your browser to see changes"
    
    register_tool "subscription_banner" true
}


if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    remove_subscription_banner_pve9
fi



================================================
FILE: scripts/global/remove-banner-pve9_.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE 9.x ONLY
# ==========================================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Tool registration system
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

remove_subscription_banner_pve9() {
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    local APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
    
    # Verify PVE 9.x
    local pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1)
    local pve_major=$(echo "$pve_version" | cut -d. -f1)
    
    if [ "$pve_major" -lt 9 ] 2>/dev/null; then
        msg_error "This script is for PVE 9.x only. Detected PVE $pve_version"
        return 1
    fi
    
    msg_info "Detected Proxmox VE $pve_version - Applying PVE 9.x patches"
    
    # Verify that the file exists
    if [ ! -f "$JS_FILE" ]; then
        msg_error "JavaScript file not found: $JS_FILE"
        return 1
    fi
    
    
    # Create backup of original file
    local backup_file="${JS_FILE}.backup.pve9.$(date +%Y%m%d_%H%M%S)"
    cp "$JS_FILE" "$backup_file"
    
    # Clean any existing problematic APT hooks
    for f in /etc/apt/apt.conf.d/*nag*; do 
        [[ -e "$f" ]] && rm -f "$f"
    done
    
    
    # Main subscription check patches for PVE 9
    sed -i "s/res\.data\.status\.toLowerCase() !== 'active'/false/g" "$JS_FILE"
    sed -i "s/subscriptionActive: ''/subscriptionActive: true/g" "$JS_FILE"
    sed -i "s/title: gettext('No valid subscription')/title: gettext('Community Edition')/g" "$JS_FILE"
    
    # Additional UX improvements for PVE 9
    sed -i "s/You do not have a valid subscription for this server/Community Edition - No subscription required/g" "$JS_FILE"
    sed -i "s/Enterprise repository needs valid subscription/Enterprise repository configured/g" "$JS_FILE"
    sed -i "s/icon: Ext\.Msg\.WARNING/icon: Ext.Msg.INFO/g" "$JS_FILE"
    
    # Additional subscription patterns that may exist in PVE 9
    sed -i "s/subscription = !(/subscription = false \&\& (/g" "$JS_FILE"
    
    # Remove compressed/minified files to force regeneration
    [[ -f "$GZ_FILE" ]] && rm -f "$GZ_FILE"
    [[ -f "$MIN_JS_FILE" ]] && rm -f "$MIN_JS_FILE"
    
    # Clear various caches
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    
    # Create PVE 9.x specific APT hook
    [[ -f "$APT_HOOK" ]] && rm -f "$APT_HOOK"
    cat > "$APT_HOOK" << 'EOF'
DPkg::Post-Invoke {
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/res\\.data\\.status\\.toLowerCase() !== '\''active'\''/false/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/subscriptionActive: '\'\'\''/subscriptionActive: true/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/title: gettext('\''No valid subscription'\'')/title: gettext('\''Community Edition'\'')/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "test -e /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js && sed -i 's/subscription = !(/subscription = false \\&\\& (/g' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js || true";
    "rm -f /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz || true";
};
EOF
    
    chmod 644 "$APT_HOOK"
    
    # Verify APT hook syntax
    if ! apt-config dump >/dev/null 2>&1; then
        msg_warn "APT hook has syntax issues, removing..."
        rm -f "$APT_HOOK"
    else
        msg_ok "APT hook created successfully"
    fi
    
    
    msg_ok "Subscription banner removed successfully for Proxmox VE $pve_version"
    msg_ok "Banner removal process completed"

    
    register_tool "subscription_banner" true
}


# Execute function if called directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    remove_subscription_banner_pve9
fi



================================================
FILE: scripts/global/remove-banner-pve9_2.sh
================================================
#!/bin/bash
# ==========================================================
# Remove Subscription Banner - Proxmox VE 9.x (Clean Version)
# ==========================================================

set -euo pipefail


BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi


load_language
initialize_cache

ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    command -v jq >/dev/null 2>&1 || return 0
    local tool="$1" state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" \
      > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MOBILE_TPL="/usr/share/pve-yew-mobile-gui/index.html.tpl"
APT_HOOK="/etc/apt/apt.conf.d/no-nag-script"
PATCH_BIN="/usr/local/bin/pve-remove-nag.sh"

MARK_JS="PROXMENUX_NAG_REMOVED_v2"
MARK_MOBILE="<!-- PROXMENUX: MOBILE NAG PATCH v2 -->"


verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] || return 1
    [ -s "$file" ] || return 1
    grep -Eq 'Ext|function|var|const|let' "$file" || return 1
    if LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null; then
        return 1
    fi
    return 0
}

create_backup() {
    local file="$1"
    local backup_dir="$BASE_DIR/backups"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$backup_dir/$(basename "$file").backup.$timestamp"
    mkdir -p "$backup_dir"
    if [ -f "$file" ]; then
        cp -a "$file" "$backup_file"
        ls -t "$backup_dir"/"$(basename "$file")".backup.* 2>/dev/null | tail -n +6 | xargs -r rm -f 2>/dev/null || true
        echo "$backup_file"
    fi
}

# ----------------------------------------------------

create_patch_script() {
    cat > "$PATCH_BIN" <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
MOBILE_TPL="/usr/share/pve-yew-mobile-gui/index.html.tpl"
MARK_JS="PROXMENUX_NAG_REMOVED_v2"
MARK_MOBILE="<!-- PROXMENUX: MOBILE NAG PATCH v2 -->"
BASE_DIR="/usr/local/share/proxmenux"

verify_js_integrity() {
    local file="$1"
    [ -f "$file" ] && [ -s "$file" ] && grep -Eq 'Ext|function' "$file" && ! LC_ALL=C grep -qP '\x00' "$file" 2>/dev/null
}

patch_web() {
    [ -f "$JS_FILE" ] || return 0
    grep -q "$MARK_JS" "$JS_FILE" && return 0

    local backup_dir="$BASE_DIR/backups"
    mkdir -p "$backup_dir"
    local backup="$backup_dir/$(basename "$JS_FILE").backup.$(date +%Y%m%d_%H%M%S)"
    cp -a "$JS_FILE" "$backup"
    trap "cp -a '$backup' '$JS_FILE' 2>/dev/null || true" ERR

    sed -i '1s|^|/* '"$MARK_JS"' */\n|' "$JS_FILE"

    local patterns_found=0

    if grep -q "res\.data\.status\.toLowerCase() !== 'active'" "$JS_FILE"; then
        sed -i "s/res\.data\.status\.toLowerCase() !== 'active'/false/g" "$JS_FILE"
        patterns_found=$((patterns_found + 1))
    fi

    if grep -q "subscriptionActive: ''" "$JS_FILE"; then
        sed -i "s/subscriptionActive: ''/subscriptionActive: true/g" "$JS_FILE"
        patterns_found=$((patterns_found + 1))
    fi

    if grep -q "title: gettext('No valid subscription')" "$JS_FILE"; then
        sed -i "s/title: gettext('No valid subscription')/title: gettext('Community Edition')/g" "$JS_FILE"
        patterns_found=$((patterns_found + 1))
    fi

    if grep -q "icon: Ext\.Msg\.WARNING" "$JS_FILE"; then
        sed -i "s/icon: Ext\.Msg\.WARNING/icon: Ext.Msg.INFO/g" "$JS_FILE"
        patterns_found=$((patterns_found + 1))
    fi

    if grep -q "subscription = !(" "$JS_FILE"; then
        sed -i "s/subscription = !(/subscription = false \&\& (/g" "$JS_FILE"
        patterns_found=$((patterns_found + 1))
    fi

    # Si nada coincidiÃ³ (cambio upstream), restaura y sal limpio
    if [ "${patterns_found:-0}" -eq 0 ]; then
        cp -a "$backup" "$JS_FILE"
        return 0
    fi

    # VerificaciÃ³n final
    if ! verify_js_integrity "$JS_FILE"; then
        cp -a "$backup" "$JS_FILE"
        return 1
    fi

    # Limpiar artefactos/cachÃ©s
    rm -f "$MIN_JS_FILE" "$GZ_FILE" 2>/dev/null || true
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true

    trap - ERR
}

patch_mobile() {
    [ -f "$MOBILE_TPL" ] || return 0
    grep -q "$MARK_MOBILE" "$MOBILE_TPL" && return 0

    local backup_dir="$BASE_DIR/backups"
    mkdir -p "$backup_dir"
    cp -a "$MOBILE_TPL" "$backup_dir/$(basename "$MOBILE_TPL").backup.$(date +%Y%m%d_%H%M%S)"

    cat >> "$MOBILE_TPL" <<EOM
$MARK_MOBILE
<script>
(function() {
  'use strict';
  function removeSubscriptionElements() {
    try {
      const dialogs = document.querySelectorAll('dialog.pwt-outer-dialog');
      dialogs.forEach(d => {
        const text = (d.textContent || '').toLowerCase();
        if (text.includes('subscription') || text.includes('no valid')) { d.remove(); }
      });
      const cards = document.querySelectorAll('.pwt-card.pwt-p-2.pwt-d-flex.pwt-interactive.pwt-justify-content-center');
      cards.forEach(c => {
        const text = (c.textContent || '').toLowerCase();
        const hasButton = c.querySelector('button');
        if (!hasButton && (text.includes('subscription') || text.includes('no valid'))) { c.remove(); }
      });
      const alerts = document.querySelectorAll('[class*="alert"], [class*="warning"], [class*="notice"]');
      alerts.forEach(a => {
        const text = (a.textContent || '').toLowerCase();
        if (text.includes('subscription') || text.includes('no valid')) { a.remove(); }
      });
    } catch (e) { console.warn('Error removing subscription elements:', e); }
  }
  if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', removeSubscriptionElements); }
  else { removeSubscriptionElements(); }
  const observer = new MutationObserver(removeSubscriptionElements);
  if (document.body) {
    observer.observe(document.body, { childList: true, subtree: true });
    const interval = setInterval(removeSubscriptionElements, 500);
    setTimeout(() => { try { observer.disconnect(); clearInterval(interval); } catch(e){} }, 30000);
  }
})();
</script>
EOM
}

reload_services() {
  systemctl is-active --quiet pveproxy 2>/dev/null && {
      systemctl reload pveproxy 2>/dev/null || systemctl restart pveproxy 2>/dev/null || true
  }
  systemctl is-active --quiet nginx 2>/dev/null && {
      systemctl reload nginx 2>/dev/null || true
  }
  systemctl is-active --quiet pvedaemon 2>/dev/null && {
      systemctl reload pvedaemon 2>/dev/null || true
  }
  find /var/cache/pve-manager/ -type f -delete 2>/dev/null || true
  find /var/lib/pve-manager/ -type f -delete 2>/dev/null || true
}

main() {
    patch_web || return 1
    patch_mobile
    reload_services
}

main
EOF
    chmod 755 "$PATCH_BIN"
}
# ----------------------------------------------------


create_apt_hook() {
    cat > "$APT_HOOK" <<'EOF'
/* ProxMenux: reapply nag patch after upgrades */
DPkg::Post-Invoke { "/usr/local/bin/pve-remove-nag.sh || true"; };
EOF
    chmod 644 "$APT_HOOK"
    apt-config dump >/dev/null 2>&1 || { msg_warn "APT hook syntax issue"; rm -f "$APT_HOOK"; }
}



remove_subscription_banner_pve9() {
  local pve_version
  pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+' | head -1 || true)
  local pve_major="${pve_version%%.*}"

  msg_info "$(translate "Detected Proxmox VE ${pve_version:-9.x} â€“ removing subscription banner")"

  create_patch_script
  create_apt_hook

  if ! "$PATCH_BIN"; then
    msg_error "$(translate "Error applying patches")"
    return 1
  fi

  register_tool "subscription_banner" true
  msg_ok "$(translate "Subscription banner removed successfully.")"
  msg_ok "$(translate "Refresh your browser to see changes.")"
}



if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  remove_subscription_banner_pve9
fi



================================================
FILE: scripts/global/share-common.func
================================================
#!/usr/bin/env bash
# ==========================================================
# ProxMenux - Global Share Functions (reusable)
# File: scripts/global/share_common.func
# ==========================================================



if [[ -n "${__PROXMENUX_SHARE_COMMON__}" ]]; then
    return 0
fi
__PROXMENUX_SHARE_COMMON__=1


: "${PROXMENUX_DEFAULT_SHARE_GROUP:=sharedfiles}"


: "${PROXMENUX_SHARE_MAP_DB:=/usr/local/share/proxmenux/share-map.db}"


mkdir -p "$(dirname "$PROXMENUX_SHARE_MAP_DB")" 2>/dev/null || true
touch "$PROXMENUX_SHARE_MAP_DB" 2>/dev/null || true


pmx_share_map_get() {

    local key="$1"
    awk -F'=' -v k="$key" '$1==k {print $2}' "$PROXMENUX_SHARE_MAP_DB" 2>/dev/null | tail -n1
}


pmx_share_map_set() {

    local key="$1" val="$2"

    sed -i "\|^${key}=|d" "$PROXMENUX_SHARE_MAP_DB" 2>/dev/null || true
    echo "${key}=${val}" >> "$PROXMENUX_SHARE_MAP_DB"
}










pmx_choose_or_create_group() {
    local default_group="${1:-$PROXMENUX_DEFAULT_SHARE_GROUP}"
    local choice group_name groups menu_args gid_min


    gid_min="$(awk '/^\s*GID_MIN\s+[0-9]+/ {print $2}' /etc/login.defs 2>/dev/null | tail -n1)"
    [[ -z "$gid_min" ]] && gid_min=1000

    choice=$(whiptail --title "$(translate "Shared Group")" \
        --menu "$(translate "Choose a group policy for this shared directory:")" 18 78 6 \
        "1"  "$(translate "Use default group:") $default_group $(translate "(recommended)")" \
        "2"  "$(translate "Create a new group for isolation")" \
        "3"  "$(translate "Select an existing group")" \
        3>&1 1>&2 2>&3) || { echo ""; return 1; }

    case "$choice" in
        1)

            pmx_ensure_host_group "$default_group" >/dev/null || { echo ""; return 1; }
            echo "$default_group"
            ;;

        2)
            group_name=$(whiptail --inputbox "$(translate "Enter new group name:")" 10 70 "sharedfiles-project" \
                --title "$(translate "New Group")" 3>&1 1>&2 2>&3) || { echo ""; return 1; }

            if [[ -z "$group_name" ]]; then
                msg_error "$(translate "Group name cannot be empty.")"
                echo ""; return 1
            fi

            if ! [[ "$group_name" =~ ^[a-zA-Z_][a-zA-Z0-9_-]*$ ]]; then
                msg_error "$(translate "Invalid group name. Use letters, digits, underscore or hyphen, and start with a letter or underscore.")"
                echo ""; return 1
            fi

            pmx_ensure_host_group "$group_name" >/dev/null || { echo ""; return 1; }
            echo "$group_name"
            ;;

        3)

            groups=$(getent group | awk -F: -v MIN="$gid_min" '
                $3 >= MIN && $1 != "nogroup" && $1 !~ /^pve/ {print $0}
            ' | sort -t: -k1,1)

            if [[ -z "$groups" ]]; then
                whiptail --title "$(translate "Groups")" --msgbox "$(translate "No user groups found.")" 8 60
                echo ""; return 1
            fi

            menu_args=()
            while IFS=: read -r gname _ gid members; do
                menu_args+=("$gname" "GID=$gid")
            done <<< "$groups"

            group_name=$(whiptail --title "$(translate "Existing Groups")" \
                --menu "$(translate "Select an existing group:")" 20 70 12 \
                "${menu_args[@]}" 3>&1 1>&2 2>&3) || { echo ""; return 1; }


            pmx_ensure_host_group "$group_name" >/dev/null || { echo ""; return 1; }
            echo "$group_name"
            ;;

        *)
            echo ""; return 1
            ;;
    esac
}








pmx_ensure_host_group() {
    local group_name="$1"
    local suggested_gid="${2:-}"
    local base_gid=101000
    local new_gid gid


    if getent group "$group_name" >/dev/null 2>&1; then
        gid="$(getent group "$group_name" | cut -d: -f3)"
        echo "$gid"
        return 0
    fi

    if [[ -n "$suggested_gid" ]]; then

        if getent group "$suggested_gid" >/dev/null 2>&1; then
            msg_error "$(translate "GID already in use:") $suggested_gid"
            echo ""
            return 1
        fi
        if ! groupadd -g "$suggested_gid" "$group_name" >/dev/null 2>&1; then
            msg_error "$(translate "Failed to create group:") $group_name"
            echo ""
            return 1
        fi
        msg_ok "$(translate "Group created:") $group_name"
    else

        new_gid="$base_gid"
        while getent group "$new_gid" >/dev/null 2>&1; do
            new_gid=$((new_gid+1))
        done
        if ! groupadd -g "$new_gid" "$group_name" >/dev/null 2>&1; then
            msg_error "$(translate "Failed to create group:") $group_name"
            echo ""
            return 1
        fi
        msg_ok "$(translate "Group created:") $group_name"
    fi

    gid="$(getent group "$group_name" | cut -d: -f3)"
    if [[ -z "$gid" ]]; then
        msg_error "$(translate "Failed to resolve group GID for") $group_name"
        echo ""
        return 1
    fi

    echo "$gid"
    return 0
}










pmx_prepare_host_shared_dir() {

    local dir="$1" group_name="$2"
    [[ -z "$dir" || -z "$group_name" ]] && { msg_error "$(translate "Internal error: missing arguments in pmx_prepare_host_shared_dir")"; return 1; }

    if [[ ! -d "$dir" ]]; then
        if mkdir -p "$dir" 2>/dev/null; then
            msg_ok "$(translate "Created directory on host:") $dir"
        else
            msg_error "$(translate "Failed to create directory on host:") $dir"
            return 1
        fi
    fi

    chown -R root:"$group_name" "$dir" 2>/dev/null || true
    chmod -R 2775 "$dir" 2>/dev/null || true

    if command -v setfacl >/dev/null 2>&1; then
        setfacl -R -m d:g:"$group_name":rwx -m d:o::rx -m g:"$group_name":rwx "$dir" 2>/dev/null || true
        msg_ok "$(translate "Default ACLs applied for group inheritance.")"
    fi
    return 0
}
















pmx_select_host_mount_point() {
    local title="${1:-$(translate "Select Mount Point")}"
    local default_path="${2:-/mnt/shared}"
    local context="${3:-local}"   
    local choice folder_name result existing_dirs mount_point

    while true; do
        choice=$(whiptail --title "$title" --menu "$(translate "Where do you want the host folder?")" 16 76 3 \
            "1"  "$(translate "Create new folder in /mnt")" \
            "2" "$(translate "Enter custom pathr")" 3>&1 1>&2 2>&3) || { echo ""; return 1; }

        case "$choice" in
            1)
                folder_name=$(whiptail --inputbox "$(translate "Enter folder name for /mnt:")" 10 70 "$(basename "$default_path")" --title "$(translate "Folder Name")" 3>&1 1>&2 2>&3) || { echo ""; return 1; }
                [[ -z "$folder_name" ]] && continue
                mount_point="/mnt/$folder_name"
                echo "$mount_point"; return 0
                ;;
            
            2)
                result=$(whiptail --inputbox "$(translate "Enter full path:")" 10 80 "$default_path" --title "$(translate "Custom Path")" 3>&1 1>&2 2>&3) || { echo ""; return 1; }
                [[ -z "$result" ]] && continue
                echo "$result"; return 0
                ;;
        esac
    done
}













select_host_directory_() {
    local method choice result

    method=$(whiptail --title "$(translate "Select Host Directory")" --menu "$(translate "How do you want to select the HOST folder to mount?")" 15 70 4 \
        "mnt" "$(translate "Select from /mnt directories")" \
        "manual" "$(translate "Enter path manually")" 3>&1 1>&2 2>&3) || return 1

    case "$method" in
        mnt|srv|media)
            local base_path="/$method"
            local host_dirs=("$base_path"/*)
            local options=()
            
            for dir in "${host_dirs[@]}"; do
                if [[ -d "$dir" ]]; then
                    options+=("$dir" "$(basename "$dir")")
                fi
            done
            
            if [[ ${#options[@]} -eq 0 ]]; then
                msg_error "$(translate "No directories found in") $base_path"
                return 1
            fi
            
            result=$(whiptail --title "$(translate "Select Host Folder")" \
                --menu "$(translate "Select the folder to mount:")" 20 80 10 "${options[@]}" 3>&1 1>&2 2>&3)
            ;;
        manual)
            
            result=$(whiptail --title "$(translate "Enter Path")" \
                --inputbox "$(translate "Enter the full path to the host folder:")" 10 70 "/mnt/" 3>&1 1>&2 2>&3)
            ;;
    esac

    if [[ -z "$result" ]]; then
        return 1
    fi

    if [[ ! -d "$result" ]]; then
        msg_error "$(translate "The selected path is not a valid directory:") $result"
        return 1
    fi

    echo "$result"
}







select_host_directory__() {
    local method result

    method=$(whiptail --title "$(translate "Select Host Directory")" \
        --menu "$(translate "How do you want to select the HOST folder to mount?")" 15 70 4 \
        "mnt"    "$(translate "Select from /mnt directories")" \
        "manual" "$(translate "Enter path manually")" \
        3>&1 1>&2 2>&3) || return 1   

    case "$method" in
        mnt|srv|media)
            local base_path="/$method"
            local host_dirs=("$base_path"/*)
            local options=()

            for dir in "${host_dirs[@]}"; do
                [[ -d "$dir" ]] && options+=("$dir" "$(basename "$dir")")
            done

            if [[ ${#options[@]} -eq 0 ]]; then
                msg_error "$(translate "No directories found in") $base_path"
                return 1
            fi

            result=$(whiptail --title "$(translate "Select Host Folder")" \
                --menu "$(translate "Select the folder to mount:")" 20 80 10 \
                "${options[@]}" 3>&1 1>&2 2>&3) || return 1
            ;;
        manual)
            result=$(whiptail --title "$(translate "Enter Path")" \
                --inputbox "$(translate "Enter the full path to the host folder:")" \
                10 70 "/mnt/" 3>&1 1>&2 2>&3) || return 1
            ;;
        *)
            return 1
            ;;
    esac

    [[ -z "$result" ]] && return 1
    [[ ! -d "$result" ]] && { 
        msg_error "$(translate "The selected path is not a valid directory:") $result"
        return 1
    }

    echo "$result"

}








select_host_directory() {
    local method result

    method=$(whiptail --title "$(translate "Select Host Directory")" \
        --menu "$(translate "How do you want to select the HOST folder to mount?")" 15 70 4 \
        "mnt"    "$(translate "Select from /mnt directories")" \
        "manual" "$(translate "Enter path manually")" \
        3>&1 1>&2 2>&3) || return 1   

    case "$method" in
        mnt|srv|media)
            local base_path="/$method"
            local host_dirs=("$base_path"/*)
            local options=()

            for dir in "${host_dirs[@]}"; do
                [[ -d "$dir" ]] && options+=("$dir" "$(basename "$dir")")
            done

            if [[ ${#options[@]} -eq 0 ]]; then
                msg_error "$(translate "No directories found in") $base_path"
                return 1
            fi

            result=$(whiptail --title "$(translate "Select Host Folder")" \
                --menu "$(translate "Select the folder to mount:")" 20 80 10 \
                "${options[@]}" 3>&1 1>&2 2>&3) || return 1
            ;;
        manual)
            result=$(whiptail --title "$(translate "Enter Path")" \
                --inputbox "$(translate "Enter the full path to the host folder:")" \
                10 70 "/mnt/" 3>&1 1>&2 2>&3) || return 1
            ;;
        *)
            return 1
            ;;
    esac

    [[ -z "$result" ]] && return 1
    [[ ! -d "$result" ]] && { 
        msg_error "$(translate "The selected path is not a valid directory:") $result"
        return 1
    }

    echo "$result"

}






select_lxc_container() {
    local ct_list ctid ct_status
    
    ct_list=$(pct list | awk 'NR>1 {print $1, $2, $3}')
    if [[ -z "$ct_list" ]]; then
        dialog --title "$(translate "Error")" \
            --msgbox "$(translate "No LXC containers available")" 8 50
        return 1
    fi

    local options=()
    while read -r id name status; do
        if [[ -n "$id" ]]; then
            options+=("$id" "$name ($status)")
        fi
    done <<< "$ct_list"

    ctid=$(dialog --title "$(translate "Select LXC Container")" \
        --menu "\n$(translate "Select container:")" 25 80 15 \
        "${options[@]}" 3>&1 1>&2 2>&3)
    
    if [[ -z "$ctid" ]]; then
        return 1
    fi

    echo "$ctid"
    return 0
}




select_container_mount_point_() {
    local ctid="$1"
    local host_dir="$2"
    local choice mount_point existing_dirs options

    while true; do
        choice=$(whiptail --title "$(translate "Configure Mount Point inside LXC")" \
            --menu "$(translate "Where to mount inside container?")" 18 70 5 \
            "1" "$(translate "Create new directory in /mnt")" \
            "2" "$(translate "Enter path manually")" \
            "3" "$(translate "Cancel")" 3>&1 1>&2 2>&3) || return 1

        case "$choice" in
            1)
                mount_point=$(whiptail --inputbox "$(translate "Enter folder name for /mnt:")" 10 60 "shared" 3>&1 1>&2 2>&3) || continue
                [[ -z "$mount_point" ]] && continue
                mount_point="/mnt/$mount_point"
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            2)
                mount_point=$(whiptail --inputbox "$(translate "Enter full path:")" 10 70 "/mnt/shared" 3>&1 1>&2 2>&3) || continue
                [[ -z "$mount_point" ]] && continue
                mount_point="/mnt/$mount_point"
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            3)
                return 1
                ;;
        esac

        if pct exec "$ctid" -- test -d "$mount_point" 2>/dev/null; then
            echo "$mount_point"
            return 0
        else
            whiptail --msgbox "$(translate "Could not create or access directory:") $mount_point" 8 70
            continue
        fi
    done
}










select_container_mount_point() {
    local ctid="$1"
    local host_dir="$2"
    local choice mount_point base_name

    base_name=$(basename "$host_dir")

    while true; do
        choice=$(whiptail --title "$(translate "Configure Mount Point inside LXC")" \
            --menu "$(translate "Where to mount inside container?")" 18 70 5 \
            "1" "$(translate "Create new directory in /mnt")" \
            "2" "$(translate "Enter path manually")" \
            "3" "$(translate "Cancel")" 3>&1 1>&2 2>&3) || return 1

        case "$choice" in
            1)
                mount_point=$(whiptail --inputbox "$(translate "Enter folder name for /mnt:")" \
                    10 60 "$base_name" 3>&1 1>&2 2>&3) || continue
                [[ -z "$mount_point" ]] && continue
                mount_point="/mnt/$mount_point"
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            2)
                mount_point=$(whiptail --inputbox "$(translate "Enter full path:")" \
                    10 70 "/mnt/$base_name" 3>&1 1>&2 2>&3) || continue
                [[ -z "$mount_point" ]] && continue
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            3)
                return 1
                ;;
        esac

        if pct exec "$ctid" -- test -d "$mount_point" 2>/dev/null; then
            echo "$mount_point"
            return 0
        else
            whiptail --msgbox "$(translate "Could not create or access directory:") $mount_point" 8 70
            continue
        fi
    done
}













# ==========================================================
# CLIENT MOUNT FUNCTIONS (NFS/SAMBA COMMON)
# ==========================================================





# Check if container is privileged (required for client mounts)
select_privileged_lxc() {
    # === Select CT ===
    local ct_list ctid ct_status conf unpriv

    ct_list=$(pct list | awk 'NR>1 {print $1, $3}')
    if [[ -z "$ct_list" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "Error")" \
            --msgbox "$(translate "No CTs available in the system.")" 8 50
        return 1
    fi

    ctid=$(dialog --backtitle "ProxMenux" --title "$(translate "Select CT")" \
        --menu "$(translate "Select the CT to manage NFS/Samba client:")" 20 70 12 \
        $ct_list 3>&1 1>&2 2>&3)

    if [[ -z "$ctid" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "Error")" \
            --msgbox "$(translate "No CT was selected.")" 8 50
        return 1
    fi

    # === Start CT if not running ===
    ct_status=$(pct status "$ctid" | awk '{print $2}')
    if [[ "$ct_status" != "running" ]]; then
        show_proxmenux_logo
        echo -e
        msg_info "$(translate "Starting CT") $ctid..."
        pct start "$ctid"
        sleep 2
        if [[ "$(pct status "$ctid" | awk '{print $2}')" != "running" ]]; then
            msg_error "$(translate "Failed to start the CT.")"
            echo -e ""
            msg_success "$(translate 'Press Enter to continue...')"
            read -r
            return 1
        fi
        msg_ok "$(translate "CT started successfully.")"
    fi

    # === Check privileged/unprivileged ===
    conf="/etc/pve/lxc/${ctid}.conf"
    unpriv=$(awk '/^unprivileged:/ {print $2}' "$conf" 2>/dev/null)

    if [[ "$unpriv" == "1" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "Privileged Container Required")" \
            --msgbox "\n$(translate "Network share mounting (NFS/Samba) requires a PRIVILEGED container.")\n\n$(translate "Selected container") $ctid $(translate "is UNPRIVILEGED.")\n\n$(translate "For unprivileged containers, use instead:")\n  â€¢ $(translate "Configure LXC mount points")\n  â€¢ $(translate "Mount shares on HOST first")\n  â€¢ $(translate "Then bind-mount to container")" 15 75
        exit 1
    fi

    # Export CTID if all good
    echo "$ctid"
    CTID="$ctid"
    return 0
}



# Common mount point selection for containers
pmx_select_container_mount_point() {
    local ctid="$1"
    local share_name="${2:-shared}"
    
    while true; do
        local choice=$(whiptail --title "$(translate "Select Mount Point")" --menu "$(translate "Where do you want to mount inside container?")" 15 70 3 \
        "existing" "$(translate "Select from existing folders in /mnt")" \
        "new" "$(translate "Create new folder in /mnt")" \
        "custom" "$(translate "Enter custom path")" 3>&1 1>&2 2>&3)
        
        case "$choice" in
            existing)
                local existing_dirs=$(pct exec "$ctid" -- find /mnt -mindepth 1 -maxdepth 1 -type d 2>/dev/null | sort)
                if [[ -z "$existing_dirs" ]]; then
                    whiptail --title "$(translate "No Folders")" --msgbox "$(translate "No folders found in /mnt. Please create a new folder.")" 8 60
                    continue
                fi
                
                local options=()
                while IFS= read -r dir; do
                    if [[ -n "$dir" ]]; then
                        local name=$(basename "$dir")
                        if pct exec "$ctid" -- [ "$(ls -A "$dir" 2>/dev/null | wc -l)" -eq 0 ]; then
                            local status="$(translate "Empty")"
                        else
                            local status="$(translate "Contains files")"
                        fi
                        options+=("$dir" "$name ($status)")
                    fi
                done <<< "$existing_dirs"
                
                local mount_point=$(whiptail --title "$(translate "Select Existing Folder")" --menu "$(translate "Choose a folder to mount:")" 20 80 10 "${options[@]}" 3>&1 1>&2 2>&3)
                
                if [[ -n "$mount_point" ]]; then
                    if pct exec "$ctid" -- [ "$(ls -A "$mount_point" 2>/dev/null | wc -l)" -gt 0 ]; then
                        local file_count=$(pct exec "$ctid" -- ls -A "$mount_point" 2>/dev/null | wc -l || true)
                        if ! whiptail --yesno "$(translate "WARNING: The selected directory is not empty!")\n\n$(translate "Directory:"): $mount_point\n$(translate "Contains:"): $file_count $(translate "files/folders")\n\n$(translate "Mounting here will hide existing files until unmounted.")\n\n$(translate "Do you want to continue?")" 14 70 --title "$(translate "Directory Not Empty")"; then
                            continue
                        fi
                    fi
                    echo "$mount_point"
                    return 0
                fi
                ;;
            new)
                local folder_name=$(whiptail --inputbox "$(translate "Enter new folder name:")" 10 60 "$share_name" --title "$(translate "New Folder in /mnt")" 3>&1 1>&2 2>&3)
                if [[ -n "$folder_name" ]]; then
                    local mount_point="/mnt/$folder_name"
                    echo "$mount_point"
                    return 0
                fi
                ;;
            custom)
                local mount_point=$(whiptail --inputbox "$(translate "Enter full path for mount point:")" 10 70 "/mnt/${share_name}" --title "$(translate "Custom Path")" 3>&1 1>&2 2>&3)
                if [[ -n "$mount_point" ]]; then
                    echo "$mount_point"
                    return 0
                fi
                ;;
            *)
                return 1
                ;;
        esac
    done
}

# Common server discovery function
pmx_discover_network_servers() {
    local service_type="$1"  # "NFS" or "Samba"
    local port="$2"          # "2049" for NFS, "139,445" for Samba
    
    local host_ip=$(hostname -I | awk '{print $1}')
    local network=$(echo "$host_ip" | cut -d. -f1-3).0/24

    # Install nmap if needed
    if ! which nmap >/dev/null 2>&1; then
        apt-get install -y nmap &>/dev/null
    fi

    local servers
    if [[ "$service_type" == "Samba" ]]; then
        servers=$(nmap -p 139,445 --open "$network" 2>/dev/null | grep -B 4 -E "(139|445)/tcp open" | grep "Nmap scan report" | awk '{print $5}' | sort -u || true)
    else
        servers=$(nmap -p 2049 --open "$network" 2>/dev/null | grep -B 4 "2049/tcp open" | grep "Nmap scan report" | awk '{print $5}' | sort -u || true)
    fi
    
    if [[ -z "$servers" ]]; then
        whiptail --title "$(translate "No Servers Found")" --msgbox "$(translate "No") $service_type $(translate "servers found on the network.")\n\n$(translate "You can add servers manually.")" 10 60
        return 1
    fi

    local options=()
    while IFS= read -r server; do
        if [[ -n "$server" ]]; then
            if [[ "$service_type" == "Samba" ]]; then
                # Try to get NetBIOS name for Samba
                local nb_name=$(nmblookup -A "$server" 2>/dev/null | awk '/<00> -.*B <ACTIVE>/ {print $1; exit}')
                if [[ -z "$nb_name" || "$nb_name" == "$server" || "$nb_name" == "address" || "$nb_name" == "-" ]]; then
                    nb_name="Unknown"
                fi
                options+=("$server" "$nb_name ($server)")
            else
                # For NFS, show export count
                local exports_count=$(showmount -e "$server" 2>/dev/null | tail -n +2 | wc -l || echo "0")
                options+=("$server" "NFS Server ($exports_count exports)")
            fi
        fi
    done <<< "$servers"
    
    if [[ ${#options[@]} -eq 0 ]]; then
        whiptail --title "$(translate "No Valid Servers")" --msgbox "$(translate "No accessible") $service_type $(translate "servers found.")" 8 50
        return 1
    fi

    local selected_server=$(whiptail --title "$(translate "Select") $service_type $(translate "Server")" --menu "$(translate "Choose a server:")" 20 80 10 "${options[@]}" 3>&1 1>&2 2>&3)
    
    if [[ -n "$selected_server" ]]; then
        echo "$selected_server"
        return 0
    else
        return 1
    fi
}

# Common server selection function
pmx_select_server() {
    local service_type="$1"  # "NFS" or "Samba"
    local port="$2"          # "2049" for NFS, "139,445" for Samba
    
    local method=$(whiptail --title "$(translate "$service_type Server Selection")" --menu "$(translate "How do you want to select the") $service_type $(translate "server?")" 15 70 3 \
    "auto" "$(translate "Auto-discover servers on network")" \
    "manual" "$(translate "Enter server IP/hostname manually")" \
    "recent" "$(translate "Select from recent servers")" 3>&1 1>&2 2>&3)
    
    local result_code=$?
    if [[ $result_code -ne 0 ]]; then
        return 1
    fi
    
    case "$method" in
        auto)
            local discovered_server
            discovered_server=$(pmx_discover_network_servers "$service_type" "$port")
            local discover_result=$?
            if [[ $discover_result -eq 0 && -n "$discovered_server" ]]; then
                echo "$discovered_server"
                return 0
            else
                return 1
            fi
            ;;
        manual)
            local server=$(whiptail --inputbox "$(translate "Enter") $service_type $(translate "server IP or hostname:")" 10 60 --title "$(translate "$service_type Server")" 3>&1 1>&2 2>&3)
            local input_result=$?
            if [[ $input_result -eq 0 && -n "$server" ]]; then
                echo "$server"
                return 0
            else
                return 1
            fi
            ;;
        recent)
            local fs_type
            if [[ "$service_type" == "NFS" ]]; then
                fs_type="nfs"
            else
                fs_type="cifs"
            fi
            
            # Fix the recent servers detection for NFS
            local recent
            if [[ "$service_type" == "NFS" ]]; then
                recent=$(grep "$fs_type" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d: -f1 | sort -u || true)
            else
                recent=$(grep "$fs_type" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d/ -f3 | sort -u || true)
            fi
            
            if [[ -z "$recent" ]]; then
                whiptail --title "$(translate "No Recent Servers")" --msgbox "\n$(translate "No recent") $service_type $(translate "servers found.")" 8 50
                return 1
            fi
            
            local options=()
            while IFS= read -r server; do
                [[ -n "$server" ]] && options+=("$server" "$(translate "Recent") $service_type $(translate "server")")
            done <<< "$recent"
            
            local selected_server=$(whiptail --title "$(translate "Recent") $service_type $(translate "Servers")" --menu "$(translate "Choose a recent server:")" 20 70 10 "${options[@]}" 3>&1 1>&2 2>&3)
            local select_result=$?
            if [[ $select_result -eq 0 && -n "$selected_server" ]]; then
                echo "$selected_server"
                return 0
            else
                return 1
            fi
            ;;
        *)
            return 1
            ;;
    esac
}

# Common mount options configuration
pmx_configure_mount_options() {
    local service_type="$1"  # "NFS" or "CIFS"
    
    local mount_type
    if [[ "$service_type" == "NFS" ]]; then
        mount_type=$(whiptail --title "$(translate "Mount Options")" --menu "$(translate "Select mount configuration:")" 15 70 4 \
        "default" "$(translate "Default options")" \
        "readonly" "$(translate "Read-only mount")" \
        "performance" "$(translate "Performance optimized")" \
        "custom" "$(translate "Custom options")" 3>&1 1>&2 2>&3)
        
        case "$mount_type" in
            default)
                echo "rw,hard,intr,rsize=8192,wsize=8192,timeo=14"
                ;;
            readonly)
                echo "ro,hard,intr,rsize=8192,timeo=14"
                ;;
            performance)
                echo "rw,hard,intr,rsize=1048576,wsize=1048576,timeo=14,retrans=2"
                ;;
            custom)
                local options=$(whiptail --inputbox "$(translate "Enter custom mount options:")" 10 70 "rw,hard,intr" --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
                echo "${options:-rw,hard,intr}"
                ;;
            *)
                echo "rw,hard,intr,rsize=8192,wsize=8192,timeo=14"
                ;;
        esac
    else
        # CIFS options
        mount_type=$(whiptail --title "$(translate "Mount Options")" --menu "$(translate "Select mount configuration:")" 15 70 4 \
        "default" "$(translate "Default options")" \
        "readonly" "$(translate "Read-only mount")" \
        "performance" "$(translate "Performance optimized")" \
        "custom" "$(translate "Custom options")" 3>&1 1>&2 2>&3)
        
        case "$mount_type" in
            default)
                echo "rw,file_mode=0664,dir_mode=0775,iocharset=utf8"
                ;;
            readonly)
                echo "ro,file_mode=0444,dir_mode=0555,iocharset=utf8"
                ;;
            performance)
                echo "rw,file_mode=0664,dir_mode=0775,iocharset=utf8,cache=strict,rsize=1048576,wsize=1048576"
                ;;
            custom)
                local options=$(whiptail --inputbox "$(translate "Enter custom mount options:")" 10 70 "rw,file_mode=0664,dir_mode=0775" --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
                echo "${options:-rw,file_mode=0664,dir_mode=0775}"
                ;;
            *)
                echo "rw,file_mode=0664,dir_mode=0775,iocharset=utf8"
                ;;
        esac
    fi
}

# Common permanent mount question
pmx_ask_permanent_mount() {
    if whiptail --yesno "$(translate "Do you want to make this mount permanent?")\n\n$(translate "This will add the mount to /etc/fstab so it persists after reboot.")" 10 70 --title "$(translate "Permanent Mount")"; then
        echo "true"
    else
        echo "false"
    fi
}



================================================
FILE: scripts/global/update-pve.sh
================================================
#!/bin/bash
# ==========================================================
# Proxmox VE Update Script
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

download_common_functions() {
    if ! source "$LOCAL_SCRIPTS/global/common-functions.sh"; then
        return 1
    fi
}

update_pve9() {
    local pve_version=$(pveversion | awk -F'/' '{print $2}' | cut -d'-' -f1)
    local start_time=$(date +%s)
    local log_file="/var/log/proxmox-update-$(date +%Y%m%d-%H%M%S).log"
    local changes_made=false
    local OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
    local TARGET_CODENAME="trixie"
    
    if [ -z "$OS_CODENAME" ]; then
        OS_CODENAME=$(lsb_release -cs 2>/dev/null || echo "trixie")
    fi

    download_common_functions


    msg_info2 "$(translate "Detected: Proxmox VE $pve_version (Current: $OS_CODENAME, Target: $TARGET_CODENAME)")"
    echo -e

    local available_space=$(df /var/cache/apt/archives | awk 'NR==2 {print int($4/1024)}')
    if [ "$available_space" -lt 1024 ]; then
        msg_error "$(translate "Insufficient disk space. Available: ${available_space}MB")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! ping -c 1 download.proxmox.com >/dev/null 2>&1; then
        msg_error "$(translate "Cannot reach Proxmox repositories")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi


disable_sources_repo() {
    local file="$1"
    if [[ -f "$file" ]]; then
        sed -i ':a;/^\n*$/{$d;N;ba}' "$file"

        if grep -q "^Enabled:" "$file"; then
            sed -i 's/^Enabled:.*$/Enabled: false/' "$file"
        else
            echo "Enabled: false" >> "$file"
        fi

        if ! grep -q "^Types: " "$file"; then
            msg_warn "$(translate "Malformed .sources file detected, removing: $(basename "$file")")"
            rm -f "$file"
        fi
        return 0
    fi
    return 1
}




    if disable_sources_repo "/etc/apt/sources.list.d/pve-enterprise.sources"; then
        msg_ok "$(translate "Enterprise Proxmox repository disabled")"
        changes_made=true
    fi

    if disable_sources_repo "/etc/apt/sources.list.d/ceph.sources"; then
        msg_ok "$(translate "Enterprise Proxmox Ceph repository disabled")"
        changes_made=true
    fi

    for legacy_file in /etc/apt/sources.list.d/pve-public-repo.list \
                       /etc/apt/sources.list.d/pve-install-repo.list \
                       /etc/apt/sources.list.d/debian.list; do
        if [[ -f "$legacy_file" ]]; then
            rm -f "$legacy_file"
            msg_ok "$(translate "Removed legacy repository: $(basename "$legacy_file")")"
        fi
    done


    if [[ -f /etc/apt/sources.list.d/debian.sources ]]; then
        rm -f /etc/apt/sources.list.d/debian.sources
        msg_ok "$(translate "Old debian.sources file removed to prevent duplication")"
    fi


    msg_info "$(translate "Creating Proxmox VE 9.x no-subscription repository...")"
    cat > /etc/apt/sources.list.d/proxmox.sources << EOF
Enabled: true
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: ${TARGET_CODENAME}
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
    msg_ok "$(translate "Proxmox VE 9.x no-subscription repository created")"
    changes_made=true



    msg_info "$(translate "Creating Debian ${TARGET_CODENAME} sources file...")"
    cat > /etc/apt/sources.list.d/debian.sources << EOF
Types: deb
URIs: http://deb.debian.org/debian/
Suites: ${TARGET_CODENAME} ${TARGET_CODENAME}-updates
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg

Types: deb
URIs: http://security.debian.org/debian-security/
Suites: ${TARGET_CODENAME}-security
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg
EOF



    msg_ok "$(translate "Debian repositories configured for $TARGET_CODENAME")"

    local firmware_conf="/etc/apt/apt.conf.d/no-firmware-warnings.conf"
    if [ ! -f "$firmware_conf" ]; then
        msg_info "$(translate "Disabling non-free firmware warnings...")"
        echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' > "$firmware_conf"
        msg_ok "$(translate "Non-free firmware warnings disabled")"
    fi

    update_output=$(apt-get update 2>&1)
    update_exit_code=$?

    if [ $update_exit_code -eq 0 ]; then
        msg_ok "$(translate "Package lists updated successfully")"
    else
        if echo "$update_output" | grep -q "NO_PUBKEY\|GPG error"; then
            msg_info "$(translate "Fixing GPG key issues...")"
            apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $(echo "$update_output" | grep "NO_PUBKEY" | sed 's/.*NO_PUBKEY //' | head -1) 2>/dev/null
            if apt-get update > "$log_file" 2>&1; then
                msg_ok "$(translate "Package lists updated after GPG fix")"
            else
                msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
                return 1
            fi
        elif echo "$update_output" | grep -q "404\|Failed to fetch"; then
            msg_warn "$(translate "Some repositories are not available, continuing with available ones...")"
        else
            msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
            echo "Error details: $update_output"
            return 1
        fi
    fi



    if apt policy 2>/dev/null | grep -q "${TARGET_CODENAME}.*pve-no-subscription"; then
        msg_ok "$(translate "Proxmox VE 9.x repositories verified")"
    else
        msg_warn "$(translate "Proxmox VE 9.x repositories verification inconclusive, continuing...")"
    fi

    local current_pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local available_pve_version=$(apt-cache policy pve-manager 2>/dev/null | grep -oP 'Candidate: \K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local upgradable=$(apt list --upgradable 2>/dev/null | grep -c "upgradable")
    local security_updates=$(apt list --upgradable 2>/dev/null | grep -c "security")

    show_update_menu() {
        local current_version="$1"
        local target_version="$2"
        local upgradable_count="$3"
        local security_count="$4"

        local menu_text="$(translate "System Update Information")\n\n"
        menu_text+="$(translate "Current PVE Version"): $current_version\n"
        if [ -n "$target_version" ] && [ "$target_version" != "$current_version" ]; then
            menu_text+="$(translate "Available PVE Version"): $target_version\n"
        fi
        menu_text+="\n$(translate "Package Updates Available"): $upgradable_count\n"
        menu_text+="$(translate "Security Updates"): $security_count\n\n"

        if [ "$upgradable_count" -eq 0 ]; then
            menu_text+="$(translate "System is already up to date")"
            whiptail --title "$(translate "Update Status")" --msgbox "$menu_text" 15 70
            return 2
        else
            menu_text+="$(translate "Do you want to proceed with the system update?")"
            if whiptail --title "$(translate "Proxmox Update")" --yesno "$menu_text" 18 70; then
                return 0
            else
                return 1
            fi
        fi
    }

    show_update_menu "$current_pve_version" "$available_pve_version" "$upgradable" "$security_updates"
    MENU_RESULT=$?

    if [[ $MENU_RESULT -eq 1 ]]; then
        msg_info2 "$(translate "Update cancelled by user")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        return 0
    elif [[ $MENU_RESULT -eq 2 ]]; then
        msg_ok "$(translate "System is already up to date. No update needed.")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        return 0
    fi

    msg_info "$(translate "Cleaning up unused time synchronization services...")"

    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' purge ntp openntpd systemd-timesyncd > /dev/null 2>&1; then
        msg_ok "$(translate "Old time services removed successfully")"
    else
        msg_warn "$(translate "Some old time services could not be removed (not installed)")"
    fi



    msg_info "$(translate "Updating packages...")"
    apt-get install pv -y > /dev/null 2>&1
    msg_ok "$(translate "Packages updated successfully")"
    
    tput sc
    
    DEBIAN_FRONTEND=noninteractive apt-get -y \
        -o Dpkg::Options::='--force-confdef' \
        -o Dpkg::Options::='--force-confold' \
        dist-upgrade 2>&1 | while IFS= read -r line; do
    
        echo "$line" >> "$log_file"
    
        if [[ "$line" =~ \[[#=\-]+\]\ *[0-9]{1,3}% ]]; then
            continue
        fi
    
        if [[ "$line" =~ ^(Setting\ up|Unpacking|Preparing\ to\ unpack|Processing\ triggers\ for) ]]; then
            package_name=$(echo "$line" | sed -E 's/.*(Setting up|Unpacking|Preparing to unpack|Processing triggers for) ([^ :]+).*/\2/')
            [ -z "$package_name" ] && package_name="$(translate "Unknown")"
    
            row=$(( $(tput lines) - 6 ))
            tput cup $row 0; printf "%s\n" "$(translate "Installing packages...")"
            tput cup $((row + 1)) 0; printf "%s\n" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
            tput cup $((row + 2)) 0; printf "%s %s\n" "$(translate "Package:")" "$package_name"
            tput cup $((row + 3)) 0; printf "%s\n" "Progress: [                                                  ] 0%"
            tput cup $((row + 4)) 0; printf "%s\n" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
    
            for i in $(seq 1 10); do
                sleep 0.1
                progress=$((i * 10))
                tput cup $((row + 3)) 9
                printf "[%-50s] %3d%%" "$(printf "#%.0s" $(seq 1 $((progress/2))))" "$progress"
            done
        fi
    done
    
    tput rc
    tput ed
    
    upgrade_exit_code=${PIPESTATUS[0]}




    if [ $upgrade_exit_code -eq 0 ]; then
        msg_ok "$(translate "System upgrade completed successfully")"
    else
        msg_error "$(translate "System upgrade failed. Check log: $log_file")"
        return 1
    fi


    msg_info "$(translate "Installing essential Proxmox packages...")"
    local additional_packages="zfsutils-linux proxmox-backup-restore-image chrony"
    
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install $additional_packages >> "$log_file" 2>&1; then
        msg_ok "$(translate "Essential Proxmox packages installed")"
    else
        msg_warn "$(translate "Some essential Proxmox packages may not have been installed")"
    fi

    lvm_repair_check
    cleanup_duplicate_repos

    #msg_info "$(translate "Performing system cleanup...")"
    apt-get -y autoremove > /dev/null 2>&1 || true
    apt-get -y autoclean > /dev/null 2>&1 || true
    msg_ok "$(translate "Cleanup finished")"

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))

    echo -e "${TAB}${BGN}$(translate "====== PVE UPDATE COMPLETED ======")${CL}"
    echo -e "${TAB}${GN}â±ï¸  $(translate "Duration")${CL}: ${BL}${minutes}m ${seconds}s${CL}"
    echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$log_file${CL}"
    echo -e "${TAB}${GN}ğŸ“¦ $(translate "Packages upgraded")${CL}: ${BL}$upgradable${CL}"
    echo -e "${TAB}${GN}ğŸ–¥ï¸  $(translate "Proxmox VE")${CL}: ${BL}$target_version (Debian $OS_CODENAME)${CL}"

    msg_ok "$(translate "Proxmox VE 9.x configuration completed.")"
    
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    update_pve9
fi



================================================
FILE: scripts/global/update-pve8.sh
================================================
#!/bin/bash
# ==========================================================
# Proxmox VE 8.x Update Script
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

download_common_functions() {
    if ! source "$LOCAL_SCRIPTS/global/common-functions.sh"; then
        return 1
    fi
}

update_pve8() {
    local start_time=$(date +%s)
    local log_file="/var/log/proxmox-update-$(date +%Y%m%d-%H%M%S).log"
    local changes_made=false
    local OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
    
    if [ -z "$OS_CODENAME" ]; then
        OS_CODENAME=$(lsb_release -cs 2>/dev/null || echo "bookworm")
    fi

    download_common_functions

    msg_info2 "$(translate "Detected: Proxmox VE 8.x (Debian $OS_CODENAME)")"
    echo

    local available_space=$(df /var/cache/apt/archives | awk 'NR==2 {print int($4/1024)}')
    if [ "$available_space" -lt 1024 ]; then
        msg_error "$(translate "Insufficient disk space. Available: ${available_space}MB")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! ping -c 1 download.proxmox.com >/dev/null 2>&1; then
        msg_error "$(translate "Cannot reach Proxmox repositories")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi


    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ] && grep -q "^deb" /etc/apt/sources.list.d/pve-enterprise.list; then
        sed -i "s/^deb/#deb/g" /etc/apt/sources.list.d/pve-enterprise.list
        msg_ok "$(translate "Enterprise Proxmox repository disabled")"
        changes_made=true
    fi

    if [ -f /etc/apt/sources.list.d/ceph.list ] && grep -q "^deb" /etc/apt/sources.list.d/ceph.list; then
        sed -i "s/^deb/#deb/g" /etc/apt/sources.list.d/ceph.list
        msg_ok "$(translate "Enterprise Proxmox Ceph repository disabled")"
        changes_made=true
    fi


    if [ ! -f /etc/apt/sources.list.d/pve-public-repo.list ] || ! grep -q "pve-no-subscription" /etc/apt/sources.list.d/pve-public-repo.list; then
        echo "deb http://download.proxmox.com/debian/pve $OS_CODENAME pve-no-subscription" > /etc/apt/sources.list.d/pve-public-repo.list
        msg_ok "$(translate "Free public Proxmox repository enabled")"
        changes_made=true
    fi


    local sources_file="/etc/apt/sources.list"
    cp "$sources_file" "${sources_file}.backup.$(date +%Y%m%d_%H%M%S)"

    if grep -q -E "(debian-security -security|debian main$|debian -updates)" "$sources_file"; then
        sed -i '/^deb.*debian-security -security/d' "$sources_file"
        sed -i '/^deb.*debian main$/d' "$sources_file"
        sed -i '/^deb.*debian -updates/d' "$sources_file"
        changes_made=true
        msg_ok "$(translate "Malformed repository entries cleaned")"
    fi

    cat > "$sources_file" << EOF
# Debian $OS_CODENAME repositories
deb http://deb.debian.org/debian $OS_CODENAME main contrib non-free non-free-firmware
deb http://deb.debian.org/debian $OS_CODENAME-updates main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security $OS_CODENAME-security main contrib non-free non-free-firmware
EOF

    msg_ok "$(translate "Debian repositories configured for $OS_CODENAME")"

    local firmware_conf="/etc/apt/apt.conf.d/no-firmware-warnings.conf"
    if [ ! -f "$firmware_conf" ]; then
        echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' > "$firmware_conf"
    fi

    cleanup_duplicate_repos

    msg_info "$(translate "Updating package lists...")"
    if apt-get update > "$log_file" 2>&1; then
        msg_ok "$(translate "Package lists updated successfully")"
    else
        msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
        return 1
    fi

    local current_pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local available_pve_version=$(apt-cache policy pve-manager 2>/dev/null | grep -oP 'Candidate: \K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local upgradable=$(apt list --upgradable 2>/dev/null | grep -c "upgradable")
    local security_updates=$(apt list --upgradable 2>/dev/null | grep -c "security")

    show_update_menu() {
        local current_version="$1"
        local target_version="$2"
        local upgradable_count="$3"
        local security_count="$4"

        local menu_text="$(translate "System Update Information")\n\n"
        menu_text+="$(translate "Current PVE Version"): $current_version\n"
        if [ -n "$target_version" ] && [ "$target_version" != "$current_version" ]; then
            menu_text+="$(translate "Available PVE Version"): $target_version\n"
        fi
        menu_text+="\n$(translate "Package Updates Available"): $upgradable_count\n"
        menu_text+="$(translate "Security Updates"): $security_count\n\n"

        if [ "$upgradable_count" -eq 0 ]; then
            menu_text+="$(translate "System is already up to date")"
            whiptail --title "$(translate "Update Status")" --msgbox "$menu_text" 15 70
            return 2
        else
            menu_text+="$(translate "Do you want to proceed with the system update?")"
            if whiptail --title "$(translate "Proxmox Update")" --yesno "$menu_text" 18 70; then
                return 0
            else
                return 1
            fi
        fi
    }

    show_update_menu "$current_pve_version" "$available_pve_version" "$upgradable" "$security_updates"
    MENU_RESULT=$?

    if [[ $MENU_RESULT -eq 1 ]]; then
        msg_info2 "$(translate "Update cancelled by user")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        return 0
    elif [[ $MENU_RESULT -eq 2 ]]; then
        msg_ok "$(translate "System is already up to date. No update needed.")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        return 0
    fi

    
    local conflicting_packages=$(dpkg -l 2>/dev/null | grep -E "^ii.*(ntp|openntpd|systemd-timesyncd)" | awk '{print $2}')
    if [ -n "$conflicting_packages" ]; then
        msg_info "$(translate "Removing conflicting utilities...")"
        DEBIAN_FRONTEND=noninteractive apt-get -y purge $conflicting_packages >> "$log_file" 2>&1
        msg_ok "$(translate "Conflicting utilities removed")"
    fi


    export DEBIAN_FRONTEND=noninteractive
    export APT_LISTCHANGES_FRONTEND=none
    export NEEDRESTART_MODE=a      
    export UCF_FORCE_CONFOLD=1       
    export DPKG_OPTIONS="--force-confdef --force-confold"  

    msg_info "$(translate "Performing packages upgrade...")"
    apt-get install pv -y > /dev/null 2>&1
    total_packages=$(apt-get -s dist-upgrade | grep "^Inst" | wc -l)
    msg_ok "$(translate "Packages upgrade successfull")"

    if [ "$total_packages" -eq 0 ]; then
        total_packages=1
    fi

    tput civis  
    tput sc      

    (
        /usr/bin/env \
            DEBIAN_FRONTEND=noninteractive \
            APT_LISTCHANGES_FRONTEND=none \
            NEEDRESTART_MODE=a \
            UCF_FORCE_CONFOLD=1 \
            apt-get -y \
                -o Dpkg::Options::="--force-confdef" \
                -o Dpkg::Options::="--force-confold" \
                dist-upgrade 2>&1 | \
        while IFS= read -r line; do
            if [[ "$line" =~ ^(Setting\ up|Unpacking|Preparing\ to\ unpack|Processing\ triggers\ for) ]]; then
                package_name=$(echo "$line" | sed -E 's/.*(Setting up|Unpacking|Preparing to unpack|Processing triggers for) ([^ ]+).*/\2/')
                [ -z "$package_name" ] && package_name="$(translate "Unknown")"

                tput rc
                tput ed

                row=$(( $(tput lines) - 6 ))
                tput cup $row 0; echo "$(translate "Installing packages...")"
                tput cup $((row + 1)) 0; echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                tput cup $((row + 2)) 0; echo "Package: $package_name"
                tput cup $((row + 3)) 0; echo "Progress: [                                                  ] 0%"
                tput cup $((row + 4)) 0; echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

                for i in $(seq 1 10); do
                    progress=$((i * 10))
                    tput cup $((row + 3)) 9
                    printf "[%-50s] %3d%%" "$(printf "#%.0s" $(seq 1 $((progress/2))))" "$progress"
                done
            fi
        done
    )

    if [ $? -eq 0 ]; then
        tput rc
        tput ed
        tput cnorm
        msg_ok "$(translate "System upgrade completed")"
    fi


    
    local essential_packages=("zfsutils-linux" "proxmox-backup-restore-image" "chrony")
    local missing_packages=()
    
    for package in "${essential_packages[@]}"; do
        if ! dpkg -l 2>/dev/null | grep -q "^ii  $package "; then
            missing_packages+=("$package")
        fi
    done

    if [ ${#missing_packages[@]} -gt 0 ]; then
        msg_info "$(translate "Installing essential Proxmox packages...")"
        DEBIAN_FRONTEND=noninteractive apt-get -y install "${missing_packages[@]}" >> "$log_file" 2>&1
        msg_ok "$(translate "Essential Proxmox packages installed")"
    fi

    lvm_repair_check
    cleanup_duplicate_repos

    msg_info "$(translate "Performing system cleanup...")"
    apt-get -y autoremove > /dev/null 2>&1 || true
    apt-get -y autoclean > /dev/null 2>&1 || true
    msg_ok "$(translate "Cleanup finished")"

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))

    echo -e "${TAB}${BGN}$(translate "====== PVE UPDATE COMPLETED ======")${CL}"
    echo -e "${TAB}${GN}â±ï¸  $(translate "Duration")${CL}: ${BL}${minutes}m ${seconds}s${CL}"
    echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$log_file${CL}"
    echo -e "${TAB}${GN}ğŸ“¦ $(translate "Packages upgraded")${CL}: ${BL}$upgradable${CL}"
    echo -e "${TAB}${GN}ğŸ–¥ï¸  $(translate "Proxmox VE")${CL}: ${BL}$target_version (Debian $OS_CODENAME)${CL}"



    msg_ok "$(translate "Proxmox VE 8 system update completed successfully")"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    update_pve8
fi



================================================
FILE: scripts/global/update-pve9_2.sh
================================================
#!/bin/bash
# ==========================================================
# Proxmox VE Update Script - Improved Version (with apt progress)
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"
APT_ENV="env DEBIAN_FRONTEND=noninteractive LC_ALL=C LANG=C"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

download_common_functions() {
    if ! source "$LOCAL_SCRIPTS/global/common-functions.sh"; then
        return 1
    fi
}

update_pve9() {
    local pve_version
    pve_version=$(pveversion | awk -F'/' '{print $2}' | cut -d'-' -f1)
    local start_time
    start_time=$(date +%s)
    local log_file="/var/log/proxmox-update-$(date +%Y%m%d-%H%M%S).log"
    local changes_made=false
    local OS_CODENAME
    OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
    local TARGET_CODENAME="trixie"
    
    local screen_capture="/tmp/proxmenux_screen_capture_$$.txt"
    
    if [ -z "$OS_CODENAME" ]; then
        OS_CODENAME=$(lsb_release -cs 2>/dev/null || echo "trixie")
    fi

    download_common_functions

    {
        msg_info2 "$(translate "Detected: Proxmox VE $pve_version (Current: $OS_CODENAME, Target: $TARGET_CODENAME)")"
    } | tee -a "$screen_capture"


    local available_space
    available_space=$(df /var/cache/apt/archives | awk 'NR==2 {print int($4/1024)}')
    if [ "$available_space" -lt 1024 ]; then
        msg_error "$(translate "Insufficient disk space. Available: ${available_space}MB")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! ping -c 1 download.proxmox.com >/dev/null 2>&1; then
        msg_error "$(translate "Cannot reach Proxmox repositories")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    disable_sources_repo() {
        local file="$1"
        if [[ -f "$file" ]]; then
            sed -i ':a;/^\n*$/{$d;N;ba}' "$file"

            if grep -q "^Enabled:" "$file"; then
                sed -i 's/^Enabled:.*$/Enabled: false/' "$file"
            else
                echo "Enabled: false" >> "$file"
            fi

            if ! grep -q "^Types: " "$file"; then
                msg_warn "$(translate "Malformed .sources file detected, removing: $(basename "$file")")"
                rm -f "$file"
            fi
            return 0
        fi
        return 1
    }

    if disable_sources_repo "/etc/apt/sources.list.d/pve-enterprise.sources"; then
        msg_ok "$(translate "Enterprise Proxmox repository disabled")" | tee -a "$screen_capture"
        changes_made=true
    fi

    if disable_sources_repo "/etc/apt/sources.list.d/ceph.sources"; then
        msg_ok "$(translate "Enterprise Proxmox Ceph repository disabled")" | tee -a "$screen_capture"
        changes_made=true
    fi

    for legacy_file in /etc/apt/sources.list.d/pve-public-repo.list \
                       /etc/apt/sources.list.d/pve-install-repo.list \
                       /etc/apt/sources.list.d/debian.list; do
        if [[ -f "$legacy_file" ]]; then
            rm -f "$legacy_file"
            msg_ok "$(translate "Removed legacy repository: $(basename "$legacy_file")")" | tee -a "$screen_capture"
        fi
    done

    if [[ -f /etc/apt/sources.list.d/debian.sources ]]; then
        rm -f /etc/apt/sources.list.d/debian.sources
        msg_ok "$(translate "Old debian.sources file removed to prevent duplication")" | tee -a "$screen_capture"
    fi

    msg_info "$(translate "Creating Proxmox VE 9.x no-subscription repository...")"
    cat > /etc/apt/sources.list.d/proxmox.sources << EOF
Enabled: true
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: ${TARGET_CODENAME}
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
    msg_ok "$(translate "Proxmox VE 9.x no-subscription repository created")" | tee -a "$screen_capture"
    changes_made=true

    msg_info "$(translate "Creating Debian ${TARGET_CODENAME} sources file...")"
    cat > /etc/apt/sources.list.d/debian.sources << EOF
Types: deb
URIs: http://deb.debian.org/debian/
Suites: ${TARGET_CODENAME} ${TARGET_CODENAME}-updates
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg

Types: deb
URIs: http://security.debian.org/debian-security/
Suites: ${TARGET_CODENAME}-security
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg
EOF

    msg_ok "$(translate "Debian repositories configured for $TARGET_CODENAME")"

    local firmware_conf="/etc/apt/apt.conf.d/no-firmware-warnings.conf"
    if [ ! -f "$firmware_conf" ]; then
        msg_info "$(translate "Disabling non-free firmware warnings...")"
        echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' > "$firmware_conf"
        msg_ok "$(translate "Non-free firmware warnings disabled")"
    fi

    # UPDATE: no progress bar here (dpkg is not involved); capture output to parse errors
    update_output=$(apt-get update 2>&1)
    update_exit_code=$?

    if [ $update_exit_code -eq 0 ]; then
        msg_ok "$(translate "Package lists updated successfully")" | tee -a "$screen_capture"
    else
        # Handle common apt errors
        if echo "$update_output" | grep -Eq "NO_PUBKEY|GPG error"; then

            # Extract first missing key (NO_PUBKEY ABCDEF... pattern)
            key=$(echo "$update_output" | sed -n 's/.*NO_PUBKEY \([0-9A-F]\{8,40\}\).*/\1/p' | head -1)

            if [ -n "$key" ]; then
                mkdir -p /etc/apt/keyrings

                if command -v gpg >/dev/null 2>&1; then
                    # Modern approach: receive -> export -> dearmor into /etc/apt/keyrings/<KEY>.gpg
                    if gpg --batch --keyserver keyserver.ubuntu.com --recv-keys "$key" \
                    && gpg --batch --export "$key" | gpg --dearmor -o "/etc/apt/keyrings/${key}.gpg"; then
                        msg_ok "$(translate "Imported missing GPG key: $key")"
                    else
                        msg_warn "$(translate "Keyrings method failed; trying apt-key fallback")"
                        apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "$key" >/dev/null 2>&1 || true
                    fi
                else
                    # Fallback for minimal systems without gpg installed
                    msg_warn "$(translate "gpg not found; trying apt-key fallback")"
                    apt-key adv --keyserver keyserver.ubuntu.com --recv-keys "$key" >/dev/null 2>&1 || true
                fi
            fi

            # Retry update after importing the key
            if apt-get update > "$log_file" 2>&1; then
                msg_ok "$(translate "Package lists updated after GPG fix")" | tee -a "$screen_capture"
            else
                msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
                return 1
            fi

        elif echo "$update_output" | grep -Eq "404|Failed to fetch"; then
            msg_warn "$(translate "Some repositories are not available, continuing with available ones...")"
        else
            msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
            echo "Error details: $update_output"
            return 1
        fi
    fi

    if apt policy 2>/dev/null | grep -q "${TARGET_CODENAME}.*pve-no-subscription"; then
        msg_ok "$(translate "Proxmox VE $pve_version repositories verified")" | tee -a "$screen_capture"
    else
        msg_warn "$(translate "Proxmox VE $pve_version repositories verification inconclusive, continuing...")"
    fi

    local current_pve_version
    current_pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local available_pve_version
    available_pve_version=$(apt-cache policy pve-manager 2>/dev/null | grep -oP 'Candidate: \K[0-9]+\.[0-9]+\.[0-9]+' | head -1)


    local upgradable
    upgradable=$($APT_ENV apt list --upgradable 2>/dev/null \
        | sed '1d' \
        | sed '/^\s*$/d' \
        | wc -l)

    local security_updates
    security_updates=$($APT_ENV apt list --upgradable 2>/dev/null \
        | sed '1d' \
        | grep -ci '\-security')


    show_update_menu() {
        local current_version="$1"
        local target_version="$2"
        local upgradable_count="$3"
        local security_count="$4"

        local menu_text
        menu_text="$(translate "System Update Information")\n\n"
        menu_text+="$(translate "Current PVE Version"): $current_version\n"
        if [ -n "$target_version" ] && [ "$target_version" != "$current_version" ]; then
            menu_text+="$(translate "Available PVE Version"): $target_version\n"
        fi
        menu_text+="\n$(translate "Package Updates Available"): $upgradable_count\n"
        menu_text+="$(translate "Security Updates"): $security_count\n\n"

        if [ "$upgradable_count" -eq 0 ]; then
            menu_text+="$(translate "System is already up to date")"
            whiptail --title "$(translate "Update Status")" --msgbox "$menu_text" 15 70
            return 2
        else
            menu_text+="$(translate "Do you want to proceed with the system update?")"
            if whiptail --title "$(translate "Proxmox Update")" --yesno "$menu_text" 18 70; then
                return 0
            else
                return 1
            fi
        fi
    }

    show_update_menu "$current_pve_version" "$available_pve_version" "$upgradable" "$security_updates"
    MENU_RESULT=$?

    clear
    show_proxmenux_logo
    msg_title "$(translate "$SCRIPT_TITLE")"
    cat "$screen_capture"

    if [[ $MENU_RESULT -eq 1 ]]; then
        msg_info2 "$(translate "Update cancelled by user")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        rm -f "$screen_capture"
        return 0
    elif [[ $MENU_RESULT -eq 2 ]]; then
        msg_ok "$(translate "System is already up to date. No update needed.")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        rm -f "$screen_capture"
        return 0
    fi

    msg_info "$(translate "Cleaning up unused time synchronization services...")"
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' purge ntp openntpd systemd-timesyncd > /dev/null 2>&1; then
        msg_ok "$(translate "Old time services removed successfully")"
    else
        msg_warn "$(translate "Some old time services could not be removed (not installed)")"
    fi

    echo -e


    DEBIAN_FRONTEND=noninteractive apt -y \
        -o Dpkg::Options::='--force-confdef' \
        -o Dpkg::Options::='--force-confold' \
        full-upgrade 2> >(tee -a "$log_file" >&2)

    upgrade_exit_code=$?
    echo -e

    clear
    show_proxmenux_logo
    msg_title "$(translate "$SCRIPT_TITLE")"
    cat "$screen_capture"

    if [ $upgrade_exit_code -ne 0 ]; then
        msg_error "$(translate "System upgrade failed. Check log: $log_file")"
        rm -f "$screen_capture"
        return 1
    fi

    msg_info "$(translate "Installing essential Proxmox packages...")"
    local additional_packages="zfsutils-linux proxmox-backup-restore-image chrony"
    
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install $additional_packages >> "$log_file" 2>&1; then
        msg_ok "$(translate "Essential Proxmox packages installed")"
    else
        msg_warn "$(translate "Some essential Proxmox packages may not have been installed")"
    fi

    lvm_repair_check
    cleanup_duplicate_repos

    apt-get -y autoremove > /dev/null 2>&1 || true
    apt-get -y autoclean > /dev/null 2>&1 || true
    msg_ok "$(translate "Cleanup finished")"

    local end_time
    end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))

    echo -e "${TAB}${BGN}$(translate "====== PVE UPDATE COMPLETED ======")${CL}"
    echo -e "${TAB}${GN}â±ï¸  $(translate "Duration")${CL}: ${BL}${minutes}m ${seconds}s${CL}"
    echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$log_file${CL}"
    echo -e "${TAB}${GN}ğŸ“¦ $(translate "Packages upgraded")${CL}: ${BL}$upgradable${CL}"
    echo -e "${TAB}${GN}ğŸ–¥ï¸  $(translate "Proxmox VE")${CL}: ${BL}$available_pve_version (Debian $OS_CODENAME)${CL}"

    msg_ok "$(translate "Proxmox VE configuration completed.")"
    
    rm -f "$screen_capture"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    update_pve9
fi



================================================
FILE: scripts/global/update-pve9_2_.sh
================================================
#!/bin/bash
# ==========================================================
# Proxmox VE Update Script - Improved Version
# ==========================================================

# Configuration
REPO_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

download_common_functions() {
    if ! source <(curl -s "$REPO_URL/scripts/global/common-functions.sh"); then
        return 1
    fi
}

update_pve9() {
    local pve_version=$(pveversion | awk -F'/' '{print $2}' | cut -d'-' -f1)
    local start_time=$(date +%s)
    local log_file="/var/log/proxmox-update-$(date +%Y%m%d-%H%M%S).log"
    local changes_made=false
    local OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
    local TARGET_CODENAME="trixie"
    
    local screen_capture="/tmp/proxmenux_screen_capture_$$.txt"
    
    if [ -z "$OS_CODENAME" ]; then
        OS_CODENAME=$(lsb_release -cs 2>/dev/null || echo "trixie")
    fi

    download_common_functions

    {
        msg_info2 "$(translate "Detected: Proxmox VE $pve_version (Current: $OS_CODENAME, Target: $TARGET_CODENAME)")"
    } | tee -a "$screen_capture"


    local available_space=$(df /var/cache/apt/archives | awk 'NR==2 {print int($4/1024)}')
    if [ "$available_space" -lt 1024 ]; then
        msg_error "$(translate "Insufficient disk space. Available: ${available_space}MB")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! ping -c 1 download.proxmox.com >/dev/null 2>&1; then
        msg_error "$(translate "Cannot reach Proxmox repositories")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    disable_sources_repo() {
        local file="$1"
        if [[ -f "$file" ]]; then
            sed -i ':a;/^\n*$/{$d;N;ba}' "$file"

            if grep -q "^Enabled:" "$file"; then
                sed -i 's/^Enabled:.*$/Enabled: false/' "$file"
            else
                echo "Enabled: false" >> "$file"
            fi

            if ! grep -q "^Types: " "$file"; then
                msg_warn "$(translate "Malformed .sources file detected, removing: $(basename "$file")")"
                rm -f "$file"
            fi
            return 0
        fi
        return 1
    }

    if disable_sources_repo "/etc/apt/sources.list.d/pve-enterprise.sources"; then
        msg_ok "$(translate "Enterprise Proxmox repository disabled")" | tee -a "$screen_capture"
        changes_made=true
    fi

    if disable_sources_repo "/etc/apt/sources.list.d/ceph.sources"; then
        msg_ok "$(translate "Enterprise Proxmox Ceph repository disabled")" | tee -a "$screen_capture"
        changes_made=true
    fi

    for legacy_file in /etc/apt/sources.list.d/pve-public-repo.list \
                       /etc/apt/sources.list.d/pve-install-repo.list \
                       /etc/apt/sources.list.d/debian.list; do
        if [[ -f "$legacy_file" ]]; then
            rm -f "$legacy_file"
            msg_ok "$(translate "Removed legacy repository: $(basename "$legacy_file")")" | tee -a "$screen_capture"
        fi
    done

    if [[ -f /etc/apt/sources.list.d/debian.sources ]]; then
        rm -f /etc/apt/sources.list.d/debian.sources
        msg_ok "$(translate "Old debian.sources file removed to prevent duplication")" | tee -a "$screen_capture"
    fi

    msg_info "$(translate "Creating Proxmox VE 9.x no-subscription repository...")"
    cat > /etc/apt/sources.list.d/proxmox.sources << EOF
Enabled: true
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: ${TARGET_CODENAME}
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
    msg_ok "$(translate "Proxmox VE 9.x no-subscription repository created")" | tee -a "$screen_capture"
    changes_made=true

    msg_info "$(translate "Creating Debian ${TARGET_CODENAME} sources file...")"
    cat > /etc/apt/sources.list.d/debian.sources << EOF
Types: deb
URIs: http://deb.debian.org/debian/
Suites: ${TARGET_CODENAME} ${TARGET_CODENAME}-updates
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg

Types: deb
URIs: http://security.debian.org/debian-security/
Suites: ${TARGET_CODENAME}-security
Components: main contrib non-free non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg
EOF

    msg_ok "$(translate "Debian repositories configured for $TARGET_CODENAME")"

    local firmware_conf="/etc/apt/apt.conf.d/no-firmware-warnings.conf"
    if [ ! -f "$firmware_conf" ]; then
        msg_info "$(translate "Disabling non-free firmware warnings...")"
        echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' > "$firmware_conf"
        msg_ok "$(translate "Non-free firmware warnings disabled")"
    fi

    #update_output=$(apt-get update 2>&1)
    update_output=$(apt-get -o Dpkg::Progress-Fancy=1 update 2>&1)
    update_exit_code=$?

    if [ $update_exit_code -eq 0 ]; then
        msg_ok "$(translate "Package lists updated successfully")" | tee -a "$screen_capture"
    else
        if echo "$update_output" | grep -q "NO_PUBKEY\|GPG error"; then
            msg_info "$(translate "Fixing GPG key issues...")"
            apt-key adv --keyserver keyserver.ubuntu.com --recv-keys $(echo "$update_output" | grep "NO_PUBKEY" | sed 's/.*NO_PUBKEY //' | head -1) 2>/dev/null
            if apt-get update > "$log_file" 2>&1; then
                msg_ok "$(translate "Package lists updated after GPG fix")" | tee -a "$screen_capture"
            else
                msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
                return 1
            fi
        elif echo "$update_output" | grep -q "404\|Failed to fetch"; then
            msg_warn "$(translate "Some repositories are not available, continuing with available ones...")"
        else
            msg_error "$(translate "Failed to update package lists. Check log: $log_file")"
            echo "Error details: $update_output"
            return 1
        fi
    fi

    if apt policy 2>/dev/null | grep -q "${TARGET_CODENAME}.*pve-no-subscription"; then
        msg_ok "$(translate "Proxmox VE 9.x repositories verified")" | tee -a "$screen_capture"
    else
        msg_warn "$(translate "Proxmox VE 9.x repositories verification inconclusive, continuing...")"
    fi

    local current_pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local available_pve_version=$(apt-cache policy pve-manager 2>/dev/null | grep -oP 'Candidate: \K[0-9]+\.[0-9]+\.[0-9]+' | head -1)
    local upgradable=$(apt list --upgradable 2>/dev/null | grep -c "upgradable")
    local security_updates=$(apt list --upgradable 2>/dev/null | grep -c "security")

    show_update_menu() {
        local current_version="$1"
        local target_version="$2"
        local upgradable_count="$3"
        local security_count="$4"

        local menu_text="$(translate "System Update Information")\n\n"
        menu_text+="$(translate "Current PVE Version"): $current_version\n"
        if [ -n "$target_version" ] && [ "$target_version" != "$current_version" ]; then
            menu_text+="$(translate "Available PVE Version"): $target_version\n"
        fi
        menu_text+="\n$(translate "Package Updates Available"): $upgradable_count\n"
        menu_text+="$(translate "Security Updates"): $security_count\n\n"

        if [ "$upgradable_count" -eq 0 ]; then
            menu_text+="$(translate "System is already up to date")"
            whiptail --title "$(translate "Update Status")" --msgbox "$menu_text" 15 70
            return 2
        else
            menu_text+="$(translate "Do you want to proceed with the system update?")"
            if whiptail --title "$(translate "Proxmox Update")" --yesno "$menu_text" 18 70; then
                return 0
            else
                return 1
            fi
        fi
    }

    show_update_menu "$current_pve_version" "$available_pve_version" "$upgradable" "$security_updates"
    MENU_RESULT=$?

    clear
    show_proxmenux_logo
    msg_title "$(translate "$SCRIPT_TITLE")"
    cat "$screen_capture"


    if [[ $MENU_RESULT -eq 1 ]]; then
        msg_info2 "$(translate "Update cancelled by user")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        rm -f "$screen_capture"
        return 0
    elif [[ $MENU_RESULT -eq 2 ]]; then
        msg_ok "$(translate "System is already up to date. No update needed.")"
        apt-get -y autoremove > /dev/null 2>&1 || true
        apt-get -y autoclean > /dev/null 2>&1 || true
        rm -f "$screen_capture"
        return 0
    fi

    msg_info "$(translate "Cleaning up unused time synchronization services...")"
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' purge ntp openntpd systemd-timesyncd > /dev/null 2>&1; then
        msg_ok "$(translate "Old time services removed successfully")"
    else
        msg_warn "$(translate "Some old time services could not be removed (not installed)")"
    fi

    echo -e
    DEBIAN_FRONTEND=noninteractive apt-get -y \
        -o Dpkg::Options::='--force-confdef' \
        -o Dpkg::Options::='--force-confold' \
        dist-upgrade 2>&1 | tee -a "$log_file"
    
    upgrade_exit_code=${PIPESTATUS[0]}
    echo -e

    clear
    show_proxmenux_logo
     msg_title "$(translate "$SCRIPT_TITLE")"
    cat "$screen_capture"

    
    if [ $upgrade_exit_code -ne 0 ]; then
        msg_error "$(translate "System upgrade failed. Check log: $log_file")"
        rm -f "$screen_capture"
        return 1
    fi

    msg_info "$(translate "Installing essential Proxmox packages...")"
    local additional_packages="zfsutils-linux proxmox-backup-restore-image chrony"
    
    if /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install $additional_packages >> "$log_file" 2>&1; then
        msg_ok "$(translate "Essential Proxmox packages installed")"
    else
        msg_warn "$(translate "Some essential Proxmox packages may not have been installed")"
    fi

    lvm_repair_check
    cleanup_duplicate_repos

    apt-get -y autoremove > /dev/null 2>&1 || true
    apt-get -y autoclean > /dev/null 2>&1 || true
    msg_ok "$(translate "Cleanup finished")"

    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))

    echo -e "${TAB}${BGN}$(translate "====== PVE UPDATE COMPLETED ======")${CL}"
    echo -e "${TAB}${GN}â±ï¸  $(translate "Duration")${CL}: ${BL}${minutes}m ${seconds}s${CL}"
    echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$log_file${CL}"
    echo -e "${TAB}${GN}ğŸ“¦ $(translate "Packages upgraded")${CL}: ${BL}$upgradable${CL}"
    echo -e "${TAB}${GN}ğŸ–¥ï¸  $(translate "Proxmox VE")${CL}: ${BL}$available_pve_version (Debian $OS_CODENAME)${CL}"

    msg_ok "$(translate "Proxmox VE 9.x configuration completed.")"
    
    rm -f "$screen_capture"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    update_pve9
fi



================================================
FILE: scripts/gpu_tpu/install_coral_pve9.sh
================================================
#!/bin/bash
# ProxMenux - Coral TPU Installer (PVE 9.x)
# =========================================
# Author      : MacRimi
# License     : MIT
# Version     : 1.3 (PVE9, silent build)
# Last Updated: 25/09/2025
# =========================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
LOG_FILE="/tmp/coral_install.log"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi


load_language
initialize_cache




ensure_apex_group_and_udev() {
  msg_info "Ensuring apex group and udev rules..."


  if ! getent group apex >/dev/null; then
    groupadd --system apex || true
    msg_ok "System group 'apex' created"
  else
    msg_ok "System group 'apex' already exists"
  fi


  cat >/etc/udev/rules.d/99-coral-apex.rules <<'EOF'
# Coral / Google APEX TPU (M.2 / PCIe)
# Assign group "apex" and safe permissions to device nodes
KERNEL=="apex_*", GROUP="apex", MODE="0660"
SUBSYSTEM=="apex", GROUP="apex", MODE="0660"
EOF


  if [[ -f /usr/lib/udev/rules.d/60-gasket-dkms.rules ]]; then
    sed -i 's/GROUP="[^"]*"/GROUP="apex"/g' /usr/lib/udev/rules.d/60-gasket-dkms.rules || true
  fi


  udevadm control --reload-rules
  udevadm trigger --subsystem-match=apex || true

  msg_ok "apex group and udev rules are in place"


  if ls -l /dev/apex_* 2>/dev/null | grep -q ' apex '; then
    msg_ok "Coral TPU device nodes detected with correct group (apex)"
  else
    msg_warn "apex device node not found yet; a reboot may be required"
  fi
}




pre_install_prompt() {
  if ! dialog --title "$(translate 'Coral TPU Installation')" --yesno \
    "\n$(translate 'Installing Coral TPU drivers requires rebooting the server after installation. Do you want to proceed?')" 10 70; then

    exit 0
  fi
}

install_coral_host() {
  show_proxmenux_logo
  : >"$LOG_FILE"  



  msg_info "$(translate 'Installing build dependencies...')"
  apt-get update -qq >>"$LOG_FILE" 2>&1
  apt-get install -y git devscripts dh-dkms dkms proxmox-headers-$(uname -r) >>"$LOG_FILE" 2>&1
  if [[ $? -ne 0 ]]; then msg_error "$(translate 'Error installing build dependencies. Check /tmp/coral_install.log')"; exit 1; fi
  msg_ok   "$(translate 'Build dependencies installed.')"



  cd /tmp || exit 1
  rm -rf gasket-driver >>"$LOG_FILE" 2>&1
  msg_info "$(translate 'Cloning Google Coral driver repository...')"
  git clone https://github.com/google/gasket-driver.git >>"$LOG_FILE" 2>&1
  if [[ $? -ne 0 ]]; then msg_error "$(translate 'Could not clone the repository. Check /tmp/coral_install.log')"; exit 1; fi
  msg_ok   "$(translate 'Repository cloned successfully.')"



  cd /tmp/gasket-driver || exit 1
  msg_info "$(translate 'Patching source for kernel compatibility...')"


  sed -i 's/\.llseek = no_llseek/\.llseek = noop_llseek/' src/gasket_core.c

  sed -i 's/^MODULE_IMPORT_NS(DMA_BUF);/MODULE_IMPORT_NS("DMA_BUF");/' src/gasket_page_table.c

  sed -i "s/\(linux-headers-686-pae | linux-headers-amd64 | linux-headers-generic | linux-headers\)/\1 | proxmox-headers-$(uname -r) | pve-headers-$(uname -r)/" debian/control
  if [[ $? -ne 0 ]]; then msg_error "$(translate 'Patching failed. Check /tmp/coral_install.log')"; exit 1; fi
  msg_ok   "$(translate 'Source patched successfully.')"



  msg_info "$(translate 'Building DKMS package...')"
  debuild -us -uc -tc -b >>"$LOG_FILE" 2>&1
  if [[ $? -ne 0 ]]; then msg_error "$(translate 'Failed to build DKMS package. Check /tmp/coral_install.log')"; exit 1; fi
  msg_ok   "$(translate 'DKMS package built successfully.')"



  msg_info "$(translate 'Installing DKMS package...')"
  dpkg -i ../gasket-dkms_*.deb >>"$LOG_FILE" 2>&1 || true
  if ! dpkg -s gasket-dkms >/dev/null 2>&1; then
    msg_error "$(translate 'Failed to install DKMS package. Check /tmp/coral_install.log')"; exit 1
  fi
  msg_ok   "$(translate 'DKMS package installed.')"



  msg_info "$(translate 'Compiling Coral TPU drivers for current kernel...')"
  dkms remove -m gasket -v 1.0 -k "$(uname -r)" >>"$LOG_FILE" 2>&1 || true
  dkms add    -m gasket -v 1.0            >>"$LOG_FILE" 2>&1 || true
  dkms build  -m gasket -v 1.0 -k "$(uname -r)" >>"$LOG_FILE" 2>&1
  if [[ $? -ne 0 ]]; then
    sed -n '1,200p' /var/lib/dkms/gasket/1.0/build/make.log >>"$LOG_FILE" 2>&1 || true
    msg_error "$(translate 'DKMS build failed. Check /tmp/coral_install.log')"; exit 1
  fi
  dkms install -m gasket -v 1.0 -k "$(uname -r)" >>"$LOG_FILE" 2>&1
  if [[ $? -ne 0 ]]; then msg_error "$(translate 'DKMS install failed. Check /tmp/coral_install.log')"; exit 1; fi
  msg_ok   "$(translate 'Drivers compiled and installed via DKMS.')"


  ensure_apex_group_and_udev

  msg_info "$(translate 'Loading modules...')"
  modprobe gasket >>"$LOG_FILE" 2>&1 || true
  modprobe apex   >>"$LOG_FILE" 2>&1 || true
  if lsmod | grep -q '\bapex\b'; then
    msg_ok "$(translate 'Modules loaded.')"
    msg_success "$(translate 'Coral TPU drivers installed and loaded successfully.')"
  else
    msg_warn "$(translate 'Installation finished but drivers are not loaded. Please check dmesg and /tmp/coral_install.log')"
  fi



  echo "---- dmesg | grep -i apex (last lines) ----" >>"$LOG_FILE"
  dmesg | grep -i apex | tail -n 20 >>"$LOG_FILE" 2>&1
}

restart_prompt() {
  if whiptail --title "$(translate 'Coral TPU Installation')" --yesno \
    "$(translate 'The installation requires a server restart to apply changes. Do you want to restart now?')" 10 70; then
    msg_warn "$(translate 'Restarting the server...')"
    reboot
  else
    msg_success "$(translate 'Completed. Press Enter to return to menu...')"
    read -r
  fi
}


pre_install_prompt
install_coral_host
restart_prompt



================================================
FILE: scripts/gpu_tpu/nvidia_installer.sh
================================================
#!/bin/bash
# ProxMenux - NVIDIA Driver Installer (PVE 9.x)
# ============================================
# Author      : MacRimi
# License     : MIT
# Version     : 0.9 (PVE9, fixed download issues)
# Last Updated: 29/11/2025
# ============================================

SCRIPT_TITLE="NVIDIA GPU Driver Installer for Proxmox VE"

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
COMPONENTS_STATUS_FILE="$BASE_DIR/components_status.json"
LOG_FILE="/tmp/nvidia_install.log"
screen_capture="/tmp/proxmenux_nvidia_screen_capture_$$.txt"

NVIDIA_BASE_URL="https://download.nvidia.com/XFree86/Linux-x86_64"
NVIDIA_WORKDIR="/opt/nvidia"

export BASE_DIR
export COMPONENTS_STATUS_FILE

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

if [[ ! -f "$COMPONENTS_STATUS_FILE" ]]; then
  echo "{}" > "$COMPONENTS_STATUS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# GPU detection and current status
# ==========================================================
detect_nvidia_gpus() {
  # Only video controllers (not audio)
  local lspci_output
  lspci_output=$(lspci | grep -i "NVIDIA" \
    | grep -Ei "VGA compatible controller|3D controller|Display controller" || true)

  if [[ -z "$lspci_output" ]]; then
    NVIDIA_GPU_PRESENT=false
    DETECTED_GPUS_TEXT="$(translate 'No NVIDIA GPU detected on this system.')"
  else
    NVIDIA_GPU_PRESENT=true
    DETECTED_GPUS_TEXT=""
    local i=1
    while IFS= read -r line; do
      DETECTED_GPUS_TEXT+="  ${i}. ${line}\n"
      ((i++))
    done <<< "$lspci_output"
  fi
}

detect_driver_status() {
  CURRENT_DRIVER_INSTALLED=false
  CURRENT_DRIVER_VERSION=""
  
  # First check if nvidia kernel module is actually loaded
  if lsmod | grep -q "^nvidia "; then

    modprobe nvidia-uvm 2>/dev/null || true
    sleep 1
    

    if command -v nvidia-smi >/dev/null 2>&1; then
      CURRENT_DRIVER_VERSION=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -n1)
      
      if [[ -n "$CURRENT_DRIVER_VERSION" ]]; then
        CURRENT_DRIVER_INSTALLED=true
        # Register the installed driver version in components_status.json
        update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
      fi
    fi
  fi

  if $CURRENT_DRIVER_INSTALLED; then
    CURRENT_STATUS_TEXT="$(printf '%s %s' "$(translate 'NVIDIA driver installed:')" "$CURRENT_DRIVER_VERSION")"
  else
    CURRENT_STATUS_TEXT="$(translate 'No NVIDIA driver installed.')"
  fi

  if $CURRENT_DRIVER_INSTALLED; then
    CURRENT_STATUS_COLORED="${CURRENT_STATUS_TEXT}"
  else
    CURRENT_STATUS_COLORED="${CURRENT_STATUS_TEXT}"
  fi
}

# ==========================================================
# System preparation (repos, headers, etc.)
# ==========================================================
ensure_repos_and_headers() {
  msg_info "$(translate 'Checking kernel headers and build tools...')"

  local kver
  kver=$(uname -r)

  apt-get update -qq >>"$LOG_FILE" 2>&1

  if ! dpkg -s "pve-headers-$kver" >/dev/null 2>&1 && \
     ! dpkg -s "proxmox-headers-$kver" >/dev/null 2>&1; then
    apt-get install -y "pve-headers-$kver" "proxmox-headers-$kver" build-essential dkms >>"$LOG_FILE" 2>&1 || true
  else
    apt-get install -y build-essential dkms >>"$LOG_FILE" 2>&1 || true
  fi

  msg_ok "$(translate 'Kernel headers and build tools verified.')" | tee -a "$screen_capture"
}

blacklist_nouveau() {
  msg_info "$(translate 'Blacklisting nouveau driver...')"
  if ! grep -q '^blacklist nouveau' /etc/modprobe.d/blacklist.conf 2>/dev/null; then
    echo "blacklist nouveau" >> /etc/modprobe.d/blacklist.conf
  fi
  msg_ok "$(translate 'nouveau driver has been blacklisted.')" | tee -a "$screen_capture"
}

ensure_modules_config() {
  msg_info "$(translate 'Configuring NVIDIA and VFIO modules...')"
  cat > /etc/modules-load.d/nvidia-vfio.conf <<'EOF'
vfio
vfio_iommu_type1
vfio_pci
vfio_virqfd
nvidia
nvidia_uvm
EOF
  msg_ok "$(translate 'Modules configuration updated.')" | tee -a "$screen_capture"
}

stop_and_disable_nvidia_services() {
  local services=(
    "nvidia-persistenced.service"
    "nvidia-persistenced"
    "nvidia-powerd.service"
  )

  local services_detected=0 

  for service in "${services[@]}"; do
    if systemctl is-active --quiet "$service" 2>/dev/null || \
       systemctl is-enabled --quiet "$service" 2>/dev/null; then
      services_detected=1
      break 
    fi
  done

  if [ "$services_detected" -eq 1 ]; then
    msg_info "$(translate 'Stopping and disabling NVIDIA services...')"
    
    for service in "${services[@]}"; do
      if systemctl is-active --quiet "$service" 2>/dev/null; then
        systemctl stop "$service" >/dev/null 2>&1 || true
      fi
      if systemctl is-enabled --quiet "$service" 2>/dev/null; then
        systemctl disable "$service" >/dev/null 2>&1 || true
      fi
    done
    
    sleep 2
    
    msg_ok "$(translate 'NVIDIA services stopped and disabled.')" | tee -a "$screen_capture"
  fi
}

unload_nvidia_modules() {
  msg_info "$(translate 'Unloading NVIDIA kernel modules...')"

  for mod in nvidia_uvm nvidia_drm nvidia_modeset nvidia; do
    modprobe -r "$mod" >/dev/null 2>&1 || true
  done


  if lsmod | grep -qi '\bnvidia'; then
    for mod in nvidia_uvm nvidia_drm nvidia_modeset nvidia; do
      modprobe -r --force "$mod" >/dev/null 2>&1 || true
    done
  fi

  if lsmod | grep -qi '\bnvidia'; then
    msg_warn "$(translate 'Some NVIDIA modules could not be unloaded. Installation may fail. Ensure no processes are using the GPU.')"
    if command -v lsof >/dev/null 2>&1; then
      echo "$(translate 'Processes using NVIDIA:'):" >> "$LOG_FILE"
      lsof /dev/nvidia* 2>/dev/null >> "$LOG_FILE" || true
    fi
  else
    msg_ok "$(translate 'NVIDIA kernel modules unloaded successfully.')" | tee -a "$screen_capture"
  fi
}

complete_nvidia_uninstall() {
  stop_and_disable_nvidia_services
  unload_nvidia_modules
  
  if command -v nvidia-uninstall >/dev/null 2>&1; then
    msg_info "$(translate 'Running NVIDIA uninstaller...')"
    nvidia-uninstall --silent >>"$LOG_FILE" 2>&1 || true
    msg_ok "$(translate 'NVIDIA uninstaller completed.')"
  fi
  
  cleanup_nvidia_dkms
  
  msg_info "$(translate 'Removing NVIDIA packages...')"
  apt-get -y purge 'nvidia-*' 'libnvidia-*' 'cuda-*' 'libcudnn*' >>"$LOG_FILE" 2>&1 || true
  apt-get -y autoremove --purge >>"$LOG_FILE" 2>&1 || true
  apt-get -y autoclean >>"$LOG_FILE" 2>&1 || true
  
  rm -f /etc/modules-load.d/nvidia-vfio.conf
  rm -f /etc/udev/rules.d/70-nvidia.rules
  rm -rf /usr/lib/modprobe.d/nvidia*.conf
  rm -rf /etc/modprobe.d/nvidia*.conf
  
  if [[ -d "$NVIDIA_WORKDIR" ]]; then
    find "$NVIDIA_WORKDIR" -type d -name "nvidia-persistenced" -exec rm -rf {} + 2>/dev/null || true
    find "$NVIDIA_WORKDIR" -type d -name "nvidia-patch" -exec rm -rf {} + 2>/dev/null || true
  fi
  
  update_component_status "nvidia_driver" "removed" "" "gpu" '{}'
  
  msg_ok "$(translate 'Complete NVIDIA uninstallation finished.')" | tee -a "$screen_capture"
}

cleanup_nvidia_dkms() {
  local versions
  versions=$(dkms status 2>/dev/null | awk -F, '/nvidia/ {gsub(/ /,"",$2); print $2}' || true)

  [[ -z "$versions" ]] && return 0

  msg_info "$(translate 'Removing NVIDIA DKMS entries...')"
  while IFS= read -r ver; do
    [[ -z "$ver" ]] && continue
    dkms remove -m nvidia -v "$ver" --all >/dev/null 2>&1 || true
  done <<< "$versions"
  msg_ok "$(translate 'NVIDIA DKMS entries removed.')"
}

ensure_workdir() {
  mkdir -p "$NVIDIA_WORKDIR"
}

# ==========================================================
# Kernel compatibility detection
# ==========================================================
get_kernel_compatibility_info() {
  local kernel_version
  kernel_version=$(uname -r)
  
  # Determine Proxmox and kernel version
  if [[ -f /etc/pve/.version ]]; then
    PVE_VERSION=$(cat /etc/pve/.version)
  else
    PVE_VERSION="unknown"
  fi
  
  # Extract kernel major version (6.x, 5.x, etc)
  KERNEL_MAJOR=$(echo "$kernel_version" | cut -d. -f1)
  KERNEL_MINOR=$(echo "$kernel_version" | cut -d. -f2)
  
  # Define minimum compatible versions based on kernel
  # Based on https://docs.nvidia.com/datacenter/tesla/drivers/index.html
  if [[ "$KERNEL_MAJOR" -ge 6 ]] && [[ "$KERNEL_MINOR" -ge 17 ]]; then
    # Kernel 6.17+ (Proxmox 9.x) - Requires 580.82.07 or higher
    MIN_DRIVER_VERSION="580.82.07"
    RECOMMENDED_BRANCH="580"
    COMPATIBILITY_NOTE="Kernel $kernel_version requires NVIDIA driver 580.82.07 or newer"
  elif [[ "$KERNEL_MAJOR" -ge 6 ]] && [[ "$KERNEL_MINOR" -ge 8 ]]; then
    # Kernel 6.8-6.16 (Proxmox 8.2+) - Works with 550.x or higher
    MIN_DRIVER_VERSION="550"
    RECOMMENDED_BRANCH="580"
    COMPATIBILITY_NOTE="Kernel $kernel_version works best with NVIDIA driver 550.x or newer"
  elif [[ "$KERNEL_MAJOR" -ge 6 ]]; then
    # Kernel 6.2-6.7 (Proxmox 8.x initial) - Works with 535.x or higher
    MIN_DRIVER_VERSION="535"
    RECOMMENDED_BRANCH="550"
    COMPATIBILITY_NOTE="Kernel $kernel_version works with NVIDIA driver 535.x or newer"
  elif [[ "$KERNEL_MAJOR" -eq 5 ]] && [[ "$KERNEL_MINOR" -ge 15 ]]; then
    # Kernel 5.15+ (Proxmox 7.x, 8.x legacy) - Works with 470.x or higher
    MIN_DRIVER_VERSION="470"
    RECOMMENDED_BRANCH="535"
    COMPATIBILITY_NOTE="Kernel $kernel_version works with NVIDIA driver 470.x or newer"
  else
    # Old kernels
    MIN_DRIVER_VERSION="450"
    RECOMMENDED_BRANCH="470"
    COMPATIBILITY_NOTE="For older kernels, compatibility may vary"
  fi
}

is_version_compatible() {
  local version="$1"
  local ver_major ver_minor ver_patch
  
  # Extract version components (major.minor.patch)
  ver_major=$(echo "$version" | cut -d. -f1)
  ver_minor=$(echo "$version" | cut -d. -f2)
  ver_patch=$(echo "$version" | cut -d. -f3)
  
  if [[ "$MIN_DRIVER_VERSION" == "580.82.07" ]]; then
    # Compare full version: must be >= 580.82.07
    if [[ ${ver_major} -gt 580 ]]; then
      return 0
    elif [[ ${ver_major} -eq 580 ]]; then
      if [[ $((10#${ver_minor})) -gt 82 ]]; then
        return 0
      elif [[ $((10#${ver_minor})) -eq 82 ]]; then
        if [[ $((10#${ver_patch:-0})) -ge 7 ]]; then
          return 0
        fi
      fi
    fi
    return 1
  fi
  

  if [[ ${ver_major} -ge ${MIN_DRIVER_VERSION} ]]; then
    return 0
  else
    return 1
  fi
}

# ==========================================================
# NVIDIA version management - FIXED VERSION
# ==========================================================
download_latest_version() {
  local latest_line version

  latest_line=$(curl -fsSL "${NVIDIA_BASE_URL}/latest.txt" 2>&1)
  if [[ -z "$latest_line" ]]; then
    echo "" >&2
    return 1
  fi

  version=$(echo "$latest_line" | awk '{print $1}' | tr -d '[:space:]')
  
  if [[ -z "$version" ]]; then
    echo "" >&2
    return 1
  fi
  
  if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
    echo "" >&2
    return 1
  fi
  
  echo "$version"
  return 0
}

list_available_versions() {
  local html_content versions
  
  html_content=$(curl -s "$NVIDIA_BASE_URL/" 2>&1)
  
  if [[ -z "$html_content" ]]; then
    echo "" >&2
    return 1
  fi
  
  versions=$(echo "$html_content" \
    | grep -o 'href=[^ >]*' \
    | awk -F"'" '{print $2}' \
    | grep -E '^[0-9]' \
    | sed 's/\/$//' \
    | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
    | sort -Vr \
    | uniq)
  
  if [[ -z "$versions" ]]; then
    echo "" >&2
    return 1
  fi
  
  echo "$versions"
  return 0
}

verify_version_exists() {
  local version="$1"
  local url="${NVIDIA_BASE_URL}/${version}/"
  
  if curl -fsSL --head "$url" >/dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}

download_nvidia_installer() {
  ensure_workdir
  local version="$1"
  
  version=$(echo "$version" | tr -d '[:space:]' | tr -d '\n' | tr -d '\r')
  
  if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
    msg_error "Invalid version format: $version" >&2
    echo "ERROR: Invalid version format: '$version'" >> "$LOG_FILE"
    return 1
  fi
  
  local run_file="$NVIDIA_WORKDIR/NVIDIA-Linux-x86_64-${version}.run"

  if [[ -f "$run_file" ]]; then
    echo "Found existing file: $run_file" >> "$LOG_FILE"
    local existing_size file_type
    existing_size=$(stat -c%s "$run_file" 2>/dev/null || stat -f%z "$run_file" 2>/dev/null || echo "0")
    file_type=$(file "$run_file" 2>/dev/null || echo "unknown")
    
    echo "Existing file size: $existing_size bytes" >> "$LOG_FILE"
    echo "Existing file type: $file_type" >> "$LOG_FILE"
    
 
    if [[ $existing_size -gt 40000000 ]] && echo "$file_type" | grep -q "executable"; then

      if sh "$run_file" --check 2>&1 | tee -a "$LOG_FILE" | grep -q "OK"; then
        echo "Existing file passed integrity check" >> "$LOG_FILE"
        msg_ok "$(translate 'Installer already downloaded and verified.')" >&2
        printf '%s\n' "$run_file"
        return 0
      else
        echo "Existing file FAILED integrity check, removing..." >> "$LOG_FILE"
        msg_warn "$(translate 'Existing file failed verification, re-downloading...')" >&2
        rm -f "$run_file"
      fi
    else
      echo "Existing file invalid (size or type), removing..." >> "$LOG_FILE"
      msg_warn "$(translate 'Removing invalid existing file...')" >&2
      rm -f "$run_file"
    fi
  fi

  if ! verify_version_exists "$version"; then
    msg_error "Version $version does not exist on NVIDIA servers" >&2
    echo "ERROR: Version $version not found on server" >> "$LOG_FILE"
    return 1
  fi

  local urls=(
    "${NVIDIA_BASE_URL}/${version}/NVIDIA-Linux-x86_64-${version}.run"
    "${NVIDIA_BASE_URL}/${version}/NVIDIA-Linux-x86_64-${version}-no-compat32.run"
  )
  
  local success=false
  local url_index=0
  
  for url in "${urls[@]}"; do
    ((url_index++))
    echo "Attempting download from: $url" >> "$LOG_FILE"
    

    rm -f "$run_file"
    

    if curl -fL --connect-timeout 30 --max-time 600 "$url" -o "$run_file" >> "$LOG_FILE" 2>&1; then
      echo "Download completed, verifying file..." >> "$LOG_FILE"
      
   
      if [[ ! -f "$run_file" ]]; then
        echo "ERROR: File not created after download" >> "$LOG_FILE"
        continue
      fi
      
 
      local file_size
      file_size=$(stat -c%s "$run_file" 2>/dev/null || stat -f%z "$run_file" 2>/dev/null || echo "0")
      echo "Downloaded file size: $file_size bytes" >> "$LOG_FILE"
      
      if [[ $file_size -lt 40000000 ]]; then
        echo "ERROR: File too small ($file_size bytes, expected >40MB)" >> "$LOG_FILE"
        head -c 200 "$run_file" >> "$LOG_FILE" 2>&1
        rm -f "$run_file"
        continue
      fi
      

      local file_type
      file_type=$(file "$run_file" 2>/dev/null)
      echo "File type: $file_type" >> "$LOG_FILE"
      
      if echo "$file_type" | grep -q "executable"; then
        echo "SUCCESS: Valid executable downloaded" >> "$LOG_FILE"
        success=true
        break
      else
        echo "ERROR: Not a valid executable" >> "$LOG_FILE"
        head -c 200 "$run_file" | od -c >> "$LOG_FILE" 2>&1
        rm -f "$run_file"
      fi
    else
      echo "ERROR: curl failed for $url (exit code: $?)" >> "$LOG_FILE"
      rm -f "$run_file"
    fi
  done
  
  if ! $success; then
    msg_error "$(translate 'Download failed for all attempted URLs')" >&2
    msg_error "Version $version may not be available for your architecture" >&2
    echo "ERROR: All download attempts failed" >> "$LOG_FILE"
    return 1
  fi

  chmod +x "$run_file"
  echo "Installation file ready: $run_file" >> "$LOG_FILE"
  printf '%s\n' "$run_file"
}

# ==========================================================
# Installation / uninstallation
# ==========================================================
run_nvidia_installer() {
  local installer="$1"

  msg_info2 "$(translate 'Starting NVIDIA installer. This may take several minutes...')"
  echo "" >>"$LOG_FILE"
  echo "=== Running NVIDIA installer: $installer ===" >>"$LOG_FILE"

  local tmp_extract_dir="$NVIDIA_WORKDIR/tmp_extract"
  mkdir -p "$tmp_extract_dir"
  
  sh "$installer" --tmpdir="$tmp_extract_dir" --no-questions --ui=none --disable-nouveau --dkms 2>&1 | tee -a "$LOG_FILE"
  local rc=${PIPESTATUS[0]}
  echo "" >>"$LOG_FILE"
  
  rm -rf "$tmp_extract_dir"

  if [[ $rc -ne 0 ]]; then
    msg_error "$(translate 'NVIDIA installer reported an error. Check /tmp/nvidia_install.log')"
    update_component_status "nvidia_driver" "failed" "" "gpu" '{"patched":false}'
    return 1
  fi

  msg_ok "$(translate 'NVIDIA driver installed successfully.')" | tee -a "$screen_capture"
  return 0
}

remove_nvidia_driver() {
  complete_nvidia_uninstall
}

install_udev_rules_and_persistenced() {
  msg_info "$(translate 'Installing NVIDIA udev rules and persistence service...')"

  cat >/etc/udev/rules.d/70-nvidia.rules <<'EOF'
# /etc/udev/rules.d/70-nvidia.rules
KERNEL=="nvidia", RUN+="/bin/bash -c '/usr/bin/nvidia-smi -L'"
KERNEL=="nvidia_uvm", RUN+="/bin/bash -c '/usr/bin/nvidia-modprobe -c0 -u'"
EOF

  udevadm control --reload-rules
  udevadm trigger --subsystem-match=drm --subsystem-match=pci || true

  ensure_workdir
  cd "$NVIDIA_WORKDIR" || return 1
  if [[ ! -d nvidia-persistenced ]]; then
    git clone https://github.com/NVIDIA/nvidia-persistenced.git >>"$LOG_FILE" 2>&1 || true
  fi

  if [[ -d nvidia-persistenced/init ]]; then
    cd nvidia-persistenced/init || return 1
    ./install.sh >>"$LOG_FILE" 2>&1 || true
  fi

  msg_ok "$(translate 'NVIDIA udev rules and persistence service installed.')" | tee -a "$screen_capture"
}

apply_nvidia_patch_if_needed() {
  if ! hybrid_whiptail_yesno "$(translate 'NVIDIA Patch')" \
    "\n$(translate 'Do you want to apply the optional NVIDIA patch to remove some GPU limitations?')"; then
    msg_info2 "$(translate 'NVIDIA patch not applied.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
    return 0
  fi

  msg_info "$(translate 'Cloning and applying NVIDIA patch (keylase/nvidia-patch)...')"
  ensure_workdir
  cd "$NVIDIA_WORKDIR" || return 1
  if [[ ! -d nvidia-patch ]]; then
    git clone https://github.com/keylase/nvidia-patch.git >>"$LOG_FILE" 2>&1 || true
  fi

  if [[ -x nvidia-patch/patch.sh ]]; then
    cd nvidia-patch || return 1
    ./patch.sh >>"$LOG_FILE" 2>&1 || true
    msg_ok "$(translate 'NVIDIA patch applied - check README for supported versions.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":true}'
  else
    msg_warn "$(translate 'Could not run NVIDIA patch script. Please verify repository and driver version.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
  fi
}

restart_prompt() {
  if hybrid_whiptail_yesno "$(translate 'NVIDIA Drivers')" \
    "\n$(translate 'The installation/changes require a server restart to apply correctly. Do you want to reboot now?')"; then
    msg_success "$(translate 'Installation completed. Press Enter to continue...')"
    read -r
    msg_warn "$(translate 'Restarting the server...')"
    rm -f "$screen_capture"
    reboot
  else
    msg_success "$(translate 'Installation completed. Please reboot the server manually as soon as possible.')"
    msg_success "$(translate 'Completed. Press Enter to return to menu...')"
    read -r
    rm -f "$screen_capture"
  fi
}

# ==========================================================
# Dialog menus
# ==========================================================
show_action_menu_if_installed() {
  if ! $CURRENT_DRIVER_INSTALLED; then
    ACTION="install"
    return 0
  fi

  local menu_choices=(
    "install" "$(translate 'Reinstall/Update NVIDIA drivers')"
    "remove"  "$(translate 'Uninstall NVIDIA drivers and configuration')"
  )

  ACTION=$(hybrid_menu "ProxMenux" "$(translate 'NVIDIA Actions')\n\n$(translate 'Choose an action:')" 14 80 8 "${menu_choices[@]}") || ACTION="cancel"
}

show_install_overview() {
  local overview
  overview="\n$(translate 'This installation will:')\n\n"
  overview+=" â€¢ $(translate 'Install NVIDIA proprietary drivers')\n"
  overview+=" â€¢ $(translate 'Configure GPU passthrough with VFIO')\n"
  overview+=" â€¢ $(translate 'Blacklist nouveau driver')\n"
  overview+=" â€¢ $(translate 'Enable IOMMU support if not enabled')\n\n"

  overview+="$(translate 'Detected GPU(s):')\n"
  overview+="\Zb\Z4$DETECTED_GPUS_TEXT\Zn\n"   

  overview+="\n\Zn$(translate 'Current status: ') "
  overview+="\Zb${CURRENT_STATUS_TEXT}\Zn\n\n"  

  overview+="$(translate 'After confirming, you will be asked to choose the NVIDIA driver version to install.')\n\n"
  overview+="$(translate 'Do you want to continue?')"

  hybrid_yesno "$(translate 'NVIDIA GPU Driver Installation')" "$overview" 22 90
}

show_version_menu() {
  local latest versions_list
  local kernel_version
  kernel_version=$(uname -r)
  

  latest=$(download_latest_version 2>/dev/null)
  

  versions_list=$(list_available_versions 2>/dev/null)
  

  if [[ -z "$latest" ]] && [[ -z "$versions_list" ]]; then
    hybrid_msgbox "$(translate 'Error')" \
      "$(translate 'Could not retrieve versions list from NVIDIA. Please check your internet connection.')\n\nURL: ${NVIDIA_BASE_URL}" 10 80
    DRIVER_VERSION="cancel"
    return 1
  fi
  

  if [[ -z "$latest" ]] && [[ -n "$versions_list" ]]; then
    latest=$(echo "$versions_list" | head -n1)
  fi
  

  if [[ -n "$latest" ]] && [[ -z "$versions_list" ]]; then
    versions_list="$latest"
  fi
  
  # Clean latest version
  latest=$(echo "$latest" | tr -d '[:space:]')
  
  local current_list="$versions_list"
  
  # Apply kernel compatibility filter if needed
  if [[ -n "$MIN_DRIVER_VERSION" ]]; then
    local filtered_list=""
    while IFS= read -r ver; do
      [[ -z "$ver" ]] && continue
      if is_version_compatible "$ver"; then
        filtered_list+="$ver"$'\n'
      fi
    done <<< "$current_list"
    current_list="$filtered_list"
  fi

  local menu_text="$(translate 'Select the NVIDIA driver version to install:')\n\n"
  menu_text+="$(translate 'Versions shown are compatible with your kernel. Latest available is recommended in most cases.')"

  local choices=()
  choices+=("latest" "$(translate 'Latest available') (${latest:-unknown})")
  choices+=("" "")

  if [[ -n "$current_list" ]]; then
    while IFS= read -r ver; do
      [[ -z "$ver" ]] && continue
      ver=$(echo "$ver" | tr -d '[:space:]')
      [[ -z "$ver" ]] && continue
      
      choices+=("$ver" "$ver")
    done <<< "$current_list"
  else
    choices+=("" "$(translate 'No compatible versions found for your kernel')")
  fi

  local selection=$(hybrid_menu "$(translate 'NVIDIA Driver Version')" "$menu_text" 26 90 16 "${choices[@]}") || { DRIVER_VERSION="cancel"; return 1; }

  case "$selection" in
    "")
      DRIVER_VERSION="cancel"
      return 1
      ;;
    latest)
      DRIVER_VERSION="$latest"
      DRIVER_VERSION=$(echo "$DRIVER_VERSION" | tr -d '[:space:]')
      return 0
      ;;
    *)
      DRIVER_VERSION="$selection"
      DRIVER_VERSION=$(echo "$DRIVER_VERSION" | tr -d '[:space:]')
      return 0
      ;;
  esac
}

# ==========================================================
# Main flow
# ==========================================================
main() {
  : >"$LOG_FILE"
  : >"$screen_capture"

  detect_nvidia_gpus
  detect_driver_status

  if ! $NVIDIA_GPU_PRESENT; then
    dialog --backtitle "ProxMenux" --title "$(translate 'NVIDIA GPU Driver Installation')" --msgbox \
      "\n$(translate 'No NVIDIA GPU has been detected on this system. The installer will now exit.')" 20 70
    exit 1
  fi

  show_action_menu_if_installed

  case "$ACTION" in
    install)
      if ! show_install_overview; then
        exit 0
      fi

      get_kernel_compatibility_info

      show_version_menu
      if [[ "$DRIVER_VERSION" == "cancel" || -z "$DRIVER_VERSION" ]]; then
        exit 0
      fi

      if $CURRENT_DRIVER_INSTALLED; then
        if [[ "$CURRENT_DRIVER_VERSION" == "$DRIVER_VERSION" ]]; then
          local confirm_text
          confirm_text="\n\n\n$(translate 'Version') \Zb\Z4$DRIVER_VERSION\Zn\n\n$(translate 'is already installed. Do you want to reinstall it? This will perform a clean uninstall first.')"
          if ! hybrid_yesno "$(translate 'Same Version Detected')" "$confirm_text" 14 70; then
              exit 0
          fi
        else
          local confirm_text
          confirm_text="\n\n$(translate 'Current version:') \Zb$CURRENT_DRIVER_VERSION\Zn\n"
          confirm_text+="$(translate 'New version:') \Zb\Z4$DRIVER_VERSION\Zn\n\n"
          confirm_text+="$(translate 'The current driver will be completely uninstalled before installing the new version. Continue?')"
          if ! hybrid_yesno "$(translate 'Version Change Detected')" "$confirm_text" 20 70; then
              exit 0
          fi
        fi
        
        show_proxmenux_logo
        msg_title "$(translate "$SCRIPT_TITLE")"
        msg_info2 "$(translate 'Uninstalling current NVIDIA driver before installing new version...')"
        complete_nvidia_uninstall
        
        sleep 2
        
        CURRENT_DRIVER_INSTALLED=false
        CURRENT_DRIVER_VERSION=""
      fi

      show_proxmenux_logo
      msg_title "$(translate "$SCRIPT_TITLE")"

      ensure_repos_and_headers
      blacklist_nouveau
      ensure_modules_config
      
      stop_and_disable_nvidia_services
      unload_nvidia_modules

      msg_info "$(translate 'Downloading NVIDIA driver version:') $DRIVER_VERSION"
      
      local installer
      installer=$(download_nvidia_installer "$DRIVER_VERSION" 2>>"$LOG_FILE")
      local download_result=$?
      
      if [[ $download_result -ne 0 ]]; then
        msg_error "$(translate 'Failed to download NVIDIA installer')"
        exit 1
      fi
      
      msg_ok "$(translate 'NVIDIA installer downloaded successfully')"

      if [[ -z "$installer" || ! -f "$installer" ]]; then
        msg_error "$(translate 'Internal error: NVIDIA installer path is empty or file not found.')"
        rm -f "$screen_capture"
        exit 1
      fi

      if ! run_nvidia_installer "$installer"; then
        rm -f "$screen_capture"
        exit 1
      fi
      
      sleep 2
      show_proxmenux_logo
      msg_title "$(translate "$SCRIPT_TITLE")"
      cat "$screen_capture"
      echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$LOG_FILE${CL}"

      install_udev_rules_and_persistenced

      msg_info "$(translate 'Updating initramfs for all kernels...')"
      update-initramfs -u -k all >>"$LOG_FILE" 2>&1 || true
      msg_ok "$(translate 'initramfs updated.')"

      msg_info2 "$(translate 'Checking NVIDIA driver status with nvidia-smi')"
      if command -v nvidia-smi >/dev/null 2>&1; then
        nvidia-smi || true
        CURRENT_DRIVER_VERSION=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -n1)
        CURRENT_DRIVER_INSTALLED=true
      else
        msg_warn "$(translate 'nvidia-smi not found in PATH. Please verify the driver installation.')"
      fi

      if [[ -n "$CURRENT_DRIVER_VERSION" ]]; then
        msg_ok "$(translate 'NVIDIA driver') $CURRENT_DRIVER_VERSION $(translate 'installed successfully.')"
        update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
        msg_success "$(translate 'Driver installed successfully. Press Enter to continue...')"
        read -r
      else
        msg_error "$(translate 'Failed to detect installed NVIDIA driver version.')"
        update_component_status "nvidia_driver" "failed" "" "gpu" '{"patched":false}'
      fi

      apply_nvidia_patch_if_needed
      restart_prompt
      ;;
    remove)
      if hybrid_yesno "$(translate 'NVIDIA Driver Uninstall')" \
        "\n\n\n$(translate 'This will remove NVIDIA drivers and related configuration. Do you want to continue?')" 14 70; then

        show_proxmenux_logo
        msg_title "$(translate "$SCRIPT_TITLE")"

        remove_nvidia_driver

        msg_info "$(translate 'Updating initramfs for all kernels...')"
        update-initramfs -u -k all >>"$LOG_FILE" 2>&1 || true
        msg_ok "$(translate 'initramfs updated.')"

        restart_prompt
      fi
      ;;
    cancel|*)
      exit 0
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main
fi



================================================
FILE: scripts/gpu_tpu/nvidia_installer_.sh
================================================
#!/bin/bash
# ProxMenux - NVIDIA Driver Installer (PVE 9.x)
# ============================================
# Author      : MacRimi
# License     : MIT
# Version     : 0.9 (PVE9, fixed download issues)
# Last Updated: 29/11/2025
# ============================================

SCRIPT_TITLE="NVIDIA GPU Driver Installer for Proxmox VE"

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
COMPONENTS_STATUS_FILE="$BASE_DIR/components_status.json"
LOG_FILE="/tmp/nvidia_install.log"
screen_capture="/tmp/proxmenux_nvidia_screen_capture_$$.txt"

NVIDIA_BASE_URL="https://download.nvidia.com/XFree86/Linux-x86_64"
NVIDIA_WORKDIR="/opt/nvidia"

export BASE_DIR
export COMPONENTS_STATUS_FILE

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

if [[ ! -f "$COMPONENTS_STATUS_FILE" ]]; then
  echo "{}" > "$COMPONENTS_STATUS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# GPU detection and current status
# ==========================================================
detect_nvidia_gpus() {
  # Only video controllers (not audio)
  local lspci_output
  lspci_output=$(lspci | grep -i "NVIDIA" \
    | grep -Ei "VGA compatible controller|3D controller|Display controller" || true)

  if [[ -z "$lspci_output" ]]; then
    NVIDIA_GPU_PRESENT=false
    DETECTED_GPUS_TEXT="$(translate 'No NVIDIA GPU detected on this system.')"
  else
    NVIDIA_GPU_PRESENT=true
    DETECTED_GPUS_TEXT=""
    local i=1
    while IFS= read -r line; do
      DETECTED_GPUS_TEXT+="  ${i}. ${line}\n"
      ((i++))
    done <<< "$lspci_output"
  fi
}

detect_driver_status() {
  CURRENT_DRIVER_INSTALLED=false
  CURRENT_DRIVER_VERSION=""
  
  # First check if nvidia kernel module is actually loaded
  if lsmod | grep -q "^nvidia "; then

    modprobe nvidia-uvm 2>/dev/null || true
    sleep 1
    

    if command -v nvidia-smi >/dev/null 2>&1; then
      CURRENT_DRIVER_VERSION=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -n1)
      
      if [[ -n "$CURRENT_DRIVER_VERSION" ]]; then
        CURRENT_DRIVER_INSTALLED=true
        # Register the installed driver version in components_status.json
        update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
      fi
    fi
  fi

  if $CURRENT_DRIVER_INSTALLED; then
    CURRENT_STATUS_TEXT="$(printf '%s %s' "$(translate 'NVIDIA driver installed:')" "$CURRENT_DRIVER_VERSION")"
  else
    CURRENT_STATUS_TEXT="$(translate 'No NVIDIA driver installed.')"
  fi

  if $CURRENT_DRIVER_INSTALLED; then
    CURRENT_STATUS_COLORED="\Z2${CURRENT_STATUS_TEXT}\Zn"
  else
    CURRENT_STATUS_COLORED="\Z3${CURRENT_STATUS_TEXT}\Zn"
  fi
}

# ==========================================================
# System preparation (repos, headers, etc.)
# ==========================================================
ensure_repos_and_headers() {
  msg_info "$(translate 'Checking kernel headers and build tools...')"

  local kver
  kver=$(uname -r)

  apt-get update -qq >>"$LOG_FILE" 2>&1

  if ! dpkg -s "pve-headers-$kver" >/dev/null 2>&1 && \
     ! dpkg -s "proxmox-headers-$kver" >/dev/null 2>&1; then
    apt-get install -y "pve-headers-$kver" "proxmox-headers-$kver" build-essential dkms >>"$LOG_FILE" 2>&1 || true
  else
    apt-get install -y build-essential dkms >>"$LOG_FILE" 2>&1 || true
  fi

  msg_ok "$(translate 'Kernel headers and build tools verified.')" | tee -a "$screen_capture"
}

blacklist_nouveau() {
  msg_info "$(translate 'Blacklisting nouveau driver...')"
  if ! grep -q '^blacklist nouveau' /etc/modprobe.d/blacklist.conf 2>/dev/null; then
    echo "blacklist nouveau" >> /etc/modprobe.d/blacklist.conf
  fi
  msg_ok "$(translate 'nouveau driver has been blacklisted.')" | tee -a "$screen_capture"
}

ensure_modules_config() {
  msg_info "$(translate 'Configuring NVIDIA and VFIO modules...')"
  cat > /etc/modules-load.d/nvidia-vfio.conf <<'EOF'
vfio
vfio_iommu_type1
vfio_pci
vfio_virqfd
nvidia
nvidia_uvm
EOF
  msg_ok "$(translate 'Modules configuration updated.')" | tee -a "$screen_capture"
}

stop_and_disable_nvidia_services() {
  local services=(
    "nvidia-persistenced.service"
    "nvidia-persistenced"
    "nvidia-powerd.service"
  )

  local services_detected=0 

  for service in "${services[@]}"; do
    if systemctl is-active --quiet "$service" 2>/dev/null || \
       systemctl is-enabled --quiet "$service" 2>/dev/null; then
      services_detected=1
      break 
    fi
  done

  if [ "$services_detected" -eq 1 ]; then
    msg_info "$(translate 'Stopping and disabling NVIDIA services...')"
    
    for service in "${services[@]}"; do
      if systemctl is-active --quiet "$service" 2>/dev/null; then
        systemctl stop "$service" >/dev/null 2>&1 || true
      fi
      if systemctl is-enabled --quiet "$service" 2>/dev/null; then
        systemctl disable "$service" >/dev/null 2>&1 || true
      fi
    done
    
    sleep 2
    
    msg_ok "$(translate 'NVIDIA services stopped and disabled.')" | tee -a "$screen_capture"
  fi
}

unload_nvidia_modules() {
  msg_info "$(translate 'Unloading NVIDIA kernel modules...')"

  for mod in nvidia_uvm nvidia_drm nvidia_modeset nvidia; do
    modprobe -r "$mod" >/dev/null 2>&1 || true
  done


  if lsmod | grep -qi '\bnvidia'; then
    for mod in nvidia_uvm nvidia_drm nvidia_modeset nvidia; do
      modprobe -r --force "$mod" >/dev/null 2>&1 || true
    done
  fi

  if lsmod | grep -qi '\bnvidia'; then
    msg_warn "$(translate 'Some NVIDIA modules could not be unloaded. Installation may fail. Ensure no processes are using the GPU.')"
    if command -v lsof >/dev/null 2>&1; then
      echo "$(translate 'Processes using NVIDIA:'):" >> "$LOG_FILE"
      lsof /dev/nvidia* 2>/dev/null >> "$LOG_FILE" || true
    fi
  else
    msg_ok "$(translate 'NVIDIA kernel modules unloaded successfully.')" | tee -a "$screen_capture"
  fi
}

complete_nvidia_uninstall() {
  stop_and_disable_nvidia_services
  unload_nvidia_modules
  
  if command -v nvidia-uninstall >/dev/null 2>&1; then
    msg_info "$(translate 'Running NVIDIA uninstaller...')"
    nvidia-uninstall --silent >>"$LOG_FILE" 2>&1 || true
    msg_ok "$(translate 'NVIDIA uninstaller completed.')"
  fi
  
  cleanup_nvidia_dkms
  
  msg_info "$(translate 'Removing NVIDIA packages...')"
  apt-get -y purge 'nvidia-*' 'libnvidia-*' 'cuda-*' 'libcudnn*' >>"$LOG_FILE" 2>&1 || true
  apt-get -y autoremove --purge >>"$LOG_FILE" 2>&1 || true
  apt-get -y autoclean >>"$LOG_FILE" 2>&1 || true
  
  rm -f /etc/modules-load.d/nvidia-vfio.conf
  rm -f /etc/udev/rules.d/70-nvidia.rules
  rm -rf /usr/lib/modprobe.d/nvidia*.conf
  rm -rf /etc/modprobe.d/nvidia*.conf
  
  if [[ -d "$NVIDIA_WORKDIR" ]]; then
    find "$NVIDIA_WORKDIR" -type d -name "nvidia-persistenced" -exec rm -rf {} + 2>/dev/null || true
    find "$NVIDIA_WORKDIR" -type d -name "nvidia-patch" -exec rm -rf {} + 2>/dev/null || true
  fi
  
  update_component_status "nvidia_driver" "removed" "" "gpu" '{}'
  
  msg_ok "$(translate 'Complete NVIDIA uninstallation finished.')" | tee -a "$screen_capture"
}

cleanup_nvidia_dkms() {
  local versions
  versions=$(dkms status 2>/dev/null | awk -F, '/nvidia/ {gsub(/ /,"",$2); print $2}' || true)

  [[ -z "$versions" ]] && return 0

  msg_info "$(translate 'Removing NVIDIA DKMS entries...')"
  while IFS= read -r ver; do
    [[ -z "$ver" ]] && continue
    dkms remove -m nvidia -v "$ver" --all >/dev/null 2>&1 || true
  done <<< "$versions"
  msg_ok "$(translate 'NVIDIA DKMS entries removed.')"
}

ensure_workdir() {
  mkdir -p "$NVIDIA_WORKDIR"
}

# ==========================================================
# Kernel compatibility detection
# ==========================================================
get_kernel_compatibility_info() {
  local kernel_version
  kernel_version=$(uname -r)
  
  # Determine Proxmox and kernel version
  if [[ -f /etc/pve/.version ]]; then
    PVE_VERSION=$(cat /etc/pve/.version)
  else
    PVE_VERSION="unknown"
  fi
  
  # Extract kernel major version (6.x, 5.x, etc)
  KERNEL_MAJOR=$(echo "$kernel_version" | cut -d. -f1)
  KERNEL_MINOR=$(echo "$kernel_version" | cut -d. -f2)
  
  # Define minimum compatible versions based on kernel
  # Based on https://docs.nvidia.com/datacenter/tesla/drivers/index.html
  if [[ "$KERNEL_MAJOR" -ge 6 ]] && [[ "$KERNEL_MINOR" -ge 17 ]]; then
    # Kernel 6.17+ (Proxmox 9.x) - Requires 580.82.07 or higher
    MIN_DRIVER_VERSION="580.82.07"
    RECOMMENDED_BRANCH="580"
    COMPATIBILITY_NOTE="Kernel $kernel_version requires NVIDIA driver 580.82.07 or newer"
  elif [[ "$KERNEL_MAJOR" -ge 6 ]] && [[ "$KERNEL_MINOR" -ge 8 ]]; then
    # Kernel 6.8-6.16 (Proxmox 8.2+) - Works with 550.x or higher
    MIN_DRIVER_VERSION="550"
    RECOMMENDED_BRANCH="580"
    COMPATIBILITY_NOTE="Kernel $kernel_version works best with NVIDIA driver 550.x or newer"
  elif [[ "$KERNEL_MAJOR" -ge 6 ]]; then
    # Kernel 6.2-6.7 (Proxmox 8.x initial) - Works with 535.x or higher
    MIN_DRIVER_VERSION="535"
    RECOMMENDED_BRANCH="550"
    COMPATIBILITY_NOTE="Kernel $kernel_version works with NVIDIA driver 535.x or newer"
  elif [[ "$KERNEL_MAJOR" -eq 5 ]] && [[ "$KERNEL_MINOR" -ge 15 ]]; then
    # Kernel 5.15+ (Proxmox 7.x, 8.x legacy) - Works with 470.x or higher
    MIN_DRIVER_VERSION="470"
    RECOMMENDED_BRANCH="535"
    COMPATIBILITY_NOTE="Kernel $kernel_version works with NVIDIA driver 470.x or newer"
  else
    # Old kernels
    MIN_DRIVER_VERSION="450"
    RECOMMENDED_BRANCH="470"
    COMPATIBILITY_NOTE="For older kernels, compatibility may vary"
  fi
}

is_version_compatible() {
  local version="$1"
  local ver_major ver_minor ver_patch
  
  # Extract version components (major.minor.patch)
  ver_major=$(echo "$version" | cut -d. -f1)
  ver_minor=$(echo "$version" | cut -d. -f2)
  ver_patch=$(echo "$version" | cut -d. -f3)
  
  if [[ "$MIN_DRIVER_VERSION" == "580.82.07" ]]; then
    # Compare full version: must be >= 580.82.07
    if [[ ${ver_major} -gt 580 ]]; then
      return 0
    elif [[ ${ver_major} -eq 580 ]]; then
      if [[ $((10#${ver_minor})) -gt 82 ]]; then
        return 0
      elif [[ $((10#${ver_minor})) -eq 82 ]]; then
        if [[ $((10#${ver_patch:-0})) -ge 7 ]]; then
          return 0
        fi
      fi
    fi
    return 1
  fi
  

  if [[ ${ver_major} -ge ${MIN_DRIVER_VERSION} ]]; then
    return 0
  else
    return 1
  fi
}

# ==========================================================
# NVIDIA version management - FIXED VERSION
# ==========================================================
download_latest_version() {
  local latest_line version

  latest_line=$(curl -fsSL "${NVIDIA_BASE_URL}/latest.txt" 2>&1)
  if [[ -z "$latest_line" ]]; then
    echo "" >&2
    return 1
  fi

  version=$(echo "$latest_line" | awk '{print $1}' | tr -d '[:space:]')
  
  if [[ -z "$version" ]]; then
    echo "" >&2
    return 1
  fi
  
  if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
    echo "" >&2
    return 1
  fi
  
  echo "$version"
  return 0
}

list_available_versions() {
  local html_content versions
  
  html_content=$(curl -s "$NVIDIA_BASE_URL/" 2>&1)
  
  if [[ -z "$html_content" ]]; then
    echo "" >&2
    return 1
  fi
  
  versions=$(echo "$html_content" \
    | grep -o 'href=[^ >]*' \
    | awk -F"'" '{print $2}' \
    | grep -E '^[0-9]' \
    | sed 's/\/$//' \
    | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
    | sort -Vr \
    | uniq)
  
  if [[ -z "$versions" ]]; then
    echo "" >&2
    return 1
  fi
  
  echo "$versions"
  return 0
}

verify_version_exists() {
  local version="$1"
  local url="${NVIDIA_BASE_URL}/${version}/"
  
  if curl -fsSL --head "$url" >/dev/null 2>&1; then
    return 0
  else
    return 1
  fi
}

download_nvidia_installer() {
  ensure_workdir
  local version="$1"
  
  version=$(echo "$version" | tr -d '[:space:]' | tr -d '\n' | tr -d '\r')
  
  if [[ ! "$version" =~ ^[0-9]+\.[0-9]+(\.[0-9]+)?$ ]]; then
    msg_error "Invalid version format: $version" >&2
    echo "ERROR: Invalid version format: '$version'" >> "$LOG_FILE"
    return 1
  fi
  
  local run_file="$NVIDIA_WORKDIR/NVIDIA-Linux-x86_64-${version}.run"

  if [[ -f "$run_file" ]]; then
    echo "Found existing file: $run_file" >> "$LOG_FILE"
    local existing_size file_type
    existing_size=$(stat -c%s "$run_file" 2>/dev/null || stat -f%z "$run_file" 2>/dev/null || echo "0")
    file_type=$(file "$run_file" 2>/dev/null || echo "unknown")
    
    echo "Existing file size: $existing_size bytes" >> "$LOG_FILE"
    echo "Existing file type: $file_type" >> "$LOG_FILE"
    
 
    if [[ $existing_size -gt 40000000 ]] && echo "$file_type" | grep -q "executable"; then

      if sh "$run_file" --check 2>&1 | tee -a "$LOG_FILE" | grep -q "OK"; then
        echo "Existing file passed integrity check" >> "$LOG_FILE"
        msg_ok "$(translate 'Installer already downloaded and verified.')" >&2
        printf '%s\n' "$run_file"
        return 0
      else
        echo "Existing file FAILED integrity check, removing..." >> "$LOG_FILE"
        msg_warn "$(translate 'Existing file failed verification, re-downloading...')" >&2
        rm -f "$run_file"
      fi
    else
      echo "Existing file invalid (size or type), removing..." >> "$LOG_FILE"
      msg_warn "$(translate 'Removing invalid existing file...')" >&2
      rm -f "$run_file"
    fi
  fi

  if ! verify_version_exists "$version"; then
    msg_error "Version $version does not exist on NVIDIA servers" >&2
    echo "ERROR: Version $version not found on server" >> "$LOG_FILE"
    return 1
  fi

  local urls=(
    "${NVIDIA_BASE_URL}/${version}/NVIDIA-Linux-x86_64-${version}.run"
    "${NVIDIA_BASE_URL}/${version}/NVIDIA-Linux-x86_64-${version}-no-compat32.run"
  )
  
  local success=false
  local url_index=0
  
  for url in "${urls[@]}"; do
    ((url_index++))
    echo "Attempting download from: $url" >> "$LOG_FILE"
    

    rm -f "$run_file"
    

    if curl -fL --connect-timeout 30 --max-time 600 "$url" -o "$run_file" >> "$LOG_FILE" 2>&1; then
      echo "Download completed, verifying file..." >> "$LOG_FILE"
      
   
      if [[ ! -f "$run_file" ]]; then
        echo "ERROR: File not created after download" >> "$LOG_FILE"
        continue
      fi
      
 
      local file_size
      file_size=$(stat -c%s "$run_file" 2>/dev/null || stat -f%z "$run_file" 2>/dev/null || echo "0")
      echo "Downloaded file size: $file_size bytes" >> "$LOG_FILE"
      
      if [[ $file_size -lt 40000000 ]]; then
        echo "ERROR: File too small ($file_size bytes, expected >40MB)" >> "$LOG_FILE"
        head -c 200 "$run_file" >> "$LOG_FILE" 2>&1
        rm -f "$run_file"
        continue
      fi
      

      local file_type
      file_type=$(file "$run_file" 2>/dev/null)
      echo "File type: $file_type" >> "$LOG_FILE"
      
      if echo "$file_type" | grep -q "executable"; then
        echo "SUCCESS: Valid executable downloaded" >> "$LOG_FILE"
        success=true
        break
      else
        echo "ERROR: Not a valid executable" >> "$LOG_FILE"
        head -c 200 "$run_file" | od -c >> "$LOG_FILE" 2>&1
        rm -f "$run_file"
      fi
    else
      echo "ERROR: curl failed for $url (exit code: $?)" >> "$LOG_FILE"
      rm -f "$run_file"
    fi
  done
  
  if ! $success; then
    msg_error "$(translate 'Download failed for all attempted URLs')" >&2
    msg_error "Version $version may not be available for your architecture" >&2
    echo "ERROR: All download attempts failed" >> "$LOG_FILE"
    return 1
  fi

  chmod +x "$run_file"
  echo "Installation file ready: $run_file" >> "$LOG_FILE"
  printf '%s\n' "$run_file"
}

# ==========================================================
# Installation / uninstallation
# ==========================================================
run_nvidia_installer() {
  local installer="$1"

  msg_info2 "$(translate 'Starting NVIDIA installer. This may take several minutes...')"
  echo "" >>"$LOG_FILE"
  echo "=== Running NVIDIA installer: $installer ===" >>"$LOG_FILE"

  local tmp_extract_dir="$NVIDIA_WORKDIR/tmp_extract"
  mkdir -p "$tmp_extract_dir"
  
  sh "$installer" --tmpdir="$tmp_extract_dir" --no-questions --ui=none --disable-nouveau --dkms 2>&1 | tee -a "$LOG_FILE"
  local rc=${PIPESTATUS[0]}
  echo "" >>"$LOG_FILE"
  
  rm -rf "$tmp_extract_dir"

  if [[ $rc -ne 0 ]]; then
    msg_error "$(translate 'NVIDIA installer reported an error. Check /tmp/nvidia_install.log')"
    update_component_status "nvidia_driver" "failed" "" "gpu" '{"patched":false}'
    return 1
  fi

  msg_ok "$(translate 'NVIDIA driver installed successfully.')" | tee -a "$screen_capture"
  return 0
}

remove_nvidia_driver() {
  complete_nvidia_uninstall
}

install_udev_rules_and_persistenced() {
  msg_info "$(translate 'Installing NVIDIA udev rules and persistence service...')"

  cat >/etc/udev/rules.d/70-nvidia.rules <<'EOF'
# /etc/udev/rules.d/70-nvidia.rules
KERNEL=="nvidia", RUN+="/bin/bash -c '/usr/bin/nvidia-smi -L'"
KERNEL=="nvidia_uvm", RUN+="/bin/bash -c '/usr/bin/nvidia-modprobe -c0 -u'"
EOF

  udevadm control --reload-rules
  udevadm trigger --subsystem-match=drm --subsystem-match=pci || true

  ensure_workdir
  cd "$NVIDIA_WORKDIR" || return 1
  if [[ ! -d nvidia-persistenced ]]; then
    git clone https://github.com/NVIDIA/nvidia-persistenced.git >>"$LOG_FILE" 2>&1 || true
  fi

  if [[ -d nvidia-persistenced/init ]]; then
    cd nvidia-persistenced/init || return 1
    ./install.sh >>"$LOG_FILE" 2>&1 || true
  fi

  msg_ok "$(translate 'NVIDIA udev rules and persistence service installed.')" | tee -a "$screen_capture"
}

apply_nvidia_patch_if_needed() {
  if ! whiptail --title "$(translate 'NVIDIA Patch')" --yesno \
    "\n$(translate 'Do you want to apply the optional NVIDIA patch to remove some GPU limitations?')" 10 70; then
    msg_info2 "$(translate 'NVIDIA patch not applied.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
    return 0
  fi

  msg_info "$(translate 'Cloning and applying NVIDIA patch (keylase/nvidia-patch)...')"
  ensure_workdir
  cd "$NVIDIA_WORKDIR" || return 1
  if [[ ! -d nvidia-patch ]]; then
    git clone https://github.com/keylase/nvidia-patch.git >>"$LOG_FILE" 2>&1 || true
  fi

  if [[ -x nvidia-patch/patch.sh ]]; then
    cd nvidia-patch || return 1
    ./patch.sh >>"$LOG_FILE" 2>&1 || true
    msg_ok "$(translate 'NVIDIA patch applied - check README for supported versions.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":true}'
  else
    msg_warn "$(translate 'Could not run NVIDIA patch script. Please verify repository and driver version.')"
    update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
  fi
}

restart_prompt() {
  if whiptail --title "$(translate 'NVIDIA Drivers')" --yesno \
    "\n$(translate 'The installation/changes require a server restart to apply correctly. Do you want to reboot now?')" 10 70; then
    msg_success "$(translate 'Installation completed. Press Enter to continue...')"
    read -r
    msg_warn "$(translate 'Restarting the server...')"
    rm -f "$screen_capture"
    reboot
  else
    msg_success "$(translate 'Installation completed. Please reboot the server manually as soon as possible.')"
    msg_success "$(translate 'Completed. Press Enter to return to menu...')"
    read -r
    rm -f "$screen_capture"
  fi
}

# ==========================================================
# Dialog menus
# ==========================================================
show_action_menu_if_installed() {
  if ! $CURRENT_DRIVER_INSTALLED; then
    ACTION="install"
    return 0
  fi

  local menu_choices=(
    "install" "$(translate 'Reinstall/Update NVIDIA drivers')"
    "remove"  "$(translate 'Uninstall NVIDIA drivers and configuration')"
  )

  ACTION=$(dialog --clear --stdout \
    --backtitle "ProxMenux" \
    --title "$(translate 'NVIDIA GPU Driver Management')" \
    --menu "$(translate 'Choose an action:')" 14 80 8 \
    "${menu_choices[@]}") || ACTION="cancel"
}

show_install_overview() {
  local overview
  overview="\n$(translate 'This installation will:')\n\n"
  overview+=" â€¢ $(translate 'Install NVIDIA proprietary drivers')\n"
  overview+=" â€¢ $(translate 'Configure GPU passthrough with VFIO')\n"
  overview+=" â€¢ $(translate 'Blacklist nouveau driver')\n"
  overview+=" â€¢ $(translate 'Enable IOMMU support if not enabled')\n\n"

  overview+="$(translate 'Detected GPU(s):')\n"
  overview+="\Zb\Z4$DETECTED_GPUS_TEXT\Zn\n"   

  overview+="\n\Zn$(translate 'Current status: ') "
  overview+="\Zb${CURRENT_STATUS_TEXT}\Zn\n\n"  

  overview+="$(translate 'After confirming, you will be asked to choose the NVIDIA driver version to install.')\n\n"
  overview+="$(translate 'Do you want to continue?')"

  dialog --colors --backtitle "ProxMenux" \
         --title "$(translate 'NVIDIA GPU Driver Installation')" \
         --yesno "$overview" 22 90
}

show_version_menu() {
  local latest versions_list
  local kernel_version
  kernel_version=$(uname -r)
  

  latest=$(download_latest_version 2>/dev/null)
  

  versions_list=$(list_available_versions 2>/dev/null)
  

  if [[ -z "$latest" ]] && [[ -z "$versions_list" ]]; then
    dialog --backtitle "ProxMenux" --title "$(translate 'Error')" --msgbox \
      "$(translate 'Could not retrieve versions list from NVIDIA. Please check your internet connection.')\n\nURL: ${NVIDIA_BASE_URL}" 10 80
    DRIVER_VERSION="cancel"
    return 1
  fi
  

  if [[ -z "$latest" ]] && [[ -n "$versions_list" ]]; then
    latest=$(echo "$versions_list" | head -n1)
  fi
  

  if [[ -n "$latest" ]] && [[ -z "$versions_list" ]]; then
    versions_list="$latest"
  fi
  
  # Clean latest version
  latest=$(echo "$latest" | tr -d '[:space:]')
  
  local filter=""
  local selection
  local choices
  local current_list
  local menu_text

  while true; do
    current_list="$versions_list"
    
    if [[ -n "$MIN_DRIVER_VERSION" ]]; then
      local filtered_list=""
      while IFS= read -r ver; do
        [[ -z "$ver" ]] && continue
        if is_version_compatible "$ver"; then
          filtered_list+="$ver"$'\n'
        fi
      done <<< "$current_list"
      current_list="$filtered_list"
    fi
    

    if [[ -n "$filter" ]]; then
      current_list=$(echo "$current_list" | grep "$filter" || true)
    fi

    menu_text="$(translate 'Select the NVIDIA driver version to install:')\n\n"
    menu_text+="$(translate 'Use the filter entry to narrow the list. Latest available (recommended in most cases), or choose a specific version from the list.')"

    choices=()
    choices+=("latest" "$(translate 'Latest available') (${latest:-unknown})")
    choices+=("" "")
    choices+=("filter" "$(translate 'Filter versions')${filter:+: $filter}")


    if [[ -n "$current_list" ]]; then
      while IFS= read -r ver; do
        [[ -z "$ver" ]] && continue
        ver=$(echo "$ver" | tr -d '[:space:]')
        [[ -z "$ver" ]] && continue
        
        choices+=("$ver" "$ver")
      done <<< "$current_list"
    else
      choices+=("" "$(translate 'No versions match the current filter')")
    fi

    selection=$(dialog --clear --stdout \
      --backtitle "ProxMenux" \
      --title "$(translate 'NVIDIA Driver Version')" \
      --menu "$menu_text" 26 90 16 \
      "${choices[@]}") || { DRIVER_VERSION="cancel"; return 1; }

    case "$selection" in
      "")
        continue
        ;;
      filter)
        filter=$(dialog --clear --stdout \
          --backtitle "ProxMenux" \
          --title "$(translate 'Filter NVIDIA versions')" \
          --inputbox "$(translate 'Enter a filter (e.g., 560, 570, 580). Leave empty to show all.')" 10 80 "$filter") || true
        ;;
      latest)
        DRIVER_VERSION="$latest"
        DRIVER_VERSION=$(echo "$DRIVER_VERSION" | tr -d '[:space:]')
        return 0
        ;;
      *)
        DRIVER_VERSION="$selection"
        DRIVER_VERSION=$(echo "$DRIVER_VERSION" | tr -d '[:space:]')
        return 0
        ;;
    esac
  done
}

# ==========================================================
# Main flow
# ==========================================================
main() {
  : >"$LOG_FILE"
  : >"$screen_capture"

  detect_nvidia_gpus
  detect_driver_status

  if ! $NVIDIA_GPU_PRESENT; then
    dialog --backtitle "ProxMenux" --title "$(translate 'NVIDIA GPU Driver Installation')" --msgbox \
      "\n$(translate 'No NVIDIA GPU has been detected on this system. The installer will now exit.')" 20 70
    exit 1
  fi

  show_action_menu_if_installed

  case "$ACTION" in
    install)
      if ! show_install_overview; then
        exit 0
      fi

      get_kernel_compatibility_info

      show_version_menu
      if [[ "$DRIVER_VERSION" == "cancel" || -z "$DRIVER_VERSION" ]]; then
        exit 0
      fi

      if $CURRENT_DRIVER_INSTALLED; then
        if [[ "$CURRENT_DRIVER_VERSION" == "$DRIVER_VERSION" ]]; then
          if ! dialog --colors --backtitle "ProxMenux" --title "$(translate 'Same Version Detected')" --yesno \
              "$(printf '\n\n\n%s \Zb%s\Zn\n\n%s' \
                "$(translate 'Version')" "$DRIVER_VERSION" \
                "$(translate 'is already installed. Do you want to reinstall it? This will perform a clean uninstall first.')")" 14 70; then
              exit 0
          fi
        else
          if ! dialog --colors --backtitle "ProxMenux" --title "$(translate 'Version Change Detected')" --yesno \
              "$(printf '\n\n%s \Zb%s\Zn\n%s \Zb\Z4%s\Zn\n\n%s' \
                "$(translate 'Current version:')" "$CURRENT_DRIVER_VERSION" \
                "$(translate 'New version:')" "$DRIVER_VERSION" \
                "$(translate 'The current driver will be completely uninstalled before installing the new version. Continue?')")" 20 70; then
              exit 0
          fi
        fi
        
        show_proxmenux_logo
        msg_title "$(translate "$SCRIPT_TITLE")"
        msg_info2 "$(translate 'Uninstalling current NVIDIA driver before installing new version...')"
        complete_nvidia_uninstall
        
        sleep 2
        
        CURRENT_DRIVER_INSTALLED=false
        CURRENT_DRIVER_VERSION=""
      fi

      show_proxmenux_logo
      msg_title "$(translate "$SCRIPT_TITLE")"

      ensure_repos_and_headers
      blacklist_nouveau
      ensure_modules_config
      
      stop_and_disable_nvidia_services
      unload_nvidia_modules

      msg_info "$(translate 'Downloading NVIDIA driver version:') $DRIVER_VERSION"
      
      local installer
      installer=$(download_nvidia_installer "$DRIVER_VERSION" 2>>"$LOG_FILE")
      local download_result=$?
      
      if [[ $download_result -ne 0 ]]; then
        msg_error "$(translate 'Failed to download NVIDIA installer')"
        exit 1
      fi
      
      msg_ok "$(translate 'NVIDIA installer downloaded successfully')"

      if [[ -z "$installer" || ! -f "$installer" ]]; then
        msg_error "$(translate 'Internal error: NVIDIA installer path is empty or file not found.')"
        rm -f "$screen_capture"
        exit 1
      fi

      if ! run_nvidia_installer "$installer"; then
        rm -f "$screen_capture"
        exit 1
      fi
      
      sleep 2
      show_proxmenux_logo
      msg_title "$(translate "$SCRIPT_TITLE")"
      cat "$screen_capture"
      echo -e "${TAB}${GN}ğŸ“„ $(translate "Log file")${CL}: ${BL}$LOG_FILE${CL}"

      install_udev_rules_and_persistenced

      msg_info "$(translate 'Updating initramfs for all kernels...')"
      update-initramfs -u -k all >>"$LOG_FILE" 2>&1 || true
      msg_ok "$(translate 'initramfs updated.')"

      msg_info2 "$(translate 'Checking NVIDIA driver status with nvidia-smi')"
      if command -v nvidia-smi >/dev/null 2>&1; then
        nvidia-smi || true
        CURRENT_DRIVER_VERSION=$(nvidia-smi --query-gpu=driver_version --format=csv,noheader 2>/dev/null | head -n1)
        CURRENT_DRIVER_INSTALLED=true
      else
        msg_warn "$(translate 'nvidia-smi not found in PATH. Please verify the driver installation.')"
      fi

      if [[ -n "$CURRENT_DRIVER_VERSION" ]]; then
        msg_ok "$(translate 'NVIDIA driver') $CURRENT_DRIVER_VERSION $(translate 'installed successfully.')"
        update_component_status "nvidia_driver" "installed" "$CURRENT_DRIVER_VERSION" "gpu" '{"patched":false}'
        msg_success "$(translate 'Driver installed successfully. Press Enter to continue...')"
        read -r
      else
        msg_error "$(translate 'Failed to detect installed NVIDIA driver version.')"
        update_component_status "nvidia_driver" "failed" "" "gpu" '{"patched":false}'
      fi

      apply_nvidia_patch_if_needed
      restart_prompt
      ;;
    remove)
      if dialog --backtitle "ProxMenux" --title "$(translate 'NVIDIA Driver Uninstall')" --yesno \
        "\n\n\n$(translate 'This will remove NVIDIA drivers and related configuration. Do you want to continue?')" 14 70; then

        show_proxmenux_logo
        msg_title "$(translate "$SCRIPT_TITLE")"

        remove_nvidia_driver

        msg_info "$(translate 'Updating initramfs for all kernels...')"
        update-initramfs -u -k all >>"$LOG_FILE" 2>&1 || true
        msg_ok "$(translate 'initramfs updated.')"

        restart_prompt
      fi
      ;;
    cancel|*)
      exit 0
      ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  main
fi



================================================
FILE: scripts/lxc/jd2.sh
================================================
#!/bin/bash

# Script para instalar JDownloader en un contenedor LXC desde el host Proxmox
# Autor: MacRimi

# Mostrar lista de CTs
CT_LIST=$(pct list | awk 'NR>1 {print $1, $3}')
if [ -z "$CT_LIST" ]; then
    whiptail --title "Error" --msgbox "No hay contenedores LXC disponibles en el sistema." 8 50
    exit 1
fi

# Seleccionar CT
CTID=$(whiptail --title "InstalaciÃ³n de JDownloader" --menu "Selecciona el contenedor donde instalar JDownloader:" 20 60 10 $CT_LIST 3>&1 1>&2 2>&3)
if [ -z "$CTID" ]; then
    whiptail --title "Cancelado" --msgbox "No se ha seleccionado ningÃºn contenedor." 8 40
    exit 1
fi

# Solicitar email
EMAIL=$(whiptail --title "Cuenta My JDownloader" --inputbox "Introduce tu correo electrÃ³nico para vincular JDownloader:" 10 60 3>&1 1>&2 2>&3)
if [ -z "$EMAIL" ]; then
    whiptail --title "Error" --msgbox "No se ha introducido ningÃºn correo." 8 40
    exit 1
fi

# Solicitar contraseÃ±a con confirmaciÃ³n
while true; do
    PASSWORD=$(whiptail --title "Cuenta My JDownloader" --passwordbox "Introduce tu contraseÃ±a de My JDownloader:" 10 60 3>&1 1>&2 2>&3)
    [ -z "$PASSWORD" ] && whiptail --title "Error" --msgbox "No se ha introducido ninguna contraseÃ±a." 8 40 && exit 1

    CONFIRM=$(whiptail --title "ConfirmaciÃ³n de contraseÃ±a" --passwordbox "Repite tu contraseÃ±a para confirmar:" 10 60 3>&1 1>&2 2>&3)
    [ "$PASSWORD" = "$CONFIRM" ] && break
    whiptail --title "Error" --msgbox "Las contraseÃ±as no coinciden. Intenta de nuevo." 8 50
done

# ConfirmaciÃ³n final
whiptail --title "Confirmar datos" --yesno "Â¿Deseas continuar con los siguientes datos?\n\nCorreo: $EMAIL\nContraseÃ±a: (oculta)\n\nEsta informaciÃ³n se usarÃ¡ para vincular el contenedor con tu cuenta de My.JDownloader." 14 60
[ $? -ne 0 ] && whiptail --title "Cancelado" --msgbox "InstalaciÃ³n cancelada por el usuario." 8 40 && exit 1

clear
echo "ğŸ” Detectando sistema operativo dentro del CT $CTID..."
OS_ID=$(pct exec "$CTID" -- awk -F= '/^ID=/{gsub("\"",""); print $2}' /etc/os-release)

echo "Sistema detectado: $OS_ID"
echo "ğŸ§° Preparando entorno..."

case "$OS_ID" in
  debian)
    # Repositorio adicional para Java 8
    pct exec "$CTID" -- wget -q http://www.mirbsd.org/~tg/Debs/sources.txt/wtf-bookworm.sources
    pct exec "$CTID" -- mv wtf-bookworm.sources /etc/apt/sources.list.d/
    pct exec "$CTID" -- apt update -y
    pct exec "$CTID" -- apt install -y openjdk-8-jdk wget
    JAVA_PATH="/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java"
    ;;
  ubuntu)
    pct exec "$CTID" -- apt update -y
    pct exec "$CTID" -- apt install -y openjdk-8-jdk wget
    JAVA_PATH="/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java"
    ;;
  alpine)
    pct exec "$CTID" -- apk update
    pct exec "$CTID" -- apk add openjdk8 wget
    JAVA_PATH="/usr/lib/jvm/java-1.8-openjdk/bin/java"
    ;;
  *)
    echo "âŒ Sistema operativo no soportado: $OS_ID"
    exit 1
    ;;
esac

# Crear carpeta de instalaciÃ³n
pct exec "$CTID" -- mkdir -p /opt/jdownloader
pct exec "$CTID" -- bash -c 'cd /opt/jdownloader && curl -O https://installer.jdownloader.org/JDownloader.jar'


# Crear archivo de configuraciÃ³n JSON para My JDownloader
pct exec "$CTID" -- bash -c "mkdir -p /opt/jdownloader/cfg && cat > /opt/jdownloader/cfg/org.jdownloader.api.myjdownloader.MyJDownloaderSettings.json" <<EOF
{
  "email" : "$EMAIL",
  "password" : "$PASSWORD",
  "enabled" : true
}
EOF


# Crear servicio segÃºn sistema
if [[ "$OS_ID" == "alpine" ]]; then
    # Servicio OpenRC para Alpine
    pct exec "$CTID" -- bash -c 'cat > /etc/init.d/jdownloader <<EOF
#!/sbin/openrc-run

command="/usr/bin/java"
command_args="-jar /opt/jdownloader/JDownloader.jar -norestart"
pidfile="/var/run/jdownloader.pid"
name="JDownloader"

depend() {
    need net
}
EOF'

    pct exec "$CTID" -- chmod +x /etc/init.d/jdownloader
    pct exec "$CTID" -- rc-update add jdownloader default
    pct exec "$CTID" -- rc-service jdownloader start

else
    # Servicio systemd para Debian/Ubuntu
    pct exec "$CTID" -- bash -c 'cat > /etc/systemd/system/jdownloader.service <<EOF
[Unit]
Description=JDownloader
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/jdownloader
ExecStart=/usr/bin/java -jar JDownloader.jar -norestart
Restart=always

[Install]
WantedBy=multi-user.target
EOF'

    pct exec "$CTID" -- systemctl daemon-reexec
    pct exec "$CTID" -- systemctl daemon-reload
    pct exec "$CTID" -- systemctl enable jdownloader
    pct exec "$CTID" -- systemctl start jdownloader
fi

pct exec "$CTID" -- reboot

echo -e "\n\033[1;32mâœ… JDownloader se ha instalado correctamente en el CT $CTID y estÃ¡ funcionando como servicio.\033[0m"
echo -e "\nâ¡ï¸ Accede a \033[1;34mhttps://my.jdownloader.org\033[0m con tu cuenta para gestionarlo.\n"



================================================
FILE: scripts/lxc/jd2_.sh
================================================
#!/bin/bash

# Script para instalar JDownloader en un contenedor LXC desde el host Proxmox
# Autor: MacRimi

# Mostrar lista de CTs
CT_LIST=$(pct list | awk 'NR>1 {print $1, $3}')
if [ -z "$CT_LIST" ]; then
    whiptail --title "Error" --msgbox "No hay contenedores LXC disponibles en el sistema." 8 50
    exit 1
fi

# Seleccionar CT
CTID=$(whiptail --title "InstalaciÃ³n de JDownloader" --menu "Selecciona el contenedor donde instalar JDownloader:" 20 60 10 $CT_LIST 3>&1 1>&2 2>&3)
if [ -z "$CTID" ]; then
    whiptail --title "Cancelado" --msgbox "No se ha seleccionado ningÃºn contenedor." 8 40
    exit 1
fi

# Solicitar email
EMAIL=$(whiptail --title "Cuenta My JDownloader" --inputbox "Introduce tu correo electrÃ³nico para vincular JDownloader:" 10 60 3>&1 1>&2 2>&3)
if [ -z "$EMAIL" ]; then
    whiptail --title "Error" --msgbox "No se ha introducido ningÃºn correo." 8 40
    exit 1
fi

# Solicitar contraseÃ±a
while true; do
    PASSWORD=$(whiptail --title "Cuenta My JDownloader" --passwordbox "Introduce tu contraseÃ±a de My JDownloader:" 10 60 3>&1 1>&2 2>&3)
    if [ -z "$PASSWORD" ]; then
        whiptail --title "Error" --msgbox "No se ha introducido ninguna contraseÃ±a." 8 40
        exit 1
    fi

    CONFIRM_PASSWORD=$(whiptail --title "ConfirmaciÃ³n de contraseÃ±a" --passwordbox "Repite tu contraseÃ±a para confirmar:" 10 60 3>&1 1>&2 2>&3)

    if [ "$PASSWORD" = "$CONFIRM_PASSWORD" ]; then
        break
    else
        whiptail --title "Error" --msgbox "Las contraseÃ±as no coinciden. Intenta de nuevo." 8 50
    fi
done

# Confirmar datos
whiptail --title "Confirmar datos" --yesno "Â¿Deseas continuar con los siguientes datos?\n\nCorreo: $EMAIL\nContraseÃ±a: (establecida)\n\nEsta informaciÃ³n se usarÃ¡ para vincular el contenedor con tu cuenta de My.JDownloader." 14 60
if [ $? -ne 0 ]; then
    whiptail --title "Cancelado" --msgbox "InstalaciÃ³n cancelada por el usuario." 8 40
    exit 1
fi

echo
echo "Instalando JDownloader en CT $CTID..."
echo

# AÃ±adir repositorio alternativo para Java 8 y actualizar
pct exec "$CTID" -- wget -q http://www.mirbsd.org/~tg/Debs/sources.txt/wtf-bookworm.sources
pct exec "$CTID" -- mv wtf-bookworm.sources /etc/apt/sources.list.d/
pct exec "$CTID" -- apt update -y
pct exec "$CTID" -- apt install -y openjdk-8-jdk wget

# Crear carpeta y descargar JDownloader
pct exec "$CTID" -- mkdir -p /root/jdownloader
pct exec "$CTID" -- bash -c "cd /root/jdownloader && wget -q http://installer.jdownloader.org/JDownloader.jar"

# Crear archivo de configuraciÃ³n JSON para My JDownloader
pct exec "$CTID" -- bash -c "mkdir -p /root/jdownloader/cfg && cat > /root/jdownloader/cfg/org.jdownloader.api.myjdownloader.MyJDownloaderSettings.json" <<EOF

{
  "email" : "$EMAIL",
  "password" : "$PASSWORD",
  "enabled" : true
}
EOF

# Crear servicio systemd
pct exec "$CTID" -- bash -c "cat > /etc/systemd/system/jdownloader.service <<EOF
[Unit]
Description=JDownloader Headless
After=network.target

[Service]
Type=simple
WorkingDirectory=/root/jdownloader
ExecStart=/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java -jar JDownloader.jar -norestart
Restart=always
User=root

[Install]
WantedBy=multi-user.target
EOF"

# Activar y arrancar servicio
pct exec "$CTID" -- systemctl daemon-reexec
pct exec "$CTID" -- systemctl daemon-reload
pct exec "$CTID" -- systemctl enable jdownloader
pct exec "$CTID" -- systemctl start jdownloader

echo -e "\n\033[1;32mâœ… JDownloader se ha instalado y estÃ¡ funcionando como servicio en el CT $CTID.\033[0m"
echo -e "\nPuedes acceder a \033[1;34mhttps://my.jdownloader.org\033[0m con tu cuenta para gestionarlo.\n"



================================================
FILE: scripts/lxc/jd2_2.sh
================================================
#!/bin/bash

# Script para instalar JDownloader en un contenedor LXC desde el host Proxmox
# Autor: MacRimi

# Mostrar lista de CTs
CT_LIST=$(pct list | awk 'NR>1 {print $1, $3}')
if [ -z "$CT_LIST" ]; then
    whiptail --title "Error" --msgbox "No hay contenedores LXC disponibles en el sistema." 8 50
    exit 1
fi

# Seleccionar CT
CTID=$(whiptail --title "InstalaciÃ³n de JDownloader" --menu "Selecciona el contenedor donde instalar JDownloader:" 20 60 10 $CT_LIST 3>&1 1>&2 2>&3)
if [ -z "$CTID" ]; then
    whiptail --title "Cancelado" --msgbox "No se ha seleccionado ningÃºn contenedor." 8 40
    exit 1
fi

# Solicitar email
EMAIL=$(whiptail --title "Cuenta My JDownloader" --inputbox "Introduce tu correo electrÃ³nico para vincular JDownloader:" 10 60 3>&1 1>&2 2>&3)
if [ -z "$EMAIL" ]; then
    whiptail --title "Error" --msgbox "No se ha introducido ningÃºn correo." 8 40
    exit 1
fi

# Solicitar contraseÃ±a con confirmaciÃ³n
while true; do
    PASSWORD=$(whiptail --title "Cuenta My JDownloader" --passwordbox "Introduce tu contraseÃ±a de My JDownloader:" 10 60 3>&1 1>&2 2>&3)
    [ -z "$PASSWORD" ] && whiptail --title "Error" --msgbox "No se ha introducido ninguna contraseÃ±a." 8 40 && exit 1

    CONFIRM=$(whiptail --title "ConfirmaciÃ³n de contraseÃ±a" --passwordbox "Repite tu contraseÃ±a para confirmar:" 10 60 3>&1 1>&2 2>&3)
    [ "$PASSWORD" = "$CONFIRM" ] && break
    whiptail --title "Error" --msgbox "Las contraseÃ±as no coinciden. Intenta de nuevo." 8 50
done

# ConfirmaciÃ³n final
whiptail --title "Confirmar datos" --yesno "Â¿Deseas continuar con los siguientes datos?\n\nCorreo: $EMAIL\nContraseÃ±a: (oculta)\n\nEsta informaciÃ³n se usarÃ¡ para vincular el contenedor con tu cuenta de My.JDownloader." 14 60
[ $? -ne 0 ] && whiptail --title "Cancelado" --msgbox "InstalaciÃ³n cancelada por el usuario." 8 40 && exit 1

clear
echo "ğŸ” Detectando sistema operativo dentro del CT $CTID..."
OS_ID=$(pct exec "$CTID" -- awk -F= '/^ID=/{gsub("\"",""); print $2}' /etc/os-release)

echo "Sistema detectado: $OS_ID"
echo "ğŸ§° Preparando entorno..."

case "$OS_ID" in
  debian)
    # Repositorio adicional para Java 8
    pct exec "$CTID" -- wget -q http://www.mirbsd.org/~tg/Debs/sources.txt/wtf-bookworm.sources
    pct exec "$CTID" -- mv wtf-bookworm.sources /etc/apt/sources.list.d/
    pct exec "$CTID" -- apt update -y
    pct exec "$CTID" -- apt install -y openjdk-8-jdk wget
    JAVA_PATH="/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java"
    ;;
  ubuntu)
    pct exec "$CTID" -- apt update -y
    pct exec "$CTID" -- apt install -y openjdk-8-jdk wget
    JAVA_PATH="/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java"
    ;;
  alpine)
    pct exec "$CTID" -- apk update
    pct exec "$CTID" -- apk add openjdk8 wget
    JAVA_PATH="/usr/lib/jvm/java-1.8-openjdk/bin/java"
    ;;
  *)
    echo "âŒ Sistema operativo no soportado: $OS_ID"
    exit 1
    ;;
esac

# Crear carpeta de instalaciÃ³n
pct exec "$CTID" -- mkdir -p /opt/jdownloader
pct exec "$CTID" -- bash -lc '
  set -e
  mkdir -p /opt/jdownloader
  cd /opt/jdownloader
  if [ ! -f JDownloader.jar ]; then
    if ls JDownloader.jar.backup.* >/dev/null 2>&1; then
      cp -a "$(ls -t JDownloader.jar.backup.* | head -1)" JDownloader.jar
    else
      curl -fSLo JDownloader.jar https://installer.jdownloader.org/JDownloader.jar
    fi
  fi
  chown root:root JDownloader.jar
  chmod 0644 JDownloader.jar
'



# Crear archivo de configuraciÃ³n JSON para My JDownloader
pct exec "$CTID" -- bash -c "mkdir -p /opt/jdownloader/cfg && cat > /opt/jdownloader/cfg/org.jdownloader.api.myjdownloader.MyJDownloaderSettings.json" <<EOF
{
  "email" : "$EMAIL",
  "password" : "$PASSWORD",
  "enabled" : true
}
EOF


# Crear servicio segÃºn sistema
if [[ "$OS_ID" == "alpine" ]]; then
    # Servicio OpenRC para Alpine
    pct exec "$CTID" -- bash -c 'cat > /etc/init.d/jdownloader <<EOF
#!/sbin/openrc-run

command="/usr/bin/java"
command_args="-jar /opt/jdownloader/JDownloader.jar -norestart"
pidfile="/var/run/jdownloader.pid"
name="JDownloader"

depend() {
    need net
}
EOF'

    pct exec "$CTID" -- chmod +x /etc/init.d/jdownloader
    pct exec "$CTID" -- rc-update add jdownloader default
    pct exec "$CTID" -- rc-service jdownloader start

else
    # Servicio systemd para Debian/Ubuntu
pct exec "$CTID" -- bash -lc 'cat > /etc/systemd/system/jdownloader.service <<'"'"'EOF'"'"'
[Unit]
Description=JDownloader
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/jdownloader
ExecStartPre=/usr/bin/test -s /opt/jdownloader/JDownloader.jar
ExecStart=/usr/bin/java -jar /opt/jdownloader/JDownloader.jar -norestart
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable jdownloader
systemctl restart jdownloader
systemctl status jdownloader --no-pager || true
'

    pct exec "$CTID" -- systemctl daemon-reexec
    pct exec "$CTID" -- systemctl daemon-reload
    pct exec "$CTID" -- systemctl enable jdownloader
    pct exec "$CTID" -- systemctl start jdownloader
fi

pct exec "$CTID" -- reboot

echo -e "\n\033[1;32mâœ… JDownloader se ha instalado correctamente en el CT $CTID y estÃ¡ funcionando como servicio.\033[0m"
echo -e "\nâ¡ï¸ Accede a \033[1;34mhttps://my.jdownloader.org\033[0m con tu cuenta para gestionarlo.\n"



================================================
FILE: scripts/lxc/lxc-manual-guide.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - Manual LXC Conversion Guide
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 19/08/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

show_command() {
    local step="$1"
    local description="$2"
    local command="$3"
    local note="$4"
    local command_extra="$5"
    
    echo -e "${BGN}${step}.${CL} ${BL}${description}${CL}"
    echo ""
    echo -e "${TAB}${command}"
    echo -e
    [[ -n "$note" ]] && echo -e "${TAB}${DARK_GRAY}${note}${CL}"
    [[ -n "$command_extra" ]] && echo -e "${TAB}${YW}${command_extra}${CL}"
    echo ""
}

show_privileged_to_unprivileged_guide() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Manual Guide: Convert LXC Privileged to Unprivileged")"
        
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e "${TAB}${BGN}$(translate "Source:")${CL} ${BL}https://forum.proxmox.com/threads/converting-between-privileged-and-unprivileged-containers.97243/${CL}"
    echo -e
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "IMPORTANT PREREQUISITES:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}â€¢ $(translate "Container must be stopped before conversion")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Create a backup of your container before proceeding")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "This process changes file ownership inside the container")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Process may take several minutes depending on container size")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Works with LVM, ZFS, and BTRFS storage types")${CL}"
    echo -e 
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 

    show_command "1" \
        "$(translate "List all containers to identify the privileged one:")" \
        "pct list" \
        "$(translate "Look for containers without 'unprivileged: 1' in their config")"

    show_command "2" \
        "$(translate "Stop the container if it's running:")" \
        "pct stop <container-id>" \
        "$(translate "Replace <container-id> with your actual container ID")" \
        "$(translate "Example: pct stop 114")"

    show_command "3" \
        "$(translate "Create a backup of the container configuration:")" \
        "cp /etc/pve/lxc/<container-id>.conf /etc/pve/lxc/<container-id>.conf.bak" \
        "$(translate "This creates a backup in case you need to revert changes")" \
        "$(translate "Example: cp /etc/pve/lxc/114.conf /etc/pve/lxc/114.conf.bak")"

    show_command "4" \
        "$(translate "Get the container's storage information:")" \
        "grep '^rootfs:' /etc/pve/lxc/<container-id>.conf" \
        "$(translate "This shows the storage type and disk identifier")" \
        "$(translate "Example output: rootfs: local-lvm:vm-114-disk-0,size=8G")"

    show_command "5" \
        "$(translate "Get the actual disk path:")" \
        "pvesm path <storage-identifier>" \
        "$(translate "Replace <storage-identifier> with the value from step 4")" \
        "$(translate "Example: pvesm path local-lvm:vm-114-disk-0")"

    echo -e "${TAB}${BOLD}$(translate "STEP 6: Choose commands based on your storage type")${CL}"
    echo -e
    echo -e "${TAB}${BGN}$(translate "If pvesm path returned a DIRECTORY (ZFS/BTRFS):")${CL}"
    echo -e "${TAB}${YW}$(translate "Example: /rpool/data/subvol-114-disk-0")${CL}"
    echo -e

    show_command "6a" \
        "$(translate "For ZFS/BTRFS - Set the mount path:")" \
        "MOUNT_PATH=\"/rpool/data/subvol-<container-id>-disk-0\"" \
        "$(translate "Replace with your actual path from step 5")" \
        "$(translate "Example: MOUNT_PATH=\"/rpool/data/subvol-114-disk-0\"")"

    echo -e "${TAB}${BGN}$(translate "If pvesm path returned a DEVICE (LVM):")${CL}"
    echo -e "${TAB}${YW}$(translate "Example: /dev/pve/vm-114-disk-0")${CL}"
    echo -e

    show_command "6b" \
        "$(translate "For LVM - Create mount directory and mount:")" \
        "mkdir -p /tmp/lxc_convert_<container-id>\nmount -o loop /dev/path/to/disk /tmp/lxc_convert_<container-id>\nMOUNT_PATH=\"/tmp/lxc_convert_<container-id>\"" \
        "$(translate "Replace paths with your actual values from step 5")" \
        "$(translate "Example: mkdir -p /tmp/lxc_convert_114")"

    show_command "7" \
        "$(translate "Convert file ownership (this takes time):")" \
        "find \"\$MOUNT_PATH\" -type f | while read file; do\n  if [ -e \"\$file\" ]; then\n    CURRENT_UID=\$(stat -c '%u' \"\$file\")\n    CURRENT_GID=\$(stat -c '%g' \"\$file\")\n    NEW_UID=\$((100000 + CURRENT_UID))\n    NEW_GID=\$((100000 + CURRENT_GID))\n    chown \"\$NEW_UID:\$NEW_GID\" \"\$file\"\n  fi\ndone" \
        "$(translate "This converts all file UIDs/GIDs by adding 100000")" \
        "$(translate "Process may take several minutes for large containers")"

    show_command "8" \
        "$(translate "Convert directory ownership:")" \
        "find \"\$MOUNT_PATH\" -type d | while read dir; do\n  if [ -e \"\$dir\" ]; then\n    CURRENT_UID=\$(stat -c '%u' \"\$dir\")\n    CURRENT_GID=\$(stat -c '%g' \"\$dir\")\n    NEW_UID=\$((100000 + CURRENT_UID))\n    NEW_GID=\$((100000 + CURRENT_GID))\n    chown \"\$NEW_UID:\$NEW_GID\" \"\$dir\"\n  fi\ndone" \
        "$(translate "This converts all directory UIDs/GIDs by adding 100000")"

    echo -e "${TAB}${BOLD}$(translate "STEP 9: Cleanup (LVM only)")${CL}"
    echo -e "${TAB}${YW}$(translate "Only run this if you used LVM (step 6b):")${CL}"
    echo -e

    show_command "9" \
        "$(translate "Unmount and cleanup (LVM only):")" \
        "umount /tmp/lxc_convert_<container-id>\nrmdir /tmp/lxc_convert_<container-id>" \
        "$(translate "Only needed if you mounted the filesystem in step 6b")" \
        "$(translate "Skip this step for ZFS/BTRFS")"

    show_command "10" \
        "$(translate "Add unprivileged flag to container configuration:")" \
        "echo 'unprivileged: 1' >> /etc/pve/lxc/<container-id>.conf" \
        "$(translate "This marks the container as unprivileged")"

    show_command "11" \
        "$(translate "Start the converted container:")" \
        "pct start <container-id>" \
        "$(translate "The container should now start as unprivileged")"

    show_command "12" \
        "$(translate "Verify the conversion:")" \
        "pct config <container-id> | grep unprivileged" \
        "$(translate "Should show 'unprivileged: 1'")"
    
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "STORAGE TYPE IDENTIFICATION:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}â€¢ $(translate "LVM:")${CL} ${YW}pvesm path returns /dev/xxx (block device)${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "ZFS:")${CL} ${YW}pvesm path returns /rpool/xxx (directory)${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "BTRFS:")${CL} ${YW}pvesm path returns directory path${CL}"
    echo -e
    echo -e "${TAB}${BOLD}$(translate "TROUBLESHOOTING:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}$(translate "If mount fails (LVM):")${CL} ${YW}Check that the container is stopped and disk path is correct${CL}"
    echo -e "${TAB}${BGN}$(translate "If path not accessible (ZFS/BTRFS):")${CL} ${YW}Verify the dataset/subvolume exists and is mounted${CL}"
    echo -e "${TAB}${BGN}$(translate "If container won't start:")${CL} ${YW}Check /var/log/pve/tasks/ for detailed error messages${CL}"
    echo -e "${TAB}${BGN}$(translate "To revert changes:")${CL} ${YW}cp /etc/pve/lxc/<container-id>.conf.bak /etc/pve/lxc/<container-id>.conf${CL}"
    echo -e

    echo -e 
    msg_success "$(translate "Press Enter to return to menu...")"
    echo -e 
    read -r
}

show_unprivileged_to_privileged_guide() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Manual Guide: Convert LXC Unprivileged to Privileged")"
        
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e "${TAB}${RD}$(translate "SECURITY WARNING:")${CL} ${YW}$(translate "Privileged containers have full root access to the host system!")${CL}"
    echo -e "${TAB}${YW}$(translate "Only convert to privileged if absolutely necessary for your use case.")${CL}"
    echo -e
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "IMPORTANT PREREQUISITES:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}â€¢ $(translate "Container must be stopped before conversion")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Create a backup of your container before proceeding")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Understand the security implications of privileged containers")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "This is a simple configuration change")${CL}"
    echo -e 
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    

    show_command "1" \
        "$(translate "List all containers to identify the unprivileged one:")" \
        "pct list" \
        "$(translate "Look for containers with 'unprivileged: 1' in their config")"

    show_command "2" \
        "$(translate "Check if container is unprivileged:")" \
        "pct config <container-id> | grep unprivileged" \
        "$(translate "Should show 'unprivileged: 1' if it's unprivileged")" \
        "$(translate "Example: pct config 110 | grep unprivileged")"

    show_command "3" \
        "$(translate "Stop the container if it's running:")" \
        "pct stop <container-id>" \
        "$(translate "Replace <container-id> with your actual container ID")" \
        "$(translate "Example: pct stop 110")"

    show_command "4" \
        "$(translate "Create a backup of the container configuration:")" \
        "cp /etc/pve/lxc/<container-id>.conf /etc/pve/lxc/<container-id>.conf.bak" \
        "$(translate "This creates a backup in case you need to revert changes")" \
        "$(translate "Example: cp /etc/pve/lxc/110.conf /etc/pve/lxc/110.conf.bak")"

    show_command "5" \
        "$(translate "Remove the unprivileged flag from configuration:")" \
        "sed -i '/^unprivileged: 1/d' /etc/pve/lxc/<container-id>.conf" \
        "$(translate "This removes the 'unprivileged: 1' line from the config")" \
        "$(translate "Example: sed -i '/^unprivileged: 1/d' /etc/pve/lxc/110.conf")"

    show_command "6" \
        "$(translate "Add explicit privileged flag (optional but recommended):")" \
        "echo 'unprivileged: 0' >> /etc/pve/lxc/<container-id>.conf" \
        "$(translate "This explicitly marks the container as privileged")"

    show_command "7" \
        "$(translate "Start the converted container:")" \
        "pct start <container-id>" \
        "$(translate "The container should now start as privileged")"

    show_command "8" \
        "$(translate "Verify the conversion:")" \
        "pct config <container-id> | grep unprivileged" \
        "$(translate "Should show 'unprivileged: 0' or no unprivileged line")"
    
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "SECURITY CONSIDERATIONS:")${CL}"
    echo -e
    echo -e "${TAB}${RD}â€¢ $(translate "Privileged containers can access host devices directly")${CL}"
    echo -e "${TAB}${RD}â€¢ $(translate "Root inside container = root on host system")${CL}"
    echo -e "${TAB}${RD}â€¢ $(translate "Use only when unprivileged containers cannot meet your needs")${CL}"
    echo -e "${TAB}${RD}â€¢ $(translate "Consider security implications for production environments")${CL}"
    echo -e
    echo -e
    
    echo -e "${TAB}${BOLD}$(translate "TROUBLESHOOTING:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}$(translate "If container won't start:")${CL} ${YW}Check /var/log/pve/tasks/ for detailed error messages${CL}"
    echo -e "${TAB}${BGN}$(translate "To revert changes:")${CL} ${YW}cp /etc/pve/lxc/<container-id>.conf.bak /etc/pve/lxc/<container-id>.conf${CL}"
    echo -e "${TAB}${BGN}$(translate "If config issues occur:")${CL} ${YW}Manually edit /etc/pve/lxc/<container-id>.conf${CL}"
    echo -e
    echo -e

    
    echo -e 
    msg_success "$(translate "Press Enter to return to menu...")"
    echo -e 
    read -r
}

show_lxc_conversion_manual_menu() {
    while true; do
        CHOICE=$(dialog --title "$(translate "LXC Conversion Manual Guides")" \
            --menu "$(translate "Select conversion guide:")" 18 70 10 \
            "1" "$(translate "Convert Privileged to Unprivileged")" \
            "2" "$(translate "Convert Unprivileged to Privileged")" \
            "3" "$(translate "Return to Main Menu")" \
            3>&1 1>&2 2>&3)
        
        case $CHOICE in
            1) show_privileged_to_unprivileged_guide ;;
            2) show_unprivileged_to_privileged_guide ;;
            3) return ;;
            *) return ;;
        esac
    done
}

# Main execution
show_lxc_conversion_manual_menu



================================================
FILE: scripts/lxc/lxc-privileged-to-unprivileged.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - LXC Privileged to Unprivileged Converter
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 19/08/2025
# ==========================================================
# Description:
# This script converts a privileged LXC container to an unprivileged one
# using the direct conversion method (mount and chown).
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

select_privileged_container() {

    CONTAINERS=$(pct list | awk 'NR>1 {print $1, $3}' | while read id name; do
        if pct config "$id" | grep -q "^unprivileged: 0" || ! pct config "$id" | grep -q "^unprivileged:"; then
            echo "$id" "$name"
        fi
    done | xargs -n2)
    
    if [ -z "$CONTAINERS" ]; then
        msg_error "$(translate 'No privileged containers available in Proxmox.')"
        exit 1
    fi
    cleanup
    CONTAINER_ID=$(whiptail --title "$(translate 'Select Privileged Container')" \
        --menu "$(translate 'Select the privileged LXC container to convert:')" 20 70 10 $CONTAINERS 3>&1 1>&2 2>&3)

    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'No container selected. Exiting.')"
        exit 1
    fi

    msg_ok "$(translate 'Privileged container selected:') $CONTAINER_ID"
}

validate_container_id() {
    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'Container ID not defined. Make sure to select a container first.')"
        exit 1
    fi


    if pct config "$CONTAINER_ID" | grep -q "^unprivileged: 1"; then
        msg_error "$(translate 'Container') $CONTAINER_ID $(translate 'is already unprivileged.')"
        exit 1
    fi

    if pct status "$CONTAINER_ID" | grep -q "running"; then
        msg_info "$(translate 'Stopping the container before conversion...')"
        pct stop "$CONTAINER_ID"
        msg_ok "$(translate 'Container stopped.')"
    fi
}

show_backup_warning() {
    local message="$(translate 'It is strongly recommended to create a backup of your container before proceeding with the conversion.')"
    message="$message\n\n$(translate 'Do you want to continue with the conversion now, or exit to create a backup first?')"
    message="$message\n\n$(translate 'Continue: Proceed with conversion')"
    message="$message\n$(translate 'Exit: Stop to create backup manually')"
    
    if whiptail --title "$(translate 'Backup Recommendation')" \
        --yes-button "$(translate 'Continue')" \
        --no-button "$(translate 'Exit')" \
        --yesno "$message" 18 80; then
        return 0
    else
        msg_info2 "$(translate 'User chose to exit for manual backup creation.')"
        exit 0
    fi
}

convert_direct_method() {
    msg_info2 "$(translate 'Starting direct conversion of container') $CONTAINER_ID..."
    
    TEMP_DIR="/tmp/lxc_convert_$CONTAINER_ID"
    mkdir -p "$TEMP_DIR"
    

    ROOTFS_CONFIG=$(pct config "$CONTAINER_ID" | grep "^rootfs:")
    if [ -z "$ROOTFS_CONFIG" ]; then
        msg_error "$(translate 'Could not find rootfs configuration for container.')"
        exit 1
    fi
    

    STORAGE_DISK=$(echo "$ROOTFS_CONFIG" | awk '{print $2}' | cut -d, -f1)
    
    msg_ok "$(translate 'Storage disk identifier:') $STORAGE_DISK"
    

    DISK_PATH=$(pvesm path "$STORAGE_DISK" 2>/dev/null)
    
    if [ -n "$DISK_PATH" ] && [ -e "$DISK_PATH" ]; then
        msg_ok "$(translate 'Disk path resolved via pvesm:') $DISK_PATH"
    else

        STORAGE_NAME=$(echo "$STORAGE_DISK" | cut -d: -f1)
        DISK_NAME=$(echo "$STORAGE_DISK" | cut -d: -f2)
        
        msg_info2 "$(translate 'pvesm path failed, trying manual detection...')"
        msg_info2 "$(translate 'Storage:') $STORAGE_NAME, $(translate 'Disk:') $DISK_NAME"
        

        for vg in pve $(vgs --noheadings -o vg_name 2>/dev/null | tr -d ' '); do
            if [ -e "/dev/$vg/$DISK_NAME" ]; then
                DISK_PATH="/dev/$vg/$DISK_NAME"
                break
            fi
        done
        

        if [ -z "$DISK_PATH" ] || [ ! -e "$DISK_PATH" ]; then
            ZFS_PATH="/dev/zvol/$STORAGE_NAME/$DISK_NAME"
            if [ -e "$ZFS_PATH" ]; then
                DISK_PATH="$ZFS_PATH"
            fi
        fi
    fi
    

    if [ -z "$DISK_PATH" ] || [ ! -e "$DISK_PATH" ]; then
        msg_error "$(translate 'Could not determine disk path for:') $STORAGE_DISK"
        msg_error "$(translate 'Tried pvesm path and manual detection methods')"
        msg_info2 "$(translate 'Available storage information:')"
        pvesm status 2>/dev/null || msg_error "$(translate 'pvesm status failed')"
        rmdir "$TEMP_DIR"
        exit 1
    fi
    
    
    msg_ok "$(translate 'Mounting container filesystem')"
    if ! mount "$DISK_PATH" "$TEMP_DIR" 2>/dev/null; then

        if ! mount -o loop "$DISK_PATH" "$TEMP_DIR" 2>/dev/null; then
            msg_error "$(translate 'Failed to mount container filesystem.')"
            msg_error "$(translate 'Disk path:') $DISK_PATH"
            msg_success "$(translate "Press Enter to return")"
            read -r
            rmdir "$TEMP_DIR"
            exit 1
        fi
    fi
    
    msg_info "$(translate 'Converting file ownership (this may take several minutes)...')"
    

    find "$TEMP_DIR" -type f -print0 | while IFS= read -r -d '' S; do 

        if [ ! -e "$S" ] || [ ! -r "$S" ]; then
            continue
        fi
        

        if STAT_OUTPUT=$(stat -c "%u %g" "$S" 2>/dev/null); then
            U=$(echo "$STAT_OUTPUT" | awk '{print $1}')
            G=$(echo "$STAT_OUTPUT" | awk '{print $2}')
            F=100000
            

            NEW_UID=$((F + U))
            NEW_GID=$((F + G))
            

            if ! chown "$NEW_UID:$NEW_GID" "$S" 2>/dev/null; then

                continue
            fi
        fi
    done
    

    find "$TEMP_DIR" -type d -print0 | while IFS= read -r -d '' S; do 

        if [ ! -e "$S" ] || [ ! -r "$S" ]; then
            continue
        fi
        

        if STAT_OUTPUT=$(stat -c "%u %g" "$S" 2>/dev/null); then
            U=$(echo "$STAT_OUTPUT" | awk '{print $1}')
            G=$(echo "$STAT_OUTPUT" | awk '{print $2}')
            F=100000
            

            NEW_UID=$((F + U))
            NEW_GID=$((F + G))
            

            if ! chown "$NEW_UID:$NEW_GID" "$S" 2>/dev/null; then

                continue
            fi
        fi
    done
    

    [ -e "$TEMP_DIR/var/spool/postfix/dev/-random" ] && rm -f "$TEMP_DIR/var/spool/postfix/dev/-random"
    [ -e "$TEMP_DIR/var/spool/postfix/dev/-urandom" ] && rm -f "$TEMP_DIR/var/spool/postfix/dev/-urandom"
    

    [ -e "$TEMP_DIR/usr/bin/sudo" ] && chmod u+s "$TEMP_DIR/usr/bin/sudo"
    
    umount "$TEMP_DIR"
    rmdir "$TEMP_DIR"
    

    CONFIG_FILE="/etc/pve/lxc/$CONTAINER_ID.conf"
    if ! grep -q "^unprivileged:" "$CONFIG_FILE"; then
        echo "unprivileged: 1" >> "$CONFIG_FILE"
    else
        sed -i 's/^unprivileged:.*/unprivileged: 1/' "$CONFIG_FILE"
    fi
    
    msg_ok "$(translate 'Direct conversion completed for container') $CONTAINER_ID"

    echo -e
    msg_success "Press Enter to continue..."
    read -r
}

cleanup_and_finalize() {

    if whiptail --yesno "$(translate 'Do you want to start the converted unprivileged container') $CONTAINER_ID $(translate 'now?')" 10 60; then
        msg_info2 "$(translate 'Starting unprivileged container...')"
        pct start "$CONTAINER_ID"
        msg_ok "$(translate 'Unprivileged container') $CONTAINER_ID $(translate 'started successfully.')"
    fi
}

main() {
    show_proxmenux_logo
    msg_title "$(translate "LXC Privileged to Unprivileged conversion")"
    msg_info "$(translate 'Starting LXC Privileged to Unprivileged conversion process...')"
    
    select_privileged_container
    validate_container_id
    show_backup_warning
    
    convert_direct_method
    cleanup_and_finalize
    
    msg_ok "$(translate 'Converted container ID:') $CONTAINER_ID"
    msg_ok "$(translate 'LXC conversion from privileged to unprivileged completed successfully!')"
    echo -e
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
    exit 0
}


main



================================================
FILE: scripts/lxc/lxc-unprivileged-to-privileged.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - LXC Unprivileged to Privileged Converter
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 2.0
# Last Updated: 19/08/2025
# ==========================================================
# Description:
# This script converts an unprivileged LXC container to a privileged one
# by directly modifying the configuration file.
# WARNING: This reduces security. Use only when necessary.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================



select_unprivileged_container() {

    CONTAINERS=$(pct list | awk 'NR>1 {print $1, $3}' | while read id name; do
        if pct config "$id" | grep -q "^unprivileged: 1"; then
            echo "$id" "$name"
        fi
    done | xargs -n2)
    
    if [ -z "$CONTAINERS" ]; then
        msg_error "$(translate 'No unprivileged containers available in Proxmox.')"
        exit 1
    fi
    cleanup
    CONTAINER_ID=$(whiptail --title "$(translate 'Select Unprivileged Container')" \
        --menu "$(translate 'Select the unprivileged LXC container to convert:')" 20 70 10 $CONTAINERS 3>&1 1>&2 2>&3)

    if [ -z "$CONTAINER_ID" ]; then
        msg_error "$(translate 'No container selected. Exiting.')"
        exit 1
    fi

    msg_ok "$(translate 'Unprivileged container selected:') $CONTAINER_ID"
}

show_backup_warning() {
    if ! whiptail --title "$(translate 'Backup Recommendation')" \
        --yes-button "$(translate 'Continue')" \
        --no-button "$(translate 'Exit')" \
        --yesno "$(translate 'It is recommended to create a backup before continuing.')" \
        12 70; then
        msg_info "$(translate 'Operation cancelled by user to create backup.')"
        exit 0
    fi
    
}

convert_to_privileged() {
    CONF_FILE="/etc/pve/lxc/$CONTAINER_ID.conf"
    
    CONTAINER_STATUS=$(pct status "$CONTAINER_ID" | awk '{print $2}')
    
    if [ "$CONTAINER_STATUS" == "running" ]; then
        msg_info "$(translate 'Stopping container') $CONTAINER_ID..."
        pct shutdown "$CONTAINER_ID"
        
        # Wait for container to stop
        for i in {1..10}; do
            sleep 1
            if [ "$(pct status "$CONTAINER_ID" | awk '{print $2}')" != "running" ]; then
                break
            fi
        done

        # Verify container stopped
        if [ "$(pct status "$CONTAINER_ID" | awk '{print $2}')" == "running" ]; then
            msg_error "$(translate 'Failed to stop the container.')"
            exit 1
        fi

        msg_ok "$(translate 'Container stopped.')"
    else
        msg_ok "$(translate 'Container is already stopped.')"
    fi
    
    msg_info "$(translate 'Creating backup of configuration file...')"
    cp "$CONF_FILE" "$CONF_FILE.bak"
    msg_ok "$(translate 'Configuration backup created:') $CONF_FILE.bak"
    
    msg_info "$(translate 'Converting container to privileged...')"
    sed -i '/^unprivileged: 1/d' "$CONF_FILE"
    echo "unprivileged: 0" >> "$CONF_FILE"
    
    msg_ok "$(translate 'Container successfully converted to privileged.')"

    echo -e
    msg_success "Press Enter to continue..."
    read -r
}

finalize_conversion() {

    if whiptail --yesno "$(translate 'Do you want to start the privileged container') $CONTAINER_ID $(translate 'now?')" 10 60; then
        msg_info "$(translate 'Starting privileged container...')"
        pct start "$CONTAINER_ID"
        msg_ok "$(translate 'Privileged container') $CONTAINER_ID $(translate 'started successfully.')"
    fi
}

main() {

    show_proxmenux_logo
    msg_title "$(translate "LXC Unprivileged to Privileged conversion")"
    msg_info "$(translate 'Starting LXC Unprivileged to Privileged conversion process...')"
    

    select_unprivileged_container
    show_backup_warning
    convert_to_privileged
    finalize_conversion
    
    msg_ok "$(translate 'LXC conversion from unprivileged to privileged completed successfully!')"
    msg_ok "$(translate 'Converted container ID:') $CONTAINER_ID"
    echo -e
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
    exit 0
}

# Execute main function
main



================================================
FILE: scripts/menus/config_menu.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# Contributors : cod378
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 04/07/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
CONFIG_FILE="$BASE_DIR/config.json"
CACHE_FILE="$BASE_DIR/cache.json"
UTILS_FILE="$BASE_DIR/utils.sh"
LOCAL_VERSION_FILE="$BASE_DIR/version.txt"
INSTALL_DIR="/usr/local/bin"
MENU_SCRIPT="menu"
VENV_PATH="/opt/googletrans-env"

MONITOR_SERVICE="proxmenux-monitor.service"
MONITOR_UNIT_FILE="/etc/systemd/system/${MONITOR_SERVICE}"
MONITOR_CONFIG_DIR="/root/.config/proxmenux-monitor"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

uninstall_proxmenux_monitor() {

    # 1. Stop service if it is running
    if systemctl is-active --quiet "${MONITOR_SERVICE}"; then
    echo " - Stoping service..."
    systemctl stop "${MONITOR_SERVICE}" > /dev/null 2>&1
    else
    echo " - Service is not running (ok)"
    fi

    # 2. Disable service if enabled
    if systemctl is-enabled --quiet "${MONITOR_SERVICE}"; then
    echo " - Disabling service..."
    systemctl disable "${MONITOR_SERVICE}" > /dev/null 2>&1
    else
    echo " - Service is not enabled (ok)"
    fi

    # 3. Remove unit file
    if [ -f "${MONITOR_UNIT_FILE}" ]; then
    echo " - Removing unit file ${MONITOR_UNIT_FILE}..."
    rm -f "${MONITOR_UNIT_FILE}"
    else
    echo " - Unit file ${MONITOR_UNIT_FILE} does not exist (ok)"
    fi

    # 4. Remove config directory (~/.config/proxmenux-monitor)
    if [ -d "${MONITOR_CONFIG_DIR}" ]; then
    echo " - Removing config dir ${MONITOR_CONFIG_DIR}..."
    rm -rf "${MONITOR_CONFIG_DIR}"
    else
    echo " - Config dir ${MONITOR_CONFIG_DIR} does not exist (ok)"
    fi

    # 5. Reload systemd
    echo " - Recargando systemd..."
    systemctl daemon-reload > /dev/null 2>&1
    systemctl reset-failed > /dev/null 2>&1 || true

    echo "==> Service ${MONITOR_SERVICE} uninstalled."

    
}

detect_installation_type() {
    local has_venv=false
    local has_language=false
    
    # Check if virtual environment exists
    if [ -d "$VENV_PATH" ] && [ -f "$VENV_PATH/bin/activate" ]; then
        has_venv=true
    fi
    
    # Check if language is configured
    if [ -f "$CONFIG_FILE" ]; then
        local current_language=$(jq -r '.language // empty' "$CONFIG_FILE" 2>/dev/null)
        if [[ -n "$current_language" && "$current_language" != "null" && "$current_language" != "empty" ]]; then
            has_language=true
        fi
    fi
    
    if [ "$has_venv" = true ] && [ "$has_language" = true ]; then
        echo "translation"
    else
        echo "normal"
    fi
}

check_monitor_status() {
    if systemctl list-unit-files | grep -q "$MONITOR_SERVICE"; then
        if systemctl is-active --quiet "$MONITOR_SERVICE"; then
            echo "active"
        else
            echo "inactive"
        fi
    else
        echo "not_installed"
    fi
}

toggle_monitor_service() {
    local status=$(check_monitor_status)
    
    if [ "$status" = "not_installed" ]; then
        dialog --clear --backtitle "ProxMenux Configuration" \
               --title "$(translate "ProxMenux Monitor")" \
               --msgbox "\n\n$(translate "ProxMenux Monitor is not installed.")" 10 50
        return
    fi
    
    if [ "$status" = "active" ]; then
        if dialog --clear --backtitle "ProxMenux Configuration" \
                  --title "$(translate "Deactivate Monitor")" \
                  --yesno "\n$(translate "Do you want to deactivate ProxMenux Monitor?")" 8 60; then
            systemctl stop "$MONITOR_SERVICE" 2>/dev/null
            systemctl disable "$MONITOR_SERVICE" 2>/dev/null
            dialog --clear --backtitle "ProxMenux Configuration" \
                   --title "$(translate "Monitor Deactivated")" \
                   --msgbox "\n\n$(translate "ProxMenux Monitor has been deactivated.")" 10 50
        fi
    else
        if dialog --clear --backtitle "ProxMenux Configuration" \
                  --title "$(translate "Activate Monitor")" \
                  --yesno "\n$(translate "Do you want to activate ProxMenux Monitor?")" 8 60; then
            systemctl enable "$MONITOR_SERVICE" 2>/dev/null
            systemctl start "$MONITOR_SERVICE" 2>/dev/null
            dialog --clear --backtitle "ProxMenux Configuration" \
                   --title "$(translate "Monitor Activated")" \
                   --msgbox "\n\n$(translate "ProxMenux Monitor has been activated.")" 10 50
        fi
    fi
}

show_monitor_status() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "ProxMenux Monitor Service Verification")"
    echo ""
    
    local status=$(check_monitor_status)
    
    if [ "$status" = "not_installed" ]; then
        msg_warn "$(translate "ProxMenux Monitor is not installed")"
        echo ""
        msg_info2 "$(translate "To install the monitor, reinstall ProxMenux with the latest version")"
    else
        msg_info2 "$(translate "Service Status"): $MONITOR_SERVICE"
        echo ""
        
        if [ "$status" = "active" ]; then
            msg_ok "$(translate "Service is active and running")"
            
            local server_ip=$(hostname -I | awk '{print $1}')
            if [ -n "$server_ip" ]; then
                echo -e "${TAB}${GN}ğŸŒ $(translate "Monitor URL")${CL}: ${BL}http://${server_ip}:8008${CL}"
            fi
        else
            msg_warn "$(translate "Service is inactive")"
        fi
        
        echo ""
        msg_info2 "$(translate "Detailed service information"):"
        echo ""
        systemctl status "$MONITOR_SERVICE" --no-pager -l
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}

# ==========================================================
show_config_menu() {
    local install_type
    install_type=$(detect_installation_type)
    
    while true; do
        local menu_options=()
        local option_actions=()
        
        local monitor_status=$(check_monitor_status)
        local option_num=1
        
        if [ "$monitor_status" != "not_installed" ]; then
            if [ "$monitor_status" = "active" ]; then
                menu_options+=("$option_num" "$(translate "Deactivate ProxMenux Monitor")")
                option_actions[$option_num]="toggle_monitor"
            else
                menu_options+=("$option_num" "$(translate "Activate ProxMenux Monitor")")
                option_actions[$option_num]="toggle_monitor"
            fi
            ((option_num++))
            
            menu_options+=("$option_num" "$(translate "Show Monitor Service Status")")
            option_actions[$option_num]="show_monitor_status"
            ((option_num++))
        fi
        
        # Build menu based on installation type
        if [ "$install_type" = "translation" ]; then
            menu_options+=("$option_num" "$(translate "Change Language")")
            option_actions[$option_num]="change_language"
            ((option_num++))
            
            menu_options+=("$option_num" "$(translate "Show Version Information")")
            option_actions[$option_num]="show_version_info"
            ((option_num++))
            
            menu_options+=("$option_num" "$(translate "Uninstall ProxMenux")")
            option_actions[$option_num]="uninstall_proxmenu"
            ((option_num++))
            
            menu_options+=("$option_num" "$(translate "Return to Main Menu")")
            option_actions[$option_num]="return_main"
        else
            # Normal version (English only)
            menu_options+=("$option_num" "Show Version Information")
            option_actions[$option_num]="show_version_info"
            ((option_num++))
            
            menu_options+=("$option_num" "Uninstall ProxMenux")
            option_actions[$option_num]="uninstall_proxmenu"
            ((option_num++))
            
            menu_options+=("$option_num" "Return to Main Menu")
            option_actions[$option_num]="return_main"
        fi
        
        # Show menu
        OPTION=$(dialog --clear --backtitle "ProxMenux Configuration" \
                        --title "$(translate "Configuration Menu")" \
                        --menu "$(translate "Select an option:")" 20 70 10 \
                        "${menu_options[@]}" 3>&1 1>&2 2>&3)
        
        # Execute selected action
        case "${option_actions[$OPTION]}" in
            "toggle_monitor")
                toggle_monitor_service
                ;;
            "show_monitor_status")
                show_monitor_status
                ;;
            "change_language")
                change_language
                ;;
            "show_version_info")
                show_version_info
                ;;
            "uninstall_proxmenu")
                uninstall_proxmenu
                ;;
            "return_main"|"")
                exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
                ;;
        esac
    done
}

# ==========================================================
change_language() {
    local new_language
    new_language=$(dialog --clear --backtitle "ProxMenux Configuration" \
                          --title "$(translate "Change Language")" \
                          --menu "$(translate "Select a new language for the menu:")" 20 60 6 \
                          "en" "$(translate "English")" \
                          "es" "$(translate "Spanish")" \
                          "fr" "$(translate "French")" \
                          "de" "$(translate "German")" \
                          "it" "$(translate "Italian")" \
                          "pt" "$(translate "Portuguese")" 3>&1 1>&2 2>&3)
    
    if [ -z "$new_language" ]; then
        dialog --clear --backtitle "ProxMenux Configuration" \
               --title "$(translate "Language Change")" \
               --msgbox "\n\n$(translate "No language selected.")" 10 50
        return
    fi
    
    # Update language in config file
    if [ -f "$CONFIG_FILE" ]; then
        tmp=$(mktemp)
        jq --arg lang "$new_language" '.language = $lang' "$CONFIG_FILE" > "$tmp" && mv "$tmp" "$CONFIG_FILE"
    else
        echo "{\"language\": \"$new_language\"}" > "$CONFIG_FILE"
    fi
    
    dialog --clear --backtitle "ProxMenux Configuration" \
           --title "$(translate "Language Change")" \
           --msgbox "\n\n$(translate "Language changed to") $new_language" 10 50
    
    # Reload menu with new language
    exec bash "$LOCAL_SCRIPTS/menus/config_menu.sh"
}

# ==========================================================
show_version_info() {
    local version info_message install_type
    install_type=$(detect_installation_type)
    
    if [ -f "$LOCAL_VERSION_FILE" ]; then
        version=$(<"$LOCAL_VERSION_FILE")
    else
        version="Unknown"
    fi
    
    info_message+="$(translate "Current ProxMenux version:") $version\n\n"
    
    # Show installation type
    info_message+="$(translate "Installation type:")\n"
    if [ "$install_type" = "translation" ]; then
        info_message+="âœ“ $(translate "Translation Version (Multi-language support)")\n"
    else
        info_message+="âœ“ $(translate "Normal Version (English only - Lightweight)")\n"
    fi
    info_message+="\n"
    
    info_message+="$(translate "Installed components:")\n"
    if [ -f "$CONFIG_FILE" ]; then
        while IFS=': ' read -r component value; do
            [ "$component" = "language" ] && continue
            local status
            if echo "$value" | jq -e '.status' >/dev/null 2>&1; then
                status=$(echo "$value" | jq -r '.status')
            else
                status="$value"
            fi
            local translated_status=$(translate "$status")
            case "$status" in
                "installed"|"already_installed"|"created"|"already_exists"|"upgraded"|"updated")
                    info_message+="âœ“ $component: $translated_status\n"
                    ;;
                *)
                    info_message+="âœ— $component: $translated_status\n"
                    ;;
            esac
        done < <(jq -r 'to_entries[] | "\(.key): \(.value)"' "$CONFIG_FILE")
    else
        info_message+="$(translate "No installation information available.")\n"
    fi
    
    info_message+="\n$(translate "ProxMenux files:")\n"
    [ -f "$INSTALL_DIR/$MENU_SCRIPT" ] && info_message+="âœ“ $MENU_SCRIPT â†’ $INSTALL_DIR/$MENU_SCRIPT\n" || info_message+="âœ— $MENU_SCRIPT\n"
    [ -f "$UTILS_FILE" ] && info_message+="âœ“ utils.sh â†’ $UTILS_FILE\n" || info_message+="âœ— utils.sh\n"
    [ -f "$CONFIG_FILE" ] && info_message+="âœ“ config.json â†’ $CONFIG_FILE\n" || info_message+="âœ— config.json\n"
    [ -f "$LOCAL_VERSION_FILE" ] && info_message+="âœ“ version.txt â†’ $LOCAL_VERSION_FILE\n" || info_message+="âœ— version.txt\n"
    
    # Show translation-specific files
    if [ "$install_type" = "translation" ]; then
        [ -f "$CACHE_FILE" ] && info_message+="âœ“ cache.json â†’ $CACHE_FILE\n" || info_message+="âœ— cache.json\n"
        
        info_message+="\n$(translate "Virtual Environment:")\n"
        if [ -d "$VENV_PATH" ] && [ -f "$VENV_PATH/bin/activate" ]; then
            info_message+="âœ“ $(translate "Installed") â†’ $VENV_PATH\n"
            [ -f "$VENV_PATH/bin/pip" ] && info_message+="âœ“ pip: $(translate "Installed") â†’ $VENV_PATH/bin/pip\n" || info_message+="âœ— pip: $(translate "Not installed")\n"
        else
            info_message+="âœ— $(translate "Virtual Environment"): $(translate "Not installed")\n"
            info_message+="âœ— pip: $(translate "Not installed")\n"
        fi
        
        current_language=$(jq -r '.language // "en"' "$CONFIG_FILE")
        info_message+="\n$(translate "Current language:")\n$current_language\n"
    else
        info_message+="\n$(translate "Language:")\nEnglish (Fixed)\n"
    fi
    
    # Display information in a scrollable text box
    tmpfile=$(mktemp)
    echo -e "$info_message" > "$tmpfile"
    dialog --clear --backtitle "ProxMenux Configuration" \
           --title "$(translate "ProxMenux Information")" \
           --textbox "$tmpfile" 25 80
    rm -f "$tmpfile"
}

# ==========================================================
uninstall_proxmenu() {
    local install_type
    install_type=$(detect_installation_type)
    
    if ! dialog --clear --backtitle "ProxMenux Configuration" \
                --title "Uninstall ProxMenux" \
                --yesno "\n$(translate "Are you sure you want to uninstall ProxMenux?")" 8 60; then
        return
    fi
    
    local deps_to_remove=""
    
    # Show different dependency options based on installation type
    if [ "$install_type" = "translation" ]; then
        deps_to_remove=$(dialog --clear --backtitle "ProxMenux Configuration" \
                               --title "Remove Dependencies" \
                               --checklist "Select dependencies to remove:" 15 60 4 \
                               "python3-venv" "Python virtual environment" OFF \
                               "python3-pip" "Python package installer" OFF \
                               "python3" "Python interpreter" OFF \
                               "jq" "JSON processor" OFF \
                               3>&1 1>&2 2>&3)
    else
        deps_to_remove=$(dialog --clear --backtitle "ProxMenux Configuration" \
                               --title "Remove Dependencies" \
                               --checklist "Select dependencies to remove:" 12 60 2 \
                               "dialog" "Interactive dialog boxes" OFF \
                               "jq" "JSON processor" OFF \
                               3>&1 1>&2 2>&3)
    fi
    
    # Perform uninstallation with progress bar
    (
        echo "10" ; echo "Removing ProxMenu files..."
        sleep 1
        
        # Remove googletrans and virtual environment if exists
        if [ -f "$VENV_PATH/bin/activate" ]; then
            echo "30" ; echo "Removing googletrans and virtual environment..."
            source "$VENV_PATH/bin/activate"
            pip uninstall -y googletrans >/dev/null 2>&1
            deactivate
            rm -rf "$VENV_PATH"
        fi
        
        echo "50" ; echo "Removing ProxMenu files..."
        rm -f "$INSTALL_DIR/$MENU_SCRIPT"
        rm -rf "$BASE_DIR"
        
        # Remove selected dependencies
        if [ -n "$deps_to_remove" ]; then
            echo "70" ; echo "Removing selected dependencies..."
            read -r -a DEPS_ARRAY <<< "$(echo "$deps_to_remove" | tr -d '"')"
            for dep in "${DEPS_ARRAY[@]}"; do
                apt-mark auto "$dep" >/dev/null 2>&1
                apt-get -y --purge autoremove "$dep" >/dev/null 2>&1
            done
            apt-get autoremove -y --purge >/dev/null 2>&1
        fi

        echo "80" ; echo "Removing ProxMenux Monitor..."
        uninstall_proxmenux_monitor
        
        echo "90" ; echo "Restoring system files..."
        # Restore .bashrc and motd
        [ -f /root/.bashrc.bak ] && mv /root/.bashrc.bak /root/.bashrc
        if [ -f /etc/motd.bak ]; then
            mv /etc/motd.bak /etc/motd
        else
            sed -i '/This system is optimised by: ProxMenux/d' /etc/motd
        fi
        
        echo "100" ; echo "Uninstallation complete!"
        sleep 1
        
    ) | dialog --clear --backtitle "ProxMenux Configuration" \
               --title "Uninstalling ProxMenux" \
               --gauge "Starting uninstallation..." 10 60 0
    
    # Show completion message
    local final_message="ProxMenux has been uninstalled successfully.\n\n"
    if [ -n "$deps_to_remove" ]; then
        final_message+="The following dependencies were removed:\n$deps_to_remove\n\n"
    fi
    final_message+="Thank you for using ProxMenux!"
    
    dialog --clear --backtitle "ProxMenux Configuration" \
           --title "Uninstallation Complete" \
           --msgbox "$final_message" 12 60
    clear    
    exit 0
}

# ==========================================================
# Main execution
show_config_menu



================================================
FILE: scripts/menus/create_vm_menu.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================



LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
VM_REPO="$LOCAL_SCRIPTS/vm"
ISO_REPO="$LOCAL_SCRIPTS/vm"
MENU_REPO="$LOCAL_SCRIPTS/menus"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

# Source utilities and required scripts
if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
else
    echo "Error: $UTILS_FILE not found"
    exit 1
fi

load_language
initialize_cache

# Source VM management scripts
[[ -f "$VM_REPO/vm_configurator.sh" ]] && source "$VM_REPO/vm_configurator.sh" || { echo "Error: vm_configurator.sh not found"; exit 1; }
[[ -f "$VM_REPO/disk_selector.sh" ]] && source "$VM_REPO/disk_selector.sh" || { echo "Error: disk_selector.sh not found"; exit 1; }
[[ -f "$VM_REPO/vm_creator.sh" ]] && source "$VM_REPO/vm_creator.sh" || { echo "Error: vm_creator.sh not found"; exit 1; }



function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}             ProxMenux VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}

# ==========================================================
# MAIN EXECUTION
# ==========================================================

#header_info
#echo -e "\n Loading..."
#sleep 1




function start_vm_configuration() {

  if (whiptail --title "ProxMenux" --yesno "$(translate "Use Default Settings?")" --no-button "$(translate "Advanced")" 10 60); then
    header_info
    load_default_vm_config "$OS_TYPE"

    if [[ -z "$HN" ]]; then
      HN=$(whiptail --inputbox "$(translate "Enter a name for the new virtual machine:")" 10 60 --title "VM Hostname" 3>&1 1>&2 2>&3)
      [[ -z "$HN" ]] && HN="custom-vm"
    fi

    apply_default_vm_config
  else
    header_info
    echo -e "${CUS}$(translate "Using advanced configuration")${CL}"
    configure_vm_advanced "$OS_TYPE"
  fi
}



while true; do
  OS_TYPE=$(dialog --backtitle "ProxMenux" \
    --title "$(translate "Select System Type")" \
    --menu "\n$(translate "Choose the type of virtual system to install:")" 20 70 10 \
    1 "$(translate "Create") VM System NAS" \
    2 "$(translate "Create") VM System Windows" \
    3 "$(translate "Create") VM System Linux" \
    4 "$(translate "Create") VM System macOS (OSX-PROXMOX)" \
    5 "$(translate "Create") VM System Others (based Linux)" \
    6 "$(translate "Return to Main Menu")" \
    3>&1 1>&2 2>&3)


  [[ $? -ne 0 || "$OS_TYPE" == "6" ]] && exec bash "$MENU_REPO/main_menu.sh"

  case "$OS_TYPE" in
    1)
      source "$ISO_REPO/select_nas_iso.sh" && select_nas_iso || continue
      ;;
    2)
      source "$ISO_REPO/select_windows_iso.sh" && select_windows_iso || continue
      ;;
    3)
      source "$ISO_REPO/select_linux_iso.sh" && select_linux_iso || continue
      ;;
    4)
      whiptail --title "OSX-PROXMOX" --yesno "$(translate "This is an external script that creates a macOS VM in Proxmox VE in just a few steps, whether you are using AMD or Intel hardware.")\n\n$(translate "The script clones the osx-proxmox.com repository and once the setup is complete, the server will automatically reboot.")\n\n$(translate "Make sure there are no critical services running as they will be interrupted. Ensure your server can be safely rebooted.")\n\n$(translate  "Visit https://osx-proxmox.com for more information.")\n\n$(translate "Do you want to run the script now?")" 24 70
      if [[ $? -eq 0 ]]; then
        bash -c "$(curl -fsSL https://install.osx-proxmox.com)"
      fi
      continue
      ;;
    5)
      source "$ISO_REPO/select_linux_iso.sh" && select_linux_other_scripts || continue
      ;;
  esac

  if ! confirm_vm_creation; then
    continue  
  fi


  start_vm_configuration || continue


  select_disk_type
  if [[ -z "$DISK_TYPE" ]]; then
    msg_error "$(translate "Disk type selection failed or cancelled")"
    continue  
  fi

  create_vm
  break
done



================================================
FILE: scripts/menus/hw_grafics_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

    while true; do
        OPTION=$(dialog --clear --backtitle "ProxMenux" --title "$(translate "GPUs and Coral-TPU Menu")" \
                        --menu "\n$(translate "Select an option:")" 20 70 8 \
                        "1" "$(translate "Add HW iGPU acceleration to an LXC")" \
                        "2" "$(translate "Add Coral TPU to an LXC")" \
                        "3" "$(translate "Install/Update Coral TPU on the Host")" \
                        "4" "$(translate "Return to Main Menu")" \
                        2>&1 >/dev/tty)

        case $OPTION in
            1)
                bash "$LOCAL_SCRIPTS/configure_igpu_lxc.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;
            2)
                bash "$LOCAL_SCRIPTS/install_coral_lxc.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;
            3)
                bash "$LOCAL_SCRIPTS/gpu_tpu/install_coral_pve9.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;
            4) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
            *) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
        esac
    done



================================================
FILE: scripts/menus/lxc_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - LXC Conversion Management Menu
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 19/08/2025
# ==========================================================
# Description:
# This script provides a menu interface for LXC container privilege conversions.
# Allows converting between privileged and unprivileged containers safely.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

show_main_menu() {
    CHOICE=$(dialog --backtitle "ProxMenux" --title "$(translate 'LXC Management')" \
        --menu "$(translate 'Select conversion option:')" 20 70 10 \
        "1" "$(translate 'Convert Privileged to Unprivileged')" \
        "2" "$(translate 'Convert Unprivileged to Privileged')" \
        "3" "$(translate 'Show Container Privilege Status')" \
        "4" "$(translate "Help & Info (commands)")" \
        "5" "$(translate 'Exit')" 3>&1 1>&2 2>&3)
    
    case $CHOICE in
        1)
            bash "$LOCAL_SCRIPTS/lxc/lxc-privileged-to-unprivileged.sh"
            ;;
        2)
            bash "$LOCAL_SCRIPTS/lxc/lxc-unprivileged-to-privileged.sh"
            ;;
        3)
            show_container_status
            ;;
        4)
            bash "$LOCAL_SCRIPTS/lxc/lxc-conversion-manual-guide.sh"
            ;;
        5)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
        *)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
    esac
}



show_container_status() {
    msg_info "$(translate 'Gathering container privilege information...')"
    

    TEMP_FILE=$(mktemp)
    
    echo "$(translate 'LXC Container Privilege Status')" > "$TEMP_FILE"
    echo "=================================" >> "$TEMP_FILE"
    echo "" >> "$TEMP_FILE"
    

    pct list | awk 'NR>1 {print $1, $3}' | while read id name; do
        if pct config "$id" | grep -q "^unprivileged: 1"; then
            status="$(translate 'Unprivileged')"
        else
            status="$(translate 'Privileged')"
        fi
        
        running_status=$(pct status "$id" | grep -q "running" && echo "$(translate 'Running')" || echo "$(translate 'Stopped')")
        
        printf "ID: %-4s | %-20s | %-12s | %s\n" "$id" "$name" "$status" "$running_status" >> "$TEMP_FILE"
    done
    
    echo "" >> "$TEMP_FILE"
    echo "$(translate 'Legend:')" >> "$TEMP_FILE"
    echo "$(translate 'Privileged: Full host access (less secure)')" >> "$TEMP_FILE"
    echo "$(translate 'Unprivileged: Limited access (more secure)')" >> "$TEMP_FILE"
    
    cleanup
    dialog --title "$(translate 'Container Status')" --textbox "$TEMP_FILE" 25 80
    

    rm -f "$TEMP_FILE"
    
  
    show_main_menu
}

show_main_menu



================================================
FILE: scripts/menus/main_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 2.0
# Last Updated: 04/04/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"


if ! command -v dialog &>/dev/null; then
    apt update -qq >/dev/null 2>&1
    apt install -y dialog >/dev/null 2>&1
fi


check_pve9_translation_compatibility() {
    local pve_version
    
    if command -v pveversion &>/dev/null; then
        pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)
    else
        return 0
    fi
    
    if [[ -n "$pve_version" ]] && [[ "$pve_version" -ge 9 ]] && [[ -d "$VENV_PATH" ]]; then
        
        local has_googletrans=false
        local has_cache=false
        
        if [[ -f "$VENV_PATH/bin/pip" ]]; then
            if "$VENV_PATH/bin/pip" list 2>/dev/null | grep -q "googletrans"; then
                has_googletrans=true
            fi
        fi
        
        if [[ -f "$BASE_DIR/cache.json" ]]; then
            has_cache=true
        fi
        
        if [[ "$has_googletrans" = true ]] || [[ "$has_cache" = true ]]; then
            
            dialog --clear \
                --backtitle "ProxMenux - Compatibility Required" \
                --title "Translation Environment Incompatible with PVE $pve_version" \
                --msgbox "NOTICE: You are running Proxmox VE $pve_version with translation components installed.\n\nTranslations are NOT supported in PVE 9+. This causes:\nâ€¢ Menu loading errors\nâ€¢ Translation failures\nâ€¢ System instability\n\nREQUIRED ACTION:\nProxMenux will now automatically reinstall the Normal Version.\n\nThis process will:\nâ€¢ Remove incompatible translation components\nâ€¢ Install PVE 9+ compatible version\nâ€¢ Preserve all your settings and preferences\n\nPress OK to continue with automatic reinstallation..." 20 75
            
            bash "$BASE_DIR/install_proxmenux.sh"

        fi
        exit 0 
    fi
}

check_pve9_translation_compatibility

# ==========================================================

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi


if [[ "$PROXMENUX_PVE9_WARNING_SHOWN" = "1" ]]; then

    if ! load_language 2>/dev/null; then
        LANGUAGE="en"
    fi

else
    load_language
    initialize_cache
fi

# ==========================================================

show_menu() {
    local TEMP_FILE
    TEMP_FILE=$(mktemp)

    while true; do

        local menu_title="Main ProxMenux"

        dialog --clear \
            --backtitle "ProxMenux" \
            --title "$(translate "$menu_title")" \
            --menu "$(translate "Select an option:")" 20 70 10 \
            1 "$(translate "Settings post-install Proxmox")" \
            2 "$(translate "Hardware: GPUs and Coral-TPU")" \
            3 "$(translate "Create VM from template or script")" \
            4 "$(translate "Disk and Storage Manager")" \
            5 "$(translate "Mount and Share Manager")" \
            6 "$(translate "Proxmox VE Helper Scripts")" \
            7 "$(translate "Network Management")" \
            8 "$(translate "Utilities and Tools")" \
            h "$(translate "Help and Info Commands")" \
            s "$(translate "Settings")" \
            0 "$(translate "Exit")" 2>"$TEMP_FILE"

        local EXIT_STATUS=$?

        if [[ $EXIT_STATUS -ne 0 ]]; then
            clear
            msg_ok "$(translate "Thank you for using ProxMenux. Goodbye!")"
            rm -f "$TEMP_FILE"
            exit 0
        fi

        OPTION=$(<"$TEMP_FILE")

        case $OPTION in
            1) exec bash "$LOCAL_SCRIPTS/menus/menu_post_install.sh" ;;
            2) exec bash "$LOCAL_SCRIPTS/menus/hw_grafics_menu.sh" ;;
            3) exec bash "$LOCAL_SCRIPTS/menus/create_vm_menu.sh" ;;
            4) exec bash "$LOCAL_SCRIPTS/menus/storage_menu.sh" ;;
            5) exec bash "$LOCAL_SCRIPTS/menus/share_menu.sh" ;;
            6) exec bash "$LOCAL_SCRIPTS/menus/menu_Helper_Scripts.sh" ;;
            7) exec bash "$LOCAL_SCRIPTS/menus/network_menu.sh" ;;
            8) exec bash "$LOCAL_SCRIPTS/menus/utilities_menu.sh" ;;
            h) bash "$LOCAL_SCRIPTS/help_info_menu.sh" ;;
            s) exec bash "$LOCAL_SCRIPTS/menus/config_menu.sh" ;;
            0) clear; msg_ok "$(translate "Thank you for using ProxMenux. Goodbye!")"; rm -f "$TEMP_FILE"; exit 0 ;;
            *) msg_warn "$(translate "Invalid option")"; sleep 2 ;;
        esac
    done
}

show_menu



================================================
FILE: scripts/menus/main_menu_.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 2.0
# Last Updated: 04/04/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache
# ==========================================================

if ! command -v dialog &>/dev/null; then
    apt update -qq >/dev/null 2>&1
    apt install -y dialog >/dev/null 2>&1
fi

show_menu() {
    local TEMP_FILE
    TEMP_FILE=$(mktemp)

    while true; do
        dialog --clear \
            --backtitle "ProxMenux" \
            --title "$(translate "Main ProxMenux")" \
            --menu "$(translate "Select an option:")" 20 70 10 \
            1 "$(translate "Settings post-install Proxmox")" \
            2 "$(translate "Help and Info Commands")" \
            3 "$(translate "Hardware: GPUs and Coral-TPU")" \
            4 "$(translate "Create VM from template or script")" \
            5 "$(translate "Disk and Storage Manager")" \
            6 "$(translate "Proxmox VE Helper Scripts")" \
            7 "$(translate "Network Management")" \
            8 "$(translate "Utilities and Tools")" \
            9 "$(translate "Settings")" \
            0 "$(translate "Exit")" 2>"$TEMP_FILE"

        local EXIT_STATUS=$?

        if [[ $EXIT_STATUS -ne 0 ]]; then
            # ESC pressed or Cancel
            clear
            msg_ok "$(translate "Thank you for using ProxMenux. Goodbye!")"
            rm -f "$TEMP_FILE"
            exit 0
        fi

        OPTION=$(<"$TEMP_FILE")

        case $OPTION in
            1) exec bash "$LOCAL_SCRIPTS/menus/menu_post_install.sh" ;;
            2) bash "$LOCAL_SCRIPTS/help_info_menu.sh" ;;
            3) exec bash "$LOCAL_SCRIPTS/menus/hw_grafics_menu.sh" ;;
            4) exec bash "$LOCAL_SCRIPTS/menus/create_vm_menu.sh" ;;
            5) exec bash "$LOCAL_SCRIPTS/menus/storage_menu.sh" ;;
            6) exec bash "$LOCAL_SCRIPTS/menus/menu_Helper_Scripts.sh" ;;
            7) exec bash "$LOCAL_SCRIPTS/menus/network_menu.sh" ;;
            8) exec bash "$LOCAL_SCRIPTS/menus/utilities_menu.sh" ;;
            9) exec bash "$LOCAL_SCRIPTS/menus/config_menu.sh" ;;
            0) clear; msg_ok "$(translate "Thank you for using ProxMenux. Goodbye!")"; rm -f "$TEMP_FILE"; exit 0 ;;
            *) msg_warn "$(translate "Invalid option")"; sleep 2 ;;
        esac
    done
}

show_menu



================================================
FILE: scripts/menus/menu_Helper_Scripts.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.2
# Last Updated: 14/11/2025
# ==========================================================
# Description:
# This script provides a simple and efficient way to access and execute Proxmox VE scripts
# from the Community Scripts project (https://community-scripts.github.io/ProxmoxVE/).
#
# It serves as a convenient tool to run key automation scripts that simplify system management,
# continuing the great work and legacy of tteck in making Proxmox VE more accessible.
# A streamlined solution for executing must-have tools in Proxmox VE.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache
# ==========================================================

HELPERS_JSON_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/json/helpers_cache.json"
METADATA_URL="https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/frontend/public/json/metadata.json"

for cmd in curl jq dialog; do
  if ! command -v "$cmd" >/dev/null; then
    echo "Missing required command: $cmd"
    exit 1
  fi
done

CACHE_JSON=$(curl -s "$HELPERS_JSON_URL")
META_JSON=$(curl -s "$METADATA_URL")

declare -A CATEGORY_NAMES
while read -r id name; do
  CATEGORY_NAMES[$id]="$name"
done < <(echo "$META_JSON" | jq -r '.categories[] | "\(.id)\t\(.name)"')

declare -A CATEGORY_COUNT
for id in $(echo "$CACHE_JSON" | jq -r '
  group_by(.slug) | map(.[0])[] | .categories[]'); do
  ((CATEGORY_COUNT[$id]++))
done

get_type_label() {
  local type="$1"
  case "$type" in
    ct) echo $'\Z1LXC\Zn' ;;
    vm) echo $'\Z4VM\Zn' ;;
    pve) echo $'\Z3PVE\Zn' ;;
    addon) echo $'\Z2ADDON\Zn' ;;
    *) echo $'\Z7GEN\Zn' ;;
  esac
}

download_script() {
  local url="$1"
  local fallback_pve="${url/misc\/tools\/pve}"
  local fallback_addon="${url/misc\/tools\/addon}"
  local fallback_copydata="${url/misc\/tools\/copy-data}"

  if curl --silent --head --fail "$url" >/dev/null; then
      bash <(curl -s "$url")
  elif curl --silent --head --fail "$fallback_pve" >/dev/null; then
      bash <(curl -s "$fallback_pve")
  elif curl --silent --head --fail "$fallback_addon" >/dev/null; then
      bash <(curl -s "$fallback_addon")
  elif curl --silent --head --fail "$fallback_copydata" >/dev/null; then
      bash <(curl -s "$fallback_copydata")
  else
      dialog --title "Helper Scripts" --msgbox "Error: Failed to download the script." 12 70
  fi
}

RETURN_TO_MAIN=false

format_credentials() {
  local script_info="$1"
  local credentials_info=""
  
  local has_credentials
  has_credentials=$(echo "$script_info" | base64 --decode | jq -r 'has("default_credentials")')
  
  if [[ "$has_credentials" == "true" ]]; then
    local username password
    username=$(echo "$script_info" | base64 --decode | jq -r '.default_credentials.username // empty')
    password=$(echo "$script_info" | base64 --decode | jq -r '.default_credentials.password // empty')
    
    if [[ -n "$username" && -n "$password" ]]; then
      credentials_info="Username: $username | Password: $password"
    elif [[ -n "$username" ]]; then
      credentials_info="Username: $username"
    elif [[ -n "$password" ]]; then
      credentials_info="Password: $password"
    fi
  fi
  
  echo "$credentials_info"
}

run_script_by_slug() {
  local slug="$1"
  local -a script_infos
  mapfile -t script_infos < <(echo "$CACHE_JSON" | jq -r --arg slug "$slug" '.[] | select(.slug == $slug) | @base64')

  if [[ ${#script_infos[@]} -eq 0 ]]; then
    dialog --title "Helper Scripts" --msgbox "Error: No script data found for slug: $slug" 8 60
    return
  fi

  decode() {
    echo "$1" | base64 --decode | jq -r "$2"
  }

  local first="${script_infos[0]}"
  local name desc notes
  name=$(decode "$first" ".name")
  desc=$(decode "$first" ".desc")
  notes=$(decode "$first" ".notes | join(\"\n\")")

  local notes_dialog=""
  if [[ -n "$notes" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      notes_dialog+="â€¢ $line\n"
    done <<< "$notes"
    notes_dialog="${notes_dialog%\\n}"
  fi

  local credentials
  credentials=$(format_credentials "$first")

  local msg="\Zb\Z4DescripciÃ³n:\Zn\n$desc"
  [[ -n "$notes_dialog" ]] && msg+="\n\n\Zb\Z4Notes:\Zn\n$notes_dialog"
  [[ -n "$credentials" ]] && msg+="\n\n\Zb\Z4Default Credentials:\Zn\n$credentials"
  
  # Add separator before menu options
  msg+="\n\n$(translate "Choose how to run the script:"):"

  declare -a MENU_OPTS=()
  local idx=0
  for s in "${script_infos[@]}"; do
    local os script_url script_url_mirror script_name
    os=$(decode "$s" ".os // empty")
    [[ -z "$os" ]] && os="$(translate "default")"
    script_name=$(decode "$s" ".name")
    script_url=$(decode "$s" ".script_url")
    script_url_mirror=$(decode "$s" ".script_url_mirror // empty")

    MENU_OPTS+=("${idx}_GH" "$os | $script_name | GitHub")

    if [[ -n "$script_url_mirror" ]]; then
      MENU_OPTS+=("${idx}_MR" "$os | $script_name | Mirror")
    fi

    ((idx++))
  done

  local choice
  choice=$(dialog --clear --colors --backtitle "ProxMenux" \
           --title "$name" \
           --menu "$msg" 28 80 6 \
           "${MENU_OPTS[@]}" 3>&1 1>&2 2>&3)

  if [[ $? -ne 0 || -z "$choice" ]]; then
    RETURN_TO_MAIN=false
    return
  fi

  local sel_idx sel_src
  IFS="_" read -r sel_idx sel_src <<< "$choice"

  local selected="${script_infos[$sel_idx]}"
  local gh_url mirror_url
  gh_url=$(decode "$selected" ".script_url")
  mirror_url=$(decode "$selected" ".script_url_mirror // empty")

  if [[ "$sel_src" == "GH" ]]; then
    download_script "$gh_url"
  elif [[ "$sel_src" == "MR" ]]; then
    if [[ -n "$mirror_url" ]]; then
      download_script "$mirror_url"
    else
      dialog --title "Helper Scripts" --msgbox "$(translate "Mirror URL not available for this script.")" 8 60
      RETURN_TO_MAIN=false
      return
    fi
  fi

  echo
  echo

  if [[ -n "$desc" || -n "$notes" || -n "$credentials" ]]; then
    echo -e "$TAB\e[1;36mScript Information:\e[0m"

    if [[ -n "$notes" ]]; then
      echo -e "$TAB\e[1;33mNotes:\e[0m"
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        echo -e "$TABâ€¢ $line"
      done <<< "$notes"
      echo
    fi

    if [[ -n "$credentials" ]]; then
      echo -e "$TAB\e[1;32mDefault Credentials:\e[0m"
      echo "$TAB$credentials"
      echo
    fi
  fi

  msg_success "Press Enter to return to the main menu..."
  read -r
  RETURN_TO_MAIN=true
}

search_and_filter_scripts() {
  local search_term=""
  
  while true; do
    search_term=$(dialog --inputbox "Enter search term (leave empty to show all scripts):" \
              8 65 "$search_term" 3>&1 1>&2 2>&3)
    
    [[ $? -ne 0 ]] && return
    
    local filtered_json
    if [[ -z "$search_term" ]]; then
      filtered_json="$CACHE_JSON"
    else
      local search_lower
      search_lower=$(echo "$search_term" | tr '[:upper:]' '[:lower:]')
      filtered_json=$(echo "$CACHE_JSON" | jq --arg term "$search_lower" '
        [.[] | select(
          (.name | ascii_downcase | contains($term)) or
          (.desc | ascii_downcase | contains($term))
        )]')
    fi
    
    local count
    count=$(echo "$filtered_json" | jq 'group_by(.slug) | length')
    
    if [[ $count -eq 0 ]]; then
      dialog --msgbox "No scripts found for: '$search_term'\n\nTry a different search term." 8 50
      continue
    fi

    while true; do
      declare -A index_to_slug
      local menu_items=()
      local i=1
      
      while IFS=$'\t' read -r slug name type; do
        index_to_slug[$i]="$slug"
        local label
        label=$(get_type_label "$type")
        local padded_name
        padded_name=$(printf "%-42s" "$name")
        local entry="$padded_name $label"
        menu_items+=("$i" "$entry")
        ((i++))
      done < <(echo "$filtered_json" | jq -r '
        group_by(.slug) | map(.[0]) | sort_by(.name)[] | [.slug, .name, .type] | @tsv')
      
      menu_items+=("" "")
      menu_items+=("new_search" "New Search")
      menu_items+=("show_all" "Show All Scripts")
      
      local title="Search Results"
      if [[ -n "$search_term" ]]; then
        title="Search Results for: '$search_term' ($count found)"
      else
        title="All Available Scripts ($count total)"
      fi
      
      local selected
      selected=$(dialog --colors --backtitle "ProxMenux" \
                 --title "$title" \
                 --menu "Select a script or action:" \
                 22 75 15 "${menu_items[@]}" 3>&1 1>&2 2>&3)
      
      if [[ $? -ne 0 ]]; then
        return
      fi
      
      case "$selected" in
        "new_search")
          break  
          ;;
        "show_all")
          search_term=""
          filtered_json="$CACHE_JSON"
          count=$(echo "$filtered_json" | jq 'group_by(.slug) | length')
          continue
          ;;
        "back"|"")
          return  
          ;;
        *)
          if [[ -n "${index_to_slug[$selected]}" ]]; then
            run_script_by_slug "${index_to_slug[$selected]}"
            [[ "$RETURN_TO_MAIN" == true ]] && { RETURN_TO_MAIN=false; return; }
          fi
          ;;
      esac
    done
  done
}

while true; do
  MENU_ITEMS=()
  
  MENU_ITEMS+=("search" "Search/Filter Scripts")
  MENU_ITEMS+=("" "")
  
  for id in $(printf "%s\n" "${!CATEGORY_COUNT[@]}" | sort -n); do
    name="${CATEGORY_NAMES[$id]:-Category $id}"
    count="${CATEGORY_COUNT[$id]}"
    padded_name=$(printf "%-35s" "$name")
    padded_count=$(printf "(%2d)" "$count")
    MENU_ITEMS+=("$id" "$padded_name $padded_count")
  done

  SELECTED=$(dialog --backtitle "ProxMenux" --title "Proxmox VE Helper-Scripts" --menu \
    "Select a category or search for scripts:" 20 70 14 \
    "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || {
     dialog --clear --title "ProxMenux" \
         --msgbox "\n\n$(translate "Visit the website to discover more scripts, stay updated with the latest updates, and support the project:")\n\nhttps://community-scripts.github.io/ProxmoxVE" 15 70
      exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
  }
 
  if [[ "$SELECTED" == "search" ]]; then
    search_and_filter_scripts
    continue
  fi

  while true; do
    declare -A INDEX_TO_SLUG
    SCRIPTS=()
    i=1
    while IFS=$'\t' read -r slug name type; do
      INDEX_TO_SLUG[$i]="$slug"
      label=$(get_type_label "$type")
      padded_name=$(printf "%-42s" "$name")
      entry="$padded_name $label"
      SCRIPTS+=("$i" "$entry") 
      ((i++))
    done < <(echo "$CACHE_JSON" | jq -r --argjson id "$SELECTED" '
      [
        .[] 
        | select(.categories | index($id)) 
        | {slug, name, type}
      ]
      | group_by(.slug)
      | map(.[0])
      | sort_by(.name)[]
      | [.slug, .name, .type]
      | @tsv')

    SCRIPT_INDEX=$(dialog --colors --backtitle "ProxMenux" --title "Scripts in ${CATEGORY_NAMES[$SELECTED]}" --menu \
      "Choose a script to execute:" 20 70 14 \
      "${SCRIPTS[@]}" 3>&1 1>&2 2>&3) || break

    SCRIPT_SELECTED="${INDEX_TO_SLUG[$SCRIPT_INDEX]}"
    run_script_by_slug "$SCRIPT_SELECTED"
    
    [[ "$RETURN_TO_MAIN" == true ]] && { RETURN_TO_MAIN=false; break; }
  done
done



================================================
FILE: scripts/menus/menu_post_install.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.2
# Last Updated: 06/07/2025
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
confirm_and_run() {
    local name="$1"
    local command="$2"
    
    dialog --clear --title "$(translate "Confirmation")" \
           --yesno "\n\n$(translate "Do you want to run the post-installation script from") $name?" 10 70
    
    response=$?
    clear
    
    if [ $response -eq 0 ]; then
        eval "$command"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r _
    else
        msg_warn "$(translate "Cancelled by user.")"
        sleep 1
    fi
}

# ==========================================================
confirm_automated_script() {
    local script_info=""


    script_info+="$(translate "This script will apply the following optimizations and advanced adjustments to your Proxmox VE server"):\n\n"
    script_info+="â€¢ $(translate "Configure") \Z4free repositories\Z0 $(translate "and upgrade the system (disables the enterprise repo)")\n"
    script_info+="â€¢ $(translate "Optionally remove") \Z4subscription banner\Z0 $(translate "from Proxmox web interface (you will be asked)")\n"
    script_info+="â€¢ $(translate "Optimize") \Z4memory\Z0, \Z4kernel\Z0, $(translate "and") \Z4network\Z0 $(translate "for better performance and stability")\n"
    script_info+="â€¢ $(translate "Install and configure") \Z4Log2RAM\Z0 $(translate "(only on SSD/NVMe) to protect your disk")\n"
    script_info+="â€¢ $(translate "Improve log rotation and limit log size to save space and extend disk life")\n"
    script_info+="â€¢ $(translate "Increase file and process limits for advanced workloads")\n"
    script_info+="â€¢ $(translate "Set up time synchronization and entropy generation")\n"
    script_info+="â€¢ $(translate "Add color prompts and useful aliases to the terminal environment")\n\n"

    script_info+="\Zb$(translate "All changes are reversible using the ProxMenux uninstaller.")\Z0\n\n"
    script_info+="$(translate "Do you want to apply these optimizations now?")"

    dialog --clear --colors \
           --backtitle "ProxMenux" \
           --title "$(translate "Automated Post-Install Script")" \
           --yesno "$script_info" 22 80

    local response=$?
    clear

    if [ $response -eq 0 ]; then
        bash "$LOCAL_SCRIPTS/post_install/auto_post_install.sh"
    else
        msg_warn "$(translate "Cancelled by user.")"
        sleep 1
    fi
}

# ==========================================================

declare -a PROXMENUX_SCRIPTS=(
    "Customizable post-installation script|ProxMenux|bash \"$LOCAL_SCRIPTS/post_install/customizable_post_install.sh\""
    "Automated post-installation script|ProxMenux|confirm_automated_script"
    "Uninstall optimizations|ProxMenux|bash \"$LOCAL_SCRIPTS/post_install/uninstall-tools.sh\""
)


declare -a COMMUNITY_SCRIPTS=(
    "Proxmox VE Post Install|Helper-Scripts|bash -c \"\$(wget -qLO - https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/post-pve-install.sh); msg_success \\\"\$(translate 'Press ENTER to continue...')\\\"; read -r _\""
    "Xshok-proxmox Post install|fork xshok-proxmox|confirm_and_run \"Xshok\" \"wget https://raw.githubusercontent.com/MacRimi/xshok-proxmox/master/install-post.sh -c -O install-post.sh && bash install-post.sh && rm install-post.sh\""
)

# ==========================================================

format_menu_item() {
    local description="$1"
    local source="$2"
    local total_width=62  
    

    local desc_length=${#description}
    local source_length=${#source}
    local spaces_needed=$((total_width - desc_length - source_length))
    

    [ $spaces_needed -lt 3 ] && spaces_needed=3
    

    local spacing=""
    for ((i=0; i<spaces_needed; i++)); do
        spacing+=" "
    done
    
    echo "${description}${spacing}${source}"
}

# ==========================================================
show_menu() {
    while true; do
        local menu_items=()
        

        declare -A script_commands
        local counter=1
        

        for script in "${PROXMENUX_SCRIPTS[@]}"; do
            IFS='|' read -r name source command <<< "$script"
            local translated_name="$(translate "$name")"
            local formatted_item
            formatted_item=$(format_menu_item "$translated_name" "$source")
            menu_items+=("$counter" "$formatted_item")
            script_commands["$counter"]="$command"
            ((counter++))
        done
        

        menu_items+=("" "")
        menu_items+=("-" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ $(translate "Community Scripts") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        menu_items+=("" "")
        

        for script in "${COMMUNITY_SCRIPTS[@]}"; do
            IFS='|' read -r name source command <<< "$script"
            local translated_name="$(translate "$name")"
            local formatted_item
            formatted_item=$(format_menu_item "$translated_name" "$source")
            menu_items+=("$counter" "$formatted_item")
            script_commands["$counter"]="$command"
            ((counter++))
        done
        

        menu_items+=("" "")
        menu_items+=("0" "$(translate "Return to Main Menu")")
        

        exec 3>&1
        script_selection=$(dialog --clear \
                                 --backtitle "ProxMenux" \
                                 --title "$(translate "Post-Installation Scripts")" \
                                 --menu "\n$(translate "Select a post-installation script:"):\n" \
                                 22 78 15 \
                                 "${menu_items[@]}" 2>&1 1>&3)
        exit_status=$?
        exec 3>&-
        

        if [ $exit_status -ne 0 ] || [ "$script_selection" = "0" ]; then
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
        fi
        

        if [[ "$script_selection" == "-" || "$script_selection" == "" ]]; then
            continue
        fi
        

        if [[ -n "${script_commands[$script_selection]}" ]]; then
            eval "${script_commands[$script_selection]}"
        else
            msg_error "$(translate "Invalid selection")"
            sleep 1
        fi
    done
}

# ==========================================================

show_menu



================================================
FILE: scripts/menus/network_menu.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Network Management and Repair Tool
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 08/07/2025
# ==========================================================

# Description:
# Advanced network management and troubleshooting tool for Proxmox VE.
# Features include interface detection, bridge management, connectivity testing,
# network diagnostics, configuration backup/restore, and automated repairs.
# Special thanks to @Andres_Eduardo_Rojas_Moya for contributing the persistent
# network naming function and for the original idea.
# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
BACKUP_DIR="/var/backups/proxmenux"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# Utility Functions
create_backup_dir() {
    [ ! -d "$BACKUP_DIR" ] && mkdir -p "$BACKUP_DIR"
}

backup_network_config() {
    create_backup_dir
    local timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
    local backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"
    cp /etc/network/interfaces "$backup_file"
    echo "$backup_file"
}
# Tool registration system
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}
# ==========================================================
# Network Detection Functions
detect_network_method() {
    # Detect Netplan
    if compgen -G "/etc/netplan/*.yaml" > /dev/null; then
        echo "netplan"
        return 0
    fi

    # Detect systemd-networkd
    if systemctl is-active --quiet systemd-networkd 2>/dev/null; then
        echo "systemd-networkd"
        return 0
    fi

    # Detect NetworkManager
    if systemctl is-active --quiet NetworkManager 2>/dev/null; then
        echo "networkmanager"
        return 0
    fi

    # Default: Debian/Proxmox classic
    echo "classic"
}

detect_physical_interfaces() {
    ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|bond|tap|tun|docker|br-)/ && $2 !~ /vmbr/ {print $2}' | sort
}

detect_bridge_interfaces() {
    ip -o link show | awk -F': ' '$2 ~ /^vmbr/ {print $2}' | sort
}

detect_all_interfaces() {
    ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|tap|tun)/ {print $2}' | sort
}

get_interface_info() {
    local interface="$1"
    local info=""
    
    # Get IP address
    local ip=$(ip -4 addr show "$interface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
    [ -z "$ip" ] && ip="$(translate "No IP")"
    
    # Get status
    local status=$(ip link show "$interface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
    [ -z "$status" ] && status="UNKNOWN"
    
    # Get MAC address
    local mac=$(ip link show "$interface" 2>/dev/null | grep -o "link/ether [a-f0-9:]*" | cut -d' ' -f2)
    [ -z "$mac" ] && mac="$(translate "No MAC")"
    
    echo "$interface|$ip|$status|$mac"
}

# ==========================================================

show_routing_table_() {
    local route_info=""
    route_info+="$(translate "Routing Table")\n"
    route_info+="$(printf '=%.0s' {1..30})\n\n"
    route_info+="$(ip route show)\n\n"
    route_info+="$(translate "Default Gateway"): $(ip route | grep default | awk '{print $3}' | head -1)\n"
    
    dialog --backtitle "ProxMenux" --title "$(translate "Routing Information")" \
           --msgbox "$route_info" 20 80
}


show_routing_table() {
    local route_info=""
    local default_gw=$(ip route | grep default | awk '{print $3}' | head -1)
    local routes=$(ip route show)
    local route_count=$(echo "$routes" | wc -l)
    
    route_info+="ğŸ—ºï¸  $(translate "Routing Table")\n"
    route_info+="$(printf 'â•%.0s' {1..60})\n\n"
    
    if [ -z "$routes" ]; then
        route_info+="âš ï¸  $(translate "No routing information found.")\n\n"
    else
        route_info+="$(translate "Total routes"): $route_count\n\n"

        while read -r line; do
            if [[ "$line" == *"default"* ]]; then
                route_info+="â¡ï¸  $line\n"
            else
                route_info+="   â€¢ $line\n"
            fi
        done <<< "$routes"
        route_info+="\n"
        route_info+="ğŸŒ $(translate "Default Gateway"): ${default_gw:-$(translate "Not found")}\n"
    fi

    dialog --backtitle "ProxMenux" --title "$(translate "Routing Information")" \
           --msgbox "$route_info" 20 80
}


# ==========================================================
# Network Testing Functions
test_connectivity() {
    local test_results=""
    local tests=(
        "8.8.8.8|Google DNS"
        "1.1.1.1|Cloudflare DNS"
        "$(ip route | grep default | awk '{print $3}' | head -1)|Gateway"
    )
    show_proxmenux_logo
    msg_info "$(translate "Test Connectivity")"
    test_results+="$(translate "Connectivity Test Results")\n"
    test_results+="$(printf '=%.0s' {1..35})\n\n"
    
    for test in "${tests[@]}"; do
        IFS='|' read -r target name <<< "$test"
        if [ -n "$target" ] && [ "$target" != "" ]; then
            if ping -c 2 -W 3 "$target" >/dev/null 2>&1; then
                test_results+="âœ“ $name ($target): $(translate "OK")\n"
            else
                test_results+="âœ— $name ($target): $(translate "FAILED")\n"
            fi
        fi
    done
    
    # DNS Resolution test
    if nslookup google.com >/dev/null 2>&1; then
        test_results+="âœ“ $(translate "DNS Resolution"): $(translate "OK")\n"
    else
        test_results+="âœ— $(translate "DNS Resolution"): $(translate "FAILED")\n"
    fi
    cleanup
    dialog --backtitle "ProxMenux" --title "$(translate "Connectivity Test")" \
           --msgbox "$test_results" 20 70
}

advanced_network_diagnostics() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    msg_info "$(translate "Advanced Diagnostics")"
    sleep 1
    
    local diag_info=""
    
    diag_info+="$(translate "Advanced Network Diagnostics")\n"
    diag_info+="$(printf '=%.0s' {1..40})\n\n"
    
    # Network statistics
    diag_info+="$(translate "Active Connections"): $(ss -tuln | wc -l)\n"
    diag_info+="$(translate "Listening Ports"): $(ss -tln | grep LISTEN | wc -l)\n"
    diag_info+="$(translate "Network Interfaces"): $(ip link show | grep -c "^[0-9]")\n\n"
    
    # Check for common issues
    diag_info+="$(translate "Common Issues Check"):\n"

    # Check if NetworkManager is running (shouldn't be on Proxmox)
    if systemctl is-active --quiet NetworkManager 2>/dev/null; then
        diag_info+="âš  $(translate "NetworkManager is running (may cause conflicts)")\n"

        if dialog --title "$(translate "NetworkManager Detected")" \
                --yesno "$(translate "NetworkManager is running, which may conflict with Proxmox.")\n\n$(translate "Do you want to disable and remove it now?")" 10 70; then

            dialog --infobox "$(translate "Disabling and removing NetworkManager...")" 6 60
            systemctl stop NetworkManager >/dev/null 2>&1
            systemctl disable NetworkManager >/dev/null 2>&1
            apt-get purge -y network-manager >/dev/null 2>&1

            diag_info+="âœ“ $(translate "NetworkManager has been removed successfully")\n"
        else
            diag_info+="â„¹ï¸  $(translate "User chose not to remove NetworkManager")\n"
        fi
    else
        diag_info+="âœ“ $(translate "NetworkManager not running")\n"
    fi

    # Check for duplicate IPs
    local ips=($(ip -4 addr show | grep -oP '(?<=inet\s)\d+(\.\d+){3}' | sort | uniq -d))
    if [ ${#ips[@]} -gt 0 ]; then
        diag_info+="âš  $(translate "Duplicate IP addresses found"): ${ips[*]}\n"
    else
        diag_info+="âœ“ $(translate "No duplicate IP addresses")\n"
    fi

    cleanup 

    dialog --backtitle "ProxMenux" --title "$(translate "Network Diagnostics")" \
           --msgbox "$diag_info" 20 70
}


# ==========================================================
# SAFE Network Analysis Functions (NO AUTO-REPAIR)
# ==========================================================

analyze_bridge_configuration() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    msg_info "$(translate "Analyzing Bridge Configuration - READ ONLY MODE")"
    sleep 1
    
    local physical_interfaces=($(detect_physical_interfaces))
    local bridges=($(detect_bridge_interfaces))
    local analysis_report=""
    local issues_found=0
    local suggestions=""
    
    analysis_report+="ğŸ” $(translate "BRIDGE CONFIGURATION ANALYSIS")\n"
    analysis_report+="$(printf '=%.0s' {1..50})\n\n"
    cleanup
    if [ ${#bridges[@]} -eq 0 ]; then
        analysis_report+="â„¹ï¸  $(translate "No bridges found in system")\n"
        dialog --backtitle "ProxMenux" --title "$(translate "Bridge Analysis")" --msgbox "$analysis_report" 10 60
        return
    fi
    
    # Analyze each bridge
    for bridge in "${bridges[@]}"; do
        analysis_report+="ğŸŒ‰ $(translate "Bridge"): $bridge\n"
        
        # Get current configuration
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        local bridge_ip=$(ip -4 addr show "$bridge" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
        local bridge_status=$(ip link show "$bridge" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
        
        analysis_report+="   ğŸ“ $(translate "Status"): ${bridge_status:-UNKNOWN}\n"
        analysis_report+="   ğŸŒ $(translate "IP"): ${bridge_ip:-$(translate "No IP assigned")}\n"
        analysis_report+="   ğŸ”Œ $(translate "Configured Ports"): ${current_ports:-$(translate "None")}\n"
        
        if [ -n "$current_ports" ]; then
            local invalid_ports=""
            local valid_ports=""
            
            # Check each configured port
            for port in $current_ports; do
                if ip link show "$port" >/dev/null 2>&1; then
                    valid_ports+="$port "
                    analysis_report+="   âœ… $(translate "Port") $port: $(translate "EXISTS")\n"
                else
                    invalid_ports+="$port "
                    analysis_report+="   âŒ $(translate "Port") $port: $(translate "NOT FOUND")\n"
                    ((issues_found++))
                fi
            done
            
            # Generate suggestions for invalid ports
            if [ -n "$invalid_ports" ]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $bridge:\n"
                if [ ${#physical_interfaces[@]} -gt 0 ]; then
                    suggestions+="   $(translate "Replace invalid port(s)") '$invalid_ports' $(translate "with"): ${physical_interfaces[0]}\n"
                    suggestions+="   $(translate "Command"): sed -i 's/bridge-ports.*/bridge-ports ${physical_interfaces[0]}/' /etc/network/interfaces\n"
                else
                    suggestions+="   $(translate "Remove invalid port(s)") '$invalid_ports'\n"
                    suggestions+="   $(translate "Command"): sed -i 's/bridge-ports.*/bridge-ports none/' /etc/network/interfaces\n"
                fi
                suggestions+="\n"
            fi
        else
            analysis_report+="   âš ï¸  $(translate "No ports configured")\n"
            if [ ${#physical_interfaces[@]} -gt 0 ]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $bridge:\n"
                suggestions+="   $(translate "Consider adding physical interface"): ${physical_interfaces[0]}\n"
                suggestions+="   $(translate "Command"): sed -i '/iface $bridge/a\\    bridge-ports ${physical_interfaces[0]}' /etc/network/interfaces\n\n"
            fi
        fi
        analysis_report+="\n"
    done
    
    # Summary
    analysis_report+="ğŸ“Š $(translate "ANALYSIS SUMMARY")\n"
    analysis_report+="$(printf '=%.0s' {1..25})\n"
    analysis_report+="$(translate "Bridges analyzed"): ${#bridges[@]}\n"
    analysis_report+="$(translate "Issues found"): $issues_found\n"


    local auto_only=$(grep "^auto" /etc/network/interfaces | awk '{print $2}' | while read i; do
        grep -q "^iface $i" /etc/network/interfaces || echo "$i"
    done)

    if [ -n "$auto_only" ]; then
        analysis_report+="âš ï¸  $(translate "Interfaces defined with 'auto' but no 'iface' block"): $auto_only\n"
        ((issues_found++))
    fi

    analysis_report+="$(translate "Physical interfaces available"): ${#physical_interfaces[@]}\n\n"
    
    if [ $issues_found -gt 0 ]; then
        analysis_report+="$suggestions"
        analysis_report+="âš ï¸  $(translate "IMPORTANT"): $(translate "No changes have been made to your system")\n"
        analysis_report+="$(translate "Use the Guided Repair option to fix issues safely")\n"
    else
        analysis_report+="âœ… $(translate "No bridge configuration issues found")\n"
    fi
    
    # Show analysis in scrollable dialog
    local temp_file=$(mktemp)
    echo -e "$analysis_report" > "$temp_file"
    dialog --backtitle "ProxMenux" --title "$(translate "Bridge Configuration Analysis")" \
           --textbox "$temp_file" 25 80
    rm -f "$temp_file"
   

    # Offer guided repair if issues found
    if [ $issues_found -gt 0 ]; then
        if dialog --backtitle "ProxMenux" --title "$(translate "Guided Repair Available")" \
                  --yesno "$(translate "Issues were found. Would you like to use the Guided Repair Assistant?")" 8 60; then
            guided_bridge_repair
        fi
    fi
}


guided_bridge_repair() {
    local step=1
    local total_steps=5


    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local preview_backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"


    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Safety Backup")" \
                --yesno "$(translate "Before making any changes, we'll create a safety backup.")\n\n$(translate "Backup location"): $preview_backup_file\n\n$(translate "Continue?")" 12 70; then
        return
    fi
    ((step++))

    
    show_proxmenux_logo
    local backup_file=$(backup_network_config)
    msg_ok "$(translate "Network configuration backed up")"
    sleep 2

    dialog --backtitle "ProxMenux" --title "$(translate "Backup Created")" \
           --msgbox "$(translate "Safety backup created"): $backup_file\n\n$(translate "You can restore it anytime with"):\ncp $backup_file /etc/network/interfaces" 10 70
    
    # Step 2: Show current configuration
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Current Configuration")" \
                --yesno "$(translate "Let's review your current network configuration.")\n\n$(translate "Would you like to see the current") /etc/network/interfaces $(translate "file?")" 10 70; then
        return
    fi
    ((step++))
    
    # Show current config
    local temp_config=$(mktemp)
    cat /etc/network/interfaces > "$temp_config"
    dialog --backtitle "ProxMenux" --title "$(translate "Current Network Configuration")" \
           --textbox "$temp_config" 20 80
    rm -f "$temp_config"
    
    # Step 3: Identify specific changes needed
    local physical_interfaces=($(detect_physical_interfaces))
    local bridges=($(detect_bridge_interfaces))
    local changes_needed=""
    
    for bridge in "${bridges[@]}"; do
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        
        if [ -n "$current_ports" ]; then
            for port in $current_ports; do
                if ! ip link show "$port" >/dev/null 2>&1; then
                    if [ ${#physical_interfaces[@]} -gt 0 ]; then
                        changes_needed+="$(translate "Bridge") $bridge: $(translate "Replace") '$port' $(translate "with") '${physical_interfaces[0]}'\n"
                    else
                        changes_needed+="$(translate "Bridge") $bridge: $(translate "Remove invalid port") '$port'\n"
                    fi
                fi
            done
        fi
    done
    
    if [ -z "$changes_needed" ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Changes Needed")" \
               --msgbox "$(translate "After detailed analysis, no changes are needed.")" 8 50
        return
    fi
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Proposed Changes")" \
                --yesno "$(translate "These are the changes that will be made"):\n\n$changes_needed\n$(translate "Do you want to proceed?")" 15 70; then
        return
    fi
    ((step++))
    
    # Step 4: Apply changes with verification
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Applying Changes")" \
           --infobox "$(translate "Applying changes safely...")\n\n$(translate "This may take a few seconds...")" 8 50
    
    # Apply the changes
    for bridge in "${bridges[@]}"; do
        local current_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        
        if [ -n "$current_ports" ]; then
            local new_ports=""
            for port in $current_ports; do
                if ip link show "$port" >/dev/null 2>&1; then
                    new_ports+="$port "
                fi
            done
            
            # If no valid ports and we have physical interfaces, use the first one
            if [ -z "$new_ports" ] && [ ${#physical_interfaces[@]} -gt 0 ]; then
                new_ports="${physical_interfaces[0]}"
            fi
            
            # Apply the change
            if [ "$new_ports" != "$current_ports" ]; then
                sed -i "/iface $bridge/,/bridge-ports/ s/bridge-ports.*/bridge-ports $new_ports/" /etc/network/interfaces
            fi
        fi
    done
    ((step++))
    
    # Step 5: Verification
    local verification_report=""
    verification_report+="âœ… $(translate "CHANGES APPLIED SUCCESSFULLY")\n\n"
    verification_report+="$(translate "Verification"):\n"
    
    for bridge in "${bridges[@]}"; do
        local new_ports=$(grep -A5 "iface $bridge" /etc/network/interfaces 2>/dev/null | grep "bridge-ports" | cut -d' ' -f2-)
        verification_report+="$(translate "Bridge") $bridge: $new_ports\n"
        
        # Verify each port exists
        for port in $new_ports; do
            if ip link show "$port" >/dev/null 2>&1; then
                verification_report+="  âœ… $port: $(translate "EXISTS")\n"
            else
                verification_report+="  âŒ $port: $(translate "NOT FOUND")\n"
            fi
        done
    done
    
    verification_report+="\n$(translate "Backup available at"): $backup_file\n"
    verification_report+="$(translate "To restore"): cp $backup_file /etc/network/interfaces"
    
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Repair Complete")" \
           --msgbox "$verification_report" 18 70
    
    # Ask about network restart
    if dialog --backtitle "ProxMenux" --title "$(translate "Network Restart")" \
              --yesno "$(translate "Changes have been applied to the configuration file.")\n\n$(translate "Do you want to restart the network service to apply changes?")\n\n$(translate "WARNING: This may cause a brief disconnection.")" 12 70; then
        
        clear
        msg_info "$(translate "Restarting network service...")"
        
        if systemctl restart networking; then
            msg_ok "$(translate "Network service restarted successfully")"
        else
            msg_error "$(translate "Failed to restart network service")"
            msg_warn "$(translate "You can restore the backup with"): cp $backup_file /etc/network/interfaces"
        fi
        
        msg_success "$(translate "Press ENTER to continue...")"
        read -r
    fi
}


# ==========================================================




analyze_network_configuration() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    msg_info "$(translate "Analyzing Network Configuration - READ ONLY MODE")"
    sleep 1
    
    local configured_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    local analysis_report=""
    local issues_found=0
    local suggestions=""
    
    analysis_report+="ğŸ” $(translate "NETWORK CONFIGURATION ANALYSIS")\n"
    analysis_report+="$(printf '=%.0s' {1..50})\n\n"
    
    cleanup
    if [ ${#configured_interfaces[@]} -eq 0 ]; then
        analysis_report+="â„¹ï¸  $(translate "No network interfaces configured (besides loopback)")\n"
        dialog --title "$(translate "Configuration Analysis")" --msgbox "$analysis_report" 10 60
        return
    fi
    
    analysis_report+="ğŸ“‹ $(translate "CONFIGURED INTERFACES")\n"
    analysis_report+="$(printf '=%.0s' {1..30})\n"
    
    # Analyze each configured interface
    for iface in "${configured_interfaces[@]}"; do
        analysis_report+="ğŸ”Œ $(translate "Interface"): $iface\n"
        
        # Check if interface exists physically
        if ip link show "$iface" >/dev/null 2>&1; then
            local status=$(ip link show "$iface" 2>/dev/null | grep -o "state [A-Z]*" | cut -d' ' -f2)
            local ip=$(ip -4 addr show "$iface" 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}/\d+' | head -1)
            
            analysis_report+="   âœ… $(translate "Status"): $(translate "EXISTS") ($status)\n"
            analysis_report+="   ğŸŒ $(translate "IP"): ${ip:-$(translate "No IP assigned")}\n"
            
            # Check if it's a bridge or bond (these are virtual, so it's normal they exist)
            if [[ $iface =~ ^(vmbr|bond) ]]; then
                analysis_report+="   â„¹ï¸  $(translate "Type"): $(translate "Virtual interface (normal)")\n"
            else
                analysis_report+="   â„¹ï¸  $(translate "Type"): $(translate "Physical interface")\n"
            fi
        else
            analysis_report+="   âŒ $(translate "Status"): $(translate "NOT FOUND")\n"
            analysis_report+="   âš ï¸  $(translate "Issue"): $(translate "Configured but doesn't exist")\n"
            ((issues_found++))
            
            # Only suggest removal for non-virtual interfaces
            if [[ ! $iface =~ ^(vmbr|bond) ]]; then
                suggestions+="ğŸ”§ $(translate "SUGGESTION FOR") $iface:\n"
                suggestions+="   $(translate "This interface is configured but doesn't exist physically")\n"
                suggestions+="   $(translate "Consider removing its configuration")\n"
                suggestions+="   $(translate "Command"): sed -i '/iface $iface/,/^$/d' /etc/network/interfaces\n\n"
            fi
        fi
        analysis_report+="\n"
    done
    
    # Summary
    analysis_report+="ğŸ“Š $(translate "ANALYSIS SUMMARY")\n"
    analysis_report+="$(printf '=%.0s' {1..25})\n"
    analysis_report+="$(translate "Interfaces configured"): ${#configured_interfaces[@]}\n"
    analysis_report+="$(translate "Issues found"): $issues_found\n\n"
    
    if [ $issues_found -gt 0 ]; then
        analysis_report+="$suggestions"
        analysis_report+="âš ï¸  $(translate "IMPORTANT"): $(translate "No changes have been made to your system")\n"
        analysis_report+="$(translate "Use the Guided Cleanup option to fix issues safely")\n"
    else
        analysis_report+="âœ… $(translate "No configuration issues found")\n"
    fi
    
    # Show analysis in scrollable dialog
    local temp_file=$(mktemp)
    echo -e "$analysis_report" > "$temp_file"
    dialog --backtitle "ProxMenux" --title "$(translate "Network Configuration Analysis")" \
           --textbox "$temp_file" 25 80
    rm -f "$temp_file"
    
    # Offer guided cleanup if issues found
    if [ $issues_found -gt 0 ]; then
        if dialog --backtitle "ProxMenux" --title "$(translate "Guided Cleanup Available")" \
                  --yesno "$(translate "Issues were found. Would you like to use the Guided Cleanup Assistant?")" 8 60; then
            guided_configuration_cleanup
        fi
    fi
}

guided_configuration_cleanup() {
    local step=1
    local total_steps=5

    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local preview_backup_file="$BACKUP_DIR/interfaces_backup_$timestamp"


    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Safety Backup")" \
                --yesno "$(translate "Before making any changes, we'll create a safety backup.")\n\n$(translate "Backup location"): $preview_backup_file\n\n$(translate "Continue?")" 12 70; then
        return
    fi
    ((step++))

    
    show_proxmenux_logo
    local backup_file=$(backup_network_config)
    msg_ok "$(translate "Network configuration backed up")"
    sleep 2
    
    dialog --backtitle "ProxMenux" --title "$(translate "Backup Created")" \
           --msgbox "$(translate "Safety backup created"): $backup_file\n\n$(translate "You can restore it anytime with"):\ncp $backup_file /etc/network/interfaces" 10 70
    
    # Step 2: Identify interfaces to remove
    local configured_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    local interfaces_to_remove=""
    local removal_list=""
    
    for iface in "${configured_interfaces[@]}"; do
        if [[ ! $iface =~ ^(vmbr|bond) ]] && ! ip link show "$iface" >/dev/null 2>&1; then
            interfaces_to_remove+="$iface "
            removal_list+="âŒ $iface: $(translate "Configured but doesn't exist")\n"
        fi
    done
    
    if [ -z "$interfaces_to_remove" ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Cleanup Needed")" \
               --msgbox "$(translate "After detailed analysis, no cleanup is needed.")" 8 50
        return
    fi
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Interfaces to Remove")" \
                --yesno "$(translate "These interface configurations will be removed"):\n\n$removal_list\n$(translate "Do you want to proceed?")" 15 70; then
        return
    fi
    ((step++))
    
    # Step 3: Show what will be removed
    local temp_preview=$(mktemp)
    echo "$(translate "Configuration sections that will be REMOVED"):" > "$temp_preview"
    echo "=================================================" >> "$temp_preview"
    echo "" >> "$temp_preview"
    
    for iface in $interfaces_to_remove; do
        echo "# Interface: $iface" >> "$temp_preview"
        sed -n "/^iface $iface/,/^$/p" /etc/network/interfaces >> "$temp_preview"
        echo "" >> "$temp_preview"
    done
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Preview Changes")" \
                --yesno "$(translate "Review what will be removed"):\n\n$(translate "Press OK to see the preview, then confirm")" 10 60; then
        rm -f "$temp_preview"
        return
    fi
    
    dialog --backtitle "ProxMenux" --title "$(translate "Configuration to be Removed")" \
           --textbox "$temp_preview" 20 80
    rm -f "$temp_preview"
    
    if ! dialog --backtitle "ProxMenux" --title "$(translate "Final Confirmation")" \
                --yesno "$(translate "Are you sure you want to remove these configurations?")" 8 60; then
        return
    fi
    ((step++))
    
    # Step 4: Apply changes
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Applying Changes")" \
           --infobox "$(translate "Removing invalid configurations...")\n\n$(translate "This may take a few seconds...")" 8 50
    
    for iface in $interfaces_to_remove; do
        sed -i "/^iface $iface/,/^$/d" /etc/network/interfaces
    done
    ((step++))
    
    # Step 5: Verification
    local verification_report=""
    verification_report+="âœ… $(translate "CLEANUP COMPLETED SUCCESSFULLY")\n\n"
    verification_report+="$(translate "Removed configurations for"):\n"
    
    for iface in $interfaces_to_remove; do
        verification_report+="âŒ $iface\n"
    done
    
    verification_report+="\n$(translate "Verification"): $(translate "Checking remaining interfaces")\n"
    local remaining_interfaces=($(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo"))
    
    for iface in "${remaining_interfaces[@]}"; do
        if ip link show "$iface" >/dev/null 2>&1; then
            verification_report+="âœ… $iface: $(translate "OK")\n"
        else
            verification_report+="âš ï¸  $iface: $(translate "Still has issues")\n"
        fi
    done
    
    verification_report+="\n$(translate "Backup available at"): $backup_file\n"
    verification_report+="$(translate "To restore"): cp $backup_file /etc/network/interfaces"
    
    dialog --backtitle "ProxMenux" --title "$(translate "Step") $step/$total_steps: $(translate "Cleanup Complete")" \
           --msgbox "$verification_report" 18 70
}


# ==========================================================



setup_persistent_network() {
    local LINK_DIR="/etc/systemd/network"
    local BACKUP_DIR="/etc/systemd/network/backup-$(date +%Y%m%d-%H%M%S)"
    
    if ! dialog --title "$(translate "Network Interface Setup")" \
         --yesno "\n$(translate "Create persistent network interface names?")" 8 60; then
        return 1
    fi
    show_proxmenux_logo    
    msg_info "$(translate "Setting up persistent network interfaces")"
    sleep 2
    # Create directory
    mkdir -p "$LINK_DIR"
    
    # Backup existing files
    if ls "$LINK_DIR"/*.link >/dev/null 2>&1; then
        mkdir -p "$BACKUP_DIR"
        cp "$LINK_DIR"/*.link "$BACKUP_DIR"/ 2>/dev/null || true
    fi
    
    # Process physical interfaces
    local count=0
    for iface in $(ls /sys/class/net/ | grep -vE "lo|docker|veth|br-|vmbr|tap|fwpr|fwln|virbr|bond|cilium|zt|wg"); do
        if [[ -e "/sys/class/net/$iface/device" ]] || [[ -e "/sys/class/net/$iface/phy80211" ]]; then
            local MAC=$(cat /sys/class/net/$iface/address 2>/dev/null)
            
            if [[ "$MAC" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]]; then
                local LINK_FILE="$LINK_DIR/10-$iface.link"
                
                cat > "$LINK_FILE" <<EOF
[Match]
MACAddress=$MAC

[Link]
Name=$iface
EOF
                chmod 644 "$LINK_FILE"
                ((count++))
            fi
        fi
    done
    
    if [[ $count -gt 0 ]]; then
        msg_ok "$(translate "Created persistent names for") $count $(translate "interfaces")"
        msg_ok "$(translate "Changes will apply after reboot.")"
    else
        msg_warn "$(translate "No physical interfaces found")"
    fi
        register_tool "persistent_network" true
        echo -e
        msg_success "$(translate "Press ENTER to continue...")"
        read -r
}



# ==========================================================


restart_network_service() {
    if dialog --title "$(translate "Restart Network")" \
              --yesno "\n$(translate "This will restart the network service and may cause a brief disconnection. Continue?")" 10 60; then

        show_proxmenux_logo
        msg_info "$(translate "Restarting network service...")"

        if systemctl restart networking; then
            msg_ok "$(translate "Network service restarted successfully")"
        else
            msg_error "$(translate "Failed to restart network service")"
            msg_warn "$(translate "If you lose connectivity, you can restore from backup using the console.")"
        fi

        msg_success "$(translate "Press ENTER to continue...")"
        read -r
    fi
}



# ==========================================================
# Configuration Management
show_network_config() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    local config_content
    config_content=$(cat /etc/network/interfaces)
    show_proxmenux_logo
    echo -e
    echo -e
    echo "========== $(translate "Network Configuration File") =========="
    echo
    cat /etc/network/interfaces
    echo
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}


create_network_backup_manual() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    show_proxmenux_logo
    echo -e
    msg_info "$(translate "Creating backup of network interfaces configuration...")"
    sleep 3
    cleanup
    backup_network_config
    msg_ok "$(translate "Network configuration backed up")"
    echo -e
    msg_success "$(translate "Press Enter to continue...")"
    read -r

}



restore_network_backup() {

    NETWORK_METHOD=$(detect_network_method)

    if [[ "$NETWORK_METHOD" != "classic" ]]; then
        dialog --title "Unsupported Network Stack" \
            --msgbox "WARNING: This script only supports the classic Debian/Proxmox network configuration (/etc/network/interfaces).\n\nDetected: $NETWORK_METHOD.\n\nAborting for safety.\n\nPlease configure your network using your distribution's supported tools." 14 70
        exit 1
    fi

    local backups=($(ls -1 "$BACKUP_DIR"/interfaces_backup_* 2>/dev/null | sort -r))
    
    if [ ${#backups[@]} -eq 0 ]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Backups")" \
               --msgbox "\n$(translate "No network configuration backups found.")" 14 60
        return
    fi

    local menu_items=()
    local counter=1

    for backup in "${backups[@]}"; do
        local filename=$(basename "$backup")
        local timestamp=$(basename "$backup" | sed 's/interfaces_backup_//')
        menu_items+=("$counter" "$timestamp")
        ((counter++))
    done

    local selection=$(dialog --backtitle "ProxMenux" --title "$(translate "Restore Backup")" \
                            --menu "$(translate "Select backup to restore:"):" 20 70 12 \
                            "${menu_items[@]}" 3>&1 1>&2 2>&3)

    if [ -n "$selection" ] && [ "$selection" -ge 1 ] && [ "$selection" -le ${#backups[@]} ]; then
        local selected_backup="${backups[$((selection-1))]}"


        if dialog --backtitle "ProxMenux" --title "$(translate "Preview Backup")" \
                  --yesno "\n$(translate "Do you want to view the selected backup before restoring?")" 8 60; then
            dialog --backtitle "ProxMenux" --title "$(translate "Backup Preview")" \
                   --textbox "$selected_backup" 22 80
        fi

        if dialog --backtitle "ProxMenux" --title "$(translate "Confirm Restore")" \
            --yesno "\n$(translate "Are you sure you want to restore this backup?\nCurrent configuration will be overwritten.")\n\n$(translate "For your safety, a backup of the current configuration will be created automatically before restoring.")" 14 70; then

            local pre_restore_backup=$(backup_network_config)
            cp "$selected_backup" /etc/network/interfaces


            dialog --backtitle "ProxMenux" --title "$(translate "Backup Restored")" \
                   --msgbox "\n$(translate "Network configuration has been restored from backup.")" 8 60


            if dialog --backtitle "ProxMenux" --title "$(translate "Restart Network")" \
                      --yesno "\n$(translate "Do you want to restart the network service now to apply changes?")" 8 60; then
                if systemctl restart networking; then
                    dialog --backtitle "ProxMenux" --title "$(translate "Network Restarted")" \
                           --msgbox "\n$(translate "Network service restarted successfully.")" 8 50
                fi
            fi
        fi
    fi
}


launch_iftop() {
    if ! command -v iftop &>/dev/null; then
        apt-get update -qq && apt-get install -y iftop &>/dev/null
    fi

    dialog --backtitle "ProxMenux" --title "$(translate "iftop usage")" --msgbox "\n$(translate "To exit iftop, press q")" 8 50
    clear
    iftop
}

launch_iptraf() {
    if ! command -v iptraf-ng &>/dev/null; then
        apt-get update -qq && apt-get install -y iptraf-ng &>/dev/null
    fi

    dialog --backtitle "ProxMenux" --title "$(translate "iptraf-ng usage")" --msgbox "\n$(translate "To exit iptraf-ng, press x")" 8 50
    clear
    iptraf-ng
}


# ==========================================================


confirm_and_run() {
    local name="$1"
    local command="$2"
    
    dialog --clear --title "$(translate "Confirmation")" \
           --yesno "\n\n$(translate "Do you want to run the network script from") $name?" 10 70
    
    response=$?
    clear
    
    if [ $response -eq 0 ]; then
        eval "$command"
        echo
        msg_success "$(translate 'Press ENTER to continue...')"
        read -r _
    else
        msg_warn "$(translate "Cancelled by user.")"
        sleep 1
    fi
}

# ==========================================================

declare -a PROXMENUX_SCRIPTS=(
    "Real-time network usage (iftop)||launch_iftop"
    "Network monitoring tool (iptraf-ng)||launch_iptraf"
    "Show Routing Table||show_routing_table"
    "Test Connectivity||test_connectivity"
    "Advanced Diagnostics||advanced_network_diagnostics"
    "Analyze Bridge Configuration||analyze_bridge_configuration"
    "Analyze Network Configuration||analyze_network_configuration"
    "Setup Persistent Network Names||setup_persistent_network"
    "Restart Network Service||restart_network_service"
    "Show Network Config File||show_network_config"
    "Create Network Backup||create_network_backup_manual"
    "Restore Network Backup||restore_network_backup"
)



declare -a COMMUNITY_SCRIPTS=(
    "Disable NIC Offloading (Intel e1000e)|Helper-Scripts|confirm_and_run \"Helper-Scripts\" \"bash <(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/tools/pve/nic-offloading-fix.sh)\""
)

# ==========================================================
format_menu_item() {
    local description="$1"
    local source="$2"
    local total_width=62  
    

    local desc_length=${#description}
    local source_length=${#source}
    local spaces_needed=$((total_width - desc_length - source_length))
    

    [ $spaces_needed -lt 3 ] && spaces_needed=3
    

    local spacing=""
    for ((i=0; i<spaces_needed; i++)); do
        spacing+=" "
    done
    
    echo "${description}${spacing}${source}"
}

# ==========================================================
show_menu() {
    while true; do
        local menu_items=()
        

        declare -A script_commands
        local counter=1

        for script in "${PROXMENUX_SCRIPTS[@]}"; do
            IFS='|' read -r name source command <<< "$script"
            local translated_name="$(translate "$name")"
            local formatted_item
            formatted_item=$(format_menu_item "$translated_name" "$source")
            menu_items+=("$counter" "$formatted_item")
            script_commands["$counter"]="$command"
            ((counter++))
        done
        

        menu_items+=("" "")
        menu_items+=("-" "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ $(translate "Community Scripts") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        menu_items+=("" "")
        

        for script in "${COMMUNITY_SCRIPTS[@]}"; do
            IFS='|' read -r name source command <<< "$script"
            local translated_name="$(translate "$name")"
            local formatted_item
            formatted_item=$(format_menu_item "$translated_name" "$source")
            menu_items+=("$counter" "$formatted_item")
            script_commands["$counter"]="$command"
            ((counter++))
        done
        

        menu_items+=("" "")
        menu_items+=("0" "$(translate "Return to Main Menu")")
        

        exec 3>&1
        script_selection=$(dialog --clear \
                                 --backtitle "ProxMenux" \
                                 --title "$(translate "Network Management")" \
                                 --menu "\n$(translate "Select a network management option:"):\n" \
                                 26 78 19 \
                                 "${menu_items[@]}" 2>&1 1>&3)
        exit_status=$?
        exec 3>&-
        

        if [ $exit_status -ne 0 ] || [ "$script_selection" = "0" ]; then
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
        fi
        

        if [[ "$script_selection" == "-" || "$script_selection" == "" ]]; then
            continue
        fi
        

        if [[ -n "${script_commands[$script_selection]}" ]]; then
            eval "${script_commands[$script_selection]}"
        else
            msg_error "$(translate "Invalid selection")"
            sleep 1
        fi
    done
}

# ==========================================================

show_menu



================================================
FILE: scripts/menus/share_menu.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Network Storage Manager Menu
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 1.2
# Last Updated: $(date +%d/%m/%Y)
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

while true; do
    OPTION=$(dialog --colors --backtitle "ProxMenux" \
        --title "$(translate "Mount and Share Manager")" \
        --menu "\n$(translate "Select an option:")" 25 80 15 \
            "" "\Z4â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ $(translate "HOST") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\Zn" \
            "1"         "$(translate "Configure NFS shared   on Host")" \
            "2"         "$(translate "Configure Samba shared on Host")" \
            "3"         "$(translate "Configure Local Shared on Host")" \
            ""  "\Z4â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ $(translate "LXC") â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\Zn" \
            "4"         "$(translate "Configure LXC Mount Points    (Host â†” Container)")" \
            ""          "" \
            "5"         "$(translate "Configure NFS Client in LXC   (only privileged)")" \
            "6"         "$(translate "Configure Samba Client in LXC (only privileged)")" \
            "7"         "$(translate "Configure NFS Server in LXC   (only privileged)")" \
            "8"         "$(translate "configure Samba Server in LXC (only privileged)")" \
            ""          "" \
            "h"         "$(translate "Help & Info (commands)")" \
            "0"         "$(translate "Return to Main Menu")" \
            2>&1 >/dev/tty
    ) || { exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"; }

    case "$OPTION" in

        lxctitle|hosttitle)
            continue
            ;;

        1)
            bash "$LOCAL_SCRIPTS/share/nfs_host.sh"
            ;;
        2)
            bash "$LOCAL_SCRIPTS/share/samba_host.sh"
            ;;
        3)
            bash "$LOCAL_SCRIPTS/share/local-shared-manager.sh"
            ;;    
        4)
            bash "$LOCAL_SCRIPTS/share/lxc-mount-manager_minimal.sh"
            ;;
        5)
            bash "$LOCAL_SCRIPTS/share/nfs_client.sh"
            ;;    
        6) 
            bash "$LOCAL_SCRIPTS/share/samba_client.sh"
            ;;
        7)
            bash "$LOCAL_SCRIPTS/share/nfs_lxc_server.sh"
            ;;
        8)
            bash "$LOCAL_SCRIPTS/share/samba_lxc_server.sh"
            ;;
        h)
            bash "$LOCAL_SCRIPTS/share/commands_share.sh"
            ;;
        0)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
        *)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
    esac
done



================================================
FILE: scripts/menus/sm.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


while true; do
    OPTION=$(whiptail --title "$(translate "Disk and Storage Manager Menu")" --menu "$(translate "Select an option:")" 20 70 10 \
        "1" "$(translate "Add Disk Passthrough to a VM")" \
        "2" "$(translate "Add Disk") Passthrough $(translate "to a CT")" \
        "3" "$(translate "Import Disk Image to a VM")" \
        "4" "$(translate "Mount point to CT")" \
        "5" "$(translate "Mount disk on HOST")" \
        "6" "$(translate "Unmount disk from HOST")" \
        "7" "$(translate "Format disk")" \
        "8" "$(translate "Return to Main Menu")" 3>&1 1>&2 2>&3)

    case $OPTION in
        1)
            msg_info2 "$(translate "Running script: Add Disk Passthrough to a VM")..."
            bash "$LOCAL_SCRIPTS/storage/disk-passthrough.sh"
            ;;
        2)
            msg_info2 "$(translate "Running script: Add Disk Passthrough to a CT")..."
            bash "$LOCAL_SCRIPTS/storage/disk-passthrough_ct.sh"
            ;;
        3)
            msg_info2 "$(translate "Running script: Import Disk Image to a VM")..."
            bash "$LOCAL_SCRIPTS/storage/import-disk-image.sh"
            ;;
        4)
            msg_info2 "$(translate "Running script: Mount point to CT")..."
            bash "$LOCAL_SCRIPTS/storage/mount-point-to-ct.sh"
            ;;
        5)
            msg_info2 "$(translate "Running script: Mount disk on HOST")..."
            bash "$LOCAL_SCRIPTS/storage/mount-disk-on-host.sh"
            ;;
        6)
            msg_info2 "$(translate "Running script: Unmount disk from HOST")..."
            bash "$LOCAL_SCRIPTS/storage/unmount-disk-from-host.sh"
            ;;
        7)
            msg_info2 "$(translate "Running script: Format disk")..."
            bash "$LOCAL_SCRIPTS/storage/format-disk.sh"
            ;;
        8)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
        *)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
    esac
done



================================================
FILE: scripts/menus/storage_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 15/04/2025
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================


while true; do
    OPTION=$(dialog --clear --backtitle "ProxMenux" --title "$(translate "Disk and Storage Manager Menu")" \
                    --menu "\n$(translate "Select an option:")" 20 70 10 \
                    "1" "$(translate "Add Disk") Passthrough $(translate "to a VM")" \
                    "2" "$(translate "Add Disk") Passthrough $(translate "to a LXC")" \
                    "3" "$(translate "Import Disk Image to a VM")" \
                    "4" "$(translate "Return to Main Menu")" \
                    2>&1 >/dev/tty) 

    case $OPTION in
        1)  
            bash "$LOCAL_SCRIPTS/storage/disk-passthrough.sh"
            ;;
        2)
            bash "$LOCAL_SCRIPTS/storage/disk-passthrough_ct.sh"
            ;;
        3)
            bash "$LOCAL_SCRIPTS/storage/import-disk-image.sh"
            ;;
        4)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
        *)
            exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh"
            ;;
    esac
done



================================================
FILE: scripts/menus/utilities_menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 02/07/2025
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

    while true; do
        OPTION=$(dialog --clear --backtitle "ProxMenux" --title "$(translate "Utilities Menu")" \
                        --menu "$(translate "Select an option:")" 20 70 8 \
                        "1" "$(translate "UUp Dump ISO creator Custom")" \
                        "2" "$(translate "System Utilities Installer")" \
                        "3" "$(translate "Proxmox System Update")" \
                        "4" "$(translate "Upgrade PVE 8 to PVE 9")" \
                        "5" "$(translate "Return to Main Menu")" \
                        2>&1 >/dev/tty)

        case $OPTION in
            1)
                bash "$LOCAL_SCRIPTS/utilities/uup_dump_iso_creator.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;
            2)
                bash "$LOCAL_SCRIPTS/utilities/system_utils.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;
            3)
                proxmox_update_msg="\n"
                proxmox_update_msg+="$(translate "This script will update your Proxmox VE system with advanced options:")\n\n"
                proxmox_update_msg+="â€¢ $(translate "Repairs and optimizes repositories")\n"
                proxmox_update_msg+="â€¢ $(translate "Cleans duplicate or conflicting sources")\n"
                proxmox_update_msg+="â€¢ $(translate "Switches to the free no-subscription repository")\n"
                proxmox_update_msg+="â€¢ $(translate "Updates all Proxmox and Debian packages")\n"
                proxmox_update_msg+="â€¢ $(translate "Installs essential packages if missing")\n"
                proxmox_update_msg+="â€¢ $(translate "Checks for LVM and storage issues")\n"
                proxmox_update_msg+="â€¢ $(translate "Performs automatic cleanup after updating")\n\n"
                proxmox_update_msg+="$(translate "Do you want to proceed and run the Proxmox System Update?")"

                dialog --colors --backtitle "ProxMenux" --title "$(translate "Proxmox System Update")" \
                    --yesno "$proxmox_update_msg" 20 70

                dialog_result=$?
                if [[ $dialog_result -eq 0 ]]; then
                    bash "$LOCAL_SCRIPTS/utilities/proxmox_update.sh"
                    if [ $? -ne 0 ]; then
                        return
                    fi
                fi
                ;;
            4)
                bash "$LOCAL_SCRIPTS/utilities/upgrade_pve8_to_pve9.sh"
                if [ $? -ne 0 ]; then
                    return
                fi
                ;;    
            5) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
            *) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
        esac
    done
    


================================================
FILE: scripts/post_install/auto_post_install.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Complete Post-Installation Script with Registration
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 06/07/2025
# ==========================================================
# Description:
#
# The script performs system optimizations including:
# - Repository configuration and system upgrades
# - Subscription banner removal and UI enhancements  
# - Advanced memory management and kernel optimizations
# - Network stack tuning and security hardening
# - Storage optimizations including log2ram for SSD protection
# - System limits increases and entropy generation improvements
# - Journald and logrotate optimizations for better log management
# - Security enhancements including RPC disabling and time synchronization
# - Bash environment customization and system monitoring setup
#
# Key Features:
# - Zero-interaction automation: Runs completely unattended
# - Intelligent hardware detection: Automatically detects SSD/NVMe for log2ram
# - RAM-aware configurations: Adjusts settings based on available system memory
# - Comprehensive error handling: Robust installation with fallback mechanisms
# - Registration system: Tracks installed optimizations for easy management
# - Reboot management: Intelligently handles reboot requirements
# - Translation support: Multi-language compatible through ProxMenux framework
# - Rollback compatibility: All optimizations can be reversed using the uninstall script
#
# This script is based on the post-install script cutotomizable
# ==========================================================


# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
TOOLS_JSON="/usr/local/share/proxmenux/installed_tools.json"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Global variables
OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs)"
RAM_SIZE_GB=$(( $(vmstat -s | grep -i "total memory" | xargs | cut -d" " -f 1) / 1024 / 1000))
NECESSARY_REBOOT=0
export SCRIPT_TITLE="ProxMenux Optimization Post-Installation"

# ==========================================================
# Tool registration system
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}



check_extremeshok_warning() {
    local marker_file="/etc/extremeshok"

    if [[ -f "$marker_file" ]]; then
        dialog --backtitle "ProxMenux" --title "xshok-proxmox Post-Install Detected" \
        --yesno "\n$(translate "It appears that you have already executed the xshok-proxmox post-install script on this system.")\n\n\
$(translate "If you continue, some adjustments may be duplicated or conflict with those already made by xshok.")\n\n\
$(translate "Do you want to continue anyway?")" 13 70

        local response=$?
        if [[ $response -ne 0 ]]; then
            show_proxmenux_logo
            msg_warn "$(translate "Action cancelled due to previous xshok-proxmox modifications.")"
            echo -e
            msg_success "$(translate "Press Enter to return to menu...")"
            read -r
            exit 1
        fi
    fi
}


# ==========================================================



apt_upgrade() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

    if [[ -z "$pve_version" ]]; then
        msg_error "Unable to detect Proxmox version."
        return 1
    fi

    if [[ "$pve_version" -ge 9 ]]; then

        bash "$LOCAL_SCRIPTS/global/update-pve9_2.sh"
    else

        bash "$LOCAL_SCRIPTS/global/update-pve8.sh"
    fi
}

# ==========================================================








remove_subscription_banner() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

     
    if [[ -z "$pve_version" ]]; then
        msg_error "Unable to detect Proxmox version."
        return 1
    fi

    kill -TERM "$SPINNER_PID" 2>/dev/null
    sleep 1

    if [[ "$pve_version" -ge 9 ]]; then
        if ! whiptail --title "Proxmox VE ${pve_version} Subscription Banner Removal" \
        --yesno "$(translate "Do you want to remove the Proxmox subscription banner from the web interface for PVE $pve_version?")\n\n$(translate "Attention: Removing the subscription banner may cause issues in the web interface after a future update.")\n\n$(translate "If this happens, you can restore the backup from the 'Subscription Banner Removal' option in 'Uninstall optimizations'.")\n\n$(translate "Are you sure you want to continue?")" 14 75; then
            msg_warn "Banner removal cancelled by user."
            return 1
        fi
        bash "$LOCAL_SCRIPTS/global/remove-banner-pve-v3.sh"
    else
        if ! whiptail --title "Proxmox VE 8.x Subscription Banner Removal" \
        --yesno "Do you want to remove the Proxmox subscription banner from the web interface for PVE $pve_version?" 10 70; then
            msg_warn "Banner removal cancelled by user."
            return 1
        fi
        bash "$LOCAL_SCRIPTS/global/remove-banner-pve8.sh"
    fi
}





   

# ==========================================================





configure_time_sync() {
    msg_info2 "$(translate "Configuring system time settings...")"

    this_ip=$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null)
    if [ -z "$this_ip" ]; then
        msg_warn "$(translate "Failed to obtain public IP address - keeping current timezone settings")"
        return 0
    fi

    timezone=$(curl -s --connect-timeout 10 "https://ipapi.co/${this_ip}/timezone" 2>/dev/null)
    if [ -z "$timezone" ] || [ "$timezone" = "undefined" ]; then
        msg_warn "$(translate "Failed to determine timezone from IP address - keeping current timezone settings")"
        return 0
    fi

    msg_ok "$(translate "Found timezone $timezone for IP $this_ip")"
    
    if timedatectl set-timezone "$timezone"; then
        msg_ok "$(translate "Timezone set to $timezone")"
        
        if timedatectl set-ntp true; then
            msg_ok "$(translate "Time settings configured - Timezone:") $timezone"
            register_tool "time_sync" true
            
            systemctl restart postfix 2>/dev/null || true
        else
            msg_warn "$(translate "Failed to enable automatic time synchronization")"
        fi
    else
        msg_warn "$(translate "Failed to set timezone - keeping current settings")"
    fi
}




# ==========================================================

skip_apt_languages() {
  msg_info "$(translate "Configuring APT to skip downloading additional languages...")"
  cat > /etc/apt/apt.conf.d/99-disable-translations <<'EOF'
Acquire::Languages "none";
EOF
  msg_ok "$(translate "APT configured to skip additional languages")"
  register_tool "apt_languages" true
}

# ==========================================================
optimize_journald() {

    if [ -f /etc/log2ram.conf ] || [ -d /var/log.hdd ]; then
    return 0
    fi
    msg_info "$(translate "Limiting size and optimizing journald...")"
    NECESSARY_REBOOT=1

    local jf="/etc/systemd/journald.conf"
    if ! grep -q "ProxMenux optimized journald" "$jf" 2>/dev/null; then
        cp -a "$jf" "${jf}.bak" 2>/dev/null || true
    fi
    
    cat <<EOF > /etc/systemd/journald.conf
[Journal]
Storage=persistent
SplitMode=none
RateLimitIntervalSec=30s
RateLimitBurst=1000
ForwardToSyslog=no
ForwardToWall=no
Seal=no
Compress=yes
SystemMaxUse=64M
RuntimeMaxUse=60M
MaxLevelStore=warning
MaxLevelSyslog=warning
MaxLevelKMsg=warning
MaxLevelConsole=notice
MaxLevelWall=crit
EOF
    
    systemctl restart systemd-journald.service > /dev/null 2>&1
    journalctl --vacuum-size=64M --vacuum-time=1d > /dev/null 2>&1
    journalctl --rotate > /dev/null 2>&1
    
    msg_ok "$(translate "Journald optimized - Max size: 64M")"
    register_tool "journald" true
}

# ==========================================================
optimize_logrotate() {
    msg_info "$(translate "Optimizing logrotate configuration...")"
    local logrotate_conf="/etc/logrotate.conf"
    local backup_conf="${logrotate_conf}.bak"
    
    if ! grep -q "# ProxMenux optimized configuration" "$logrotate_conf"; then
        cp "$logrotate_conf" "$backup_conf"
        cat <<EOF > "$logrotate_conf"
# ProxMenux optimized configuration (Log2RAM-friendly)
daily
su root adm
rotate 7
size=10M
compress
delaycompress
missingok
notifempty
create 0640 root adm
copytruncate
include /etc/logrotate.d
EOF
        systemctl restart logrotate > /dev/null 2>&1
    fi
    
    msg_ok "$(translate "Logrotate optimization completed")"
    register_tool "logrotate" true
}

# ==========================================================
increase_system_limits() {
    msg_info "$(translate "Increasing various system limits...")"
    NECESSARY_REBOOT=1
    

    cat > /etc/sysctl.d/99-maxwatches.conf << EOF
# ProxMenux configuration
fs.inotify.max_user_watches = 1048576
fs.inotify.max_user_instances = 1048576
fs.inotify.max_queued_events = 1048576
EOF
    
 
    cat > /etc/security/limits.d/99-limits.conf << EOF
# ProxMenux configuration
* soft     nproc          1048576
* hard     nproc          1048576
* soft     nofile         1048576
* hard     nofile         1048576
root soft     nproc          unlimited
root hard     nproc          unlimited
root soft     nofile         unlimited
root hard     nofile         unlimited
EOF
    
 
    cat > /etc/sysctl.d/99-maxkeys.conf << EOF
# ProxMenux configuration
kernel.keys.root_maxkeys=1000000
kernel.keys.maxkeys=1000000
EOF
    
   
    for file in /etc/systemd/system.conf /etc/systemd/user.conf; do
        if ! grep -q "^DefaultLimitNOFILE=" "$file"; then
            echo "DefaultLimitNOFILE=256000" >> "$file"
        fi
    done
    

    for file in /etc/pam.d/common-session /etc/pam.d/runuser-l; do
        if ! grep -q "^session required pam_limits.so" "$file"; then
            echo 'session required pam_limits.so' >> "$file"
        fi
    done
    

    if ! grep -q "ulimit -n 256000" /root/.profile; then
        echo "ulimit -n 256000" >> /root/.profile
    fi
    

    cat > /etc/sysctl.d/99-swap.conf << EOF
# ProxMenux configuration
vm.swappiness = 10
vm.vfs_cache_pressure = 100
EOF
    
 
    cat > /etc/sysctl.d/99-fs.conf << EOF
# ProxMenux configuration
fs.nr_open = 12000000
fs.file-max = 9223372036854775807
fs.aio-max-nr = 1048576
EOF
    
    msg_ok "$(translate "System limits increase completed.")"
    register_tool "system_limits" true
}

# ==========================================================
configure_entropy() {
    msg_info "$(translate "Configuring entropy generation to prevent slowdowns...")"
    
    /usr/bin/env DEBIAN_FRONTEND=noninteractive apt-get -y -o Dpkg::Options::='--force-confdef' install haveged > /dev/null 2>&1
    
    cat <<EOF > /etc/default/haveged
#   -w sets low entropy watermark (in bits)
DAEMON_ARGS="-w 1024"
EOF
    
    systemctl daemon-reload > /dev/null 2>&1
    systemctl enable haveged > /dev/null 2>&1
    
    msg_ok "$(translate "Entropy generation configuration completed")"
    register_tool "entropy" true
}

# ==========================================================
optimize_memory_settings() {
    msg_info "$(translate "Optimizing memory settings...")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/sysctl.d/99-memory.conf
# Balanced Memory Optimization
vm.swappiness = 10
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
vm.overcommit_memory = 1
vm.max_map_count = 65530
EOF
    
    if [ -f /proc/sys/vm/compaction_proactiveness ]; then
        echo "vm.compaction_proactiveness = 20" >> /etc/sysctl.d/99-memory.conf
    fi
    
    msg_ok "$(translate "Memory optimization completed.")"
    register_tool "memory_settings" true
}

# ==========================================================
configure_kernel_panic() {
    msg_info "$(translate "Configuring kernel panic behavior")"
    NECESSARY_REBOOT=1
    
    cat <<EOF > /etc/sysctl.d/99-kernelpanic.conf
# Enable restart on kernel panic, kernel oops and hardlockup
kernel.core_pattern = /var/crash/core.%t.%p
kernel.panic = 10
kernel.panic_on_oops = 1
kernel.hardlockup_panic = 1
EOF
    
    msg_ok "$(translate "Kernel panic behavior configuration completed")"
    register_tool "kernel_panic" true
}

# ==========================================================
force_apt_ipv4() {
    msg_info "$(translate "Configuring APT to use IPv4...")"
    
    echo 'Acquire::ForceIPv4 "true";' > /etc/apt/apt.conf.d/99-force-ipv4
    
    msg_ok "$(translate "APT IPv4 configuration completed")"
    register_tool "apt_ipv4" true
}

# ==========================================================

apply_network_optimizations() {
  msg_info "$(translate "Optimizing network settings...")"
  NECESSARY_REBOOT=1

  cat <<'EOF' > /etc/sysctl.d/99-network.conf
# ==========================================================
# ProxMenux - Network tuning (PVE 9 compatible)
# ==========================================================

# Core buffers & queues
net.core.netdev_max_backlog = 8192
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.somaxconn = 8192

# IPv4 hardening 
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.all.log_martians = 0

net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.default.log_martians = 0

# rp_filter: 
net.ipv4.conf.all.rp_filter = 2
net.ipv4.conf.default.rp_filter = 2

# ICMP
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1

# TCP/IP
net.ipv4.ip_local_port_range = 1024 65535
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_rfc1337 = 1
net.ipv4.tcp_sack = 1
net.ipv4.tcp_rmem = 8192 87380 16777216
net.ipv4.tcp_wmem = 8192 65536 16777216

# Unix sockets
net.unix.max_dgram_qlen = 4096
EOF

  sysctl --system > /dev/null 2>&1


  cat >/etc/systemd/system/proxmenux-fwbr-tune.service <<'EOF'
[Unit]
Description=ProxMenux - Tune rp_filter/log_martians on virtual fw bridges
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'for i in /proc/sys/net/ipv4/conf/*; do n=${i##*/}; case "$n" in fwbr*|fwln*|fwpr*|tap*) echo 0 > /proc/sys/net/ipv4/conf/$n/rp_filter; echo 0 > /proc/sys/net/ipv4/conf/$n/log_martians; esac; done'

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable --now proxmenux-fwbr-tune.service >/dev/null 2>&1 || true


  local interfaces_file="/etc/network/interfaces"
  if ! grep -q 'source /etc/network/interfaces.d/*' "$interfaces_file"; then
      echo "source /etc/network/interfaces.d/*" >> "$interfaces_file"
  fi

  msg_ok "$(translate "Network optimization completed")"
  register_tool "network_optimization" true
}







# ==========================================================
customize_bashrc_() {
    msg_info "$(translate "Customizing bashrc for root user...")"
    local bashrc="/root/.bashrc"
    local bash_profile="/root/.bash_profile"
    
    if [ ! -f "${bashrc}.bak" ]; then
        cp "$bashrc" "${bashrc}.bak"
    fi
    
 
    cat >> "$bashrc" << 'EOF'

# ProxMenux customizations
export HISTTIMEFORMAT="%d/%m/%y %T "
export PS1="\[\e[31m\][\[\e[m\]\[\e[38;5;172m\]\u\[\e[m\]@\[\e[38;5;153m\]\h\[\e[m\] \[\e[38;5;214m\]\W\[\e[m\]\[\e[31m\]]\[\e[m\]\\$ "
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
source /etc/profile.d/bash_completion.sh
EOF
    
    if ! grep -q "source /root/.bashrc" "$bash_profile"; then
        echo "source /root/.bashrc" >> "$bash_profile"
    fi
    
    msg_ok "$(translate "Bashrc customization completed")"
    register_tool "bashrc_custom" true
}



customize_bashrc() {    
    msg_info "$(translate "Customizing bashrc for root user...")"
    local bashrc="/root/.bashrc"
    local bash_profile="/root/.bash_profile"
    local marker_begin="# BEGIN PMX_CORE_BASHRC"
    local marker_end="# END PMX_CORE_BASHRC"
    
 
    [ -f "${bashrc}.bak" ] || cp "$bashrc" "${bashrc}.bak" > /dev/null 2>&1
    

    if grep -q "^${marker_begin}$" "$bashrc" 2>/dev/null; then
        sed -i "/^${marker_begin}$/,/^${marker_end}$/d" "$bashrc"  
    fi
    
 
    cat >> "$bashrc" << 'EOF'
${marker_begin}
# ProxMenux core customizations
export HISTTIMEFORMAT="%d/%m/%y %T "
export PS1="\[\e[31m\][\[\e[m\]\[\e[38;5;172m\]\u\[\e[m\]@\[\e[38;5;153m\]\h\[\e[m\] \[\e[38;5;214m\]\W\[\e[m\]\[\e[31m\]]\[\e[m\]\\$ "
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias ls='ls --color=auto'
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
source /etc/profile.d/bash_completion.sh
${marker_end}
EOF
    

    if ! grep -q "source /root/.bashrc" "$bash_profile" 2>/dev/null; then
        echo "source /root/.bashrc" >> "$bash_profile" 2>/dev/null
    fi
    
    msg_ok "$(translate "Bashrc customization completed")"
    register_tool "bashrc_custom" true
}



# ==========================================================








install_log2ram_auto() {
    msg_info "$(translate "Checking if system disk is SSD or M.2...")"

    local is_ssd=false
    local pool disks disk byid_path dev rot

    if grep -qE '^root=ZFS=' /etc/kernel/cmdline 2>/dev/null || mount | grep -q 'on / type zfs'; then
        pool=$(zfs list -Ho name,mountpoint 2>/dev/null | awk '$2=="/"{print $1}' | cut -d/ -f1)
        disks=$(zpool status "$pool" 2>/dev/null | awk '/ONLINE/ && $1 !~ /:|mirror|raidz|log|spare|config|NAME|rpool|state/ {print $1}' | sort -u)
        is_ssd=true
        for disk in $disks; do
            byid_path=$(readlink -f /dev/disk/by-id/*$disk* 2>/dev/null) || continue
            dev=$(basename "$byid_path" | sed -E 's|[0-9]+$||' | sed -E 's|p$||')
            rot=$(cat /sys/block/$dev/queue/rotational 2>/dev/null)
            [[ "$rot" != "0" ]] && is_ssd=false && break
        done
    else
        ROOT_PART=$(lsblk -no NAME,MOUNTPOINT | grep ' /$' | awk '{print $1}')
        SYSTEM_DISK=$(lsblk -no PKNAME /dev/$ROOT_PART 2>/dev/null | grep -E '^[a-z]+' | head -n1)
        SYSTEM_DISK=${SYSTEM_DISK:-sda}
        if [[ "$SYSTEM_DISK" == nvme* || "$(cat /sys/block/$SYSTEM_DISK/queue/rotational 2>/dev/null)" == "0" ]]; then
            is_ssd=true
        fi
    fi

    if [[ "$is_ssd" == true ]]; then
        msg_ok "$(translate "System disk is SSD or M.2. Proceeding with Log2RAM setup.")"
    else
        kill -TERM "$SPINNER_PID" 2>/dev/null
        sleep 1
        if whiptail --yesno "$(translate "Do you want to install Log2RAM anyway to reduce log write load?")" 10 70 --title "Log2RAM"; then
            msg_ok "$(translate "Proceeding with Log2RAM setup on non-SSD disk as requested by user.")"
        else
            msg_info2 "$(translate "Log2RAM installation cancelled by user")"
            return 0
        fi
    fi

    msg_info "$(translate "Cleaning previous Log2RAM installation...")"

    systemctl stop log2ram log2ram-daily.timer >/dev/null 2>&1 || true
    systemctl disable log2ram log2ram-daily.timer >/dev/null 2>&1 || true

    rm -f /etc/cron.d/log2ram /etc/cron.d/log2ram-auto-sync \
          /etc/cron.hourly/log2ram /etc/cron.daily/log2ram \
          /etc/cron.weekly/log2ram /etc/cron.monthly/log2ram 2>/dev/null || true
    rm -f /usr/local/bin/log2ram-check.sh /usr/local/bin/log2ram /usr/sbin/log2ram 2>/dev/null || true
    rm -f /etc/systemd/system/log2ram.service \
          /etc/systemd/system/log2ram-daily.timer \
          /etc/systemd/system/log2ram-daily.service \
          /etc/systemd/system/sysinit.target.wants/log2ram.service 2>/dev/null || true
    rm -rf /etc/systemd/system/log2ram.service.d 2>/dev/null || true
    rm -f /etc/log2ram.conf* 2>/dev/null || true
    rm -rf /etc/logrotate.d/log2ram /var/log.hdd /tmp/log2ram 2>/dev/null || true

    systemctl daemon-reexec >/dev/null 2>&1 || true
    systemctl daemon-reload >/dev/null 2>&1 || true
    systemctl restart cron >/dev/null 2>&1 || true

    msg_ok "$(translate "Previous installation cleaned")"
    msg_info "$(translate "Installing Log2RAM from source...")"

    if ! command -v git >/dev/null 2>&1; then
        apt-get update -qq >/dev/null 2>&1
        apt-get install -y git >/dev/null 2>&1
    fi

    rm -rf /tmp/log2ram 2>/dev/null || true
    if ! git clone https://github.com/azlux/log2ram.git /tmp/log2ram >/dev/null 2>>/tmp/log2ram_install.log; then
        msg_error "$(translate "Failed to clone log2ram repository. Check /tmp/log2ram_install.log")"
        return 1
    fi

    cd /tmp/log2ram || { msg_error "$(translate "Failed to access log2ram directory")"; return 1; }

    if ! bash install.sh >>/tmp/log2ram_install.log 2>&1; then
        msg_error "$(translate "Failed to run log2ram installer. Check /tmp/log2ram_install.log")"
        return 1
    fi

    systemctl enable --now log2ram >/dev/null 2>&1 || true
    systemctl daemon-reload >/dev/null 2>&1 || true

    if [[ -f /etc/log2ram.conf ]] && command -v log2ram >/dev/null 2>&1; then
        msg_ok "$(translate "Log2RAM installed successfully")"
    else
        msg_error "$(translate "Log2RAM installation verification failed. Check /tmp/log2ram_install.log")"
        return 1
    fi

    RAM_SIZE_GB=$(free -g | awk '/^Mem:/{print $2}')
    [[ -z "$RAM_SIZE_GB" || "$RAM_SIZE_GB" -eq 0 ]] && RAM_SIZE_GB=4

    if (( RAM_SIZE_GB <= 8 )); then
        LOG2RAM_SIZE="128M"; CRON_HOURS=1
    elif (( RAM_SIZE_GB <= 16 )); then
        LOG2RAM_SIZE="256M"; CRON_HOURS=3
    else
        LOG2RAM_SIZE="512M"; CRON_HOURS=6
    fi

    msg_ok "$(translate "Detected RAM:") $RAM_SIZE_GB GB â€” $(translate "Log2RAM size set to:") $LOG2RAM_SIZE"
    sed -i "s/^SIZE=.*/SIZE=$LOG2RAM_SIZE/" /etc/log2ram.conf

    LOG2RAM_BIN="$(command -v log2ram || echo /usr/sbin/log2ram)"

    cat > /etc/cron.d/log2ram <<EOF
# Log2RAM periodic sync - Created by ProxMenux
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAILTO=""
0 */$CRON_HOURS * * * root $LOG2RAM_BIN write >/dev/null 2>&1
EOF
    chmod 0644 /etc/cron.d/log2ram
    chown root:root /etc/cron.d/log2ram
    msg_ok "$(translate "Log2RAM write scheduled every") $CRON_HOURS $(translate "hour(s)")"

    cat > /usr/local/bin/log2ram-check.sh <<'EOF'
#!/usr/bin/env bash
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"

CONF_FILE="/etc/log2ram.conf"
L2R_BIN="$(command -v log2ram || true)"
[[ -z "$L2R_BIN" && -x /usr/sbin/log2ram ]] && L2R_BIN="/usr/sbin/log2ram"
[[ -z "$L2R_BIN" ]] && exit 0

SIZE_MiB="$(grep -E '^SIZE=' "$CONF_FILE" 2>/dev/null | cut -d'=' -f2 | tr -dc '0-9')"
[[ -z "$SIZE_MiB" ]] && SIZE_MiB=128
LIMIT_BYTES=$(( SIZE_MiB * 1024 * 1024 ))
THRESHOLD_BYTES=$(( LIMIT_BYTES * 90 / 100 ))

USED_BYTES="$(df -B1 --output=used /var/log 2>/dev/null | tail -1 | tr -dc '0-9')"
[[ -z "$USED_BYTES" ]] && exit 0

LOCK="/run/log2ram-check.lock"
exec 9>"$LOCK" 2>/dev/null || exit 0
flock -n 9 || exit 0

if (( USED_BYTES > THRESHOLD_BYTES )); then
  "$L2R_BIN" write 2>/dev/null || true
fi
EOF
    chmod +x /usr/local/bin/log2ram-check.sh

    cat > /etc/cron.d/log2ram-auto-sync <<'EOF'
# Log2RAM auto-sync based on /var/log usage - Created by ProxMenux
SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
MAILTO=""
*/5 * * * * root /usr/local/bin/log2ram-check.sh >/dev/null 2>&1
EOF
    chmod 0644 /etc/cron.d/log2ram-auto-sync
    chown root:root /etc/cron.d/log2ram-auto-sync

    systemctl restart cron >/dev/null 2>&1 || true
    msg_ok "$(translate "Auto-sync enabled when /var/log exceeds 90% of") $LOG2RAM_SIZE"


    msg_info "$(translate "Adjusting systemd-journald limits to match Log2RAM size...")"


    if [[ -f /etc/systemd/journald.conf ]]; then
        cp -n /etc/systemd/journald.conf /etc/systemd/journald.conf.bak.$(date +%Y%m%d-%H%M%S)

    fi

    SIZE_MB=$(echo "$LOG2RAM_SIZE" | tr -dc '0-9')


    USE_MB=$(( SIZE_MB * 55 / 100 ))    
    KEEP_MB=$(( SIZE_MB * 10 / 100 ))   
    RUNTIME_MB=$(( SIZE_MB * 25 / 100 )) 


    [ "$USE_MB" -lt 80 ] && USE_MB=80
    [ "$RUNTIME_MB" -lt 32 ] && RUNTIME_MB=32
    [ "$KEEP_MB" -lt 8 ] && KEEP_MB=8


    sed -i '/^\[Journal\]/,$d' /etc/systemd/journald.conf 2>/dev/null || true
    tee -a /etc/systemd/journald.conf >/dev/null <<EOF
[Journal]
Storage=persistent
SplitMode=none
RateLimitIntervalSec=30s
RateLimitBurst=1000
ForwardToSyslog=no
ForwardToWall=no
Seal=no
Compress=yes
SystemMaxUse=${USE_MB}M
SystemKeepFree=${KEEP_MB}M
RuntimeMaxUse=${RUNTIME_MB}M
MaxLevelStore=warning
MaxLevelSyslog=warning
MaxLevelKMsg=warning
MaxLevelConsole=notice
MaxLevelWall=crit
EOF


    mkdir -p /var/log/pveproxy
    chown -R www-data:www-data /var/log/pveproxy
    chmod 0750 /var/log/pveproxy

    mkdir -p /var/log.hdd/pveproxy
    chown -R www-data:www-data /var/log.hdd/pveproxy
    chmod 0750 /var/log.hdd/pveproxy

    systemctl restart systemd-journald >/dev/null 2>&1 || true
    #msg_ok "$(translate "Backup created:") /etc/systemd/journald.conf.bak.$(date +%Y%m%d-%H%M%S)"
    msg_ok "$(translate "Journald configuration adjusted to") ${USE_MB}M (Log2RAM ${LOG2RAM_SIZE})"


    register_tool "log2ram" true
}








# ==========================================================


setup_persistent_network() {
    local LINK_DIR="/etc/systemd/network"
    local BACKUP_DIR="/etc/systemd/network/backup-$(date +%Y%m%d-%H%M%S)"
    

 
    msg_info "$(translate "Setting up persistent network interfaces")"
    sleep 2

    mkdir -p "$LINK_DIR"
    
    if ls "$LINK_DIR"/*.link >/dev/null 2>&1; then
        mkdir -p "$BACKUP_DIR"
        cp "$LINK_DIR"/*.link "$BACKUP_DIR"/ 2>/dev/null || true
    fi
    
    local count=0
    for iface in $(ls /sys/class/net/ | grep -vE "lo|docker|veth|br-|vmbr|tap|fwpr|fwln|virbr|bond|cilium|zt|wg"); do
        if [[ -e "/sys/class/net/$iface/device" ]] || [[ -e "/sys/class/net/$iface/phy80211" ]]; then
            local MAC=$(cat /sys/class/net/$iface/address 2>/dev/null)
            
            if [[ "$MAC" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]]; then
                local LINK_FILE="$LINK_DIR/10-$iface.link"
                
                cat > "$LINK_FILE" <<EOF
[Match]
MACAddress=$MAC

[Link]
Name=$iface
EOF
                chmod 644 "$LINK_FILE"
                ((count++))
            fi
        fi
    done
    
    if [[ $count -gt 0 ]]; then
        msg_ok "$(translate "Created persistent names for") $count $(translate "interfaces")"
        msg_ok "$(translate "Changes will apply after reboot.")"
    else
        msg_warn "$(translate "No physical interfaces found")"
    fi
    register_tool "persistent_network" true

}


# ==========================================================

run_complete_optimization() {
    
    show_proxmenux_logo
    msg_title "$(translate "$SCRIPT_TITLE")"
    
    ensure_tools_json
    
    apt_upgrade
    remove_subscription_banner
    force_apt_ipv4
    #configure_time_sync
    skip_apt_languages
    increase_system_limits
    configure_entropy
    optimize_memory_settings
    configure_kernel_panic
    apply_network_optimizations
    #disable_rpc
    customize_bashrc
    install_log2ram_auto
    optimize_journald
    optimize_logrotate
    setup_persistent_network
    

    echo -e
    msg_success "$(translate "Complete post-installation optimization finished!")"
    
    if [[ "$NECESSARY_REBOOT" -eq 1 ]]; then
        whiptail --title "Reboot Required" \
            --yesno "$(translate "Some changes require a reboot to take effect. Do you want to restart now?")" 10 60
        if [[ $? -eq 0 ]]; then
        msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
        apt-get -y autoremove >/dev/null 2>&1
        apt-get -y autoclean >/dev/null 2>&1
        msg_ok "$(translate "Cleanup finished")"
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        msg_warn "$(translate "Rebooting the system...")"
        reboot
        else
        msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
        apt-get -y autoremove >/dev/null 2>&1
        apt-get -y autoclean >/dev/null 2>&1
        msg_ok "$(translate "Cleanup finished")"
        msg_info2 "$(translate "You can reboot later manually.")"
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        exit 0
        fi
    fi

}

check_extremeshok_warning
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    run_complete_optimization
fi



================================================
FILE: scripts/post_install/uninstall-tools.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Complete Uninstall Optimizations Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 06/07/2025
# ==========================================================
# Description:
# This script provides a complete uninstallation and rollback system 
# for all post-installation optimizations applied by ProxMenux.
#
# It allows administrators to safely revert any changes made during the 
# optimization process, restoring the system to its original state.
#
# This ensures full control over system configurations and gives users 
# the confidence to apply, test, and undo ProxMenux enhancements as needed.
# ==========================================================


LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
RETURN_SCRIPT="$LOCAL_SCRIPTS/menus/menu_post_install.sh"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
TOOLS_JSON="$BASE_DIR/installed_tools.json"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Tool registration system
ensure_tools_json() {
    [ -f "$TOOLS_JSON" ] || echo "{}" > "$TOOLS_JSON"
}

register_tool() {
    local tool="$1"
    local state="$2"
    ensure_tools_json
    jq --arg t "$tool" --argjson v "$state" '.[$t]=$v' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
}

################################################################

uninstall_fastfetch() {
    if ! command -v fastfetch &>/dev/null && [[ ! -f /usr/local/bin/fastfetch ]]; then
        msg_warn "$(translate "Fastfetch is not installed.")"
        return 0
    fi

    msg_info2 "$(translate "Uninstalling Fastfetch...")"
    rm -f /usr/local/bin/fastfetch /usr/bin/fastfetch
    rm -rf "$HOME/.config/fastfetch"
    rm -rf /usr/local/share/fastfetch
    sed -i '/fastfetch/d' "$HOME/.bashrc" "$HOME/.profile" /etc/profile 2>/dev/null
    sed -i '/# BEGIN FASTFETCH/,/# END FASTFETCH/d' "$HOME/.bashrc"
    rm -f /etc/profile.d/fastfetch.sh /etc/update-motd.d/99-fastfetch
    dpkg -r fastfetch &>/dev/null

    msg_ok "$(translate "Fastfetch removed from system")"
    register_tool "fastfetch" false
}

################################################################

uninstall_figurine_() {
    if ! command -v figurine &>/dev/null; then
        msg_warn "$(translate "Figurine is not installed.")"
        return 0
    fi

    msg_info2 "$(translate "Uninstalling Figurine...")"
    rm -f /usr/local/bin/figurine
    rm -f /etc/profile.d/figurine.sh
    sed -i '/figurine/d' "$HOME/.bashrc" "$HOME/.profile" 2>/dev/null

    msg_ok "$(translate "Figurine removed from system")"
    register_tool "figurine" false
}


uninstall_figurine() {
    if ! command -v figurine &>/dev/null; then
        msg_warn "$(translate "Figurine is not installed.")"
        return 0
    fi

    msg_info2 "$(translate "Uninstalling Figurine...")"
    rm -f /usr/local/bin/figurine
    rm -f /etc/profile.d/figurine.sh

    sed -i '/lxcclean/d;/lxcupdate/d;/kernelclean/d;/cpugov/d;/updatecerts/d;/seqwrite/d;/seqread/d;/ranwrite/d;/ranread/d' "$HOME/.bashrc" "$HOME/.profile" 2>/dev/null
    sed -i '/# ProxMenux Figurine aliases and tools/,+20d' "$HOME/.bashrc" "$HOME/.profile" 2>/dev/null
    sed -i '/# BEGIN PROXMENUX ALIASES/,/# END PROXMENUX ALIASES/d' "$HOME/.bashrc" "$HOME/.profile" 2>/dev/null

    msg_ok "$(translate "Figurine removed from system")"
    register_tool "figurine" false
}


################################################################

uninstall_kexec() {
    if ! dpkg -s kexec-tools >/dev/null 2>&1 && [ ! -f /etc/systemd/system/kexec-pve.service ]; then
        msg_warn "$(translate "kexec-tools is not installed or already removed.")"
        return 0
    fi

    msg_info2 "$(translate "Uninstalling kexec-tools and removing custom service...")"
    systemctl disable --now kexec-pve.service &>/dev/null
    rm -f /etc/systemd/system/kexec-pve.service
    sed -i "/alias reboot-quick='systemctl kexec'/d" /root/.bash_profile
    apt-get purge -y kexec-tools >/dev/null 2>&1

    msg_ok "$(translate "kexec-tools and related settings removed")"
    register_tool "kexec" false
}

################################################################

uninstall_apt_upgrade() {
    msg_info "$(translate "Restoring enterprise repositories...")"
    
    # Re-enable enterprise repos
    if [ -f /etc/apt/sources.list.d/pve-enterprise.list ]; then
        sed -i "s/^#deb/deb/g" /etc/apt/sources.list.d/pve-enterprise.list
    fi
    
    if [ -f /etc/apt/sources.list.d/ceph.list ]; then
        sed -i "s/^#deb/deb/g" /etc/apt/sources.list.d/ceph.list
    fi
    
    # Remove public repo
    rm -f /etc/apt/sources.list.d/pve-public-repo.list
    
    # Remove firmware warning config
    rm -f /etc/apt/apt.conf.d/no-bookworm-firmware.conf
    
    apt-get update > /dev/null 2>&1
    
    msg_ok "$(translate "Enterprise repositories restored")"
    register_tool "apt_upgrade" false
}

################################################################

uninstall_subscription_banner_() {
    msg_info "$(translate "Restoring subscription banner...")"
    
    # Remove APT hook
    rm -f /etc/apt/apt.conf.d/no-nag-script
    
    # Reinstall proxmox-widget-toolkit to restore original
    apt --reinstall install proxmox-widget-toolkit -y >/dev/null 2>&1
    
    msg_ok "$(translate "Subscription banner restored")"
    register_tool "subscription_banner" false
}




uninstall_subscription_banner__() {
    msg_info "$(translate "Restoring subscription banner...")"
    
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local MOBILE_TPL="/usr/share/pve-manager/templates/index.html.tpl"
    local PATCH_BIN="/usr/local/bin/pve-remove-nag.sh"
    local BASE_DIR="/opt/pve-nag-buster"
    local MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    local MARK_MOBILE=" PVE9 Mobile Subscription Banner Removal "
    
    local restored=false
    
    # Remove APT hook (both old and new versions)
    for hook in /etc/apt/apt.conf.d/*nag* /etc/apt/apt.conf.d/no-nag-script; do
        if [[ -e "$hook" ]]; then
            rm -f "$hook"
            msg_ok "$(translate "Removed APT hook: $hook")"
        fi
    done
    
    # Remove patch script
    if [[ -f "$PATCH_BIN" ]]; then
        rm -f "$PATCH_BIN"
        msg_ok "$(translate "Removed patch script: $PATCH_BIN")"
    fi
    
    # Restore JavaScript file from backups (new script method)
    if [[ -d "$BASE_DIR/backups" ]]; then
        local latest_backup
        latest_backup=$(ls -t "$BASE_DIR/backups"/proxmoxlib.js.backup.* 2>/dev/null | head -1)
        if [[ -n "$latest_backup" && -f "$latest_backup" ]]; then
            if [[ -s "$latest_backup" ]] && grep -q "Ext\|function" "$latest_backup" && ! grep -q $'\0' "$latest_backup"; then
                cp -a "$latest_backup" "$JS_FILE"
                msg_ok "$(translate "Restored from backup: $latest_backup")"
                restored=true
            fi
        fi
    fi
    
    # Restore from old script backups (if new method didn't work)
    if [[ "$restored" == false ]]; then
        local old_backup
        old_backup=$(ls -t "${JS_FILE}".backup.pve9.* "${JS_FILE}".backup.* 2>/dev/null | head -1)
        if [[ -n "$old_backup" && -f "$old_backup" ]]; then
            if [[ -s "$old_backup" ]] && grep -q "Ext\|function" "$old_backup" && ! grep -q $'\0' "$old_backup"; then
                cp -a "$old_backup" "$JS_FILE"
                msg_ok "$(translate "Restored from old backup: $old_backup")"
                restored=true
            fi
        fi
    fi
    
    # Restore mobile template if patched
    if [[ -f "$MOBILE_TPL" ]] && grep -q "$MARK_MOBILE" "$MOBILE_TPL"; then
        local mobile_backup
        mobile_backup=$(ls -t "$BASE_DIR/backups"/index.html.tpl.backup.* 2>/dev/null | head -1)
        if [[ -n "$mobile_backup" && -f "$mobile_backup" ]]; then
            cp -a "$mobile_backup" "$MOBILE_TPL"
            msg_ok "$(translate "Restored mobile template from backup")"
        else
            # Remove the patch manually if no backup available
            sed -i "/^$MARK_MOBILE$/,\$d" "$MOBILE_TPL"
            msg_ok "$(translate "Removed mobile template patches")"
        fi
    fi
    
    # If no valid backups found, reinstall packages
    if [[ "$restored" == false ]]; then
        msg_info "$(translate "No valid backups found, reinstalling packages...")"
        
        if apt --reinstall install proxmox-widget-toolkit -y >/dev/null 2>&1; then
            msg_ok "$(translate "Reinstalled proxmox-widget-toolkit")"
            restored=true
        else
            msg_error "$(translate "Failed to reinstall proxmox-widget-toolkit")"
        fi
        
        # Also try to reinstall pve-manager if mobile template was patched
        if [[ -f "$MOBILE_TPL" ]] && grep -q "$MARK_MOBILE" "$MOBILE_TPL"; then
            apt --reinstall install pve-manager -y >/dev/null 2>&1 || true
        fi
    fi
    
    rm -f "$MIN_JS_FILE" "$GZ_FILE" 2>/dev/null || true
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true
        
    register_tool "subscription_banner" false
    
    if [[ "$restored" == true ]]; then
        msg_ok "$(translate "Subscription banner restored successfully")"
        msg_ok "$(translate "Refresh your browser to see changes (server restart may be required)")"
    else
        msg_error "$(translate "Failed to restore subscription banner completely")"
        return 1
    fi
}





uninstall_subscription_banner() {
    msg_info "$(translate "Restoring subscription banner...")"
    
    local JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js"
    local MOBILE_UI_FILE="/usr/share/pve-yew-mobile-gui/index.html.tpl"
    local PATCH_BIN="/usr/local/bin/pve-remove-nag-v3.sh"
    local BASE_DIR="/usr/local/share/proxmenux"
    local MIN_JS_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.min.js"
    local GZ_FILE="/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js.gz"
    
    local restored=false
    

    for hook in /etc/apt/apt.conf.d/*nag*; do
        if [[ -e "$hook" ]]; then
            rm -f "$hook"
            msg_ok "$(translate "Removed APT hook: $hook")"
        fi
    done
    
    if [[ -f "$PATCH_BIN" ]]; then
        rm -f "$PATCH_BIN"
        msg_ok "$(translate "Removed patch script: $PATCH_BIN")"
    fi
    
    if [[ -d "$BASE_DIR/backups" ]]; then
        local backup_file
        backup_file=$(ls -t "$BASE_DIR/backups"/proxmoxlib.js.backup.* 2>/dev/null | head -1)
        
        if [[ -n "$backup_file" && -f "$backup_file" ]]; then
            # Verify backup integrity before restoring
            if [[ -s "$backup_file" ]] && grep -q "Ext\|function" "$backup_file" && ! grep -q $'\0' "$backup_file"; then
                cp -a "$backup_file" "$JS_FILE"
                msg_ok "$(translate "Restored desktop UI from backup: $backup_file")"
                restored=true
            else
                msg_warn "$(translate "Backup file appears corrupted, will reinstall packages")"
            fi
        else
            msg_warn "$(translate "No desktop UI backup found, will reinstall packages")"
        fi
        
        local mobile_backup
        mobile_backup=$(ls -t "$BASE_DIR/backups"/index.html.tpl.backup.* 2>/dev/null | head -1)
        
        if [[ -n "$mobile_backup" && -f "$mobile_backup" && -f "$MOBILE_UI_FILE" ]]; then
            if [[ -s "$mobile_backup" ]]; then
                cp -a "$mobile_backup" "$MOBILE_UI_FILE"
                msg_ok "$(translate "Restored mobile UI from backup: $mobile_backup")"
            fi
        fi
    fi
    
    if [[ "$restored" == false ]]; then
        msg_info "$(translate "Performing complete package reinstallation...")"
        
        # Update package lists
        apt-get update >/dev/null 2>&1
        
        # Reinstall packages with force-confnew to restore original configs
        if apt-get --reinstall -o Dpkg::Options::="--force-confnew" install \
            pve-manager proxmox-widget-toolkit libjs-extjs libpve-http-server-perl -y >/dev/null 2>&1; then
            msg_ok "$(translate "Reinstalled Proxmox packages successfully")"
            restored=true
        else
            msg_error "$(translate "Failed to reinstall packages")"
        fi
        
        # Clean package update cache
        rm -rf /var/lib/pve-manager/pkgupdates /var/cache/pve-manager 2>/dev/null || true
        
        # Second pass reinstallation to ensure everything is clean
        apt-get update >/dev/null 2>&1
        apt-get --reinstall install proxmox-widget-toolkit pve-manager libjs-extjs libpve-http-server-perl -y >/dev/null 2>&1 || true
    fi
    
    msg_info "$(translate "Cleaning cached files...")"
    rm -f "$MIN_JS_FILE" "$GZ_FILE" 2>/dev/null || true
    rm -rf /var/lib/pve-manager/pkgupdates /var/cache/pve-manager 2>/dev/null || true
    find /var/cache/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/lib/pve-manager/ -name "*.js*" -delete 2>/dev/null || true
    find /var/cache/nginx/ -type f -delete 2>/dev/null || true
    

    #systemctl restart pveproxy pvedaemon pvestatd 2>/dev/null || true
    
    register_tool "subscription_banner" false
    
    if [[ "$restored" == true ]]; then
        msg_ok "$(translate "Subscription banner restored successfully (desktop and mobile)")"
        msg_ok "$(translate "Refresh your browser to see changes (server restart may be required)")"
    else
        msg_error "$(translate "Failed to restore subscription banner completely")"
        return 1
    fi
}





################################################################

uninstall_time_sync() {
    msg_info "$(translate "Resetting time synchronization...")"
    
    # Reset to UTC (safe default)
    timedatectl set-timezone UTC >/dev/null 2>&1
    
    msg_ok "$(translate "Time synchronization reset to UTC")"
    register_tool "time_sync" false
}

################################################################

uninstall_apt_languages() {
    msg_info "$(translate "Restoring APT language downloads...")"
    
    # Remove the configuration that disables translations
    rm -f /etc/apt/apt.conf.d/99-disable-translations
    
    msg_ok "$(translate "APT language downloads restored")"
    register_tool "apt_languages" false
}

################################################################

uninstall_journald() {
    msg_info "$(translate "Restoring default journald configuration...")"
    
    # Restore default journald configuration
    cat > /etc/systemd/journald.conf << 'EOF'
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.
#
# Entries in this file show the compile time defaults.
# You can change settings by editing this file.
# Defaults can be restored by simply deleting this file.
#
# See journald.conf(5) for details.

[Journal]
#Storage=auto
#Compress=yes
#Seal=yes
#SplitMode=uid
#SyncIntervalSec=5m
#RateLimitInterval=30s
#RateLimitBurst=1000
#SystemMaxUse=
#SystemKeepFree=
#SystemMaxFileSize=
#RuntimeMaxUse=
#RuntimeKeepFree=
#RuntimeMaxFileSize=
#MaxRetentionSec=
#MaxFileSec=1month
#ForwardToSyslog=yes
#ForwardToKMsg=no
#ForwardToConsole=no
#ForwardToWall=yes
#TTYPath=/dev/console
#MaxLevelStore=debug
#MaxLevelSyslog=debug
#MaxLevelKMsg=notice
#MaxLevelConsole=info
#MaxLevelWall=emerg
EOF
    
    systemctl restart systemd-journald.service >/dev/null 2>&1
    
    msg_ok "$(translate "Default journald configuration restored")"
    register_tool "journald" false
}

################################################################

uninstall_logrotate() {
    msg_info "$(translate "Restoring original logrotate configuration...")"

    [ -f /etc/logrotate.d/pveproxy ] && rm -f /etc/logrotate.d/pveproxy

    if [ -f /etc/logrotate.conf.bak ]; then
        mv /etc/logrotate.conf.bak /etc/logrotate.conf
        systemctl restart logrotate >/dev/null 2>&1
        msg_ok "$(translate "Original logrotate configuration restored")"
    else
        msg_warn "$(translate "No backup found, logrotate configuration not changed")"
    fi
    
    register_tool "logrotate" false
}

################################################################

uninstall_system_limits() {
    msg_info "$(translate "Removing system limits optimizations...")"
    
    # Remove ProxMenux sysctl configurations
    rm -f /etc/sysctl.d/99-maxwatches.conf
    rm -f /etc/sysctl.d/99-maxkeys.conf
    rm -f /etc/sysctl.d/99-swap.conf
    rm -f /etc/sysctl.d/99-fs.conf
    
    # Remove ProxMenux limits configuration
    rm -f /etc/security/limits.d/99-limits.conf
    
    # Remove systemd limits (restore defaults)
    for file in /etc/systemd/system.conf /etc/systemd/user.conf; do
        if [ -f "$file" ]; then
            sed -i '/^DefaultLimitNOFILE=256000/d' "$file"
        fi
    done
    
    # Remove PAM limits
    for file in /etc/pam.d/common-session /etc/pam.d/runuser-l; do
        if [ -f "$file" ]; then
            sed -i '/^session required pam_limits.so/d' "$file"
        fi
    done
    
    # Remove ulimit from profile
    if [ -f /root/.profile ]; then
        sed -i '/ulimit -n 256000/d' /root/.profile
    fi
    
    # Reload sysctl
    sysctl --system >/dev/null 2>&1
    
    msg_ok "$(translate "System limits optimizations removed")"
    register_tool "system_limits" false
}

################################################################

uninstall_entropy() {
    msg_info "$(translate "Removing entropy generation optimization...")"
    
    # Stop and disable haveged
    systemctl stop haveged >/dev/null 2>&1
    systemctl disable haveged >/dev/null 2>&1
    
    # Remove haveged package
    apt-get purge -y haveged >/dev/null 2>&1
    
    # Remove configuration
    rm -f /etc/default/haveged
    
    msg_ok "$(translate "Entropy generation optimization removed")"
    register_tool "entropy" false
}

################################################################

uninstall_memory_settings() {
    msg_info "$(translate "Removing memory optimizations...")"
    
    # Remove ProxMenux memory configuration
    rm -f /etc/sysctl.d/99-memory.conf
    
    # Reload sysctl
    sysctl --system >/dev/null 2>&1
    
    msg_ok "$(translate "Memory optimizations removed")"
    register_tool "memory_settings" false
}

################################################################

uninstall_kernel_panic() {
    msg_info "$(translate "Removing kernel panic configuration...")"
    
    # Remove ProxMenux kernel panic configuration
    rm -f /etc/sysctl.d/99-kernelpanic.conf
    
    # Reload sysctl
    sysctl --system >/dev/null 2>&1
    
    msg_ok "$(translate "Kernel panic configuration removed")"
    register_tool "kernel_panic" false
}

################################################################

uninstall_apt_ipv4() {
    msg_info "$(translate "Removing APT IPv4 configuration...")"
    
    # Remove IPv4 force configuration
    rm -f /etc/apt/apt.conf.d/99-force-ipv4
    
    msg_ok "$(translate "APT IPv4 configuration removed")"
    register_tool "apt_ipv4" false
}

################################################################

uninstall_network_optimization() {
    msg_info "$(translate "Removing network optimizations...")"
    
    rm -f /etc/sysctl.d/99-network.conf

    local interfaces_file="/etc/network/interfaces"
    if [ -f "$interfaces_file" ]; then
        if tail -1 "$interfaces_file" | grep -q "^source /etc/network/interfaces.d/\*$"; then
            sed -i '$d' "$interfaces_file"
        fi
    fi
    
    rm -f /etc/sysctl.d/97-proxmenux-fwbr.conf \
        /etc/sysctl.d/98-proxmenux-rpf.conf

    systemctl disable --now proxmenux-fwbr-tune.service >/dev/null 2>&1 || true
    rm -f /etc/systemd/system/proxmenux-fwbr-tune.service

    systemctl daemon-reload >/dev/null 2>&1 || true
    sysctl --system >/dev/null 2>&1 || true

    
    msg_ok "$(translate "Network optimizations removed")"
    register_tool "network_optimization" false
}



################################################################

uninstall_bashrc_custom() {
    msg_info "$(translate "Restoring original bashrc...")"
    
    # Restore original bashrc from backup
    if [ -f /root/.bashrc.bak ]; then
        mv /root/.bashrc.bak /root/.bashrc
        msg_ok "$(translate "Original bashrc restored")"
    else
        # Remove ProxMenux customizations manually
        if [ -f /root/.bashrc ]; then
            # Remove our customization block
            sed -i '/# ProxMenux customizations/,/source \/etc\/profile\.d\/bash_completion\.sh/d' /root/.bashrc
        fi
        msg_ok "$(translate "ProxMenux customizations removed from bashrc")"
    fi
    
    # Remove bash_profile source line if we added it
    if [ -f /root/.bash_profile ]; then
        sed -i '/source \/root\/\.bashrc/d' /root/.bash_profile
    fi
    
    register_tool "bashrc_custom" false
}

################################################################

uninstall_log2ram() {
    msg_info "$(translate "Uninstalling log2ram (all versions)...")"

    systemctl stop log2ram log2ram-daily.timer log2ram-daily.service >/dev/null 2>&1 || true
    systemctl disable log2ram log2ram-daily.timer log2ram-daily.service >/dev/null 2>&1 || true

    rm -f /etc/cron.d/log2ram \
          /etc/cron.d/log2ram-auto-sync \
          /etc/cron.d/log2ram-sync \
          /etc/cron.hourly/log2ram \
          /etc/cron.daily/log2ram \
          /etc/cron.weekly/log2ram \
          /etc/cron.monthly/log2ram 2>/dev/null || true

    rm -f /usr/local/bin/log2ram-check.sh \
          /usr/local/bin/log2ram \
          /usr/local/bin/log2ram-sync \
          /usr/sbin/log2ram \
          /usr/bin/log2ram 2>/dev/null || true

    rm -f /etc/systemd/system/log2ram.service \
          /etc/systemd/system/log2ram-daily.timer \
          /etc/systemd/system/log2ram-daily.service \
          /etc/systemd/system/sysinit.target.wants/log2ram.service \
          /etc/systemd/system/timers.target.wants/log2ram-daily.timer \
          /lib/systemd/system/log2ram.service \
          /lib/systemd/system/log2ram-daily.timer \
          /lib/systemd/system/log2ram-daily.service 2>/dev/null || true
    rm -rf /etc/systemd/system/log2ram.service.d 2>/dev/null || true

    rm -f /etc/log2ram.conf \
          /etc/log2ram.conf.dpkg-old \
          /etc/log2ram.conf.bak \
          /etc/log2ram.conf.save 2>/dev/null || true

    rm -rf /etc/logrotate.d/log2ram 2>/dev/null || true

    if mountpoint -q /var/log 2>/dev/null; then
        if [[ -d /var/log.hdd ]]; then
            msg_info "$(translate "Preserving logs to /var/log.hdd before unmounting...")"
            rsync -a /var/log/ /var/log.hdd/ >/dev/null 2>&1 || true
        fi
        umount /var/log >/dev/null 2>&1 || true
    fi

    [[ -d /var/log.hdd ]] && rm -rf /var/log.hdd
    [[ -d /tmp/log2ram ]] && rm -rf /tmp/log2ram
    [[ -d /var/hdd.log ]] && rm -rf /var/hdd.log
    [[ -f /tmp/log2ram_install.log ]] && rm -f /tmp/log2ram_install.log

    systemctl daemon-reload >/dev/null 2>&1 || true
    systemctl reset-failed >/dev/null 2>&1 || true
    systemctl restart cron >/dev/null 2>&1 || true

    if dpkg -l 2>/dev/null | grep -q '^ii  log2ram'; then
        msg_info "$(translate "Purging log2ram apt package...")"
        apt-get purge -y log2ram >/dev/null 2>&1 || true
        apt-get autoremove -y >/dev/null 2>&1 || true
    fi

    if [[ -f /etc/log2ram.conf ]] || \
       command -v log2ram >/dev/null 2>&1 || \
       systemctl list-units --all 2>/dev/null | grep -q log2ram || \
       [[ -f /etc/cron.d/log2ram-auto-sync ]]; then
        msg_warn "$(translate "Some log2ram files may still exist. Manual cleanup may be required.")"
    else
        msg_ok "$(translate "log2ram completely removed from system")"
    fi

    register_tool "log2ram" false
    NECESSARY_REBOOT=1
}




################################################################

uninstall_persistent_network() {
    local LINK_DIR="/etc/systemd/network"
    
    msg_info "$(translate "Removing all .link files from") $LINK_DIR"
    sleep 2
    
    if ! ls "$LINK_DIR"/*.link >/dev/null 2>&1; then
        msg_warn "$(translate "No .link files found in") $LINK_DIR"
        return 0
    fi

    rm -f "$LINK_DIR"/*.link

    msg_ok "$(translate "Removed all .link files from") $LINK_DIR"
    msg_info "$(translate "Interface names will return to default systemd behavior.")"
    register_tool "persistent_network" false
    NECESSARY_REBOOT=1
}





uninstall_amd_fixes() {
    msg_info2 "$(translate "Reverting AMD (Ryzen/EPYC) fixes...")"
    NECESSARY_REBOOT=1


    if grep -q "root=ZFS=" /proc/cmdline 2>/dev/null; then

        cmdline_file="/etc/kernel/cmdline"
        if [[ -f "$cmdline_file" ]] && grep -q "idle=nomwait" "$cmdline_file"; then
            cp "$cmdline_file" "${cmdline_file}.bak.$(date +%Y%m%d_%H%M%S)" || {
                msg_error "$(translate "Failed to backup $cmdline_file")"
                return 1
            }

            sed -i 's/\bidle=nomwait\b//g; s/[[:space:]]\+/ /g; s/^ //; s/ $//' "$cmdline_file"

            if command -v proxmox-boot-tool >/dev/null 2>&1; then
                proxmox-boot-tool refresh >/dev/null 2>&1 || {
                    msg_error "$(translate "Failed to refresh boot configuration")"
                    return 1
                }
            fi
            msg_ok "$(translate "Removed idle=nomwait from /etc/kernel/cmdline (ZFS)")"
        fi
    else

        grub_file="/etc/default/grub"
        if [[ -f "$grub_file" ]] && grep -q 'GRUB_CMDLINE_LINUX_DEFAULT=' "$grub_file"; then
            if grep -q "idle=nomwait" "$grub_file"; then
                cp "$grub_file" "${grub_file}.bak.$(date +%Y%m%d_%H%M%S)" || {
                    msg_error "$(translate "Failed to backup $grub_file")"
                    return 1
                }

                sed -i -E 's/(GRUB_CMDLINE_LINUX_DEFAULT=")/\1/; s/\bidle=nomwait\b//g' "$grub_file"

                awk -F\" '
                  $1=="GRUB_CMDLINE_LINUX_DEFAULT=" {
                    gsub(/[[:space:]]+/," ",$2); sub(/^ /,"",$2); sub(/ $/,"",$2)
                  }1
                ' OFS="\"" "$grub_file" > "${grub_file}.tmp" && mv "${grub_file}.tmp" "$grub_file"

                update-grub >/dev/null 2>&1 || {
                    msg_error "$(translate "Failed to update GRUB configuration")"
                    return 1
                }
                msg_ok "$(translate "Removed idle=nomwait from GRUB configuration")"
            fi
        fi
    fi


    kvm_conf="/etc/modprobe.d/kvm.conf"
    if [[ -f "$kvm_conf" ]]; then
        if grep -Eq '(ignore_msrs|report_ignored_msrs)' "$kvm_conf"; then
            cp "$kvm_conf" "${kvm_conf}.bak.$(date +%Y%m%d_%H%M%S)" || {
                msg_error "$(translate "Failed to backup $kvm_conf")"
                return 1
            }
            sed -i -E '/ignore_msrs|report_ignored_msrs/d' "$kvm_conf"

            if [[ ! -s "$kvm_conf" ]]; then
                rm -f "$kvm_conf"
                msg_ok "$(translate "Removed empty KVM configuration file")"
            else
                msg_ok "$(translate "Removed KVM MSR options from configuration")"
            fi

            update-initramfs -u -k all >/dev/null 2>&1 || true
        else
            msg_ok "$(translate "KVM MSR options not present, nothing to revert")"
        fi
    fi

    msg_success "$(translate "AMD fixes have been successfully reverted")"
    register_tool "amd_fixes" false
}








################################################################

migrate_installed_tools() {
    if [[ -f "$TOOLS_JSON" ]]; then
        return
    fi
    
    show_proxmenux_logo
    msg_info "$(translate 'Detecting previous optimizations...')"
    
    echo "{}" > "$TOOLS_JSON"
    local updated=false
    

    
    # APT configurations
    if [[ -f /etc/apt/apt.conf.d/99-force-ipv4 ]]; then
        jq '. + {"apt_ipv4": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if [[ -f /etc/apt/apt.conf.d/99-disable-translations ]]; then
        jq '. + {"apt_languages": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    # System configurations
    if [[ -f /etc/sysctl.d/99-memory.conf ]]; then
        jq '. + {"memory_settings": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if [[ -f /etc/sysctl.d/99-network.conf ]]; then
        jq '. + {"network_optimization": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if [[ -f /etc/sysctl.d/99-kernelpanic.conf ]]; then
        jq '. + {"kernel_panic": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if [[ -f /etc/security/limits.d/99-limits.conf ]]; then
        jq '. + {"system_limits": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    # Services
    if systemctl is-active --quiet log2ram 2>/dev/null; then
        jq '. + {"log2ram": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if dpkg -l | grep -q haveged; then
        jq '. + {"entropy": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    # Bashrc customization
    if grep -q "# ProxMenux customizations" /root/.bashrc 2>/dev/null; then
        jq '. + {"bashrc_custom": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    # Subscription banner
    if [[ -f /etc/apt/apt.conf.d/no-nag-script ]]; then
        jq '. + {"subscription_banner": true}' "$TOOLS_JSON" > "$TOOLS_JSON.tmp" && mv "$TOOLS_JSON.tmp" "$TOOLS_JSON"
        updated=true
    fi
    
    if [[ "$updated" == true ]]; then
        sleep 2
        msg_ok "$(translate 'Optimizations detected and ready to revert.')"
        sleep 1
    fi
}

################################################################

show_uninstall_menu() {
    ensure_tools_json
    migrate_installed_tools
    
    mapfile -t tools_installed < <(jq -r 'to_entries | map(select(.value==true)) | .[].key' "$TOOLS_JSON")
    
    if [[ ${#tools_installed[@]} -eq 0 ]]; then
        dialog --backtitle "ProxMenux" --title "ProxMenux" \
               --msgbox "\n\n$(translate "No optimizations detected to uninstall.")" 10 60
        return 0
    fi
    
    local menu_options=()
    for tool in "${tools_installed[@]}"; do
        case "$tool" in
            lvm_repair) desc="LVM PV Headers Repair";;
            repo_cleanup) desc="Repository Cleanup";;
            #apt_upgrade) desc="APT Upgrade & Repository Config";;
            subscription_banner) desc="Subscription Banner Removal";;
            time_sync) desc="Time Synchronization";;
            apt_languages) desc="APT Language Skip";;
            journald) desc="Journald Optimization";;
            logrotate) desc="Logrotate Optimization";;
            system_limits) desc="System Limits Increase";;
            entropy) desc="Entropy Generation (haveged)";;
            memory_settings) desc="Memory Settings Optimization";;
            kernel_panic) desc="Kernel Panic Configuration";;
            apt_ipv4) desc="APT IPv4 Force";;
            kexec) desc="kexec for quick reboots";;
            network_optimization) desc="Network Optimizations";;
            bashrc_custom) desc="Bashrc Customization";;
            figurine) desc="Figurine";;
            fastfetch) desc="Fastfetch";;
            log2ram) desc="Log2ram (SSD Protection)";;
            amd_fixes) desc="AMD CPU (Ryzen/EPYC) fixes";;
            persistent_network) desc="Setting persistent network interfaces";;
            *) desc="$tool";;
        esac
        menu_options+=("$tool" "$desc" "off")
    done
    
    selected_tools=$(dialog --backtitle "ProxMenux" \
                           --title "$(translate "Uninstall Optimizations")" \
                           --checklist "$(translate "Select optimizations to uninstall:")" 20 70 12 \
                           "${menu_options[@]}" 3>&1 1>&2 2>&3)
    
    local dialog_result=$?
    if [[ $dialog_result -ne 0 || -z "$selected_tools" ]]; then
        return 0
    fi
    
    # Show confirmation
    if ! dialog --backtitle "ProxMenux" \
                --title "$(translate "Confirm Uninstallation")" \
                --yesno "\n\n$(translate "Are you sure you want to uninstall the selected optimizations.")" 10 60; then
        return 0
    fi
    
    # Execute uninstallations
    for tool in $selected_tools; do
        tool=$(echo "$tool" | tr -d '"')
        if declare -f "uninstall_$tool" > /dev/null 2>&1; then
            clear
            show_proxmenux_logo
            "uninstall_$tool"
        else
            msg_warn "$(translate "No uninstaller found for:") $tool"
        fi
    done
    
    msg_success "$(translate "Selected optimizations have been uninstalled.")"
    msg_warn "$(translate "A system reboot is recommended to ensure all changes take effect.")"
    echo -e
    msg_success "$(translate "Press Enter to continue...")"
    read -r
    
    if dialog --backtitle "ProxMenux" \
              --title "$(translate "Reboot Recommended")" \
              --yesno "$(translate "Do you want to reboot now?")" 8 50; then
        reboot
    fi
}

################################################################

show_uninstall_menu



================================================
FILE: scripts/share/commands_share.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.5
# Last Updated: 04/08/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

show_command() {
    local step="$1"
    local description="$2"
    local command="$3"
    local note="$4"
    local command_extra="$5"
    
    echo -e "${BGN}${step}.${CL} ${BL}${description}${CL}"
    echo ""
    echo -e "${TAB}${command}"
    echo -e
    [[ -n "$note" ]] && echo -e "${TAB}${DARK_GRAY}${note}${CL}"
    [[ -n "$command_extra" ]] && echo -e "${TAB}${YW}${command_extra}${CL}"
    echo ""
}

show_how_to_enter_lxc() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "How to Access an LXC Terminal from Proxmox Host")"
    
    msg_info2 "$(translate "Use these commands on your Proxmox host to access an LXC container's terminal:")"
    echo -e 
    
    show_command "1" \
        "$(translate "Get a list of all your containers:")" \
        "pct list" \
        "" \
        ""

    show_command "2" \
        "$(translate "Enter the container's terminal")" \
        "pct enter ${CUS}<container-id>${CL}" \
        "$(translate "Replace <container-id> with the actual ID.")"\
        "$(translate "For example: pct enter 101")"

    show_command "3" \
        "$(translate "To exit the container's terminal, press:")" \
        "CTRL + D" \
        "" \
        ""
        
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_host_mount_resources_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Mount Remote Resources on Proxmox Host")"
    
    msg_info2 "$(translate "How to mount NFS and Samba shares directly on the Proxmox host. Proxmox already has the necessary tools installed.")"
    echo -e 

    echo -e "${BOLD}${BL}=== MOUNT NFS SHARE ===${CL}"
    echo -e
    
    show_command "1" \
        "$(translate "Create mount point:")" \
        "mkdir -p ${CUS}/mnt/nfs_share${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""

    show_command "2" \
        "$(translate "Mount NFS share:")" \
        "mount -t nfs ${CUS}192.168.1.100${CL}:${CUS}/path/to/share${CL} ${CUS}/mnt/nfs_share${CL}" \
        "$(translate "Replace IP and paths with your values.")" \
        ""

    show_command "3" \
        "$(translate "Make permanent (optional):")" \
        "echo '${CUS}192.168.1.100${CL}:${CUS}/path/to/share${CL} ${CUS}/mnt/nfs_share${CL} nfs4 rw,hard,intr,_netdev,rsize=1048576,wsize=1048576,timeo=600,retrans=2 0 0' >> /etc/fstab" \
        "$(translate "_netdev waits for network before mounting.")" \
        ""

    echo -e "${BOLD}${BL}=== MOUNT SAMBA SHARE ===${CL}"
    echo -e

    show_command "4" \
        "$(translate "Create mount point:")" \
        "mkdir -p ${CUS}/mnt/samba_share${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""

    show_command "5" \
        "$(translate "Mount Samba share:")" \
        "mount -t cifs //${CUS}192.168.1.100${CL}/${CUS}sharename${CL} ${CUS}/mnt/samba_share${CL} -o username=${CUS}user${CL}" \
        "$(translate "You will be prompted for password. Replace IP, share and user.")" \
        ""

    show_command "6" \
        "$(translate "Make permanent (optional):")" \
        "echo '//${CUS}192.168.1.100${CL}/${CUS}sharename${CL} ${CUS}/mnt/samba_share${CL} cifs username=${CUS}user${CL},password=${CUS}pass${CL},_netdev 0 0' >> /etc/fstab" \
        "$(translate "Replace with your credentials.")" \
        ""

    echo -e "${BOLD}${BL}=== CREATE LOCAL DIRECTORY ===${CL}"
    echo -e

    show_command "7" \
        "$(translate "Create directory:")" \
        "mkdir -p ${CUS}/mnt/local_share${CL}" \
        "$(translate "Creates a local directory on Proxmox host.")" \
        ""

    show_command "8" \
        "$(translate "Set permissions:")" \
        "chmod 755 ${CUS}/mnt/local_share${CL}" \
        "$(translate "Sets basic read/write permissions.")" \
        ""

    show_command "9" \
        "$(translate "Verify mounts:")" \
        "df -h" \
        "$(translate "Shows all mounted filesystems.")" \
        ""
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_host_to_lxc_mount_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Mount Host Directory to LXC Container")"
    
    msg_info2 "$(translate "How to mount a Proxmox host directory into an LXC container. Execute these commands on the Proxmox host.")"
    echo -e 
    
    show_command "1" \
        "$(translate "Add mount point to container:")" \
        "pct set ${CUS}<container-id>${CL} -mp0 ${CUS}/host/directory${CL},mp=${CUS}/container/path${CL},backup=0,shared=1" \
        "$(translate "Replace container-id, host directory and container path.")" \
        "$(translate "Example: pct set 101 -mp0 /mnt/shared,mp=/mnt/shared,,backup=0,shared=1")"

    show_command "2" \
        "$(translate "Restart container:")" \
        "pct reboot ${CUS}<container-id>${CL}" \
        "$(translate "Required to activate the mount point.")" \
        ""

    show_command "3" \
        "$(translate "Verify mount inside container:")" \
        "pct enter ${CUS}<container-id>${CL}
    df -h | grep ${CUS}/container/path${CL}" \
        "$(translate "Check if the directory is mounted.")" \
        ""

    show_command "4" \
        "$(translate "Remove mount point (if needed):")" \
        "pct set ${CUS}<container-id>${CL} --delete mp0" \
        "$(translate "Removes the mount point. Use mp1, mp2, etc. for other mounts.")" \
        ""
    
    echo -e "${BOR}"
    echo -e "${BOLD}$(translate "Notes:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Mount indices:")${CL} ${BL}Use mp0, mp1, mp2, etc. for multiple mounts${CL}"
    echo -e "${TAB}${BGN}$(translate "Permissions:")${CL} ${BL}May need adjustment depending on directory type${CL}"
    echo -e "${TAB}${BGN}$(translate "Container types:")${CL} ${BL}Works with both privileged and unprivileged containers${CL}"
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_nfs_server_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "NFS Server Installation")"
    
    msg_info2 "$(translate "How to install and configure an NFS server in an LXC container.")"
    echo -e 
    
    show_command "1" \
        "$(translate "Update and install packages:")" \
        "apt-get update && apt-get install -y nfs-kernel-server" \
        "" \
        ""

    show_command "2" \
        "$(translate "Create export directory:")" \
        "mkdir -p ${CUS}/mnt/nfs_export${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""
    
    show_command "3" \
        "$(translate "Set directory permissions:")" \
        "chmod 755 ${CUS}/mnt/nfs_export${CL}" \
        "" \
        ""
    
    show_command "4.1" \
        "$(translate "Configure exports (safe root_squash):")" \
        "echo '${CUS}/mnt/nfs_export${CL} ${CUS}192.168.1.0/24${CL}(rw,sync,no_subtree_check,root_squash)' >> /etc/exports" \
        "$(translate "Replace directory path and network range.")" \
        ""

    show_command "4.2" \
        "$(translate "Or Configure exports (map all users):")" \
        "echo '${CUS}/mnt/nfs_export${CL} ${CUS}192.168.1.0/24${CL}(rw,sync,no_subtree_check,all_squash,anonuid=0,anongid=0)' >> /etc/exports" \
        "$(translate "Replace directory path and network range.")" \
        ""

    
    show_command "5" \
        "$(translate "Apply configuration:")" \
        "exportfs -ra" \
        "" \
        ""
    
    show_command "6" \
        "$(translate "Start and enable service:")" \
        "systemctl restart nfs-kernel-server
    systemctl enable nfs-kernel-server" \
        "" \
        ""
    
    show_command "7" \
        "$(translate "Verify exports:")" \
        "showmount -e localhost" \
        "$(translate "Shows available NFS exports.")" \
        ""
    
    echo -e "${BOR}"
    echo -e "${BOLD}$(translate "Export Options:")${CL}"
    echo -e "${TAB}${BGN}$(translate "rw:")${CL} ${BL}Read-write access${CL}"
    echo -e "${TAB}${BGN}$(translate "sync:")${CL} ${BL}Synchronous writes${CL}"
    echo -e "${TAB}${BGN}$(translate "no_subtree_check:")${CL} ${BL}Improves performance${CL}"
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_samba_server_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Samba Server Installation")"
    
    msg_info2 "$(translate "How to install and configure a Samba server in an LXC container.")"
    echo -e
    
    show_command "1" \
        "$(translate "Update and install packages:")" \
        "apt-get update && apt-get install -y samba" \
        "" \
        ""
    
    show_command "2" \
        "$(translate "Create share directory:")" \
        "mkdir -p ${CUS}/mnt/samba_share${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""
    
    show_command "3" \
        "$(translate "Set directory permissions:")" \
        "chmod 755 ${CUS}/mnt/samba_share${CL}" \
        "" \
        ""
    
    show_command "4" \
        "$(translate "Create Samba user:")" \
        "adduser ${CUS}sambauser${CL}
    smbpasswd -a ${CUS}sambauser${CL}" \
        "$(translate "Replace with your username. You'll be prompted for password.")" \
        ""
    
    show_command "5" \
        "$(translate "Configure share:")" \
        "cat >> /etc/samba/smb.conf << EOF
[shared]
    comment = Shared folder
    path = ${CUS}/mnt/samba_share${CL}
    read only = no
    browseable = yes
    valid users = ${CUS}sambauser${CL}
EOF" \
        "$(translate "Replace path and username.")" \
        ""
    
    show_command "6" \
        "$(translate "Restart and enable service:")" \
        "systemctl restart smbd
    systemctl enable smbd" \
        "" \
        ""
    
    show_command "7" \
        "$(translate "Test configuration:")" \
        "smbclient -L localhost -U ${CUS}sambauser${CL}" \
        "$(translate "Lists available shares. You'll be prompted for password.")" \
        ""
    
    echo -e "${BOR}"
    echo -e "${BOLD}$(translate "Connection Examples:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Windows:")${CL} ${YW}\\\\<server-ip>\\shared${CL}"
    echo -e "${TAB}${BGN}$(translate "Linux:")${CL} ${YW}smbclient //server-ip/shared -U sambauser${CL}"
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_nfs_client_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "NFS Client Configuration")"
    
    msg_info2 "$(translate "How to configure an NFS client in an LXC container.")"
    echo -e
    
    show_command "1" \
        "$(translate "Update and install packages:")" \
        "apt-get update && apt-get install -y nfs-common" \
        "" \
        ""

    show_command "2" \
        "$(translate "Create mount point:")" \
        "mkdir -p ${CUS}/mnt/nfsmount${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""

    show_command "3" \
        "$(translate "Mount NFS share:")" \
        "mount -t nfs ${CUS}192.168.1.100${CL}:${CUS}/mnt/nfs_export${CL} ${CUS}/mnt/nfsmount${CL}" \
        "$(translate "Replace server IP and paths.")" \
        ""

    show_command "4" \
        "$(translate "Test access:")" \
        "ls -la ${CUS}/mnt/nfsmount${CL}" \
        "$(translate "Verify you can access the mounted share.")" \
        ""

    show_command "5" \
        "$(translate "Make permanent (optional):")" \
        "echo '${CUS}192.168.1.100${CL}:${CUS}/path/to/share${CL} ${CUS}/mnt/nfs_share${CL} nfs4 rw,hard,intr,_netdev,rsize=1048576,wsize=1048576,timeo=600,retrans=2 0 0' >> /etc/fstab" \
        "$(translate "Replace with your server IP and paths.")" \
        ""
    
    show_command "6" \
        "$(translate "Verify mount:")" \
        "df -h | grep nfs" \
        "$(translate "Shows NFS mounts.")" \
        ""
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_samba_client_help() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Samba Client Configuration")"
    
    msg_info2 "$(translate "How to configure a Samba client in an LXC container.")"
    echo -e
    
    show_command "1" \
        "$(translate "Update and install packages:")" \
        "apt-get update && apt-get install -y cifs-utils" \
        "" \
        ""

    show_command "2" \
        "$(translate "Create mount point:")" \
        "mkdir -p ${CUS}/mnt/sambamount${CL}" \
        "$(translate "Replace with your preferred path.")" \
        ""

    show_command "3" \
        "$(translate "Mount Samba share:")" \
        "mount -t cifs //${CUS}192.168.1.100${CL}/${CUS}shared${CL} ${CUS}/mnt/sambamount${CL} -o username=${CUS}sambauser${CL}" \
        "$(translate "Replace server IP, share name and username. You'll be prompted for password.")" \
        ""

    show_command "4" \
        "$(translate "Test access:")" \
        "ls -la ${CUS}/mnt/sambamount${CL}" \
        "$(translate "Verify you can access the mounted share.")" \
        ""

    show_command "5" \
        "$(translate "Create credentials file (optional):")" \
        "cat > /etc/samba/credentials << EOF
username=${CUS}sambauser${CL}
password=${CUS}your_password${CL}
EOF
chmod 600 /etc/samba/credentials" \
        "$(translate "Secure way to store credentials.")" \
        ""

    show_command "6" \
        "$(translate "Mount with credentials file:")" \
        "mount -t cifs //${CUS}192.168.1.100${CL}/${CUS}shared${CL} ${CUS}/mnt/sambamount${CL} -o credentials=/etc/samba/credentials" \
        "$(translate "No password prompt needed.")" \
        ""

    show_command "7" \
        "$(translate "Make permanent (optional):")" \
        "echo '//${CUS}192.168.1.100${CL}/${CUS}shared${CL} ${CUS}/mnt/sambamount${CL} cifs credentials=/etc/samba/credentials,_netdev 0 0' >> /etc/fstab" \
        "$(translate "Replace with your values.")" \
        ""
    
    show_command "8" \
        "$(translate "Verify mount:")" \
        "df -h | grep cifs" \
        "$(translate "Shows CIFS/Samba mounts.")" \
        ""
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

show_help_menu() {
    while true; do
        CHOICE=$(dialog --title "$(translate "Help & Information")" \
            --menu "$(translate "Select help topic:")" 24 80 14 \
            "0" "$(translate "How to Access an LXC Terminal")" \
            "1" "$(translate "Mount Remote Resources on Proxmox Host")" \
            "2" "$(translate "Mount Host Directory to LXC Container")" \
            "3" "$(translate "NFS Server Installation")" \
            "4" "$(translate "Samba Server Installation")" \
            "5" "$(translate "NFS Client Configuration")" \
            "6" "$(translate "Samba Client Configuration")" \
            "7" "$(translate "Return to Main Menu")" \
            3>&1 1>&2 2>&3)
        
        case $CHOICE in
            0) show_how_to_enter_lxc ;;
            1) show_host_mount_resources_help ;;
            2) show_host_to_lxc_mount_help ;;
            3) show_nfs_server_help ;;
            4) show_samba_server_help ;;
            5) show_nfs_client_help ;;
            6) show_samba_client_help ;;
            7) return ;;
            *) return ;;
        esac
    done
}
show_help_menu



================================================
FILE: scripts/share/group_manager.sh
================================================
#!/usr/bin/env bash
# ==========================================================
# ProxMenux - Shared Groups Manager
# ==========================================================
# Author      : MacRimi
# Description : Manage host groups for shared directories
# ==========================================================

# Configuration
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache


pmx_list_groups() {
    local groups
    groups=$(getent group | awk -F: '$3 >= 1000 && $1 != "nogroup" && $1 !~ /^pve/ {print $1 ":" $3}')
    if [[ -z "$groups" ]]; then
        whiptail --title "$(translate "Groups")" --msgbox "$(translate "No user groups found.")" 8 60
        return
    fi

    show_proxmenux_logo
    msg_title "$(translate "Existing Groups")"
    echo "$groups" | column -t -s: | while read -r name gid; do
        members=$(getent group "$name" | awk -F: '{print $4}')
        echo -e "  â€¢ ${BL}$name${CL} (GID: $gid)  ->  ${YW}${members:-no members}${CL}"
    done
    echo ""
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}



pmx_create_group() {
    group_name=$(dialog --inputbox "$(translate "Enter new group name:")" 10 60 "sharedfiles-new" \
        --title "$(translate "New Group")" 3>&1 1>&2 2>&3) || return
    [[ -z "$group_name" ]] && return

    if getent group "$group_name" >/dev/null; then
        dialog --title "$(translate "Error")" --msgbox "$(translate "Group already exists.")" 8 50
        return
    fi

    if groupadd "$group_name"; then
        show_proxmenux_logo
        msg_title "$(translate "Create Group")"
        msg_ok "$(translate "Group created successfully:") $group_name"
    else
        show_proxmenux_logo
        msg_title "$(translate "Create Group")"
        msg_error "$(translate "Failed to create group.")"
    fi
    
    echo -e
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}



pmx_edit_group() {
    local groups group_name action
    

    groups=$(getent group | awk -F: '$3 >= 1000 && $1 != "nogroup" && $1 !~ /^pve/ {print $1}')
    
    if [[ -z "$groups" ]]; then
        dialog --title "$(translate "Error")" --msgbox "$(translate "No groups available to edit.")" 8 50
        return
    fi


    local menu_options=""
    while read -r group; do
        if [[ -n "$group" ]]; then
            local gid=$(getent group "$group" | cut -d: -f3)
            menu_options="$menu_options $group \"GID:$gid\""
        fi
    done <<< "$groups"


    group_name=$(eval "dialog --title \"$(translate "Edit Group")\" --menu \
        \"$(translate "Select a group:")\" 20 60 10 \
        $menu_options 3>&1 1>&2 2>&3")
    
    if [[ -z "$group_name" ]]; then
        return
    fi


    action=$(dialog --title "$(translate "Edit Group")" --menu \
        "$(translate "What do you want to edit in group:") $group_name" 15 60 3 \
        "rename" "$(translate "Rename group")" \
        "gid"    "$(translate "Change GID")" \
        "users"  "$(translate "Add/Remove users")" 3>&1 1>&2 2>&3)
    
    if [[ -z "$action" ]]; then
        return
    fi

    case "$action" in
        rename)
            new_name=$(dialog --inputbox "$(translate "Enter new group name:")" 10 60 \
                "$group_name" --title "$(translate "Rename Group")" 3>&1 1>&2 2>&3)
            if [[ -n "$new_name" && "$new_name" != "$group_name" ]]; then
                if groupmod -n "$new_name" "$group_name" 2>/dev/null; then
                    show_proxmenux_logo
                    msg_title "$(translate "Rename Group")"
                    msg_ok "$(translate "Group renamed to:") $new_name"
                else
                    show_proxmenux_logo
                    msg_title "$(translate "Rename Group")"
                    msg_error "$(translate "Failed to rename group")"
                fi
            fi
            ;;
        gid)
            current_gid=$(getent group "$group_name" | cut -d: -f3)
            new_gid=$(dialog --inputbox "$(translate "Enter new GID:")" 10 60 \
                "$current_gid" --title "$(translate "Change GID")" 3>&1 1>&2 2>&3)
            if [[ -n "$new_gid" && "$new_gid" != "$current_gid" ]]; then
                if groupmod -g "$new_gid" "$group_name" 2>/dev/null; then
                    show_proxmenux_logo
                    msg_title "$(translate "Change GID")"
                    msg_ok "$(translate "GID changed to:") $new_gid"
                else
                    show_proxmenux_logo
                    msg_title "$(translate "Change GID")"
                    msg_error "$(translate "Failed to change GID")"
                fi
            fi
            ;;
        users)
            user_action=$(dialog --title "$(translate "User Management")" --menu \
                "$(translate "Choose an action for group:") $group_name" 15 60 2 \
                "add" "$(translate "Add user to group")" \
                "remove" "$(translate "Remove user from group")" 3>&1 1>&2 2>&3)

            case "$user_action" in
                add)
                    username=$(dialog --inputbox "$(translate "Enter username to add:")" 10 60 \
                        --title "$(translate "Add User")" 3>&1 1>&2 2>&3)
                    if [[ -n "$username" ]]; then
                        if id "$username" >/dev/null 2>&1; then
                            if usermod -aG "$group_name" "$username" 2>/dev/null; then
                                show_proxmenux_logo
                                msg_title "$(translate "Add User")"
                                msg_ok "$(translate "User added:") $username"
                            else
                                show_proxmenux_logo
                                msg_title "$(translate "Add User")"
                                msg_error "$(translate "Failed to add user")"
                            fi
                        else
                            show_proxmenux_logo
                            msg_title "$(translate "Add User")"
                            msg_error "$(translate "User does not exist:") $username"
                        fi
                    fi
                    ;;
                remove)
                    members=$(getent group "$group_name" | awk -F: '{print $4}' | tr ',' ' ')
                    if [[ -z "$members" ]]; then
                        dialog --title "$(translate "Info")" --msgbox "$(translate "No users in this group.")" 8 50
                        return
                    fi
                    

                    local user_options=""
                    for user in $members; do
                        user_options="$user_options $user \"\""
                    done
                    
                    username=$(eval "dialog --title \"$(translate "Remove User")\" --menu \
                        \"$(translate "Select user to remove:")\" 15 60 5 \
                        $user_options 3>&1 1>&2 2>&3")
                    
                    if [[ -n "$username" ]]; then
                        if gpasswd -d "$username" "$group_name" 2>/dev/null; then
                            show_proxmenux_logo
                            msg_title "$(translate "Remove User")"
                            msg_ok "$(translate "User removed:") $username"
                        else
                            show_proxmenux_logo
                            msg_title "$(translate "Remove User")"
                            msg_error "$(translate "Failed to remove user")"
                        fi
                    fi
                    ;;
            esac
            ;;
    esac
    

    echo -e
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}



pmx_delete_group() {
    local groups group_name menu_options
    groups=$(getent group | awk -F: '$3 >= 1000 && $1 != "nogroup" && $1 !~ /^pve/ {print $1}')
    
    if [[ -z "$groups" ]]; then
        dialog --title "$(translate "Error")" --msgbox "$(translate "No groups available to delete.")" 8 50
        return
    fi


    menu_options=""
    while read -r group; do
        if [[ -n "$group" ]]; then
            menu_options="$menu_options $group \"\""
        fi
    done <<< "$groups"

    group_name=$(eval "dialog --title \"$(translate "Delete Group")\" --menu \
        \"$(translate "Select a group to delete:")\" 20 60 10 \
        $menu_options 3>&1 1>&2 2>&3") || return

    if dialog --yesno "$(translate "Are you sure you want to delete group:") $group_name ?" 10 60; then
        if groupdel "$group_name" 2>/dev/null; then
            show_proxmenux_logo
            msg_title "$(translate "Deleting Groups")"
            msg_ok "$(translate "Group deleted:") $group_name"
        else
                        show_proxmenux_logo
            msg_title "$(translate "Deleting Groups")"
            msg_ok "$(translate "Group deleted:") $group_name"
            msg_error "$(translate "Failed to delete group")"
        fi
    fi
    echo -e
    msg_success "$(translate "Press Enter to continue...")"
    read -r
}


pmx_manage_groups() {
    while true; do
        CHOICE=$(dialog --title "$(translate "Shared Groups Manager")" \
            --menu "$(translate "Select an option:")" 20 70 10 \
            "list"   "$(translate "View existing groups")" \
            "create" "$(translate "Create new group")" \
            "edit"   "$(translate "Edit existing group")" \
            "delete" "$(translate "Delete a group")" \
            "exit"   "$(translate "Exit")" \
            3>&1 1>&2 2>&3) || return 0

        case "$CHOICE" in
            list) pmx_list_groups ;;
            create) pmx_create_group ;;
            edit) pmx_edit_group ;;
            delete) pmx_delete_group ;;
            exit) return 0 ;;
        esac
    done
}


pmx_manage_groups



================================================
FILE: scripts/share/guia.md
================================================
# ğŸ“˜ GuÃ­a Completa: Compartir Recursos entre Proxmox Host y Contenedores LXC

## ğŸ“‹ Ãndice

1. [Conceptos Fundamentales](#1-conceptos-fundamentales)
   - [Usuarios y Grupos en Linux](#usuarios-y-grupos-en-linux)
   - [Permisos BÃ¡sicos](#permisos-bÃ¡sicos)
   - [El Bit Setgid](#el-bit-setgid)
   - [Access Control Lists (ACL)](#access-control-lists-acl)
   - [Contenedores Privilegiados vs No Privilegiados](#contenedores-privilegiados-vs-no-privilegiados)

2. [CÃ³mo Funcionan los Permisos en Recursos Compartidos](#2-cÃ³mo-funcionan-los-permisos-en-recursos-compartidos)
   - [Servidores NFS](#servidores-nfs)
   - [Servidores Samba/CIFS](#servidores-sambacifs)
   - [Directorios Locales](#directorios-locales)

3. [PreparaciÃ³n del Host Proxmox](#3-preparaciÃ³n-del-host-proxmox)
   - [Crear Directorio Local](#crear-directorio-local)
   - [Montar Recurso NFS](#montar-recurso-nfs)
   - [Montar Recurso Samba](#montar-recurso-samba)

4. [ConfiguraciÃ³n de Contenedores](#4-configuraciÃ³n-de-contenedores)
   - [Contenedores Privilegiados](#contenedores-privilegiados)
   - [Contenedores No Privilegiados](#contenedores-no-privilegiados)

5. [Montaje en Contenedores](#5-montaje-en-contenedores)

6. [VerificaciÃ³n y Pruebas](#6-verificaciÃ³n-y-pruebas)

7. [SoluciÃ³n de Problemas](#7-soluciÃ³n-de-problemas)

---

## 1. Conceptos Fundamentales

### Usuarios y Grupos en Linux

#### Â¿QuÃ© es un Usuario?

Un **usuario** en Linux es una identidad que puede:
- Poseer archivos y directorios
- Ejecutar procesos
- Tener permisos especÃ­ficos

Cada usuario tiene:
- **Nombre**: Como `root`, `www-data`, `juan`, `jonatan`, `proxmenux`, `rafa` etc...
- **UID (User ID)**: NÃºmero Ãºnico, como `0` (root), `33` (www-data), `1000` (primer usuario),`1001` (segundo usuario), etc...

```bash
# Ver informaciÃ³n de un usuario
id www-data
# Salida: uid=33(www-data) gid=33(www-data) groups=33(www-data)


# Listar todos los usuarios del sistema
cat /etc/passwd | head -5
# Salida:
# root:x:0:0:root:/root:/bin/bash
# daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
# bin:x:2:2:bin:/bin:/usr/sbin/nologin
```

#### Â¿QuÃ© es un Grupo?

Un **grupo** es una colecciÃ³n de usuarios que comparten permisos. Permite:
- Dar acceso a mÃºltiples usuarios sin configurar cada uno individualmente
- Organizar permisos de manera lÃ³gica
- Simplificar la administraciÃ³n

Cada grupo tiene:
- **Nombre**: Como `root`, `www-data`, `sharedfiles`
- **GID (Group ID)**: NÃºmero Ãºnico, como `0` (root), `33` (www-data), `1000` (usuarios)

```bash
# Ver todos los grupos
cat /etc/group | head -5
# Salida:
# root:x:0:
# daemon:x:1:
# bin:x:2:


# Ver grupos de un usuario
groups www-data
# Salida: www-data : www-data


# Crear un nuevo grupo
groupadd -g 1001 migrupo


# AÃ±adir usuario a un grupo
usermod -aG migrupo www-data
```

#### Â¿Por quÃ© son importantes los grupos?

**Ejemplo prÃ¡ctico**: Tienes 3 contenedores que ejecutan aplicaciones web:
- **Sin grupos**: TendrÃ­as que dar permisos individuales a cada usuario de cada contenedor
- **Con grupos**: Creas un grupo `webapps`, aÃ±ades todos los usuarios web, y das permisos al grupo

### Permisos BÃ¡sicos

#### Tipos de Permisos

Cada archivo y directorio tiene tres tipos de permisos para tres categorÃ­as de usuarios:

| Permiso | SÃ­mbolo | Valor | En Archivos | En Directorios |
|---------|---------|-------|-------------|----------------|
| **Lectura** | `r` | 4 | Leer contenido | Listar archivos |
| **Escritura** | `w` | 2 | Modificar archivo | Crear/eliminar archivos |
| **EjecuciÃ³n** | `x` | 1 | Ejecutar archivo | Entrar al directorio |

#### CategorÃ­as de Usuarios

| CategorÃ­a | DescripciÃ³n | PosiciÃ³n |
|-----------|-------------|----------|
| **Propietario** (user) | El dueÃ±o del archivo | Primera posiciÃ³n |
| **Grupo** (group) | Miembros del grupo propietario | Segunda posiciÃ³n |
| **Otros** (others) | Todos los demÃ¡s usuarios | Tercera posiciÃ³n |

#### Lectura de Permisos

```bash
ls -l /mnt/ejemplo
# Salida: drwxrwxr-x 2 root sharedfiles 4096 sep  8 10:30 ejemplo
#         â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚â”‚
#         â”‚â””â”´â”´â”´â”´â”´â”´â”´â”€ Permisos
#         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Tipo (d=directorio, -=archivo)


# Desglose de permisos: rwxrwxr-x
# Propietario (root): rwx = 7 (lectura + escritura + ejecuciÃ³n)
# Grupo (sharedfiles): rwx = 7 (lectura + escritura + ejecuciÃ³n)  
# Otros: r-x = 5 (lectura + ejecuciÃ³n, sin escritura)
```

#### Permisos NumÃ©ricos

Los permisos se pueden expresar como nÃºmeros de 3 dÃ­gitos:

```bash
# Ejemplos comunes
chmod 755 archivo    # rwxr-xr-x (propietario: todo, otros: lectura+ejecuciÃ³n)
chmod 644 archivo    # rw-r--r-- (propietario: lectura+escritura, otros: solo lectura)
chmod 775 directorio # rwxrwxr-x (propietario y grupo: todo, otros: lectura+ejecuciÃ³n)
```

### El Bit Setgid

El **setgid** es uno de los conceptos mÃ¡s importantes para directorios compartidos, pero tambiÃ©n uno de los menos comprendidos.

#### Â¿QuÃ© hace el setgid?

Cuando se aplica a un directorio, el **setgid** hace que:
- **Todos los archivos y subdirectorios creados dentro hereden automÃ¡ticamente el grupo del directorio padre**
- **No importa quÃ© usuario o proceso cree el archivo, siempre tendrÃ¡ el mismo grupo**

#### Ejemplo PrÃ¡ctico: Sin setgid

```bash
# Crear directorio sin setgid
mkdir /tmp/sin_setgid
chmod 775 /tmp/sin_setgid
chgrp sharedfiles /tmp/sin_setgid


ls -ld /tmp/sin_setgid
# Salida: drwxrwxr-x 2 root sharedfiles 4096 sep  8 10:30 /tmp/sin_setgid
#               â†‘ No hay 's' en la posiciÃ³n del grupo


# Crear archivo como usuario www-data
sudo -u www-data touch /tmp/sin_setgid/archivo1
ls -l /tmp/sin_setgid/archivo1
# Salida: -rw-r--r-- 1 www-data www-data 0 sep  8 10:35 archivo1
# âŒ El archivo pertenece al grupo 'www-data', NO 'sharedfiles'


# Crear archivo como usuario root
touch /tmp/sin_setgid/archivo2
ls -l /tmp/sin_setgid/archivo2
# Salida: -rw-r--r-- 1 root root 0 sep  8 10:36 archivo2
# âŒ El archivo pertenece al grupo 'root', NO 'sharedfiles'
```

**Problema**: Cada usuario crea archivos con su grupo primario, causando inconsistencias.

#### Ejemplo PrÃ¡ctico: Con setgid

```bash
# Crear directorio CON setgid
mkdir /tmp/con_setgid  
chmod 2775 /tmp/con_setgid  # El '2' inicial activa setgid
chgrp sharedfiles /tmp/con_setgid


ls -ld /tmp/con_setgid
# Salida: drwxrwsr-x 2 root sharedfiles 4096 sep  8 10:37 /tmp/con_setgid
#               â†‘ La 's' indica que setgid estÃ¡ activo


# Crear archivo como usuario www-data
sudo -u www-data touch /tmp/con_setgid/archivo1
ls -l /tmp/con_setgid/archivo1
# Salida: -rw-r--r-- 1 www-data sharedfiles 0 sep  8 10:38 archivo1
# âœ… El archivo hereda el grupo 'sharedfiles' del directorio padre


# Crear archivo como usuario root
touch /tmp/con_setgid/archivo2
ls -l /tmp/con_setgid/archivo2
# Salida: -rw-r--r-- 1 root sharedfiles 0 sep  8 10:39 archivo2
# âœ… El archivo tambiÃ©n hereda el grupo 'sharedfiles'


# Crear subdirectorio
mkdir /tmp/con_setgid/subdir
ls -ld /tmp/con_setgid/subdir
# Salida: drwxr-sr-x 2 root sharedfiles 4096 sep  8 10:40 subdir
# âœ… El subdirectorio hereda el grupo Y tambiÃ©n tiene setgid activo
```

#### Â¿Por quÃ© es crucial setgid para recursos compartidos?

1. **Consistencia**: Todos los archivos tienen el mismo grupo, independientemente de quiÃ©n los cree
2. **Simplicidad**: No necesitas cambiar manualmente el grupo de cada archivo nuevo
3. **Herencia**: Los subdirectorios tambiÃ©n heredan el setgid, manteniendo la consistencia en toda la estructura
4. **Compatibilidad**: Funciona con NFS, Samba, y contenedores sin configuraciÃ³n adicional

### Access Control Lists (ACL)

#### Limitaciones de los Permisos Tradicionales

Los permisos tradicionales de Linux solo permiten:
- **1 propietario**
- **1 grupo**
- **Permisos para "otros"**

**Problema**: Â¿QuÃ© pasa si necesitas que 3 grupos diferentes tengan acceso de escritura?

#### Â¿QuÃ© son las ACL?

Las **Access Control Lists (ACL)** extienden los permisos tradicionales permitiendo:
- **MÃºltiples usuarios** con permisos especÃ­ficos
- **MÃºltiples grupos** con permisos especÃ­ficos
- **Permisos por defecto** que se heredan automÃ¡ticamente

```bash
# Instalar herramientas ACL
apt-get install acl

# Ver ACL de un archivo/directorio
getfacl /mnt/shared
# Salida:
# file: mnt/shared
# owner: root
# group: sharedfiles
# user::rwx
# group::rwx
# group:webapps:rwx
# group:developers:r-x
# other::r-x
# default:user::rwx
# default:group::rwx
# default:group:webapps:rwx
# default:other::r-x
```

#### Configurar ACL

```bash
# Dar permisos a un grupo especÃ­fico
setfacl -m g:webapps:rwx /mnt/shared

# Dar permisos a un usuario especÃ­fico  
setfacl -m u:juan:rw /mnt/shared

# Configurar permisos por defecto (se heredan)
setfacl -d -m g:webapps:rwx /mnt/shared

# Aplicar ACL recursivamente a todo el contenido existente
setfacl -R -m g:webapps:rwx /mnt/shared

# Combinar: aplicar a existente Y configurar por defecto
setfacl -R -m g:webapps:rwx /mnt/shared
setfacl -d -m g:webapps:rwx /mnt/shared
```

#### Â¿Por quÃ© son importantes las ACL para NFS y Samba?

**NFS y mapeo de IDs**:
- NFS transmite solo nÃºmeros (UID/GID), no nombres
- Si el cliente tiene usuarios con IDs diferentes, los permisos se rompen
- Las ACL aseguran que el grupo correcto siempre tenga acceso

**Ejemplo prÃ¡ctico**:
```bash
# Servidor NFS: usuario 'web' tiene UID 1001
# Cliente NFS: usuario 'web' tiene UID 1002

# Sin ACL: El cliente ve archivos del UID 1001 (usuario inexistente)
# Con ACL: El grupo 'webapps' siempre tiene acceso, independiente de UIDs
```

### Contenedores Privilegiados vs No Privilegiados

#### Â¿QuÃ© son los Contenedores No Privilegiados?

Los contenedores **no privilegiados** son mÃ¡s seguros porque:
- El usuario `root` del contenedor NO es `root` del host
- Los IDs de usuario/grupo estÃ¡n "desplazados"
- Limitan el daÃ±o si el contenedor es comprometido

#### Mapeo de IDs

En un contenedor no privilegiado tÃ­pico:

| Contenedor | Host | ExplicaciÃ³n |
|------------|------|-------------|
| UID 0 (root) | UID 100000 | Root del contenedor = usuario 100000 del host |
| UID 1 | UID 100001 | Usuario 1 del contenedor = usuario 100001 del host |
| UID 1000 (usuario) | UID 101000 | Usuario 1000 del contenedor = usuario 101000 del host |
| GID 0 (root) | GID 100000 | Grupo root del contenedor = grupo 100000 del host |
| GID 1000 (grupo) | GID 101000 | Grupo 1000 del contenedor = grupo 101000 del host |

#### El Problema en la PrÃ¡ctica

```bash
# En el HOST: Crear archivo con grupo 'sharedfiles' (GID 1000)
echo "datos" > /mnt/shared/archivo.txt
chgrp sharedfiles /mnt/shared/archivo.txt
ls -l /mnt/shared/archivo.txt
# Salida: -rw-r--r-- 1 root sharedfiles 6 sep  8 archivo.txt


# En el CONTENEDOR NO PRIVILEGIADO: Ver el mismo archivo
pct exec 101 -- ls -l /mnt/shared/archivo.txt
# Salida: -rw-r--r-- 1 nobody nogroup 6 sep  8 archivo.txt
# âŒ El contenedor ve 'nobody:nogroup' porque no conoce el GID 1000 del host
```

#### Â¿Por quÃ© pasa esto?

1. **Host**: El archivo pertenece al GID 1000 (`sharedfiles`)
2. **Contenedor**: Busca quÃ© grupo tiene GID 1000 en SU `/etc/group`
3. **Resultado**: Si no existe ese GID en el contenedor, muestra `nogroup`
4. **Consecuencia**: El usuario del contenedor no puede escribir

---

## 2. CÃ³mo Funcionan los Permisos en Recursos Compartidos

### Servidores NFS

#### Â¿CÃ³mo maneja NFS los permisos?

Los servidores NFS (ya sean Linux, TrueNAS, Synology, etc.) funcionan de manera similar:

1. **Solo transmiten nÃºmeros**: NFS envÃ­a UID/GID numÃ©ricos, no nombres de usuario
2. **No hay autenticaciÃ³n de usuario**: NFS confÃ­a en que el cliente ya autenticÃ³ al usuario
3. **Los permisos se evalÃºan en el servidor**: El servidor NFS verifica permisos usando sus propios archivos `/etc/passwd` y `/etc/group`

#### Ejemplo con TrueNAS

```bash
# En TrueNAS: Crear dataset con permisos
# Dataset: /mnt/pool/shared
# Propietario: root (UID 0)
# Grupo: shared (GID 1001)  
# Permisos: 775


# En Proxmox: Montar el NFS
mount -t nfs 192.168.1.100:/mnt/pool/shared /mnt/truenas_shared


# Ver cÃ³mo se ven los permisos en Proxmox
ls -ld /mnt/truenas_shared
# Salida: drwxrwxr-x 2 root 1001 4096 sep  8 10:45 /mnt/truenas_shared
#                        â†‘ Aparece el GID numÃ©rico porque Proxmox no tiene grupo con GID 1001
```

#### SoluciÃ³n: Crear grupo con el mismo GID

```bash
# En Proxmox: Crear grupo con el mismo GID que TrueNAS
groupadd -g 1001 truenas_shared


# Ahora se ve correctamente
ls -ld /mnt/truenas_shared
# Salida: drwxrwxr-x 2 root truenas_shared 4096 sep  8 10:45 /mnt/truenas_shared
```

#### Configuraciones comunes en servidores NFS

**TrueNAS/FreeNAS**:
- Maptype: Unix
- Usuario: root o usuario especÃ­fico
- Grupo: wheel, shared, o grupo personalizado

**Synology**:
- Squash: No mapping
- Usuario: root o admin
- Grupo: users o grupo personalizado

**Linux (Ubuntu/Debian)**:
```bash
# /etc/exports
/export/shared 192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)
```

### Servidores Samba/CIFS

#### Â¿CÃ³mo maneja Samba los permisos?

Samba es mÃ¡s complejo porque debe mapear entre:
1. **Usuarios Windows** (autenticaciÃ³n SMB)
2. **Usuarios Linux** (permisos del sistema de archivos)

#### Ejemplo con Synology

```bash
# En Synology: Crear carpeta compartida
# Nombre: SharedData
# Permisos SMB: Grupo 'users' con lectura/escritura
# Permisos Linux: 775, propietario 'admin', grupo 'users'


# En Proxmox: Montar Samba
mount -t cifs //192.168.1.200/SharedData /mnt/synology_shared \
  -o username=admin,password=mipassword,uid=root,gid=1000,file_mode=0664,dir_mode=0775


# Ver permisos
ls -ld /mnt/synology_shared
# Salida: drwxrwxr-x 2 root 1000 4096 sep  8 10:50 /mnt/synology_shared
#                        â†‘ Usa el GID especificado en las opciones de montaje
```

#### Opciones importantes de montaje CIFS

- `uid=`: UID que se asigna a todos los archivos
- `gid=`: GID que se asigna a todos los archivos  
- `file_mode=`: Permisos para archivos (ej: 0664)
- `dir_mode=`: Permisos para directorios (ej: 0775)
- `forceuid/forcegid`: Fuerza el uso de uid/gid especificados

### Directorios Locales

Los directorios locales son los mÃ¡s simples:
- Los permisos se respetan directamente
- No hay mapeo de red
- Funciona con usuarios y grupos locales del sistema

---

## 3. PreparaciÃ³n del Host Proxmox

### Crear Directorio Local

Para crear un directorio local que se compartirÃ¡ con contenedores:

```bash
# 1. Crear directorio
mkdir -p /mnt/local_shared


# 2. Crear grupo comÃºn (usaremos GID 101000 para compatibilidad universal)
groupadd -g 101000 sharedfiles


# 3. Configurar propietario y permisos con setgid
chown root:sharedfiles /mnt/local_shared
chmod 2775 /mnt/local_shared


# 4. Aplicar ACL para garantizar permisos
setfacl -R -m g:sharedfiles:rwx /mnt/local_shared
setfacl -d -m g:sharedfiles:rwx /mnt/local_shared


# 5. Verificar configuraciÃ³n
ls -ld /mnt/local_shared
# Salida esperada: drwxrwsr-x+ 2 root sharedfiles 4096 sep  8 11:00 /mnt/local_shared
#                       â†‘ 's' indica setgid activo
#                          â†‘ '+' indica ACL aplicadas


getfacl /mnt/local_shared
# Salida esperada:
# file: mnt/local_shared
# owner: root
# group: sharedfiles
# user::rwx
# group::rwx
# other::r-x
# default:user::rwx
# default:group::rwx
# default:other::r-x
```

### Montar Recurso NFS

#### Montaje Temporal

```bash
# 1. Crear punto de montaje
mkdir -p /mnt/nfs_shared


# 2. Montar NFS
mount -t nfs 192.168.1.100:/export/shared /mnt/nfs_shared


# 3. Verificar montaje
df -h | grep nfs
mount | grep nfs


# 4. Ver permisos originales
ls -ld /mnt/nfs_shared
# Ejemplo: drwxrwxr-x 2 root 1001 4096 sep  8 11:05 /mnt/nfs_shared
```

#### Crear Grupo Compatible

```bash
# Si el directorio NFS tiene un GID especÃ­fico (ej: 1001), crear grupo local
groupadd -g 1001 nfs_shared


# Verificar que ahora se ve el nombre del grupo
ls -ld /mnt/nfs_shared
# Salida: drwxrwxr-x 2 root nfs_shared 4096 sep  8 11:05 /mnt/nfs_shared
```

#### Aplicar ConfiguraciÃ³n Universal

```bash
# Para compatibilidad con contenedores, aplicar nuestro esquema estÃ¡ndar
# IMPORTANTE: Solo si tienes permisos de escritura en el NFS


# Crear nuestro grupo estÃ¡ndar
groupadd -g 101000 sharedfiles


# Cambiar grupo del directorio NFS (si es posible)
chgrp sharedfiles /mnt/nfs_shared


# Aplicar setgid y ACL
chmod 2775 /mnt/nfs_shared
setfacl -R -m g:sharedfiles:rwx /mnt/nfs_shared
setfacl -d -m g:sharedfiles:rwx /mnt/nfs_shared
```

#### Montaje Persistente

```bash
# Editar /etc/fstab
nano /etc/fstab


# AÃ±adir lÃ­nea:
192.168.1.100:/export/shared /mnt/nfs_shared nfs rw,hard,nofail,rsize=131072,wsize=131072,timeo=600,retrans=2,_netdev 0 0


# ExplicaciÃ³n de opciones:
# rw: lectura/escritura
# hard: reintentar indefinidamente si el servidor no responde
# nofail: no fallar el arranque si no se puede montar
# rsize/wsize: tamaÃ±o de buffer para lectura/escritura (mejor rendimiento)
# timeo: timeout en dÃ©cimas de segundo (60 segundos)
# retrans: nÃºmero de reintentos antes de reportar error
# _netdev: esperar a que la red estÃ© disponible
# 0 0: no hacer dump ni fsck (siempre para recursos de red)

# Probar montaje
mount -a


# Verificar
df -h | grep nfs
```

### Montar Recurso Samba

#### Crear Archivo de Credenciales

```bash
# Crear archivo de credenciales seguro
nano /etc/cifs-credentials


# Contenido:
username=tu_usuario
password=tu_password
domain=tu_dominio


# Proteger archivo
chmod 600 /etc/cifs-credentials
chown root:root /etc/cifs-credentials
```

#### Montaje Temporal

```bash
# 1. Crear punto de montaje
mkdir -p /mnt/samba_shared


# 2. Montar Samba con opciones especÃ­ficas
mount -t cifs //192.168.1.200/SharedData /mnt/samba_shared \
  -o credentials=/etc/cifs-credentials,uid=root,gid=101000,file_mode=0664,dir_mode=2775,iocharset=utf8,vers=3.0


# ExplicaciÃ³n de opciones:
# credentials: archivo con usuario/password
# uid=root: todos los archivos aparecen como propietario root
# gid=101000: todos los archivos aparecen con grupo sharedfiles
# file_mode=0664: permisos para archivos (rw-rw-r--)
# dir_mode=2775: permisos para directorios (rwxrwsr-x) con setgid
# iocharset=utf8: codificaciÃ³n de caracteres
# vers=3.0: versiÃ³n del protocolo SMB


# 3. Verificar montaje
df -h | grep cifs
ls -ld /mnt/samba_shared
```

#### Configurar Grupo y Permisos

```bash
# Crear grupo si no existe
groupadd -g 101000 sharedfiles


# Verificar que los permisos son correctos
ls -ld /mnt/samba_shared
# Salida esperada: drwxrwsr-x 2 root sharedfiles 4096 sep  8 11:10 /mnt/samba_shared


# Aplicar ACL adicionales si es necesario
setfacl -R -m g:sharedfiles:rwx /mnt/samba_shared
setfacl -d -m g:sharedfiles:rwx /mnt/samba_shared
```

#### Montaje Persistente

```bash
# Editar /etc/fstab
nano /etc/fstab


# AÃ±adir lÃ­nea:
//192.168.1.200/SharedData /mnt/samba_shared cifs credentials=/etc/cifs-credentials,uid=root,gid=101000,file_mode=0664,dir_mode=2775,iocharset=utf8,vers=3.0,_netdev,nofail 0 0


# Probar montaje
mount -a


# Verificar
df -h | grep cifs
```

---

## 4. ConfiguraciÃ³n de Contenedores

### Contenedores Privilegiados

Los contenedores privilegiados comparten los mismos UIDs/GIDs que el host, por lo que la configuraciÃ³n es mÃ¡s directa.

#### Â¿Necesitan configuraciÃ³n especial?

**Respuesta corta**: Generalmente NO, pero hay casos donde SÃ es recomendable.

#### CuÃ¡ndo NO necesitan configuraciÃ³n

Si el contenedor privilegiado:
- Solo usa el usuario `root`
- No ejecuta servicios con usuarios especÃ­ficos (como `www-data`)
- Los archivos siempre se crean como `root:root`

```bash
# Ejemplo: Contenedor que solo usa root
pct exec 100 -- bash
whoami  # root
id      # uid=0(root) gid=0(root) groups=0(root)


# Crear archivo en directorio compartido
echo "test" > /mnt/shared/archivo.txt
ls -l /mnt/shared/archivo.txt
# Salida: -rw-r--r-- 1 root root 5 sep  8 11:15 archivo.txt
# âŒ El archivo pertenece al grupo 'root', no 'sharedfiles'
```

#### CuÃ¡ndo SÃ necesitan configuraciÃ³n

Si el contenedor privilegiado:
- Ejecuta servicios web (`www-data`, `nginx`, `apache`)
- Tiene aplicaciones que crean archivos con usuarios especÃ­ficos
- Necesita compatibilidad con otros contenedores o servicios

```bash
# Ejemplo: Contenedor con Nextcloud
pct exec 100 -- bash


# Ver usuarios del sistema
cat /etc/passwd | grep -E "(www-data|nginx|apache)"
# Salida: www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin


# Sin configuraciÃ³n: Nextcloud crea archivos como www-data:www-data
sudo -u www-data touch /mnt/shared/nextcloud_file.txt
ls -l /mnt/shared/nextcloud_file.txt
# Salida: -rw-r--r-- 1 www-data www-data 0 sep  8 11:20 nextcloud_file.txt
# âŒ Grupo 'www-data' no es compatible con otros contenedores
```

#### ConfiguraciÃ³n Recomendada para Contenedores Privilegiados

```bash
# 1. Entrar al contenedor
pct exec 100 -- bash


# 2. Crear grupo con el mismo GID que el host
groupadd -g 101000 sharedfiles


# 3. AÃ±adir usuarios relevantes al grupo
usermod -aG sharedfiles root
usermod -aG sharedfiles www-data


# Si tienes otros usuarios especÃ­ficos de aplicaciones:
usermod -aG sharedfiles nextcloud 2>/dev/null || true
usermod -aG sharedfiles nginx 2>/dev/null || true
# (aÃ±ade los usuaros que desees)


# 4. Verificar membresÃ­a
groups root
# Salida: root : root sharedfiles


groups www-data  
# Salida: www-data : www-data sharedfiles


# 5. Salir del contenedor
exit
```

#### Â¿Por quÃ© es importante esta configuraciÃ³n?

1. **Consistencia**: Los archivos creados por diferentes usuarios mantienen el grupo `sharedfiles`
2. **Compatibilidad**: Funciona con contenedores no privilegiados y otros servicios
3. **Flexibilidad**: Permite que mÃºltiples usuarios/servicios accedan a los mismos archivos

### Contenedores No Privilegiados

Los contenedores no privilegiados SIEMPRE necesitan configuraciÃ³n especial debido al mapeo de UIDs/GIDs.

#### ConfiguraciÃ³n Obligatoria

```bash
# 1. Entrar al contenedor
pct exec 101 -- bash


# 2. Crear grupo con GID mapeado
# GID 1000 en contenedor = GID 101000 en host
groupadd -g 1000 sharedfiles


# 3. Listar usuarios disponibles en el contenedor
awk -F: '$3>=1000 && $1!="nobody" {print $1 " (UID: " $3 ")"}' /etc/passwd
# Salida tÃ­pica:
# root (UID: 0)
# www-data (UID: 33)  
# ncp (UID: 1000)


# TambiÃ©n incluir usuarios del sistema si es necesario
awk -F: '$3<1000 && $3>0 && $1!="nobody" {print $1 " (UID: " $3 ")"}' /etc/passwd


# 4. AÃ±adir usuarios al grupo
usermod -aG sharedfiles root
usermod -aG sharedfiles www-data


# Si tienes usuarios especÃ­ficos de aplicaciones:
usermod -aG sharedfiles ncp 2>/dev/null || true
usermod -aG sharedfiles nextcloud 2>/dev/null || true
# (aÃ±ade los usuaros que desees)


# 5. Verificar configuraciÃ³n
id www-data
# Salida esperada: uid=33(www-data) gid=33(www-data) groups=33(www-data),1000(sharedfiles)


# 6. Salir del contenedor
exit
```

#### CÃ³mo AÃ±adir MÃ¡s Usuarios

Si instalas nuevas aplicaciones que crean usuarios adicionales:

```bash
# Entrar al contenedor
pct exec 101 -- bash


# Buscar nuevos usuarios (UID >= 100)
awk -F: '$3>=100 && $3<65534 {print $1 " (UID: " $3 ", GID: " $4 ")"}' /etc/passwd


# AÃ±adir al grupo sharedfiles
usermod -aG sharedfiles nombre_usuario


# Verificar
groups nombre_usuario
```

#### AÃ±adir TODOS los usuarios automÃ¡ticamente

```bash
# Script para aÃ±adir todos los usuarios relevantes
pct exec 101 -- bash -c '
# Obtener todos los usuarios con UID >= 100 y < 65534 (excluyendo nobody)
for user in $(awk -F: "$3>=100 && $3<65534 && $1!=\"nobody\" {print $1}" /etc/passwd); do
    echo "AÃ±adiendo usuario: $user"
    usermod -aG sharedfiles "$user" 2>/dev/null || echo "Error aÃ±adiendo $user"
done

# Verificar usuarios aÃ±adidos
echo "Usuarios en grupo sharedfiles:"
getent group sharedfiles
'
```

---

## 5. Montaje en Contenedores

### ConfiguraciÃ³n del Montaje

Para ambos tipos de contenedores, el montaje se configura igual, pero con consideraciones importantes:
Por ejemplo:
```bash
# Para contenedor privilegiado (ID 100)
pct set 100 -mp0 /mnt/shared_data,mp=/mnt/shared,backup=0,acl=1,shared=1


# Para contenedor no privilegiado (ID 101)  
pct set 101 -mp0 /mnt/shared_data,mp=/mnt/shared,backup=0,acl=1,shared=1


# Reiniciar contenedores para activar montajes
pct reboot 100
pct reboot 101

```

#### ExplicaciÃ³n de ParÃ¡metros

- **`/mnt/shared_data`**: Ruta en el HOST (donde estÃ¡ montado el recurso)
- **`mp=/mnt/shared`**: Ruta en el CONTENEDOR (donde aparecerÃ¡ el directorio)
- **`backup=0`**: Excluir del backup de vzdump (recomendado para recursos de red)
- **`acl=1`**: Habilitar soporte para ACL dentro del contenedor
- **`shared=1`**: **CRUCIAL para clusters** - permite migraciÃ³n sin copiar datos

#### Â¿Por quÃ© shared=1 es importante?

Sin `shared=1`:
- Proxmox intenta copiar todo el contenido durante migraciones
- Falla si el directorio contiene muchos datos
- No funciona con recursos de red

Con `shared=1`:
- Proxmox asume que el directorio estÃ¡ disponible en todos los nodos
- Solo migra la configuraciÃ³n, no los datos
- Funciona perfectamente con NFS, Samba, y almacenamiento compartido

### VerificaciÃ³n del Montaje

```bash
# Verificar que el montaje estÃ¡ activo
pct exec 100 -- df -h | grep shared
pct exec 101 -- df -h | grep shared


# Verificar permisos dentro de los contenedores
pct exec 100 -- ls -ld /mnt/shared
pct exec 101 -- ls -ld /mnt/shared


# Verificar ACL dentro de los contenedores
pct exec 100 -- getfacl /mnt/shared
pct exec 101 -- getfacl /mnt/shared
```

---

## 6. VerificaciÃ³n y Pruebas

### Prueba BÃ¡sica de Escritura

#### Desde el Host

```bash
# Crear archivo de prueba desde el host
echo "Archivo creado desde HOST" > /mnt/shared_data/test_host.txt


# Verificar propietario y permisos
ls -l /mnt/shared_data/test_host.txt
# Salida esperada: -rw-rw-r--+ 1 root sharedfiles 26 sep  8 12:00 test_host.txt
```

#### Desde Contenedor Privilegiado

```bash
# Crear archivo como root
pct exec 100 -- bash -c 'echo "Archivo desde contenedor privilegiado (root)" > /mnt/shared/test_priv_root.txt'


# Crear archivo como www-data
pct exec 100 -- sudo -u www-data bash -c 'echo "Archivo desde contenedor privilegiado (www-data)" > /mnt/shared/test_priv_www.txt'


# Verificar en el host
ls -l /mnt/shared_data/test_priv_*
# Salida esperada:
# -rw-rw-r--+ 1 root sharedfiles 42 sep  8 12:01 test_priv_root.txt
# -rw-rw-r--+ 1 www-data sharedfiles 48 sep  8 12:01 test_priv_www.txt
```

#### Desde Contenedor No Privilegiado

```bash
# Crear archivo como root del contenedor
pct exec 101 -- bash -c 'echo "Archivo desde contenedor no privilegiado (root)" > /mnt/shared/test_unpriv_root.txt'


# Crear archivo como www-data del contenedor
pct exec 101 -- sudo -u www-data bash -c 'echo "Archivo desde contenedor no privilegiado (www-data)" > /mnt/shared/test_unpriv_www.txt'


# Verificar en el host
ls -l /mnt/shared_data/test_unpriv_*
# Salida esperada:
# -rw-rw-r--+ 1 100000 sharedfiles 46 sep  8 12:02 test_unpriv_root.txt
# -rw-rw-r--+ 1 100033 sharedfiles 52 sep  8 12:02 test_unpriv_www.txt
#              â†‘ UIDs mapeados (+100000)
```

### Prueba de Acceso Cruzado

```bash
# Desde contenedor privilegiado, leer archivo del no privilegiado
pct exec 100 -- cat /mnt/shared/test_unpriv_root.txt
# Salida: Archivo desde contenedor no privilegiado (root)


# Desde contenedor no privilegiado, leer archivo del privilegiado
pct exec 101 -- cat /mnt/shared/test_priv_root.txt
# Salida: Archivo desde contenedor privilegiado (root)


# Modificar archivo desde diferentes contenedores
pct exec 100 -- bash -c 'echo "Modificado desde privilegiado" >> /mnt/shared/test_unpriv_root.txt'
pct exec 101 -- bash -c 'echo "Modificado desde no privilegiado" >> /mnt/shared/test_priv_root.txt'


# Verificar contenido
cat /mnt/shared_data/test_unpriv_root.txt
cat /mnt/shared_data/test_priv_root.txt
```

### Prueba de Herencia de Permisos

```bash
# Crear subdirectorio desde contenedor
pct exec 100 -- mkdir /mnt/shared/subdir_test


# Verificar que hereda setgid y grupo
ls -ld /mnt/shared_data/subdir_test
# Salida esperada: drwxrwsr-x+ 2 root sharedfiles 4096 sep  8 12:05 subdir_test
#                        â†‘ 's' indica setgid heredado


# Crear archivo en subdirectorio
pct exec 101 -- touch /mnt/shared/subdir_test/archivo_en_subdir.txt


# Verificar herencia
ls -l /mnt/shared_data/subdir_test/archivo_en_subdir.txt
# Salida esperada: -rw-rw-r--+ 1 100000 sharedfiles 0 sep  8 12:06 archivo_en_subdir.txt
```


---

## 7. SoluciÃ³n de Problemas

### Error: "Permission denied" al escribir

#### SÃ­ntomas
```bash
pct exec 101 -- touch /mnt/shared/test.txt
# touch: cannot touch '/mnt/shared/test.txt': Permission denied
```

#### DiagnÃ³stico
```bash
# 1. Verificar permisos en el host
ls -ld /mnt/shared_data
getfacl /mnt/shared_data


# 2. Verificar grupo en el contenedor
pct exec 101 -- getent group sharedfiles


# 3. Verificar membresÃ­a del usuario
pct exec 101 -- groups www-data
```

#### Soluciones
```bash
# SoluciÃ³n 1: Recrear grupo en contenedor
pct exec 101 -- groupadd -g 1000 sharedfiles
pct exec 101 -- usermod -aG sharedfiles www-data


# SoluciÃ³n 2: Reaplicar ACL en host
setfacl -R -m g:sharedfiles:rwx /mnt/shared_data
setfacl -d -m g:sharedfiles:rwx /mnt/shared_data


# SoluciÃ³n 3: Verificar setgid
chmod 2775 /mnt/shared_data
```

### Error: Archivos aparecen como "nobody:nogroup"

#### SÃ­ntomas
```bash
pct exec 101 -- ls -l /mnt/shared/
# -rw-r--r-- 1 nobody nogroup 100 sep  8 12:00 archivo.txt
```

#### Causa
El contenedor no tiene un grupo con el GID del archivo.

#### SoluciÃ³n
```bash
# 1. Ver GID numÃ©rico en el host
ls -n /mnt/shared_data/archivo.txt
# -rw-r--r-- 1 0 101000 100 sep  8 12:00 archivo.txt
#              â†‘ GID 101000


# 2. Crear grupo en contenedor con GID mapeado
# GID 101000 en host = GID 1000 en contenedor no privilegiado
pct exec 101 -- groupadd -g 1000 sharedfiles


# 3. Verificar que ahora se ve correctamente
pct exec 101 -- ls -l /mnt/shared/archivo.txt
# -rw-r--r-- 1 nobody sharedfiles 100 sep  8 12:00 archivo.txt
```

### Error: "Transport endpoint is not connected" (NFS)

#### SÃ­ntomas
```bash
ls /mnt/nfs_shared
# ls: cannot access '/mnt/nfs_shared': Transport endpoint is not connected
```

#### DiagnÃ³stico
```bash
# Verificar estado del montaje
mount | grep nfs
df -h | grep nfs


# Verificar conectividad
ping 192.168.1.100
showmount -e 192.168.1.100
```

#### Soluciones
```bash
# SoluciÃ³n 1: Remontar
umount /mnt/nfs_shared
mount -t nfs 192.168.1.100:/export/shared /mnt/nfs_shared


# SoluciÃ³n 2: Usar opciones mÃ¡s robustas
mount -t nfs 192.168.1.100:/export/shared /mnt/nfs_shared \
  -o hard,intr,rsize=32768,wsize=32768,timeo=600,retrans=2


# SoluciÃ³n 3: Verificar servicios NFS
systemctl status nfs-common
systemctl restart nfs-common
```

### Error: Contenedor no puede acceder despuÃ©s de migraciÃ³n

#### SÃ­ntomas
DespuÃ©s de migrar un contenedor a otro nodo, no puede acceder al directorio compartido.

#### Causa
El directorio compartido no estÃ¡ montado en el nodo destino, o falta `shared=1`.

#### SoluciÃ³n
```bash
# 1. Verificar configuraciÃ³n del contenedor
cat /etc/pve/lxc/101.conf | grep mp0
# Debe incluir: shared=1


# 2. Si falta shared=1, aÃ±adirlo
pct set 101 -mp0 /mnt/shared_data,mp=/mnt/shared,backup=0,acl=1,shared=1


# 3. Verificar que el directorio existe en el nodo destino
ls -ld /mnt/shared_data


# 4. Si no existe, montar el recurso en el nodo destino
# (repetir pasos de montaje NFS/Samba segÃºn corresponda)
```

### Error: "Operation not supported" con ACL

#### SÃ­ntomas
```bash
setfacl -m g:sharedfiles:rwx /mnt/shared_data
# setfacl: /mnt/shared_data: Operation not supported
```

#### Causa
El sistema de archivos no soporta ACL.

#### DiagnÃ³stico
```bash
# Verificar tipo de sistema de archivos
df -T /mnt/shared_data


# Verificar opciones de montaje
mount | grep shared_data
```

#### Soluciones
```bash
# Para ext4: Remontar con soporte ACL
mount -o remount,acl /mnt/shared_data


# Para NFS: AÃ±adir opciÃ³n acl
umount /mnt/shared_data
mount -t nfs 192.168.1.100:/export/shared /mnt/shared_data -o acl


# Para sistemas de archivos que no soportan ACL:
# Usar solo permisos tradicionales con setgid
chmod 2775 /mnt/shared_data
```

### Archivos creados con permisos incorrectos

#### SÃ­ntomas
Los archivos se crean con permisos 644 en lugar de 664.

#### Causa
La umask del proceso no permite escritura de grupo.

#### SoluciÃ³n
```bash
# Verificar umask actual
pct exec 101 -- umask
# Si es 022, cambiar a 002


# Cambiar umask temporalmente
pct exec 101 -- umask 002


# Cambiar umask permanentemente
pct exec 101 -- bash -c 'echo "umask 002" >> /etc/profile'


# Alternativa: Usar ACL por defecto (mÃ¡s robusta)
setfacl -d -m g:sharedfiles:rwx /mnt/shared_data
setfacl -d -m o::r-x /mnt/shared_data
```

---

## ğŸ“‹ Resumen de Comandos Clave

### ConfiguraciÃ³n del Host

```bash
# Crear directorio local
mkdir -p /mnt/shared_data
groupadd -g 101000 sharedfiles
chown root:sharedfiles /mnt/shared_data
chmod 2775 /mnt/shared_data
setfacl -R -m g:sharedfiles:rwx /mnt/shared_data
setfacl -d -m g:sharedfiles:rwx /mnt/shared_data


# Montar NFS persistente
echo "192.168.1.100:/export/shared /mnt/nfs_shared nfs rw,hard,nofail,_netdev 0 0" >> /etc/fstab


# Montar Samba persistente  
echo "//192.168.1.200/share /mnt/samba_shared cifs credentials=/etc/cifs-creds,uid=root,gid=101000,file_mode=0664,dir_mode=2775,_netdev,nofail 0 0" >> /etc/fstab
```

### ConfiguraciÃ³n de Contenedores

```bash
# Contenedor privilegiado
pct exec 100 -- groupadd -g 101000 sharedfiles
pct exec 100 -- usermod -aG sharedfiles root
pct exec 100 -- usermod -aG sharedfiles www-data


# Contenedor no privilegiado
pct exec 101 -- groupadd -g 1000 sharedfiles
pct exec 101 -- usermod -aG sharedfiles root
pct exec 101 -- usermod -aG sharedfiles www-data


# Montaje
pct set 100 -mp0 /mnt/shared_data,mp=/mnt/shared,backup=0,acl=1,shared=1
pct set 101 -mp0 /mnt/shared_data,mp=/mnt/shared,backup=0,acl=1,shared=1
```

### VerificaciÃ³n

```bash
# Verificar configuraciÃ³n
ls -ld /mnt/shared_data
getfacl /mnt/shared_data
pct exec 101 -- groups www-data


# Prueba de escritura
echo "test" > /mnt/shared_data/test.txt
pct exec 100 -- touch /mnt/shared/test_priv.txt
pct exec 101 -- touch /mnt/shared/test_unpriv.txt
```

---

## ğŸ¯ ConclusiÃ³n

Esta guÃ­a te ha mostrado cÃ³mo configurar correctamente recursos compartidos entre Proxmox y contenedores LXC, tanto privilegiados como no privilegiados. Los conceptos clave son:

1. **Grupo comÃºn** (`sharedfiles`) con GID consistente
2. **Setgid** (2775) para herencia automÃ¡tica de grupo
3. **ACL** para garantizar permisos robustos
4. **Mapeo correcto** de UIDs/GIDs en contenedores no privilegiados
5. **ConfiguraciÃ³n adecuada** de montajes con `shared=1`, `backup=0`, `acl=1`

Con esta configuraciÃ³n, tendrÃ¡s un sistema robusto que funciona con NFS, Samba, directorios locales, y es compatible con clusters y migraciones de Proxmox.





================================================
FILE: scripts/share/local-shared-manager.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - Local Shared Directory Manager
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 1.0
# Last Updated: $(date +%d/%m/%Y)
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"



if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi


SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    SHARE_COMMON_LOADED=false
else
    SHARE_COMMON_LOADED=true
fi

load_language
initialize_cache

# ==========================================================




create_shared_directory() {
    SHARED_DIR=$(pmx_select_host_mount_point "$(translate "Select Shared Directory Location")" "/mnt/shared")
    [[ -z "$SHARED_DIR" ]] && return


    if [[ -d "$SHARED_DIR" ]]; then
        if ! whiptail --yesno "$(translate "Directory already exists. Continue with permission setup?")" 10 70 --title "$(translate "Directory Exists")"; then
            return
        fi
    fi


    SHARE_GROUP=$(pmx_choose_or_create_group "sharedfiles") || return 1
    SHARE_GID=$(pmx_ensure_host_group "$SHARE_GROUP" 101000) || return 1


    if command -v setfacl >/dev/null 2>&1; then
        setfacl -k /mnt 2>/dev/null || true   
        setfacl -b /mnt 2>/dev/null || true  
    fi
    chmod 755 /mnt 2>/dev/null || true


    pmx_prepare_host_shared_dir "$SHARED_DIR" "$SHARE_GROUP" || return 1


    if command -v setfacl >/dev/null 2>&1; then
        setfacl -b -R "$SHARED_DIR" 2>/dev/null || true
    fi


    chown root:"$SHARE_GROUP" "$SHARED_DIR"
    chmod 2775 "$SHARED_DIR"

    pmx_share_map_set "$SHARED_DIR" "$SHARE_GROUP"

    show_proxmenux_logo
    msg_title "$(translate "Create Shared Directory")"

    echo -e ""
    echo -e "${TAB}${BOLD}$(translate "Shared Directory Created:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Directory:")${CL} ${BL}$SHARED_DIR${CL}"
    echo -e "${TAB}${BGN}$(translate "Group:")${CL} ${BL}$SHARE_GROUP (GID: $SHARE_GID)${CL}"
    echo -e "${TAB}${BGN}$(translate "Permissions:")${CL} ${BL}2775 (rwxrwsr-x)${CL}"
    echo -e "${TAB}${BGN}$(translate "Owner:")${CL} ${BL}root:$SHARE_GROUP${CL}"
    echo -e "${TAB}${BGN}$(translate "ACL Status:")${CL} ${BL}$(translate "Cleaned and set for POSIX inheritance")${CL}"
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}




create_shared_directory



================================================
FILE: scripts/share/lxc-mount-manager.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - LXC Mount Manager
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 3.1-enhanced
# Last Updated: $(date +%d/%m/%Y)
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
source "$BASE_DIR/utils.sh"

SHARE_COMMON_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/scripts/global/share-common.func"
if ! source <(curl -s "$SHARE_COMMON_URL" 2>/dev/null); then
    SHARE_COMMON_LOADED=false
else
    SHARE_COMMON_LOADED=true
fi

load_language
initialize_cache

# ==========================================================

get_container_uid_shift() {
    local ctid="$1"
    local conf="/etc/pve/lxc/${ctid}.conf"
    local uid_shift

    if [[ ! -f "$conf" ]]; then
        echo "100000"   
        return 0
    fi

    local unpriv
    unpriv=$(grep "^unprivileged:" "$conf" | awk '{print $2}')

    if [[ "$unpriv" == "1" ]]; then
        uid_shift=$(grep "^lxc.idmap" "$conf" | grep 'u 0' | awk '{print $5}' | head -1)
        echo "${uid_shift:-100000}"
        return 0
    fi

    echo "0"
    return 0
}

setup_container_access() {
    local ctid="$1" group_name="$2" host_gid="$3" host_dir="$4"
    local uid_shift mapped_gid

    if [[ ! "$ctid" =~ ^[0-9]+$ ]]; then
        msg_error "$(translate 'Invalid container ID format:') $ctid"
        return 1
    fi

    uid_shift=$(get_container_uid_shift "$ctid")




    # ===================================================================
    # CONTAINER TYPE DETECTION AND STRATEGY
    # ===================================================================

    if [[ "$uid_shift" -eq 0 ]]; then
        msg_ok "$(translate "PRIVILEGED container detected - using direct UID/GID mapping")"
        mapped_gid="$host_gid"
        container_type="privileged"
    else
        msg_ok "$(translate "UNPRIVILEGED container detected - using mapped UID/GID")"
        mapped_gid=$((uid_shift + host_gid))
        container_type="unprivileged"
        msg_ok "UID shift: $uid_shift, Host GID: $host_gid â†’ Container GID: $mapped_gid"

    fi





    # ===================================================================
    # STEP 1: ACL TOOLS (only for unprivileged containers)
    # ===================================================================

    if [[ "$container_type" == "unprivileged" ]]; then
        if ! command -v setfacl >/dev/null 2>&1; then
            msg_info "$(translate "Installing ACL tools (REQUIRED for unprivileged containers)...")"
            apt-get update >/dev/null 2>&1
            apt-get install -y acl >/dev/null 2>&1
            if command -v setfacl >/dev/null 2>&1; then
                msg_ok "$(translate "ACL tools installed successfully")"
            else
                msg_error "$(translate "Failed to install ACL tools - permissions may not work correctly")"
            fi
        else
            msg_ok "$(translate "ACL tools already available")"
        fi
    else
        msg_ok "$(translate "Privileged container - ACL tools not required (using POSIX permissions)")"
    fi





    # ===================================================================
    # STEP 2: CONTAINER GROUP CONFIGURATION
    # ===================================================================

    msg_info "$(translate "Configuring container group with") $container_type $(translate "strategy...")"
    
    pct exec "$ctid" -- sh -c "
        # Remove existing group if GID is wrong
        if getent group $group_name >/dev/null 2>&1; then
            current_gid=\$(getent group $group_name | cut -d: -f3)
            if [ \"\$current_gid\" != \"$mapped_gid\" ]; then
                groupdel $group_name 2>/dev/null || true
            fi
        fi
        
        # Create group with correct GID
        groupadd -g $mapped_gid $group_name 2>/dev/null || true
    " 2>/dev/null

    msg_ok "$(translate "Container group configured:") $group_name (GID: $mapped_gid)"





    # ===================================================================
    # STEP 3: USER PROCESSING (different strategies)
    # ===================================================================

    local container_users
    container_users=$(pct exec "$ctid" -- getent passwd | awk -F: '{print $1 ":" $3}' 2>/dev/null)
    
    local users_added=0
    local acls_applied=0
    
    if [[ "$container_type" == "privileged" ]]; then

        
        msg_ok "$(translate "Privileged container:") $users_added $(translate "users added to group (no ACLs needed)")"
        
    else

        msg_info "$(translate "Using UNPRIVILEGED strategy: mapped UIDs + ACL permissions")"
        
        while IFS=: read -r username ct_uid; do
            if [[ -n "$username" && "$ct_uid" =~ ^[0-9]+$ ]]; then
                local host_uid=$((uid_shift + ct_uid))
                
                if pct exec "$ctid" -- usermod -aG "$group_name" "$username" 2>/dev/null; then
                    users_added=$((users_added + 1))
                    
                    if command -v setfacl >/dev/null 2>&1; then
                        setfacl -m u:$host_uid:rwx "$host_dir" 2>/dev/null
                        setfacl -m d:u:$host_uid:rwx "$host_dir" 2>/dev/null
                        acls_applied=$((acls_applied + 1))
                    fi
                    
                    case "$username" in
                        root|www-data|ncp|nobody|ubuntu|debian)
                            msg_ok "$(translate "Configured user:") $username (CT_UID:$ct_uid â†’ HOST_UID:$host_uid)"
                            ;;
                    esac
                fi
            fi
        done <<< "$container_users"
        
        msg_ok "$(translate "Unprivileged container:") $users_added $(translate "users added,") $acls_applied $(translate "ACL entries applied")"
    fi




    # ===================================================================
    # STEP 4: DIRECTORY PERMISSIONS
    # ===================================================================
    msg_info "$(translate "Setting optimal directory permissions...")"
    
    chmod 2775 "$host_dir" 2>/dev/null || true
    chgrp "$group_name" "$host_dir" 2>/dev/null || true
    
    msg_ok "$(translate "Host directory permissions:") 2775 root:$group_name"





    # ===================================================================
    # STEP 5: VERIFICATION
    # ===================================================================
    msg_info "$(translate "Verifying configuration...")"
    
    if [[ "$container_type" == "unprivileged" ]] && command -v getfacl >/dev/null 2>&1; then
        local acl_count=$(getfacl "$host_dir" 2>/dev/null | grep "^user:" | grep -v "^user::" | wc -l)
        msg_ok "$(translate "ACL entries configured:") $acl_count"
        
        # Show sample ACL entries
        if [[ $acl_count -gt 0 ]]; then
            echo -e "${TAB}${BGN}$(translate "  ACL entries:")${CL}"
            getfacl "$host_dir" 2>/dev/null | grep "^user:" | grep -v "^user::" | head -3 | while read acl_line; do
                echo -e "${TAB}  ${BL}$acl_line${CL}"
            done
        fi
    fi
    

    local test_users=("www-data" "root" "ncp" "nobody")
    local successful_tests=0
    
    for test_user in "${test_users[@]}"; do
        if pct exec "$ctid" -- id "$test_user" >/dev/null 2>&1; then
            if pct exec "$ctid" -- su -s /bin/bash "$test_user" -c "ls '$4' >/dev/null 2>&1" 2>/dev/null; then
                successful_tests=$((successful_tests + 1))
            fi
        fi
    done
    
    if [[ $successful_tests -gt 0 ]]; then
        msg_ok "$(translate "Access verification:") $successful_tests $(translate "users can access mount point")"
    fi


    if [[ "$container_type" == "privileged" ]]; then
        msg_ok "$(translate "PRIVILEGED container configuration completed - using direct POSIX permissions")"
    else
        msg_ok "$(translate "UNPRIVILEGED container configuration completed - using ACL permissions")"
    fi
    
    return 0
}





get_next_mp_index() {
    local ctid="$1"
    local conf="/etc/pve/lxc/${ctid}.conf"
    
    if [[ ! "$ctid" =~ ^[0-9]+$ ]] || [[ ! -f "$conf" ]]; then
        echo "0"
        return 0
    fi
    
    local used idx next=0
    used=$(awk -F: '/^mp[0-9]+:/ {print $1}' "$conf" | sed 's/mp//' | sort -n)
    for idx in $used; do
        [[ "$idx" -ge "$next" ]] && next=$((idx+1))
    done
    echo "$next"
}






add_bind_mount() {
    local ctid="$1" host_path="$2" ct_path="$3"
    local mpidx result
    
    if [[ ! "$ctid" =~ ^[0-9]+$ ]]; then
        msg_error "$(translate 'Invalid container ID format:') $ctid"
        return 1
    fi
    
    if [[ -z "$ctid" || -z "$host_path" || -z "$ct_path" ]]; then
        msg_error "$(translate "Missing arguments")"
        return 1
    fi

    if pct config "$ctid" | grep -q "$host_path"; then
        echo -e
        msg_warn "$(translate "Directory already mounted in container configuration.")"
        echo -e ""
        msg_success "$(translate 'Press Enter to return to menu...')"
        read -r
        return 1
    fi

    mpidx=$(get_next_mp_index "$ctid")
    
    result=$(pct set "$ctid" -mp${mpidx} "$host_path,mp=$ct_path,shared=1,backup=0,acl=1" 2>&1)

    if [[ $? -eq 0 ]]; then
        msg_ok "$(translate "Successfully mounted:") $host_path â†’ $ct_path"
        return 0
    else
        msg_error "$(translate "Error mounting folder:") $result"
        return 1
    fi
}






mount_host_directory_to_lxc() {
    
    # Step 1: Select container
    local container_id
    container_id=$(select_lxc_container)
    if [[ $? -ne 0 || -z "$container_id" ]]; then
        return 1
    fi


    show_proxmenux_logo
    msg_title "$(translate 'Mount Host Directory to LXC Container')"

    # Step 1.1: Ensure running
    ct_status=$(pct status "$container_id" | awk '{print $2}')
    if [[ "$ct_status" != "running" ]]; then

        msg_info "$(translate "Starting container") $container_id..."
        if pct start "$container_id"; then
            sleep 3
            msg_ok "$(translate "Container started")"
        else
            msg_error "$(translate "Failed to start container")"
            echo -e ""
            msg_success "$(translate 'Press Enter to continue...')"
            read -r
            return 1
        fi
    fi

    msg_ok "$(translate 'Container selected and running')"
    sleep 2
    
    # Step 2: Select host directory
    local host_dir
    host_dir=$(select_host_directory)
    if [[ -z "$host_dir" ]]; then
        return 1
    fi

    msg_ok "$(translate 'Host directory selected')"

    # Step 3: Setup group
    local group_name="sharedfiles"
    local group_gid
    group_gid=$(pmx_ensure_host_group "$group_name")
    if [[ -z "$group_gid" ]]; then
        return 1
    fi
    
    # Set basic permissions
    chown -R root:"$group_name" "$host_dir" 2>/dev/null || true
    chmod -R 2775 "$host_dir" 2>/dev/null || true

    msg_ok "$(translate 'Host group configured')"
     
    # Step 4: Select container mount point
    
    local ct_mount_point
    ct_mount_point=$(select_container_mount_point "$container_id" "$host_dir")
    if [[ -z "$ct_mount_point" ]]; then
        return 1
    fi
    


    # Step 5: Confirmation
    local uid_shift container_type
    uid_shift=$(get_container_uid_shift "$container_id")
    if [[ "$uid_shift" -eq 0 ]]; then
        container_type="$(translate 'Privileged')"
    else
        container_type="$(translate 'Unprivileged')"
    fi

    local confirm_msg="$(translate "Mount Configuration:")

$(translate "Container ID:"): $container_id ($container_type)
$(translate "Host Directory:"): $host_dir
$(translate "Container Mount Point:"): $ct_mount_point
$(translate "Shared Group:"): $group_name (GID: $group_gid)

$(translate "Proceed?")"

    if ! whiptail --title "$(translate "Confirm Mount")" --yesno "$confirm_msg" 16 70; then
        return 1
    fi


    
    # Step 6: Add mount
    if ! add_bind_mount "$container_id" "$host_dir" "$ct_mount_point"; then
        return 1
    fi
    
    # Step 7: Setup access (handles both privileged and unprivileged)
    setup_container_access "$container_id" "$group_name" "$group_gid" "$host_dir"
    
    # Step 8: Final setup
    pct exec "$container_id" -- chgrp "$group_name" "$ct_mount_point" 2>/dev/null || true
    pct exec "$container_id" -- chmod 2775 "$ct_mount_point" 2>/dev/null || true
    
    # Step 9: Summary
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate 'Mount Added Successfully:')${CL}"
    echo -e "${TAB}${BGN}$(translate 'Container:')${CL} ${BL}$container_id ($container_type)${CL}"
    echo -e "${TAB}${BGN}$(translate 'Host Directory:')${CL} ${BL}$host_dir${CL}"
    echo -e "${TAB}${BGN}$(translate 'Mount Point:')${CL} ${BL}$ct_mount_point${CL}"
    echo -e "${TAB}${BGN}$(translate 'Group:')${CL} ${BL}$group_name (GID: $group_gid)${CL}"
    
    if [[ "$uid_shift" -eq 0 ]]; then
        echo -e "${TAB}${BGN}$(translate 'Permission Strategy:')${CL} ${BL}POSIX (direct mapping)${CL}"
    else
        echo -e "${TAB}${BGN}$(translate 'Permission Strategy:')${CL} ${BL}ACL (mapped UIDs)${CL}"
    fi

    echo -e ""
    if whiptail --yesno "$(translate "Restart container to activate mount?")" 8 60; then
        msg_info "$(translate 'Restarting container...')"
        if pct reboot "$container_id"; then
            sleep 5
            msg_ok "$(translate 'Container restarted successfully')"
            
            echo -e
            echo -e "${TAB}${BOLD}$(translate 'Testing access and read/write:')${CL}"
            test_user=$(pct exec "$container_id" -- sh -c "id -u ncp >/dev/null 2>&1 && echo ncp || echo www-data")

            if pct exec "$container_id" -- su -s /bin/bash $test_user -c "touch $ct_mount_point/test_access.txt" 2>/dev/null; then
                msg_ok "$(translate "Mount access and read/write successful (tested as $test_user)")"
                rm -f "$host_dir/test_access.txt" 2>/dev/null || true
            else
                msg_warn "$(translate "âš  Access test failed - check permissions (user: $test_user)")"
            fi

        else
            msg_warn "$(translate 'Failed to restart - restart manually')"
        fi
    fi
    
    echo -e ""
    msg_success "$(translate 'Press Enter to continue...')"
    read -r
}

# Main menu
main_menu() {
    while true; do
        choice=$(dialog --title "$(translate 'LXC Mount Manager')" \
            --menu "\n$(translate 'Choose an option:')" 25 80 15 \
            "1" "$(translate 'Mount Host Directory to LXC')" \
            "2" "$(translate 'View Mount Points')" \
            "3" "$(translate 'Remove Mount Point')" \
            "4" "$(translate 'Exit')" 3>&1 1>&2 2>&3)
        
        case $choice in
            1)
                mount_host_directory_to_lxc
                ;;
            2)
                msg_info2 "$(translate 'Feature coming soon...')"
                read -p "$(translate 'Press Enter to continue...')"
                ;;
            3)
                msg_info2 "$(translate 'Feature coming soon...')"
                read -p "$(translate 'Press Enter to continue...')"
                ;;
            4|"")
                exit 0
                ;;
        esac
    done
}

#main_menu
mount_host_directory_to_lxc



================================================
FILE: scripts/share/lxc-mount-manager_minimal.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - LXC Mount Manager
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 5.0-minimal
# Last Updated: $(date +%d/%m/%Y)
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
source "$BASE_DIR/utils.sh"

load_language
initialize_cache



detect_mounted_shares() {
    local mounted_shares=()
    
    while IFS= read -r line; do
        local device mount_point fs_type options dump pass
        read -r device mount_point fs_type options dump pass <<< "$line"
        
        local is_network=false
        local type=""
        
        case "$fs_type" in
            nfs|nfs4)
                is_network=true
                type="NFS"
                ;;
            cifs)
                is_network=true
                type="CIFS/SMB"
                ;;
        esac
        

        if [[ "$is_network" == true ]]; then

            local exclude_internal=false
            local internal_mounts=(
                "/mnt/pve/local"
                "/mnt/pve/local-lvm" 
                "/mnt/pve/local-zfs"
                "/mnt/pve/backup"
                "/mnt/pve/snippets"
                "/mnt/pve/dump"
                "/mnt/pve/images"
                "/mnt/pve/template"
                "/mnt/pve/private"
                "/mnt/pve/vztmpl"
            )
            
            for internal_mount in "${internal_mounts[@]}"; do
                if [[ "$mount_point" == "$internal_mount" || "$mount_point" =~ ^${internal_mount}/ ]]; then
                    exclude_internal=true
                    break
                fi
            done
            

            if [[ "$exclude_internal" == false ]]; then

                local size used
                local df_info=$(df -h "$mount_point" 2>/dev/null | tail -n1)
                if [[ -n "$df_info" ]]; then
                    size=$(echo "$df_info" | awk '{print $2}')
                    used=$(echo "$df_info" | awk '{print $3}')
                else
                    size="N/A"
                    used="N/A"
                fi
                

                local mount_source="Manual"
                if [[ "$mount_point" =~ ^/mnt/pve/ ]]; then
                    mount_source="Proxmox-GUI"
                fi
                
                mounted_shares+=("$mount_point|$device|$type|$size|$used|$mount_source")
            fi
        fi
    done < /proc/mounts
    
    printf '%s\n' "${mounted_shares[@]}"
}

detect_fstab_network_mounts() {
    local fstab_mounts=()
    

    while IFS= read -r line; do

        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "${line// }" ]] && continue
        

        local source mount_point fs_type options dump pass
        read -r source mount_point fs_type options dump pass <<< "$line"
        

        local is_network=false
        local type=""
        
        case "$fs_type" in
            nfs|nfs4)
                is_network=true
                type="NFS"
                ;;
            cifs)
                is_network=true
                type="CIFS/SMB"
                ;;
        esac
        
        if [[ "$is_network" == true && -d "$mount_point" ]]; then

            local is_mounted=false
            while IFS= read -r proc_line; do
                local proc_device proc_mount_point proc_fs_type
                read -r proc_device proc_mount_point proc_fs_type _ <<< "$proc_line"
                if [[ "$proc_mount_point" == "$mount_point" && ("$proc_fs_type" == "nfs" || "$proc_fs_type" == "nfs4" || "$proc_fs_type" == "cifs") ]]; then
                    is_mounted=true
                    break
                fi
            done < /proc/mounts
            

            if [[ "$is_mounted" == false ]]; then
                fstab_mounts+=("$mount_point|$source|$type|0|0|fstab-inactive")
            fi
        fi
    done < /etc/fstab
    
    printf '%s\n' "${fstab_mounts[@]}"
}


detect_local_directories() {
    local local_dirs=()
    local network_mounts=()
    

    local all_network_mounts
    all_network_mounts=$(detect_mounted_shares)
    local fstab_network_mounts
    fstab_network_mounts=$(detect_fstab_network_mounts)
    

    local combined_network_mounts="$all_network_mounts"$'\n'"$fstab_network_mounts"

    while IFS='|' read -r mount_point source type size used mount_source; do
        [[ -n "$mount_point" ]] && network_mounts+=("$mount_point")
    done <<< "$combined_network_mounts"
    
    if [[ -d "/mnt" ]]; then
        for dir in /mnt/*/; do
            if [[ -d "$dir" && "$(basename "$dir")" != "pve" ]]; then
                local dir_path="${dir%/}"  
                local dir_name=$(basename "$dir_path")
                

                local is_network_mount=false
                
                for network_mount in "${network_mounts[@]}"; do
                    if [[ "$dir_path" == "$network_mount" ]]; then
                        is_network_mount=true
                        break
                    fi
                done
                

                if [[ "$is_network_mount" == false ]]; then
                    local dir_size=$(du -sh "$dir_path" 2>/dev/null | awk '{print $1}')
                    local_dirs+=("$dir_path|Local|Directory|$dir_size|-|Manual")
                fi
            fi
        done
    fi
    
    printf '%s\n' "${local_dirs[@]}"
}


are_same_resource() {
    local path1="$1" source1="$2" type1="$3"
    local path2="$4" source2="$5" type2="$6"
    

    [[ "$type1" != "$type2" ]] && return 1
    

    local server1 share1 server2 share2
    
    if [[ "$type1" == "NFS" ]]; then

        server1=$(echo "$source1" | cut -d: -f1)
        share1=$(echo "$source1" | cut -d: -f2)
        server2=$(echo "$source2" | cut -d: -f1)
        share2=$(echo "$source2" | cut -d: -f2)
    elif [[ "$type1" == "CIFS/SMB" ]]; then

        server1=$(echo "$source1" | cut -d/ -f3)
        share1=$(echo "$source1" | cut -d/ -f4-)
        server2=$(echo "$source2" | cut -d/ -f3)
        share2=$(echo "$source2" | cut -d/ -f4-)
    else
        return 1
    fi
    

    if [[ "$server1" == "$server2" && "$share1" == "$share2" ]]; then
        return 0  
    else
        return 1  
    fi
}



detect_problematic_storage() {
    local mount_point="$1"
    local mount_source="$2"
    local type="$3"
    

    if [[ "$mount_source" == "Proxmox-GUI" && "$type" == "CIFS/SMB" ]]; then

        local permissions=$(stat -c '%a' "$mount_point" 2>/dev/null)
        local owner=$(stat -c '%U' "$mount_point" 2>/dev/null)
        local group=$(stat -c '%G' "$mount_point" 2>/dev/null)
        

        if [[ "$owner" == "root" && "$group" == "root" && "$permissions" =~ ^75[0-5]$ ]]; then
            return 0  
        fi
    fi
    
    return 1  
}




select_host_directory_unified() {
    local mounted_shares local_dirs options=() fstab_mounts
    

    mounted_shares=$(detect_mounted_shares)
    fstab_mounts=$(detect_fstab_network_mounts)
    local_dirs=$(detect_local_directories)
    

    local all_network_shares="$mounted_shares"
    if [[ -n "$fstab_mounts" ]]; then
        all_network_shares="$all_network_shares"$'\n'"$fstab_mounts"
    fi
    

    local has_local_dirs=false
    local has_network_shares=false
    
    [[ -n "$local_dirs" ]] && has_local_dirs=true
    [[ -n "$all_network_shares" ]] && has_network_shares=true
    
    if [[ "$has_local_dirs" == false && "$has_network_shares" == false ]]; then
        whiptail --title "$(translate "No Directories Found")" \
            --msgbox "$(translate "No directories found in /mnt and no mounted network shares detected.")\n\n$(translate "Please:")\nâ€¢ Mount shares using Proxmox GUI\nâ€¢ Create directories in /mnt\nâ€¢ Use manual path entry" 12 70
        

        local manual_path
        manual_path=$(whiptail --title "$(translate "Manual Path Entry")" \
            --inputbox "$(translate "Enter the full path to the host directory:")" 10 70 "/mnt/" 3>&1 1>&2 2>&3)
        
        if [[ -n "$manual_path" && -d "$manual_path" ]]; then
            echo "$manual_path"
            return 0
        else
            return 1
        fi
    fi

    local processed_resources=()
    local final_shares=()
    

    while IFS='|' read -r mount_point source type size used mount_source; do
        if [[ -n "$mount_point" ]]; then

            local is_duplicate=false
            local duplicate_index=-1
            
            for i in "${!processed_resources[@]}"; do
                IFS='|' read -r proc_path proc_source proc_type proc_size proc_used proc_mount_source <<< "${processed_resources[$i]}"
                if are_same_resource "$mount_point" "$source" "$type" "$proc_path" "$proc_source" "$proc_type"; then

                    if [[ ("$mount_source" == "Manual" || "$proc_mount_source" =~ ^fstab) && "$proc_mount_source" == "Proxmox-GUI" ]]; then

                        is_duplicate=true
                        duplicate_index=$i
                        break
                    elif [[ "$mount_source" == "Proxmox-GUI" && ("$proc_mount_source" == "Manual" || "$proc_mount_source" =~ ^fstab) ]]; then

                        is_duplicate=true
                        break
                    fi
                fi
            done
            
            if [[ "$is_duplicate" == true && "$duplicate_index" -ge 0 ]]; then

                processed_resources[$duplicate_index]="$mount_point|$source|$type|$size|$used|$mount_source"
            elif [[ "$is_duplicate" == false ]]; then

                processed_resources+=("$mount_point|$source|$type|$size|$used|$mount_source")
            fi
        fi
    done <<< "$all_network_shares"

    if [[ "$has_local_dirs" == true ]]; then
        options+=("" "\Z4â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LOCAL DIRECTORIES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\Zn")
        
        while IFS='|' read -r dir_path source type size used mount_source; do
            if [[ -n "$dir_path" && "$type" == "Directory" ]]; then
                local dir_name=$(basename "$dir_path")
                local permissions=$(stat -c '%a' "$dir_path" 2>/dev/null)
                local owner_group=$(stat -c '%U:%G' "$dir_path" 2>/dev/null)
                options+=("$dir_path" "$dir_name ($size)")
            fi
        done <<< "$local_dirs"
    fi

    if [[ ${#processed_resources[@]} -gt 0 ]]; then

        [[ "$has_local_dirs" == true ]] && options+=("" "")
        options+=("" "\Z4â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NETWORK SHARESâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\Zn")
        
        for resource in "${processed_resources[@]}"; do
            IFS='|' read -r mount_point source type size used mount_source <<< "$resource"
            
            local share_name=$(basename "$source")
            local mount_name=$(basename "$mount_point")
            local permissions=$(stat -c '%a' "$mount_point" 2>/dev/null)
            local owner_group=$(stat -c '%U:%G' "$mount_point" 2>/dev/null)
            

            local warning=""
            if detect_problematic_storage "$mount_point" "$mount_source" "$type"; then
                warning=" [READ-ONLY]"
            fi
            
            local prefix=""
            case "$mount_source" in
                "Proxmox-GUI")
                    prefix="GUI-"
                    ;;
                "fstab-active")
                    prefix="fstab-"
                    ;;
                "fstab-inactive")
                    prefix="fstab(off)-"
                    ;;
                *)
                    prefix=""
                    ;;
            esac
            
            options+=("$mount_point" "$prefix$type: $share_name â†’ $mount_name ($size)$warning")

        done
    fi
    

    options+=("" "")
    options+=("" "\Z4â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ OTHER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\Zn")
    options+=("MANUAL" "$(translate "Enter path manually")")
    
    if [[ ${#options[@]} -eq 0 ]]; then
        dialog --title "$(translate "No Valid Options")" \
            --msgbox "$(translate "No valid directories or shares found.")" 8 50
        return 1
    fi
    

    local result
    result=$(dialog --clear --colors --title "$(translate "Select Host Directory")" \
        --menu "\n$(translate "Select the directory to bind to container:")" 25 85 15 \
        "${options[@]}" 3>&1 1>&2 2>&3)


    
    local dialog_result=$?
    if [[ $dialog_result -ne 0 ]]; then
        return 1
    fi
    

    if [[ -z "$result" || "$result" =~ ^â” ]]; then
        return 1
    fi

    
    if [[ "$result" == "MANUAL" ]]; then
        result=$(whiptail --title "$(translate "Manual Path Entry")" \
            --inputbox "$(translate "Enter the full path to the host directory:")" 10 70 "/mnt/" 3>&1 1>&2 2>&3)        
        if [[ $? -ne 0 ]]; then
            return 1
        fi
    fi

    if [[ -z "$result" ]]; then
        return 1
    fi

    if [[ ! -d "$result" ]]; then
        whiptail --title "$(translate "Invalid Path")" \
            --msgbox "$(translate "The selected path is not a valid directory:") $result" 8 70
        return 1
    fi


    if detect_problematic_storage "$result" "Proxmox-GUI" "CIFS/SMB"; then
dialog --clear --title "$(translate "CIFS Storage Notice")" --yesno "\
$(translate "\nThis directory is a CIFS storage configured from the Proxmox web interface.")\n\n\
$(translate "When CIFS storage is configured through the Proxmox GUI, it applies restrictive permissions.")\n\
$(translate "As a result, LXC containers can usually READ files but may NOT be able to WRITE.")\n\n\
$(translate "If you need WRITE access, cancel this operation and instead use the option:")\n\
$(translate "Configure Samba shared on Host")\n\n\

$(translate "Do you want to continue anyway?")" 18 80 3>&1 1>&2 2>&3

        dialog_result=$?

        case $dialog_result in
            0)  
                ;;
            1|255)  
                return 1
                ;;
        esac
    fi

    echo "$result"
    return 0
}




select_lxc_container() {
    local ct_list ctid ct_status
    
    ct_list=$(pct list 2>/dev/null | awk 'NR>1 {print $1, $2, $3}')
    if [[ -z "$ct_list" ]]; then
        whiptail --title "Error" \
            --msgbox "No LXC containers available" 8 50
        return 1
    fi

    local options=()
    while read -r id name status; do
        if [[ -n "$id" && "$id" =~ ^[0-9]+$ ]]; then
            name=${name:-"unnamed"}
            status=${status:-"unknown"}
            options+=("$id" "$name ($status)")
        fi
    done <<< "$ct_list"
    
    if [[ ${#options[@]} -eq 0 ]]; then
        dialog --title "Error" \
            --msgbox "No valid containers found" 8 50
        return 1
    fi

    ctid=$(dialog --title "Select LXC Container" \
        --menu "Select container:" 25 85 15 \
        "${options[@]}" 3>&1 1>&2 2>&3)
    
    local result=$?
    if [[ $result -ne 0 || -z "$ctid" ]]; then
        return 1
    fi

    echo "$ctid"
    return 0
}


select_container_mount_point() {
    local ctid="$1"
    local host_dir="$2"
    local choice mount_point base_name

    base_name=$(basename "$host_dir")

    while true; do
        choice=$(dialog --clear --title "$(translate "Configure Mount Point inside LXC")" \
            --menu "\n$(translate "Where to mount inside container?")" 18 70 5 \
            "1" "$(translate "Create new directory in /mnt")" \
            "2" "$(translate "Enter path manually")" \
            "3" "$(translate "Cancel")" 3>&1 1>&2 2>&3)
        
        local dialog_result=$?
        if [[ $dialog_result -ne 0 ]]; then
            return 1
        fi

        case "$choice" in
            1)
                mount_point=$(whiptail --inputbox "$(translate "Enter folder name for /mnt:")" \
                    10 60 "$base_name" 3>&1 1>&2 2>&3)
                if [[ $? -ne 0 ]]; then
                    continue
                fi
                [[ -z "$mount_point" ]] && continue
                mount_point="/mnt/$mount_point"
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            2)
                mount_point=$(whiptail --inputbox "$(translate "Enter full path:")" \
                    10 70 "/mnt/$base_name" 3>&1 1>&2 2>&3)
                if [[ $? -ne 0 ]]; then
                    continue
                fi
                [[ -z "$mount_point" ]] && continue
                pct exec "$ctid" -- mkdir -p "$mount_point" 2>/dev/null
                ;;

            3)
                return 1
                ;;
        esac

        if pct exec "$ctid" -- test -d "$mount_point" 2>/dev/null; then
            echo "$mount_point"
            return 0
        else
            whiptail --msgbox "$(translate "Could not create or access directory:") $mount_point" 8 70
            continue
        fi
    done
}

# ==========================================================
# MOUNT MANAGEMENT FUNCTIONS
# ==========================================================


view_mount_points() {
    show_proxmenux_logo
    msg_title "$(translate 'Current LXC Mount Points')"
    
    local ct_list
    ct_list=$(pct list 2>/dev/null | awk 'NR>1 {print $1, $2, $3}')
    
    if [[ -z "$ct_list" ]]; then
        msg_warn "$(translate 'No LXC containers found')"
        echo -e ""
        msg_success "$(translate 'Press Enter to continue...')"
        read -r
        return 1
    fi
    
    local found_mounts=false
    
    while read -r id name status; do
        if [[ -n "$id" && "$id" =~ ^[0-9]+$ ]]; then
            local conf="/etc/pve/lxc/${id}.conf"
            if [[ -f "$conf" ]]; then
                local mounts
                mounts=$(grep "^mp[0-9]*:" "$conf" 2>/dev/null)
                
                if [[ -n "$mounts" ]]; then
                    if [[ "$found_mounts" == false ]]; then
                        found_mounts=true
                    fi
                    
                    echo -e "${TAB}${BOLD}$(translate 'Container') $id: $name ($status)${CL}"
                    
                    while IFS= read -r mount_line; do
                        if [[ -n "$mount_line" ]]; then
                            local mp_id=$(echo "$mount_line" | cut -d: -f1)
                            local mount_info=$(echo "$mount_line" | cut -d: -f2-)
                            local host_path=$(echo "$mount_info" | cut -d, -f1)
                            local container_path=$(echo "$mount_info" | grep -o 'mp=[^,]*' | cut -d= -f2)
                            local options=$(echo "$mount_info" | sed 's/^[^,]*,mp=[^,]*,*//')
                            
                            echo -e "${TAB}  ${BGN}$mp_id:${CL} ${BL}$host_path${CL} â†’ ${BL}$container_path${CL}"
                            [[ -n "$options" ]] && echo -e "${TAB}    ${DGN}Options: $options${CL}"
                        fi
                    done <<< "$mounts"
                    echo ""
                fi
            fi
        fi
    done <<< "$ct_list"
    
    if [[ "$found_mounts" == false ]]; then
        msg_ok "$(translate 'No mount points found in any container')"
    fi
    
    echo -e ""
    msg_success "$(translate 'Press Enter to continue...')"
    read -r
}





remove_mount_point() {
    show_proxmenux_logo
    msg_title "$(translate 'Remove LXC Mount Point')"
    

    local container_id
    container_id=$(select_lxc_container)
    if [[ $? -ne 0 || -z "$container_id" ]]; then
        return 1
    fi
    
    local conf="/etc/pve/lxc/${container_id}.conf"
    if [[ ! -f "$conf" ]]; then
        msg_error "$(translate 'Container configuration not found')"
        echo -e ""
        msg_success "$(translate 'Press Enter to continue...')"
        read -r
        return 1
    fi
    

    local mounts
    mounts=$(grep "^mp[0-9]*:" "$conf" 2>/dev/null)
    
    if [[ -z "$mounts" ]]; then
        show_proxmenux_logo
        msg_title "$(translate 'Remove LXC Mount Point')"
        msg_warn "$(translate 'No mount points found in container') $container_id"
        echo -e ""
        msg_success "$(translate 'Press Enter to continue...')"
        read -r
        return 1
    fi
    

    local options=()
    while IFS= read -r mount_line; do
        if [[ -n "$mount_line" ]]; then
            local mp_id=$(echo "$mount_line" | cut -d: -f1)
            local mount_info=$(echo "$mount_line" | cut -d: -f2-)
            local host_path=$(echo "$mount_info" | cut -d, -f1)
            local container_path=$(echo "$mount_info" | grep -o 'mp=[^,]*' | cut -d= -f2)
            
            options+=("$mp_id" "$host_path â†’ $container_path")
        fi
    done <<< "$mounts"
    
    if [[ ${#options[@]} -eq 0 ]]; then
        show_proxmenux_logo
        msg_title "$(translate 'Remove LXC Mount Point')"
        msg_warn "$(translate 'No valid mount points found')"
        echo -e ""
        msg_success "$(translate 'Press Enter to continue...')"
        read -r
        return 1
    fi
    

    local selected_mp
    selected_mp=$(dialog --clear --title "$(translate "Select Mount Point to Remove")" \
        --menu "\n$(translate "Select mount point to remove from container") $container_id:" 20 80 10 \
        "${options[@]}" 3>&1 1>&2 2>&3)
    
    if [[ $? -ne 0 || -z "$selected_mp" ]]; then
        return 1
    fi
    

    local selected_mount_line
    selected_mount_line=$(grep "^${selected_mp}:" "$conf")
    local mount_info=$(echo "$selected_mount_line" | cut -d: -f2-)
    local host_path=$(echo "$mount_info" | cut -d, -f1)
    local container_path=$(echo "$mount_info" | grep -o 'mp=[^,]*' | cut -d= -f2)

    local confirm_msg="$(translate "Remove Mount Point Confirmation:")

$(translate "Container ID"): $container_id
$(translate "Mount Point ID"): $selected_mp
$(translate "Host Path"): $host_path
$(translate "Container Path"): $container_path

$(translate "WARNING"): $(translate "This will remove the mount point from the container configuration.")
$(translate "The host directory and its contents will remain unchanged.")

$(translate "Proceed with removal")?"

    if ! dialog --clear --title "$(translate "Confirm Mount Point Removal")" --yesno "$confirm_msg" 18 80; then
        return 1
    fi
    
    show_proxmenux_logo
    msg_title "$(translate 'Remove LXC Mount Point')"
    
    msg_info "$(translate 'Removing mount point') $selected_mp $(translate 'from container') $container_id..."
    

    if pct set "$container_id" --delete "$selected_mp" 2>/dev/null; then
        msg_ok "$(translate 'Mount point removed successfully')"
        

        local ct_status
        ct_status=$(pct status "$container_id" | awk '{print $2}')
        
        if [[ "$ct_status" == "running" ]]; then
            echo -e ""
            if whiptail --yesno "$(translate "Container is running. Restart to apply changes?")" 8 60; then
                msg_info "$(translate 'Restarting container...')"
                if pct reboot "$container_id"; then
                    sleep 3
                    msg_ok "$(translate 'Container restarted successfully')"
                else
                    msg_warn "$(translate 'Failed to restart container - restart manually')"
                fi
            fi
        fi
        
        echo -e ""
        echo -e "${TAB}${BOLD}$(translate 'Mount Point Removal Summary:')${CL}"
        echo -e "${TAB}${BGN}$(translate 'Container:')${CL} ${BL}$container_id${CL}"
        echo -e "${TAB}${BGN}$(translate 'Removed Mount:')${CL} ${BL}$selected_mp${CL}"
        echo -e "${TAB}${BGN}$(translate 'Host Path:')${CL} ${BL}$host_dir (preserved)${CL}"
        echo -e "${TAB}${BGN}$(translate 'Container Path:')${CL} ${BL}$container_path (unmounted)${CL}"
        
    else
        msg_error "$(translate 'Failed to remove mount point')"
    fi
    
    echo -e ""
    msg_success "$(translate 'Press Enter to continue...')"
    read -r
}





# ==========================================================
# MINIMAL CONTAINER SETUP (NO HOST MODIFICATIONS)
# ==========================================================

get_container_uid_shift() {
    local ctid="$1"
    local conf="/etc/pve/lxc/${ctid}.conf"

    if [[ ! -f "$conf" ]]; then
        echo "100000"   
        return 0
    fi

    local unpriv
    unpriv=$(grep "^unprivileged:" "$conf" | awk '{print $2}')

    if [[ "$unpriv" == "1" ]]; then
        local uid_shift=$(grep "^lxc.idmap" "$conf" | grep 'u 0' | awk '{print $5}' | head -1)
        echo "${uid_shift:-100000}"
        return 0
    fi

    echo "0"
    return 0
}






setup_minimal_container_access() {
    local ctid="$1" host_dir="$2" ct_mount_point="$3"
    local uid_shift container_type host_gid host_group mapped_gid
    
    
    host_gid=$(stat -c '%g' "$host_dir" 2>/dev/null)
    host_group=$(getent group "$host_gid" | cut -d: -f1 2>/dev/null)
    host_group=${host_group:-"root"}
    
    msg_ok "$(translate "Host directory info detected - preserving existing configuration")" >&2
    
    uid_shift=$(get_container_uid_shift "$ctid")

    if [[ "$uid_shift" -eq 0 ]]; then
        msg_ok "$(translate "PRIVILEGED container detected - using direct UID/GID mapping")" >&2
        mapped_gid="$host_gid"
        container_type="privileged"
    else
        msg_ok "$(translate "UNPRIVILEGED container detected - using mapped UID/GID")" >&2
        mapped_gid=$((uid_shift + host_gid))
        container_type="unprivileged"
        msg_ok "$(translate "UID shift:") $uid_shift, $(translate "Host GID:") $host_gid â†’ $(translate "Container GID:") $mapped_gid" >&2
    fi

    msg_info "$(translate "Creating compatible group in container...")" >&2
    
    local container_group="shared_${host_gid}"
    
    pct exec "$ctid" -- groupadd -g "$mapped_gid" "$container_group" 2>/dev/null || true
    

    local users_added=0
    local user_list=""
    
    local temp_file="/tmp/users_$$.txt"
    pct exec "$ctid" -- awk -F: '$3 >= 25 && $3 < 65534 {print $1}' /etc/passwd > "$temp_file"
    
    if [[ -s "$temp_file" ]]; then
        while IFS= read -r username; do
            if [[ -n "$username" ]]; then
                if pct exec "$ctid" -- usermod -aG "$container_group" "$username" 2>/dev/null; then
                    users_added=$((users_added + 1))
                    user_list="$user_list $username"
                fi
            fi
        done < "$temp_file"
        
        if [[ $users_added -gt 0 ]]; then
            msg_ok "$(translate "Users added to group") $container_group: $users_added" >&2
        fi
    fi
    
    rm -f "$temp_file"

    if [[ "$container_type" == "unprivileged" ]]; then
        
        if ! command -v setfacl >/dev/null 2>&1; then
            apt-get update >/dev/null 2>&1
            apt-get install -y acl >/dev/null 2>&1
            msg_ok "$(translate "ACL tools installed")" >&2
        fi

        local acls_applied=0
        local acl_users=()
        

        while IFS=: read -r username _ ct_uid _; do
            if [[ $ct_uid -ge 25 && $ct_uid -lt 65534 ]]; then
                local host_uid=$((uid_shift + ct_uid))
                
                if setfacl -m u:$host_uid:rwx "$host_dir" 2>/dev/null && \
                   setfacl -m d:u:$host_uid:rwx "$host_dir" 2>/dev/null; then
                    acls_applied=$((acls_applied + 1))
                    acl_users+=("$username")
                fi
            fi
        done < <(pct exec "$ctid" -- cat /etc/passwd)
        
        if [[ $acls_applied -gt 0 ]]; then
            msg_ok "$(translate "ACL entries applied for") $acls_applied $(translate "users:") ${acl_users[*]}" >&2
        fi
    fi

    msg_info "$(translate "Configuring container mount point with setgid...")" >&2
    
    pct exec "$ctid" -- chgrp "$container_group" "$ct_mount_point" 2>/dev/null || true
    pct exec "$ctid" -- chmod 2775 "$ct_mount_point" 2>/dev/null || true

    msg_ok "$(translate "Container mount point configured with setgid")" >&2
    
    echo "$container_type|$host_group|$host_gid|$container_group|$mapped_gid"
    return 0
}





get_next_mp_index() {
    local ctid="$1"
    local conf="/etc/pve/lxc/${ctid}.conf"
    
    if [[ ! "$ctid" =~ ^[0-9]+$ ]] || [[ ! -f "$conf" ]]; then
        echo "0"
        return 0
    fi
    
    local used idx next=0
    used=$(awk -F: '/^mp[0-9]+:/ {print $1}' "$conf" | sed 's/mp//' | sort -n)
    for idx in $used; do
        [[ "$idx" -ge "$next" ]] && next=$((idx+1))
    done
    echo "$next"
}

add_bind_mount() {
    local ctid="$1" host_path="$2" ct_path="$3"
    local mpidx result
    
    if [[ ! "$ctid" =~ ^[0-9]+$ ]]; then
        return 1
    fi
    
    if [[ -z "$ctid" || -z "$host_path" || -z "$ct_path" ]]; then
        return 1
    fi

    if pct config "$ctid" | grep -q "$host_path"; then
        msg_warn "$(translate "Mount already exists for this path")"
        return 1
    fi

    mpidx=$(get_next_mp_index "$ctid")
    
    result=$(pct set "$ctid" -mp${mpidx} "$host_path,mp=$ct_path,shared=1,backup=0,acl=1" 2>&1)

    if [[ $? -eq 0 ]]; then
        msg_ok "$(translate "Successfully mounted:") $host_path â†’ $ct_path"
        return 0

    else
        msg_error "$(translate "Failed to add bind mount:") $result"
        return 1
    fi
}

# ==========================================================
# MAIN FUNCTION
# ==========================================================

mount_host_directory_minimal() {
    # Step 1: Select container
    local container_id
    container_id=$(select_lxc_container)
    if [[ $? -ne 0 || -z "$container_id" ]]; then
        return 1
    fi

    # Step 1.1: Ensure running
    ct_status=$(pct status "$container_id" | awk '{print $2}')
    if [[ "$ct_status" != "running" ]]; then
        show_proxmenux_logo
        msg_title "$(translate 'Mount Host Directory to LXC')"
        msg_info "$(translate "Starting container") $container_id..."
        if pct start "$container_id"; then
            sleep 3
            cleanup
        else
            msg_error "$(translate "Failed to start container")"
            echo -e ""
            msg_success "$(translate 'Press Enter to continue...')"
            read -r
            return 1
        fi
    fi


    # Step 2: Select host directory (unified menu)
    local host_dir
    host_dir=$(select_host_directory_unified)
    if [[ $? -ne 0 || -z "$host_dir" ]]; then
        return 1
    fi


    # Step 3: Select container mount point
    local ct_mount_point
    ct_mount_point=$(select_container_mount_point "$container_id" "$host_dir")
    if [[ $? -ne 0 || -z "$ct_mount_point" ]]; then
        return 1
    fi


    # Step 4: Get container info for confirmation
    local uid_shift container_type_display
    uid_shift=$(get_container_uid_shift "$container_id")
    if [[ "$uid_shift" -eq 0 ]]; then
        container_type_display="$(translate 'Privileged')"
    else
        container_type_display="$(translate 'Unprivileged')"
    fi


    # Step 4.1: Confirmation
    local confirm_msg="$(translate "Mount Configuration Summary:")

$(translate "Container ID"): $container_id ($container_type_display)
$(translate "Host Directory"): $host_dir
$(translate "Container Mount Point"): $ct_mount_point

$(translate "Notes:") 
- $(translate "The host directory will remain unchanged")
- $(translate "Basic permissions will be set inside the container")
- $(translate "ACL and setgid will be applied for group consistency")

$(translate "Proceed")?"

    if ! dialog --clear --title "$(translate "Confirm Mount point")" --yesno "$confirm_msg" 18 80; then
        return 1
    fi
    
    show_proxmenux_logo
    msg_title "$(translate 'Mount Host Directory to LXC')"

    msg_ok "$(translate 'Container selected:') $container_id"
    msg_ok "$(translate 'Container is running')"
    msg_ok "$(translate 'Host directory selected:') $host_dir"
    msg_ok "$(translate 'Container mount point selected:') $ct_mount_point"


    # Step 5: Add mount
    if ! add_bind_mount "$container_id" "$host_dir" "$ct_mount_point"; then
        echo -e ""
        msg_success "$(translate 'Press Enter to continue...')"
        read -r
        return 1
    fi
    
    # Step 6: Container setup
    local setup_info
    setup_info=$(setup_minimal_container_access "$container_id" "$host_dir" "$ct_mount_point")
    
    # Parse setup info
    IFS='|' read -r container_type host_group host_gid container_group mapped_gid fix_type <<< "$setup_info"
    
    msg_ok "$(translate "container configuration completed")"
    
    # Step 7: Summary
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate 'Mount Added Successfully:')${CL}"
    echo -e "${TAB}${BGN}$(translate 'Container:')${CL} ${BL}$container_id ($container_type_display)${CL}"
    echo -e "${TAB}${BGN}$(translate 'Host Directory:')${CL} ${BL}$host_dir${CL}"
    echo -e "${TAB}${BGN}$(translate 'Mount Point:')${CL} ${BL}$ct_mount_point${CL}"
    echo -e "${TAB}${BGN}$(translate 'Action Taken:')${CL} ${BL}PRESERVE existing permissions${CL}"
    
    if [[ "$fix_type" == "cifs-fixed" ]]; then
        echo -e "${TAB}${BGN}$(translate 'Permission Strategy:')${CL} ${BL}CIFS compatibility fixes applied${CL}"
        echo -e "${TAB}${YW}$(translate 'WARNING:')${CL} ${BL}Storage CIFS de Proxmox puede ser solo LECTURA${CL}"
    else
        echo -e "${TAB}${BGN}$(translate 'Permission Strategy:')${CL} ${BL}$(if [[ "$container_type" == "unprivileged" ]]; then echo "ACL (mapped UIDs)"; else echo "Direct mapping"; fi)${CL}"
    fi

    # Step 8: Restart
    echo -e ""
    if whiptail --yesno "$(translate "Restart container to activate mount?")" 8 60; then
        msg_info "$(translate 'Restarting container...')"
        if pct reboot "$container_id"; then
            sleep 5
            msg_ok "$(translate 'Container restarted successfully')"
            
            echo -e ""
            echo -e "${TAB}${BOLD}$(translate 'Testing access and read/write:')${CL}"
            test_user=$(pct exec "$container_id" -- sh -c "id -u www-data >/dev/null 2>&1 && echo www-data || echo root")

            if pct exec "$container_id" -- su -s /bin/bash $test_user -c "touch $ct_mount_point/test_access.txt" 2>/dev/null; then
                msg_ok "$(translate "Mount access and read/write successful (tested as $test_user)")"
                rm -f "$host_dir/test_access.txt" 2>/dev/null || true
            else
                msg_warn "$(translate "âš  Test read/write failed - may need additional configuration")"
                
            fi

        else
            msg_warn "$(translate 'Failed to restart - restart manually')"
        fi
    fi
    
    echo -e ""
    msg_success "$(translate 'Press Enter to continue...')"
    read -r
}

# Main menu
main_menu() {
    while true; do
        choice=$(dialog --title "$(translate 'LXC Mount Manager')" \
            --menu "\n$(translate 'Choose an option:')" 25 85 15 \
            "1" "$(translate 'Mount point: Host Directory to LXC')" \
            "2" "$(translate 'View Mount Points')" \
            "3" "$(translate 'Remove Mount Point')" \
            "4" "$(translate 'Exit')" 3>&1 1>&2 2>&3)
        
        case $choice in
            1)
                mount_host_directory_minimal
                ;;
            2)
                view_mount_points
                ;;
            3)
                remove_mount_point
                ;;
            4|"")
                exit 0
                ;;
        esac
    done
}


main_menu



================================================
FILE: scripts/share/nfs_client.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux CT - NFS Client Manager for Proxmox LXC
# ==========================================================
# Based on ProxMenux by MacRimi
# ==========================================================
# Description:
# This script allows you to manage NFS client mounts inside Proxmox CTs:
# - Mount NFS shares (temporary and permanent)
# - View current mounts
# - Unmount and remove NFS shares
# - Auto-discover NFS servers
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

# Load shared functions
SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    msg_error "$(translate "Could not load shared functions. Script cannot continue.")"
    exit 1
fi

load_language
initialize_cache


select_privileged_lxc


install_nfs_client() {

    if pct exec "$CTID" -- dpkg -s nfs-common &>/dev/null; then
        return 0
    fi


    show_proxmenux_logo
    msg_title "$(translate "Installing NFS Client in LXC")"

    msg_info "$(translate "Installing NFS client packages...")"
    if ! pct exec "$CTID" -- apt-get update >/dev/null 2>&1; then
        msg_error "$(translate "Failed to update package list.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! pct exec "$CTID" -- apt-get install -y nfs-common >/dev/null 2>&1; then
        msg_error "$(translate "Failed to install NFS client packages.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    if ! pct exec "$CTID" -- which showmount >/dev/null 2>&1; then
        msg_error "$(translate "showmount command not found after installation.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi
    if ! pct exec "$CTID" -- which mount.nfs >/dev/null 2>&1; then
        msg_error "$(translate "mount.nfs command not found after installation.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi

    msg_ok "$(translate "NFS client installed successfully.")"
    return 0
}



discover_nfs_servers() {
    show_proxmenux_logo
    msg_title "$(translate "Mount NFS Client in LXC")"
    msg_info "$(translate "Scanning network for NFS servers...")"

    

    HOST_IP=$(hostname -I | awk '{print $1}')
    NETWORK=$(echo "$HOST_IP" | cut -d. -f1-3).0/24
    

    if ! which nmap >/dev/null 2>&1; then
        apt-get install -y nmap &>/dev/null
    fi
    

    SERVERS=$(nmap -p 2049 --open "$NETWORK" 2>/dev/null | grep -B 4 "2049/tcp open" | grep "Nmap scan report" | awk '{print $5}' | sort -u || true)
    
    if [[ -z "$SERVERS" ]]; then
        cleanup
        whiptail --title "$(translate "No Servers Found")" --msgbox "$(translate "No NFS servers found on the network.")\n\n$(translate "You can add servers manually.")" 10 60
        return 1
    fi
    
    OPTIONS=()
    while IFS= read -r server; do
        if [[ -n "$server" ]]; then
            EXPORTS_COUNT=$(showmount -e "$server" 2>/dev/null | tail -n +2 | wc -l || echo "0")
            SERVER_INFO="NFS Server ($EXPORTS_COUNT exports)"
            OPTIONS+=("$server" "$SERVER_INFO")
        fi
    done <<< "$SERVERS"
    
    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        cleanup
        whiptail --title "$(translate "No Valid Servers")" --msgbox "$(translate "No accessible NFS servers found.")" 8 50
        return 1
    fi
    msg_ok "$(translate "NFS servers detected")"
    NFS_SERVER=$(whiptail --title "$(translate "Select NFS Server")" --menu "$(translate "Choose an NFS server:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -n "$NFS_SERVER" ]] && return 0 || return 1
}

select_nfs_server() {
    METHOD=$(whiptail --backtitle "ProxMenux" --title "$(translate "NFS Server Selection")" --menu "$(translate "How do you want to select the NFS server?")" 15 70 3 \
    "auto" "$(translate "Auto-discover servers on network")" \
    "manual" "$(translate "Enter server IP/hostname manually")" 3>&1 1>&2 2>&3)    
    case "$METHOD" in
        auto)
            discover_nfs_servers || return 1
            ;;
        manual)
            NFS_SERVER=$(whiptail --inputbox "$(translate "Enter NFS server IP or hostname:")" 10 60 --title "$(translate "NFS Server")" 3>&1 1>&2 2>&3)
            [[ -z "$NFS_SERVER" ]] && return 1
            ;;
        *)
            return 1
            ;;
    esac
    return 0
}




select_nfs_export() {

    if ! pct exec "$CTID" -- which showmount >/dev/null 2>&1; then
        whiptail --title "$(translate "NFS Client Error")" \
                 --msgbox "$(translate "showmount command is not working properly.")\n\n$(translate "Please check the installation.")" \
                 10 60
        return 1
    fi

    if ! pct exec "$CTID" -- ping -c 1 -W 3 "$NFS_SERVER" >/dev/null 2>&1; then
        whiptail --title "$(translate "Connection Error")" \
               --msgbox "$(translate "Cannot reach server") $NFS_SERVER\n\n$(translate "Please check:")\nâ€¢ $(translate "Server IP/hostname is correct")\nâ€¢ $(translate "Network connectivity")\nâ€¢ $(translate "Server is online")" \
               12 70
        return 1
    fi
    

    if ! pct exec "$CTID" -- nc -z -w 3 "$NFS_SERVER" 2049 2>/dev/null; then
        whiptail --title "$(translate "NFS Port Error")" \
               --msgbox "$(translate "NFS port (2049) is not accessible on") $NFS_SERVER\n\n$(translate "Please check:")\nâ€¢ $(translate "NFS server is running")\nâ€¢ $(translate "Firewall settings")\nâ€¢ $(translate "NFS service is enabled")" \
               12 70
        return 1
    fi
    

    EXPORTS_OUTPUT=$(pct exec "$CTID" -- showmount -e "$NFS_SERVER" 2>&1)
    EXPORTS_RESULT=$?
    
    if [[ $EXPORTS_RESULT -ne 0 ]]; then
        ERROR_MSG=$(echo "$EXPORTS_OUTPUT" | grep -i "error\|failed\|denied" | head -1)

        
        if echo "$EXPORTS_OUTPUT" | grep -qi "connection refused\|network unreachable"; then
            whiptail --title "$(translate "Network Error")" \
                   --msgbox "$(translate "Network connection failed to") $NFS_SERVER\n\n$(translate "Error:"): $ERROR_MSG\n\n$(translate "Please check:")\nâ€¢ $(translate "Server is running")\nâ€¢ $(translate "Network connectivity")\nâ€¢ $(translate "Firewall settings")" \
                   14 80
        else
            whiptail --title "$(translate "NFS Error")" \
                   --msgbox "$(translate "Failed to connect to") $NFS_SERVER\n\n$(translate "Error:"): $ERROR_MSG" \
                   12 80
        fi
        return 1
    fi
    

    EXPORTS=$(echo "$EXPORTS_OUTPUT" | tail -n +2 | awk '{print $1}' | grep -v "^$")

    if [[ -z "$EXPORTS" ]]; then
        whiptail --title "$(translate "No Exports Found")" \
               --msgbox "$(translate "No exports found on server") $NFS_SERVER\n\n$(translate "Server response:")\n$(echo "$EXPORTS_OUTPUT" | head -10)\n\n$(translate "You can enter the export path manually.")" \
               16 80
    
        NFS_EXPORT=$(whiptail --inputbox "$(translate "Enter NFS export path (e.g., /mnt/shared):")" 10 60 --title "$(translate "Export Path")" 3>&1 1>&2 2>&3)
        [[ -z "$NFS_EXPORT" ]] && return 1
        return 0
    fi

    # Build options for whiptail
    OPTIONS=()
    while IFS= read -r export_line; do
        if [[ -n "$export_line" ]]; then
            EXPORT_PATH=$(echo "$export_line" | awk '{print $1}')
            # Get allowed clients if available
            CLIENTS=$(echo "$EXPORTS_OUTPUT" | grep "^$EXPORT_PATH" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//')
            if [[ -n "$CLIENTS" ]]; then
                OPTIONS+=("$EXPORT_PATH" "$CLIENTS")
            else
                OPTIONS+=("$EXPORT_PATH" "$(translate "NFS export")")
            fi
        fi
    done <<< "$EXPORTS"
    
    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        whiptail --title "$(translate "No Available Exports")" \
               --msgbox "$(translate "No accessible exports found.")\n\n$(translate "You can enter the export path manually.")" \
               10 70
        
        NFS_EXPORT=$(whiptail --inputbox "$(translate "Enter NFS export path (e.g., /mnt/shared):")" 10 60 --title "$(translate "Export Path")" 3>&1 1>&2 2>&3)
        [[ -n "$NFS_EXPORT" ]] && return 0 || return 1
    fi
    
    NFS_EXPORT=$(whiptail --title "$(translate "Select NFS Export")" --menu "$(translate "Choose an export to mount:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -n "$NFS_EXPORT" ]] && return 0 || return 1
}

select_mount_point() {
    while true; do
        METHOD=$(whiptail --title "$(translate "Select Mount Point")" --menu "$(translate "Where do you want to mount the NFS export?")" 15 70 3 \
        "1" "$(translate "Create new folder in /mnt")" \
        "2" "$(translate "Select from existing folders in /mnt")" \
        "3" "$(translate "Enter custom path")" 3>&1 1>&2 2>&3)
        
        case "$METHOD" in
            1)
                # Create default name from server and export
                EXPORT_NAME=$(basename "$NFS_EXPORT")
                DEFAULT_NAME="nfs_${NFS_SERVER}_${EXPORT_NAME}"
                FOLDER_NAME=$(whiptail --inputbox "$(translate "Enter new folder name:")" 10 60 "$DEFAULT_NAME" --title "$(translate "New Folder in /mnt")" 3>&1 1>&2 2>&3)
                if [[ -n "$FOLDER_NAME" ]]; then
                    MOUNT_POINT="/mnt/$FOLDER_NAME"
                    return 0
                fi
                ;;
            2)
                DIRS=$(pct exec "$CTID" -- find /mnt -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
                if [[ -z "$DIRS" ]]; then
                    whiptail --title "$(translate "No Folders")" --msgbox "$(translate "No folders found in /mnt. Please create a new folder.")" 8 60
                    continue
                fi
                
                OPTIONS=()
                while IFS= read -r dir; do
                    if [[ -n "$dir" ]]; then
                        name=$(basename "$dir")
                        if pct exec "$CTID" -- [ "$(ls -A "$dir" 2>/dev/null | wc -l)" -eq 0 ]; then
                            status="$(translate "Empty")"
                        else
                            status="$(translate "Contains files")"
                        fi
                        OPTIONS+=("$dir" "$name ($status)")
                    fi
                done <<< "$DIRS"
                
                MOUNT_POINT=$(whiptail --title "$(translate "Select Existing Folder")" --menu "$(translate "Choose a folder to mount the export:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
                
                if [[ -n "$MOUNT_POINT" ]]; then
                    if pct exec "$CTID" -- [ "$(ls -A "$MOUNT_POINT" 2>/dev/null | wc -l)" -gt 0 ]; then
                        FILE_COUNT=$(pct exec "$CTID" -- ls -A "$MOUNT_POINT" 2>/dev/null | wc -l)
                        if ! whiptail --yesno "$(translate "WARNING: The selected directory is not empty!")\n\n$(translate "Directory:"): $MOUNT_POINT\n$(translate "Contains:"): $FILE_COUNT $(translate "files/folders")\n\n$(translate "Mounting here will hide existing files until unmounted.")\n\n$(translate "Do you want to continue?")" 14 70 --title "$(translate "Directory Not Empty")"; then
                            continue
                        fi
                    fi
                    return 0
                fi
                ;;    
            3)
                MOUNT_POINT=$(whiptail --inputbox "$(translate "Enter full path for mount point:")" 10 70 "/mnt/nfs_share" --title "$(translate "Custom Path")" 3>&1 1>&2 2>&3)
                if [[ -n "$MOUNT_POINT" ]]; then
                    return 0
                fi
                ;;
            *)
                return 1
                ;;
        esac
    done
}

configure_mount_options() {
    MOUNT_TYPE=$(whiptail --title "$(translate "Mount Options")" --menu "$(translate "Select mount configuration:")" 15 70 4 \
    "1" "$(translate "Default options read/write")" \
    "2" "$(translate "Read-only mount")" \
    "3" "$(translate "Custom options")" 3>&1 1>&2 2>&3)
    
    case "$MOUNT_TYPE" in
        1)
            MOUNT_OPTIONS="rw,hard,rsize=1048576,wsize=1048576,timeo=600,retrans=2"
            ;;
        2)
            MOUNT_OPTIONS="ro,hard,rsize=1048576,wsize=1048576,timeo=600,retrans=2"
            ;;
        3)
            MOUNT_OPTIONS=$(whiptail --inputbox "$(translate "Enter custom mount options:")" \
                10 70 "rw,hard,rsize=1048576,wsize=1048576,timeo=600,retrans=2" \
                --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
            [[ $? -ne 0 ]] && return 1
            [[ -z "$MOUNT_OPTIONS" ]] && MOUNT_OPTIONS="rw,hard"
            ;;
        *)
            MOUNT_OPTIONS="rw,hard,rsize=65536,wsize=65536,timeo=600,retrans=2"
            ;;
    esac
    
    if whiptail --yesno "$(translate "Do you want to make this mount permanent?")\n\n$(translate "This will add the mount to /etc/fstab so it persists after reboot.")" 10 70 --title "$(translate "Permanent Mount")"; then
        PERMANENT_MOUNT=true
    else
        PERMANENT_MOUNT=false
    fi
}

validate_export_exists() {
    local server="$1"
    local export="$2"
    

    
    VALIDATION_OUTPUT=$(pct exec "$CTID" -- showmount -e "$server" 2>/dev/null | grep "^$export[[:space:]]")
    
    if [[ -n "$VALIDATION_OUTPUT" ]]; then

        return 0
    else
        show_proxmenux_logo
        echo -e
        msg_error "$(translate "Export not found on server:") $export"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi
}



mount_nfs_share() {
    # Step 0: Install NFS client first
    install_nfs_client || return
    
    # Step 1: Select server
    select_nfs_server || return
    show_proxmenux_logo
    msg_title "$(translate "Mount NFS Share on Host")"
    msg_ok "$(translate "NFS server Selected")"
    
    # Step 2: Select export
    select_nfs_export || return
     msg_ok "$(translate "NFS export Selected")"
    
    # Step 2.5: Validate export exists
    if ! validate_export_exists "$NFS_SERVER" "$NFS_EXPORT"; then
        echo -e ""
        msg_error "$(translate "Cannot proceed with invalid export path.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return
    fi
    
    # Step 3: Select mount point
    select_mount_point || return
    
    # Step 4: Configure mount options
    configure_mount_options || return


    
    
    if ! pct exec "$CTID" -- test -d "$MOUNT_POINT"; then
        if pct exec "$CTID" -- mkdir -p "$MOUNT_POINT"; then
            msg_ok "$(translate "Mount point created.")"
        else
            msg_error "$(translate "Failed to create mount point.")"
            return 1
        fi
    fi
    
    if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
        msg_warn "$(translate "Something is already mounted at") $MOUNT_POINT"
        if ! whiptail --yesno "$(translate "Do you want to unmount it first?")" 8 60 --title "$(translate "Already Mounted")"; then
            return
        fi
        pct exec "$CTID" -- umount "$MOUNT_POINT" 2>/dev/null || true
    fi
    
    # Build mount command
    NFS_PATH="$NFS_SERVER:$NFS_EXPORT"
    
    msg_info "$(translate "Testing NFS connection...")"
    if pct exec "$CTID" -- mount -t nfs -o "$MOUNT_OPTIONS" "$NFS_PATH" "$MOUNT_POINT"; then
        msg_ok "$(translate "NFS share mounted successfully!")"
        
        # Test write access
        if pct exec "$CTID" -- touch "$MOUNT_POINT/.test_write" 2>/dev/null; then
            pct exec "$CTID" -- rm "$MOUNT_POINT/.test_write" 2>/dev/null
            msg_ok "$(translate "Write access confirmed.")"
        else
            msg_warn "$(translate "Read-only access (or no write permissions).")"
        fi
        
        # Add to fstab if permanent
        if [[ "$PERMANENT_MOUNT" == "true" ]]; then
            pct exec "$CTID" -- sed -i "\|$MOUNT_POINT|d" /etc/fstab
            FSTAB_ENTRY="$NFS_PATH $MOUNT_POINT nfs $MOUNT_OPTIONS 0 0"
            pct exec "$CTID" -- bash -c "echo '$FSTAB_ENTRY' >> /etc/fstab"
            msg_ok "$(translate "Added to /etc/fstab for permanent mounting.")"
        fi
        
        # Show mount information
        echo -e ""
        echo -e "${TAB}${BOLD}$(translate "Mount Information:")${CL}"
        echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$NFS_SERVER${CL}"
        echo -e "${TAB}${BGN}$(translate "Export:")${CL} ${BL}$NFS_EXPORT${CL}"
        echo -e "${TAB}${BGN}$(translate "Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
        echo -e "${TAB}${BGN}$(translate "Options:")${CL} ${BL}$MOUNT_OPTIONS${CL}"
        echo -e "${TAB}${BGN}$(translate "Permanent:")${CL} ${BL}$PERMANENT_MOUNT${CL}"
        
    else
        msg_error "$(translate "Failed to mount NFS share.")"
        echo -e "${TAB}$(translate "Please check:")"
        echo -e "${TAB}â€¢ $(translate "Server is accessible:"): $NFS_SERVER"
        echo -e "${TAB}â€¢ $(translate "Export exists:"): $NFS_EXPORT"
        echo -e "${TAB}â€¢ $(translate "Network connectivity")"
        echo -e "${TAB}â€¢ $(translate "NFS server is running")"
        echo -e "${TAB}â€¢ $(translate "Export permissions allow access")"
    fi
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

view_nfs_mounts() {
    show_proxmenux_logo
    msg_title "$(translate "Current NFS Mounts")"
    
    echo -e "$(translate "NFS mounts in CT") $CTID:"
    echo "=================================="
    
    # Show currently mounted NFS shares - VERSIÃ“N CORREGIDA
    CURRENT_MOUNTS=$(pct exec "$CTID" -- mount | grep -E "type nfs|:.*on.*nfs" 2>/dev/null || true)
    if [[ -n "$CURRENT_MOUNTS" ]]; then
        echo -e "${BOLD}$(translate "Currently Mounted:")${CL}"
        echo "$CURRENT_MOUNTS"
        echo ""
    else
        # Verificar si hay montajes NFS en fstab que estÃ©n activos
        ACTIVE_NFS_MOUNTS=$(pct exec "$CTID" -- grep "nfs" /etc/fstab 2>/dev/null | grep -v "^#" | while read -r line; do
            MOUNT_POINT=$(echo "$line" | awk '{print $2}')
            if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
                echo "$MOUNT_POINT"
            fi
        done)
        
        if [[ -n "$ACTIVE_NFS_MOUNTS" ]]; then
            echo -e "${BOLD}$(translate "Currently Mounted:")${CL}"
            while IFS= read -r mount_point; do
                if [[ -n "$mount_point" ]]; then
                    MOUNT_INFO=$(pct exec "$CTID" -- mount | grep "$mount_point")
                    echo "$MOUNT_INFO"
                fi
            done <<< "$ACTIVE_NFS_MOUNTS"
            echo ""
        else
            echo "$(translate "No NFS shares currently mounted.")"
            echo ""
        fi
    fi
    
    # Show fstab entries
    FSTAB_NFS=$(pct exec "$CTID" -- grep "nfs" /etc/fstab 2>/dev/null || true)
    if [[ -n "$FSTAB_NFS" ]]; then
        echo -e "${BOLD}$(translate "Permanent Mounts (fstab):")${CL}"
        echo "$FSTAB_NFS"
        echo ""
        
        echo -e "${TAB}${BOLD}$(translate "Mount Details:")${CL}"
        while IFS= read -r fstab_line; do
            if [[ -n "$fstab_line" && ! "$fstab_line" =~ ^# ]]; then
                NFS_PATH=$(echo "$fstab_line" | awk '{print $1}')
                MOUNT_POINT=$(echo "$fstab_line" | awk '{print $2}')
                OPTIONS=$(echo "$fstab_line" | awk '{print $4}')
                
                # Extract server and export from NFS path
                SERVER=$(echo "$NFS_PATH" | cut -d: -f1)
                EXPORT=$(echo "$NFS_PATH" | cut -d: -f2)
                
                echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$SERVER${CL}"
                echo -e "${TAB}${BGN}$(translate "Export:")${CL} ${BL}$EXPORT${CL}"
                echo -e "${TAB}${BGN}$(translate "Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
                echo -e "${TAB}${BGN}$(translate "Options:")${CL} ${BL}$OPTIONS${CL}"
                
                # Check if currently mounted
                if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${GN}$(translate "Mounted")${CL}"
                else
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${RD}$(translate "Not Mounted")${CL}"
                fi
                echo ""
            fi
        done <<< "$FSTAB_NFS"
    else
        echo "$(translate "No permanent NFS mounts configured.")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}



unmount_nfs_share() {
    # Get current NFS mounts
    MOUNTS=$(pct exec "$CTID" -- mount | grep -E "type nfs|:.*on.*nfs" | awk '{print $3}' | sort -u || true)
    FSTAB_MOUNTS=$(pct exec "$CTID" -- grep -E "nfs" /etc/fstab 2>/dev/null | grep -v "^#" | awk '{print $2}' | sort -u || true)
    
    # Combine and deduplicate
    ALL_MOUNTS=$(echo -e "$MOUNTS\n$FSTAB_MOUNTS" | sort -u | grep -v "^$" || true)
    
    if [[ -z "$ALL_MOUNTS" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Mounts")" --msgbox "\n$(translate "No NFS mounts found.")" 8 50
        return
    fi
    
    OPTIONS=()
    while IFS= read -r mount_point; do
        [[ -n "$mount_point" ]] && OPTIONS+=("$mount_point" "")
    done <<< "$ALL_MOUNTS"
    
    SELECTED_MOUNT=$(dialog --backtitle "ProxMenux" --title "$(translate "Unmount NFS Share")" --menu "$(translate "Select mount point to unmount:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -z "$SELECTED_MOUNT" ]] && return
    
    if whiptail --yesno "$(translate "Are you sure you want to unmount this NFS share?")\n\n$(translate "Mount Point:"): $SELECTED_MOUNT\n\n$(translate "This will remove the mount from /etc/fstab.")" 12 80 --title "$(translate "Confirm Unmount")"; then
        show_proxmenux_logo
        msg_title "$(translate "Unmount NFS Share")"
        
        # Remove from fstab
        pct exec "$CTID" -- sed -i "\|[[:space:]]$SELECTED_MOUNT[[:space:]]|d" /etc/fstab
        msg_ok "$(translate "Removed from /etc/fstab.")"
        
        echo -e ""
        msg_ok "$(translate "NFS share unmount successfully. Reboot LXC required to take effect.")"
    fi
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}




test_nfs_connectivity() {
    show_proxmenux_logo
    msg_title "$(translate "Test NFS Connectivity")"
    
    echo -e "$(translate "NFS Client Status in CT") $CTID:"
    echo "=================================="
    
    # Check if NFS client is installed
    if pct exec "$CTID" -- dpkg -s nfs-common &>/dev/null; then
        echo "$(translate "NFS Client: INSTALLED")"
        
        # Check showmount
        if pct exec "$CTID" -- which showmount >/dev/null 2>&1; then
            echo "$(translate "NFS Client Tools: AVAILABLE")"
        else
            echo "$(translate "NFS Client Tools: NOT AVAILABLE")"
        fi
        
        # Check rpcbind service
        if pct exec "$CTID" -- systemctl is-active --quiet rpcbind 2>/dev/null; then
            echo "$(translate "RPC Bind Service: RUNNING")"
        else
            echo "$(translate "RPC Bind Service: STOPPED")"
            msg_warn "$(translate "Starting rpcbind service...")"
            pct exec "$CTID" -- systemctl start rpcbind 2>/dev/null || true
        fi
        
        echo ""
        echo "$(translate "Current NFS mounts:")"
        CURRENT_MOUNTS=$(pct exec "$CTID" -- mount | grep -E "type nfs|:.*on.*nfs" 2>/dev/null || true)
        if [[ -n "$CURRENT_MOUNTS" ]]; then
            echo "$CURRENT_MOUNTS"
        else
            # Check for active NFS mounts from fstab
            ACTIVE_NFS_MOUNTS=$(pct exec "$CTID" -- grep "nfs" /etc/fstab 2>/dev/null | grep -v "^#" | while read -r line; do
                MOUNT_POINT=$(echo "$line" | awk '{print $2}')
                if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
                    pct exec "$CTID" -- mount | grep "$MOUNT_POINT"
                fi
            done)
            
            if [[ -n "$ACTIVE_NFS_MOUNTS" ]]; then
                echo "$ACTIVE_NFS_MOUNTS"
            else
                echo "$(translate "No NFS mounts active.")"
            fi
        fi
        
        echo ""
        echo "$(translate "Testing network connectivity...")"
        
        # Test connectivity to known NFS servers from fstab
        FSTAB_SERVERS=$(pct exec "$CTID" -- grep "nfs" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d: -f1 | sort -u || true)
        if [[ -n "$FSTAB_SERVERS" ]]; then
            while IFS= read -r server; do
                if [[ -n "$server" ]]; then
                    echo -n "$(translate "Testing") $server: "
                    if pct exec "$CTID" -- ping -c 1 -W 2 "$server" >/dev/null 2>&1; then
                        echo -e "\033[1;92m$(translate "Reachable")\033[0m"
                        
                        # Test NFS port
                        echo -n "  $(translate "NFS port 2049"): "
                        if pct exec "$CTID" -- nc -z -w 2 "$server" 2049 2>/dev/null; then
                            echo -e "\033[1;92m$(translate "Open")\033[0m"
                        else
                            echo -e "\033[1;91m$(translate "Closed")\033[0m"
                        fi
                        
                        # Try to list exports
                        echo -n "  $(translate "Export list test"): "
                        if pct exec "$CTID" -- showmount -e "$server" >/dev/null 2>&1; then
                            echo -e "\033[1;92m$(translate "Available")\033[0m"
                        else
                            echo -e "\033[1;91m$(translate "Failed")\033[0m"
                        fi
                    else
                        echo -e "\033[1;91m$(translate "Unreachable")\033[0m"
                    fi
                fi
            done <<< "$FSTAB_SERVERS"
        else
            echo "$(translate "No NFS servers configured to test.")"
        fi
        
    else
        echo "$(translate "NFS Client: NOT INSTALLED")"
        echo ""
        echo "$(translate "Run 'Mount NFS Share' to install NFS client automatically.")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}


# === Main Menu ===
while true; do
    CHOICE=$(dialog --backtitle "ProxMenux" --title "$(translate "NFS Client Manager - CT") $CTID" \
    --menu "$(translate "Choose an option:")" 20 70 12 \
    "1" "$(translate "Mount NFS Share")" \
    "2" "$(translate "View Current Mounts")" \
    "3" "$(translate "Unmount NFS Share")" \
    "4" "$(translate "Test NFS Connectivity")" \
    "5" "$(translate "Exit")" \
    3>&1 1>&2 2>&3)
    
    RETVAL=$?
    if [[ $RETVAL -ne 0 ]]; then
        exit 0
    fi
    
    case $CHOICE in
        1) mount_nfs_share ;;
        2) view_nfs_mounts ;;
        3) unmount_nfs_share ;;
        4) test_nfs_connectivity ;;
        5) exit 0 ;;
        *) exit 0 ;;
    esac
done



================================================
FILE: scripts/share/nfs_host.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux Host - NFS Host Manager for Proxmox Host
# ==========================================================
# Based on ProxMenux by MacRimi
# ==========================================================
# Description:
# This script allows you to manage NFS client mounts on Proxmox Host:
# - Mount external NFS shares on the host
# - Configure permanent mounts
# - Auto-discover NFS servers
# - Integrate with Proxmox storage system
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Load common share functions
SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    msg_warn "$(translate "Could not load shared functions. Using fallback methods.")"
    SHARE_COMMON_LOADED=false
else
    SHARE_COMMON_LOADED=true
fi



discover_nfs_servers() {
    show_proxmenux_logo
    msg_title "$(translate "Mount NFS Share on Host")"
    msg_info "$(translate "Scanning network for NFS servers...")"

    HOST_IP=$(hostname -I | awk '{print $1}')
    NETWORK=$(echo "$HOST_IP" | cut -d. -f1-3).0/24

    if ! which nmap >/dev/null 2>&1; then
        apt-get install -y nmap &>/dev/null
    fi

    SERVERS=$(nmap -p 2049 --open "$NETWORK" 2>/dev/null | grep -B 4 "2049/tcp open" | grep "Nmap scan report" | awk '{print $5}' | sort -u || true)
    
    if [[ -z "$SERVERS" ]]; then
        cleanup
        dialog --clear --title "$(translate "No Servers Found")" --msgbox "$(translate "No NFS servers found on the network.")\n\n$(translate "You can add servers manually.")" 10 60
        return 1
    fi
    
    OPTIONS=()
    while IFS= read -r server; do
        if [[ -n "$server" ]]; then
            EXPORTS_COUNT=$(showmount -e "$server" 2>/dev/null | tail -n +2 | wc -l || echo "0")
            SERVER_INFO="NFS Server ($EXPORTS_COUNT exports)"
            OPTIONS+=("$server" "$SERVER_INFO")
        fi
    done <<< "$SERVERS"
    
    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        cleanup
        dialog --clear --title "$(translate "No Valid Servers")" --msgbox "$(translate "No accessible NFS servers found.")" 8 50
        return 1
    fi
    cleanup
    NFS_SERVER=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select NFS Server")" --menu "$(translate "Choose an NFS server:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -n "$NFS_SERVER" ]] && return 0 || return 1
}

select_nfs_server() {
    METHOD=$(dialog --backtitle "ProxMenux" --title "$(translate "NFS Server Selection")" --menu "$(translate "How do you want to select the NFS server?")" 15 70 3 \
    "auto" "$(translate "Auto-discover servers on network")" \
    "manual" "$(translate "Enter server IP/hostname manually")" \
    "recent" "$(translate "Select from recent servers")" 3>&1 1>&2 2>&3)
    
    case "$METHOD" in
        auto)
            discover_nfs_servers || return 1
            ;;
        manual)
            clear
            NFS_SERVER=$(whiptail --inputbox "$(translate "Enter NFS server IP or hostname:")" 10 60 --title "$(translate "NFS Server")" 3>&1 1>&2 2>&3)
            [[ -z "$NFS_SERVER" ]] && return 1
            ;;
        recent)
            clear
            RECENT=$(grep "nfs" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d: -f1 | sort -u || true)
            if [[ -z "$RECENT" ]]; then
                dialog --title "$(translate "No Recent Servers")" --msgbox "\n$(translate "No recent NFS servers found.")" 8 50
                return 1
            fi
            
            OPTIONS=()
            while IFS= read -r server; do
                [[ -n "$server" ]] && OPTIONS+=("$server" "$(translate "Recent NFS server")")
            done <<< "$RECENT"
            
            NFS_SERVER=$(whiptail --title "$(translate "Recent NFS Servers")" --menu "$(translate "Choose a recent server:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
            [[ -n "$NFS_SERVER" ]] && return 0 || return 1
            ;;
        *)
            return 1
            ;;
    esac
    return 0
}

select_nfs_export() {
    if ! which showmount >/dev/null 2>&1; then
        whiptail --title "$(translate "NFS Client Error")" \
                 --msgbox "$(translate "showmount command is not working properly.")\n\n$(translate "Please check the installation.")" \
                 10 60
        return 1
    fi

    if ! ping -c 1 -W 3 "$NFS_SERVER" >/dev/null 2>&1; then
        whiptail --title "$(translate "Connection Error")" \
               --msgbox "$(translate "Cannot reach server") $NFS_SERVER\n\n$(translate "Please check:")\nâ€¢ $(translate "Server IP/hostname is correct")\nâ€¢ $(translate "Network connectivity")\nâ€¢ $(translate "Server is online")" \
               12 70
        return 1
    fi

    if ! nc -z -w 3 "$NFS_SERVER" 2049 2>/dev/null; then
        whiptail --title "$(translate "NFS Port Error")" \
               --msgbox "$(translate "NFS port (2049) is not accessible on") $NFS_SERVER\n\n$(translate "Please check:")\nâ€¢ $(translate "NFS server is running")\nâ€¢ $(translate "Firewall settings")\nâ€¢ $(translate "NFS service is enabled")" \
               12 70
        return 1
    fi

    EXPORTS_OUTPUT=$(showmount -e "$NFS_SERVER" 2>&1)
    EXPORTS_RESULT=$?
    
    if [[ $EXPORTS_RESULT -ne 0 ]]; then
        ERROR_MSG=$(echo "$EXPORTS_OUTPUT" | grep -i "error\|failed\|denied" | head -1)
        
        if echo "$EXPORTS_OUTPUT" | grep -qi "connection refused\|network unreachable"; then
            whiptail --title "$(translate "Network Error")" \
                   --msgbox "$(translate "Network connection failed to") $NFS_SERVER\n\n$(translate "Error:"): $ERROR_MSG\n\n$(translate "Please check:")\nâ€¢ $(translate "Server is running")\nâ€¢ $(translate "Network connectivity")\nâ€¢ $(translate "Firewall settings")" \
                   14 80
        else
            whiptail --title "$(translate "NFS Error")" \
                   --msgbox "$(translate "Failed to connect to") $NFS_SERVER\n\n$(translate "Error:"): $ERROR_MSG" \
                   12 80
        fi
        return 1
    fi
    
    EXPORTS=$(echo "$EXPORTS_OUTPUT" | tail -n +2 | awk '{print $1}' | grep -v "^$")

    if [[ -z "$EXPORTS" ]]; then
        whiptail --title "$(translate "No Exports Found")" \
               --msgbox "$(translate "No exports found on server") $NFS_SERVER\n\n$(translate "Server response:")\n$(echo "$EXPORTS_OUTPUT" | head -10)\n\n$(translate "You can enter the export path manually.")" \
               16 80
    
        NFS_EXPORT=$(whiptail --inputbox "$(translate "Enter NFS export path (e.g., /mnt/shared):")" 10 60 --title "$(translate "Export Path")" 3>&1 1>&2 2>&3)
        [[ -z "$NFS_EXPORT" ]] && return 1
        return 0
    fi

    OPTIONS=()
    while IFS= read -r export_line; do
        if [[ -n "$export_line" ]]; then
            EXPORT_PATH=$(echo "$export_line" | awk '{print $1}')
            CLIENTS=$(echo "$EXPORTS_OUTPUT" | grep "^$EXPORT_PATH" | awk '{for(i=2;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/[[:space:]]*$//')
            if [[ -n "$CLIENTS" ]]; then
                OPTIONS+=("$EXPORT_PATH" "$CLIENTS")
            else
                OPTIONS+=("$EXPORT_PATH" "$(translate "NFS export")")
            fi
        fi
    done <<< "$EXPORTS"
    
    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        whiptail --title "$(translate "No Available Exports")" \
               --msgbox "$(translate "No accessible exports found.")\n\n$(translate "You can enter the export path manually.")" \
               10 70
        
        NFS_EXPORT=$(whiptail --inputbox "$(translate "Enter NFS export path (e.g., /mnt/shared):")" 10 60 --title "$(translate "Export Path")" 3>&1 1>&2 2>&3)
        [[ -n "$NFS_EXPORT" ]] && return 0 || return 1
    fi
    
    NFS_EXPORT=$(whiptail --title "$(translate "Select NFS Export")" --menu "$(translate "Choose an export to mount:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -n "$NFS_EXPORT" ]] && return 0 || return 1
}


select_host_mount_point() {
    local export_name=$(basename "$NFS_EXPORT")
    local default_path="/mnt/shared_nfs_${export_name}"

    MOUNT_POINT=$(pmx_select_host_mount_point "$(translate "NFS Mount Point")" "$default_path")
    [[ -n "$MOUNT_POINT" ]] && return 0 || return 1
}



configure_host_mount_options() {
    MOUNT_TYPE=$(whiptail --title "$(translate "Mount Options")" --menu "$(translate "Select mount configuration:")" 15 70 4 \
    "1"     "$(translate "Default options read/write")" \
    "2"    "$(translate "Read-only mount")" \
    "3"      "$(translate "Enter custom options")" 3>&1 1>&2 2>&3)
    
    [[ $? -ne 0 ]] && return 1
    
    case "$MOUNT_TYPE" in
        1)
            MOUNT_OPTIONS="rw,hard,nofail,rsize=131072,wsize=131072,timeo=600,retrans=2" 
            ;;
        2)
            MOUNT_OPTIONS="ro,hard,nofail,rsize=131072,wsize=131072,timeo=600,retrans=2" 
            ;;
        3)

            MOUNT_OPTIONS=$(whiptail --inputbox "$(translate "Enter custom mount options:")" \
                10 70 "rw,hard,nofail,rsize=131072,wsize=131072,timeo=600,retrans=2" \
                --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
            [[ $? -ne 0 ]] && return 1
            [[ -z "$MOUNT_OPTIONS" ]] && MOUNT_OPTIONS="rw,hard,nofail"
            ;;
        *)
            MOUNT_OPTIONS="rw,hard,nofail,rsize=131072,wsize=131072,timeo=600,retrans=2"
            ;;
    esac

    if whiptail --yesno "$(translate "Do you want to make this mount permanent?")\n\n$(translate "This will add the mount to /etc/fstab so it persists after reboot.")" 10 70 --title "$(translate "Permanent Mount")"; then
        PERMANENT_MOUNT=true
    else
        if [[ $? -eq 1 ]]; then
            PERMANENT_MOUNT=false
        else
            return 1
        fi
    fi

    
    TEMP_MOUNT="/tmp/nfs_test_$$"
    mkdir -p "$TEMP_MOUNT" 2>/dev/null
    
    NFS_PATH="$NFS_SERVER:$NFS_EXPORT"
    if timeout 10 mount -t nfs -o ro,soft,timeo=5 "$NFS_PATH" "$TEMP_MOUNT" 2>/dev/null; then
        umount "$TEMP_MOUNT" 2>/dev/null || true
        rmdir "$TEMP_MOUNT" 2>/dev/null || true
        msg_ok "$(translate "NFS export is accessible")"
        

        if whiptail --yesno "$(translate "Do you want to add this as Proxmox storage?")\n\n$(translate "This will make the NFS share available as storage in Proxmox web interface.")" 10 70 --title "$(translate "Proxmox Storage")"; then
            PROXMOX_STORAGE=true
            
            STORAGE_ID=$(whiptail --inputbox "$(translate "Enter storage ID for Proxmox:")" 10 60 "nfs-$(echo $NFS_SERVER | tr '.' '-')" --title "$(translate "Storage ID")" 3>&1 1>&2 2>&3)
            STORAGE_ID_RESULT=$?
            
            if [[ $STORAGE_ID_RESULT -ne 0 ]]; then
                if whiptail --yesno "$(translate "Storage ID input was cancelled.")\n\n$(translate "Do you want to continue without Proxmox storage integration?")" 10 70 --title "$(translate "Continue Without Storage")"; then
                    PROXMOX_STORAGE=false
                else
                    return 1
                fi
            else
                [[ -z "$STORAGE_ID" ]] && STORAGE_ID="nfs-$(echo $NFS_SERVER | tr '.' '-')"
            fi
        else
            DIALOG_RESULT=$?
            if [[ $DIALOG_RESULT -eq 1 ]]; then
                PROXMOX_STORAGE=false
            else
                return 1
            fi
        fi
    else

        rmdir "$TEMP_MOUNT" 2>/dev/null || true
        msg_warn "$(translate "NFS export accessibility test failed")"
        
        if whiptail --yesno "$(translate "The NFS export could not be validated for accessibility.")\n\n$(translate "This might be due to:")\nâ€¢ $(translate "Network connectivity issues")\nâ€¢ $(translate "Export permission restrictions")\nâ€¢ $(translate "Firewall blocking access")\n\n$(translate "Do you want to continue mounting anyway?")\n$(translate "(Proxmox storage integration will be skipped)")" 16 80 --title "$(translate "Export Validation Failed")"; then
            PROXMOX_STORAGE=false
            msg_info2 "$(translate "Continuing without Proxmox storage integration due to accessibility issues.")"
            sleep 2
        else
            return 1
        fi
    fi
    
    return 0
}

validate_host_export_exists() {
    local server="$1"
    local export="$2"
    
    VALIDATION_OUTPUT=$(showmount -e "$server" 2>/dev/null | grep "^$export[[:space:]]")
    
    if [[ -n "$VALIDATION_OUTPUT" ]]; then
        return 0
    else
        show_proxmenux_logo
        echo -e
        msg_error "$(translate "Export not found on server:") $export"
        return 1
    fi
}

add_proxmox_nfs_storage() {
    local storage_id="$1"
    local server="$2"
    local export="$3"
    local content="${4:-backup,iso,vztmpl}"
    
    msg_info "$(translate "Starting Proxmox storage integration...")"
    
    if ! command -v pvesm >/dev/null 2>&1; then
        show_proxmenux_logo
        msg_error "$(translate "pvesm command not found. This should not happen on Proxmox.")"
        echo "Press Enter to continue..."
        read -r
        return 1
    fi
    
    msg_ok "$(translate "pvesm command found")"

    # Check if storage ID already exists
    if pvesm status "$storage_id" >/dev/null 2>&1; then
        msg_warn "$(translate "Storage ID already exists:") $storage_id"
        if ! whiptail --yesno "$(translate "Storage ID already exists. Do you want to remove and recreate it?")" 8 60 --title "$(translate "Storage Exists")"; then
            return 0 
        fi
        pvesm remove "$storage_id" 2>/dev/null || true
    fi
    
    msg_ok "$(translate "Storage ID is available")"

    
    # Let Proxmox handle NFS version negotiation automatically
    if pvesm_output=$(pvesm add nfs "$storage_id" \
        --server "$server" \
        --export "$export" \
        --content "$content" 2>&1); then
        
        msg_ok "$(translate "NFS storage added successfully!")"
        
        # Get the actual NFS version that Proxmox negotiated
        local nfs_version="Auto-negotiated"
        if pvesm config "$storage_id" 2>/dev/null | grep -q "options.*vers="; then
            nfs_version="v$(pvesm config "$storage_id" | grep "options" | grep -o "vers=[0-9.]*" | cut -d= -f2)"
        fi
        
        echo -e ""
        echo -e "${TAB}${BGN}$(translate "Storage ID:")${CL} ${BL}$storage_id${CL}"
        echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$server${CL}"
        echo -e "${TAB}${BGN}$(translate "Export:")${CL} ${BL}$export${CL}"
        echo -e "${TAB}${BGN}$(translate "Content Types:")${CL} ${BL}$content${CL}"
        echo -e "${TAB}${BGN}$(translate "NFS Version:")${CL} ${BL}$nfs_version${CL}"
        echo -e ""
        msg_ok "$(translate "Storage is now available in Proxmox web interface under Datacenter > Storage")"
        return 0
    else
        msg_error "$(translate "Failed to add NFS storage to Proxmox.")"
        echo "$(translate "Error details:"): $pvesm_output"
        msg_warn "$(translate "The NFS share is still mounted, but not added as Proxmox storage.")"
        msg_info2 "$(translate "You can add it manually through:")"
        echo -e "${TAB}â€¢ $(translate "Proxmox web interface: Datacenter > Storage > Add > NFS")"
        echo -e "${TAB}â€¢ $(translate "Command line:"): pvesm add nfs $storage_id --server $server --export $export --content backup,iso,vztmpl"
        return 1
    fi
}

prepare_host_directory() {
    local mount_point="$1"
    
    if [[ "$SHARE_COMMON_LOADED" == "true" ]]; then
        # Use common functions for advanced directory preparation
        local group_name
        group_name=$(pmx_choose_or_create_group "sharedfiles")
        if [[ -n "$group_name" ]]; then
            local host_gid
            host_gid=$(pmx_ensure_host_group "$group_name")
            if [[ -n "$host_gid" ]]; then
                pmx_prepare_host_shared_dir "$mount_point" "$group_name"
                pmx_share_map_set "$mount_point" "$group_name"
                msg_ok "$(translate "Directory prepared with shared group:") $group_name (GID: $host_gid)"
                return 0
            fi
        fi
        msg_warn "$(translate "Failed to use shared functions, using basic directory creation.")"
    fi
    
    # Fallback: basic directory creation
    if ! test -d "$mount_point"; then
        if mkdir -p "$mount_point"; then
            msg_ok "$(translate "Mount point created on host.")"
            return 0
        else
            msg_error "$(translate "Failed to create mount point on host.")"
            return 1
        fi
    fi
    return 0
}

mount_host_nfs_share() {
    if ! which showmount >/dev/null 2>&1; then
        msg_error "$(translate "NFS client tools not found. Please check Proxmox installation.")"
        return 1
    fi
    
    # Step 1: 
    select_nfs_server || return
    
    # Step 2: 
    select_nfs_export || return
    
    # Step 2.5: 
    if ! validate_host_export_exists "$NFS_SERVER" "$NFS_EXPORT"; then
        echo -e ""
        msg_error "$(translate "Cannot proceed with invalid export path.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return
    fi
    
    # Step 3: 
    select_host_mount_point || return
    
    # Step 4: 
    configure_host_mount_options || return

    show_proxmenux_logo
    msg_title "$(translate "Mount NFS Share on Host")"
    msg_ok "$(translate "NFS server selected")"

    prepare_host_directory "$MOUNT_POINT" || return 1

    if mount | grep -q "$MOUNT_POINT"; then
        msg_warn "$(translate "Something is already mounted at") $MOUNT_POINT"
        if ! whiptail --yesno "$(translate "Do you want to unmount it first?")" 8 60 --title "$(translate "Already Mounted")"; then
            return
        fi
        umount "$MOUNT_POINT" 2>/dev/null || true
    fi

    NFS_PATH="$NFS_SERVER:$NFS_EXPORT"

    if mount -t nfs -o "$MOUNT_OPTIONS" "$NFS_PATH" "$MOUNT_POINT" > /dev/null 2>&1; then
        msg_ok "$(translate "NFS share mounted successfully on host!")"

        if touch "$MOUNT_POINT/.test_write" 2>/dev/null; then
            rm "$MOUNT_POINT/.test_write" 2>/dev/null
            msg_ok "$(translate "Write access confirmed.")"
        else
            msg_warn "$(translate "Read-only access (or no write permissions).")"
        fi

        if [[ "$PERMANENT_MOUNT" == "true" ]]; then
            sed -i "\|$MOUNT_POINT|d" /etc/fstab
            FSTAB_ENTRY="$NFS_PATH $MOUNT_POINT nfs $MOUNT_OPTIONS 0 0"
            echo "$FSTAB_ENTRY" >> /etc/fstab
            msg_ok "$(translate "Added to /etc/fstab for permanent mounting.")"

            msg_info "$(translate "Reloading systemd configuration...")"
            systemctl daemon-reload 2>/dev/null || true
            msg_ok "$(translate "Systemd configuration reloaded.")"
        fi

        if [[ "$PROXMOX_STORAGE" == "true" ]]; then
            add_proxmox_nfs_storage "$STORAGE_ID" "$NFS_SERVER" "$NFS_EXPORT" "$MOUNT_CONTENT"
        fi

        echo -e ""
        echo -e "${TAB}${BOLD}$(translate "Host Mount Information:")${CL}"
        echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$NFS_SERVER${CL}"
        echo -e "${TAB}${BGN}$(translate "Export:")${CL} ${BL}$NFS_EXPORT${CL}"
        echo -e "${TAB}${BGN}$(translate "Host Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
        echo -e "${TAB}${BGN}$(translate "Options:")${CL} ${BL}$MOUNT_OPTIONS${CL}"
        echo -e "${TAB}${BGN}$(translate "Permanent:")${CL} ${BL}$PERMANENT_MOUNT${CL}"
        if [[ "$PROXMOX_STORAGE" == "true" ]]; then
            echo -e "${TAB}${BGN}$(translate "Proxmox Storage ID:")${CL} ${BL}$STORAGE_ID${CL}"
        fi
        
    else
        msg_error "$(translate "Failed to mount NFS share on host.")"
        echo -e "${TAB}$(translate "Please check:")"
        echo -e "${TAB}â€¢ $(translate "Server is accessible:"): $NFS_SERVER"
        echo -e "${TAB}â€¢ $(translate "Export exists:"): $NFS_EXPORT"
        echo -e "${TAB}â€¢ $(translate "Network connectivity")"
        echo -e "${TAB}â€¢ $(translate "NFS server is running")"
        echo -e "${TAB}â€¢ $(translate "Export permissions allow access")"
    fi
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

view_host_nfs_mounts() {
    show_proxmenux_logo
    msg_title "$(translate "Current NFS Mounts on Host")"
    
    echo -e "$(translate "NFS mounts on Proxmox host:"):"
    echo "=================================="
    
    CURRENT_MOUNTS=$(mount | grep -E "type nfs|:.*on.*nfs" 2>/dev/null || true)
    if [[ -n "$CURRENT_MOUNTS" ]]; then
        echo -e "${BOLD}$(translate "Currently Mounted:")${CL}"
        echo "$CURRENT_MOUNTS"
        echo ""
    else
        echo "$(translate "No NFS shares currently mounted on host.")"
        echo ""
    fi
    
    FSTAB_NFS=$(grep "nfs" /etc/fstab 2>/dev/null || true)
    if [[ -n "$FSTAB_NFS" ]]; then
        echo -e "${BOLD}$(translate "Permanent Mounts (fstab):")${CL}"
        echo "$FSTAB_NFS"
        echo ""
        
        echo -e "${TAB}${BOLD}$(translate "Mount Details:")${CL}"
        while IFS= read -r fstab_line; do
            if [[ -n "$fstab_line" && ! "$fstab_line" =~ ^# ]]; then
                NFS_PATH=$(echo "$fstab_line" | awk '{print $1}')
                MOUNT_POINT=$(echo "$fstab_line" | awk '{print $2}')
                OPTIONS=$(echo "$fstab_line" | awk '{print $4}')
                
                SERVER=$(echo "$NFS_PATH" | cut -d: -f1)
                EXPORT=$(echo "$NFS_PATH" | cut -d: -f2)
                
                echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$SERVER${CL}"
                echo -e "${TAB}${BGN}$(translate "Export:")${CL} ${BL}$EXPORT${CL}"
                echo -e "${TAB}${BGN}$(translate "Host Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
                echo -e "${TAB}${BGN}$(translate "Options:")${CL} ${BL}$OPTIONS${CL}"
                
                if mount | grep -q "$MOUNT_POINT"; then
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${GN}$(translate "Mounted")${CL}"
                else
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${RD}$(translate "Not Mounted")${CL}"
                fi
                echo ""
            fi
        done <<< "$FSTAB_NFS"
    else
        echo "$(translate "No NFS mounts found in fstab.")"
    fi

    echo ""
    echo "$(translate "Proxmox NFS Storage Status:")"
    if which pvesm >/dev/null 2>&1; then
        NFS_STORAGES=$(pvesm status 2>/dev/null | grep "nfs" || true)
        if [[ -n "$NFS_STORAGES" ]]; then
            echo "$NFS_STORAGES"
        else
            echo "$(translate "No NFS storage configured in Proxmox.")"
        fi
    else
        echo "$(translate "pvesm command not available.")"
    fi
        
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

unmount_host_nfs_share() {
    MOUNTS=$(mount | grep -E "type nfs|:.*on.*nfs" | awk '{print $3}' | sort -u || true)
    FSTAB_MOUNTS=$(grep -E "nfs" /etc/fstab 2>/dev/null | grep -v "^#" | awk '{print $2}' | sort -u || true)

    ALL_MOUNTS=$(echo -e "$MOUNTS\n$FSTAB_MOUNTS" | sort -u | grep -v "^$" || true)
    
    if [[ -z "$ALL_MOUNTS" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Mounts")" --msgbox "\n$(translate "No NFS mounts found on host.")" 8 50
        return
    fi
    
    OPTIONS=()
    while IFS= read -r mount_point; do
        if [[ -n "$mount_point" ]]; then
            NFS_PATH=$(mount | grep "$mount_point" | awk '{print $1}' || grep "$mount_point" /etc/fstab | awk '{print $1}' || echo "Unknown")
            SERVER=$(echo "$NFS_PATH" | cut -d: -f1)
            EXPORT=$(echo "$NFS_PATH" | cut -d: -f2)
            OPTIONS+=("$mount_point" "$SERVER:$EXPORT")
        fi
    done <<< "$ALL_MOUNTS"
    
    SELECTED_MOUNT=$(dialog --backtitle "ProxMenux" --title "$(translate "Unmount NFS Share")" --menu "$(translate "Select mount point to unmount:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -z "$SELECTED_MOUNT" ]] && return

    NFS_PATH=$(mount | grep "$SELECTED_MOUNT" | awk '{print $1}' || grep "$SELECTED_MOUNT" /etc/fstab | awk '{print $1}' || echo "Unknown")
    SERVER=$(echo "$NFS_PATH" | cut -d: -f1)
    EXPORT=$(echo "$NFS_PATH" | cut -d: -f2)

    PROXMOX_STORAGE=""
    if which pvesm >/dev/null 2>&1; then
        NFS_STORAGES=$(pvesm status 2>/dev/null | grep "nfs" | awk '{print $1}' || true)
        while IFS= read -r storage_id; do
            if [[ -n "$storage_id" ]]; then
                STORAGE_INFO=$(pvesm config "$storage_id" 2>/dev/null || true)
                STORAGE_SERVER=$(echo "$STORAGE_INFO" | grep "server" | awk '{print $2}')
                STORAGE_EXPORT=$(echo "$STORAGE_INFO" | grep "export" | awk '{print $2}')
                if [[ "$STORAGE_SERVER" == "$SERVER" && "$STORAGE_EXPORT" == "$EXPORT" ]]; then
                    PROXMOX_STORAGE="$storage_id"
                    break
                fi
            fi
        done <<< "$NFS_STORAGES"
    fi

    CONFIRMATION_MSG="$(translate "Are you sure you want to unmount this NFS share?")\n\n$(translate "Mount Point:"): $SELECTED_MOUNT\n$(translate "Server:"): $SERVER\n$(translate "Export:"): $EXPORT\n\n$(translate "This will:")\nâ€¢ $(translate "Unmount the NFS share")\nâ€¢ $(translate "Remove from /etc/fstab")"
    
    if [[ -n "$PROXMOX_STORAGE" ]]; then
        CONFIRMATION_MSG="$CONFIRMATION_MSG\nâ€¢ $(translate "Remove Proxmox storage:"): $PROXMOX_STORAGE"
    fi
    
    CONFIRMATION_MSG="$CONFIRMATION_MSG\nâ€¢ $(translate "Remove mount point directory")"
    
    if whiptail --yesno "$CONFIRMATION_MSG" 16 80 --title "$(translate "Confirm Unmount")"; then
        show_proxmenux_logo
        msg_title "$(translate "Unmount NFS Share from Host")"
        
        if [[ -n "$PROXMOX_STORAGE" ]]; then
            if pvesm remove "$PROXMOX_STORAGE" 2>/dev/null; then
                msg_ok "$(translate "Proxmox storage removed successfully.")"
            else
                msg_warn "$(translate "Failed to remove Proxmox storage, continuing with unmount...")"
            fi
        fi

        if mount | grep -q "$SELECTED_MOUNT"; then
            if umount "$SELECTED_MOUNT"; then
                msg_ok "$(translate "Successfully unmounted.")"
            else
                msg_warn "$(translate "Failed to unmount. Trying force unmount...")"
                if umount -f "$SELECTED_MOUNT" 2>/dev/null; then
                    msg_ok "$(translate "Force unmount successful.")"
                else
                    msg_error "$(translate "Failed to unmount. Mount point may be busy.")"
                    echo -e "${TAB}$(translate "Try closing any applications using the mount point.")"
                fi
            fi
        fi

        msg_info "$(translate "Removing from /etc/fstab...")"
        sed -i "\|[[:space:]]$SELECTED_MOUNT[[:space:]]|d" /etc/fstab
        msg_ok "$(translate "Removed from /etc/fstab.")"
                
        echo -e ""
        msg_ok "$(translate "NFS share unmounted successfully from host!")"
        
        if [[ -n "$PROXMOX_STORAGE" ]]; then
            echo -e "${TAB}${BGN}$(translate "Proxmox storage removed:")${CL} ${BL}$PROXMOX_STORAGE${CL}"
        fi
        echo -e "${TAB}${BGN}$(translate "Mount point unmounted:")${CL} ${BL}$SELECTED_MOUNT${CL}"
        echo -e "${TAB}${BGN}$(translate "Removed from fstab:")${CL} ${BL}Yes${CL}"
    fi
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

manage_proxmox_storage() {
    if ! command -v pvesm >/dev/null 2>&1; then
        dialog --backtitle "ProxMenux" --title "$(translate "Error")" --msgbox "\n$(translate "pvesm command not found. This should not happen on Proxmox.")" 8 60
        return
    fi

    NFS_STORAGES=$(pvesm status 2>/dev/null | awk '$2 == "nfs" {print $1}')
    if [[ -z "$NFS_STORAGES" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No NFS Storage")" --msgbox "\n$(translate "No NFS storage found in Proxmox.")" 8 60
        return
    fi

    OPTIONS=()
    while IFS= read -r storage_id; do
        if [[ -n "$storage_id" ]]; then
            STORAGE_INFO=$(pvesm config "$storage_id" 2>/dev/null || true)
            SERVER=$(echo "$STORAGE_INFO" | grep "server" | awk '{print $2}')
            EXPORT=$(echo "$STORAGE_INFO" | grep "export" | awk '{print $2}')
            
            if [[ -n "$SERVER" && -n "$EXPORT" ]]; then
                OPTIONS+=("$storage_id" "$SERVER:$EXPORT")
            else
                OPTIONS+=("$storage_id" "$(translate "NFS Storage")")
            fi
        fi
    done <<< "$NFS_STORAGES"
    
    SELECTED_STORAGE=$(dialog --backtitle "ProxMenux" --title "$(translate "Manage Proxmox NFS Storage")" --menu "$(translate "Select storage to manage:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -z "$SELECTED_STORAGE" ]] && return

    STORAGE_INFO=$(pvesm config "$SELECTED_STORAGE" 2>/dev/null || true)
    SERVER=$(echo "$STORAGE_INFO" | grep "server" | awk '{print $2}')
    EXPORT=$(echo "$STORAGE_INFO" | grep "export" | awk '{print $2}')
    CONTENT=$(echo "$STORAGE_INFO" | grep "content" | awk '{print $2}')

    FSTAB_NFS=$(grep "nfs" /etc/fstab 2>/dev/null || true)
    if [[ -n "$FSTAB_NFS" ]]; then
        while IFS= read -r fstab_line; do
            if [[ -n "$fstab_line" && ! "$fstab_line" =~ ^# ]]; then
                NFS_PATH=$(echo "$fstab_line" | awk '{print $1}')
                MOUNT_POINT=$(echo "$fstab_line" | awk '{print $2}')
                OPTIONS=$(echo "$fstab_line" | awk '{print $4}')
                
                SERVER=$(echo "$NFS_PATH" | cut -d: -f1)
                EXPORT=$(echo "$NFS_PATH" | cut -d: -f2)
            fi
        done <<< "$FSTAB_NFS"
    fi

    if whiptail --yesno "$(translate "Are you sure you want to REMOVE storage") $SELECTED_STORAGE?\n\n$(translate "Server:"): $SERVER\n$(translate "Export:"): $EXPORT\n\n$(translate "WARNING: This will permanently remove the storage from Proxmox configuration.")\n$(translate "The NFS mount on the host will NOT be affected.")" 14 80 --title "$(translate "Remove Storage")"; then
        show_proxmenux_logo
        msg_title "$(translate "Remove Storage")"
        
        if pvesm remove "$SELECTED_STORAGE" 2>/dev/null; then
            msg_ok "$(translate "Storage removed successfully from Proxmox.")"
            echo -e ""
            msg_success "$(translate "Press Enter to return to menu...")"
            read -r
        else
            msg_error "$(translate "Failed to remove storage.")"
        fi
    fi
}

test_host_nfs_connectivity() {
    show_proxmenux_logo
    msg_title "$(translate "Test NFS Connectivity on Host")"
    
    echo -e "$(translate "NFS Client Status on Proxmox Host:"):"
    echo "=================================="

    if which showmount >/dev/null 2>&1; then
        echo "$(translate "NFS Client Tools: AVAILABLE")"

        if systemctl is-active --quiet rpcbind 2>/dev/null; then
            echo "$(translate "RPC Bind Service: RUNNING")"
        else
            echo "$(translate "RPC Bind Service: STOPPED")"
            msg_warn "$(translate "Starting rpcbind service...")"
            systemctl start rpcbind 2>/dev/null || true
        fi
        
        echo ""
        echo "$(translate "Current NFS mounts on host:")"
        CURRENT_MOUNTS=$(mount | grep -E "type nfs|:.*on.*nfs" 2>/dev/null || true)
        if [[ -n "$CURRENT_MOUNTS" ]]; then
            echo "$CURRENT_MOUNTS"
        else
            echo "$(translate "No NFS mounts active on host.")"
        fi
        
        echo ""
        echo "$(translate "Testing network connectivity...")"

        FSTAB_SERVERS=$(grep "nfs" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d: -f1 | sort -u || true)
        if [[ -n "$FSTAB_SERVERS" ]]; then
            while IFS= read -r server; do
                if [[ -n "$server" ]]; then
                    echo -n "$(translate "Testing") $server: "
                    if ping -c 1 -W 2 "$server" >/dev/null 2>&1; then
                        echo -e "${GN}$(translate "Reachable")${CL}"

                        echo -n "  $(translate "NFS port 2049"): "
                        if nc -z -w 2 "$server" 2049 2>/dev/null; then
                            echo -e "${GN}$(translate "Open")${CL}"
                        else
                            echo -e "${RD}$(translate "Closed")${CL}"
                        fi

                        echo -n "  $(translate "Export list test"): "
                        if showmount -e "$server" >/dev/null 2>&1; then
                            echo -e "${GN}$(translate "Available")${CL}"
                        else
                            echo -e "${RD}$(translate "Failed")${CL}"
                        fi
                    else
                        echo -e "${RD}$(translate "Unreachable")${CL}"
                    fi
                fi
            done <<< "$FSTAB_SERVERS"
        else
            echo "$(translate "No NFS servers configured to test.")"
        fi

        echo ""
        echo "$(translate "Proxmox NFS Storage Status:")"
        if which pvesm >/dev/null 2>&1; then
            NFS_STORAGES=$(pvesm status 2>/dev/null | grep "nfs" || true)
            if [[ -n "$NFS_STORAGES" ]]; then
                echo "$NFS_STORAGES"
            else
                echo "$(translate "No NFS storage configured in Proxmox.")"
            fi
        else
            echo "$(translate "pvesm command not available.")"
        fi
        
    else
        echo "$(translate "NFS Client Tools: NOT AVAILABLE")"
        echo ""
        echo "$(translate "This is unusual for Proxmox. NFS client tools should be installed.")"
    fi

    echo ""
    echo "$(translate "ProxMenux Extensions:")"
    if [[ "$SHARE_COMMON_LOADED" == "true" ]]; then
        echo "$(translate "Shared Functions: LOADED")"
        if [[ -f "$PROXMENUX_SHARE_MAP_DB" ]]; then
            MAPPED_DIRS=$(wc -l < "$PROXMENUX_SHARE_MAP_DB" 2>/dev/null || echo "0")
            echo "$(translate "Mapped directories:"): $MAPPED_DIRS"
        fi
    else
        echo "$(translate "Shared Functions: NOT LOADED (using fallback methods)")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

# === Main Menu ===
while true; do
    CHOICE=$(dialog --backtitle "ProxMenux" --title "$(translate "NFS Host Manager - Proxmox Host")" \
    --menu "$(translate "Choose an option:")" 22 80 14 \
    "1" "$(translate "Mount NFS Share on Host")" \
    "2" "$(translate "View Current Host NFS Mounts")" \
    "3" "$(translate "Unmount NFS Share from Host")" \
    "4" "$(translate "Remove Proxmox NFS Storage")" \
    "5" "$(translate "Test NFS Connectivity")" \
    "6" "$(translate "Exit")" \
    3>&1 1>&2 2>&3)
    
    RETVAL=$?
    if [[ $RETVAL -ne 0 ]]; then
        exit 0
    fi
    
    case $CHOICE in
        1) mount_host_nfs_share ;;
        2) view_host_nfs_mounts ;;
        3) unmount_host_nfs_share ;;
        4) manage_proxmox_storage ;;
        5) test_host_nfs_connectivity ;;
        6) exit 0 ;;
        *) exit 0 ;;
    esac
done



================================================
FILE: scripts/share/nfs_lxc_server.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux CT - NFS Manager for Proxmox LXC (Simple + Universal)
# ==========================================================
# Based on ProxMenux by MacRimi
# ==========================================================
# Description:
# This script allows you to manage NFS shares inside Proxmox CTs:
# - Create NFS exports with universal sharedfiles group
# - View configured exports
# - Delete existing exports
# - Check NFS service status
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

# Load shared functions
SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    msg_error "$(translate "Could not load shared functions. Script cannot continue.")"
    exit 1
fi

load_language
initialize_cache


select_privileged_lxc




setup_universal_sharedfiles_group() {
    local ctid="$1"
    
    msg_info "$(translate "Setting sharedfiles group with UID remapping...")"
    
    if ! pct exec "$ctid" -- getent group sharedfiles >/dev/null 2>&1; then
        pct exec "$ctid" -- groupadd -g 101000 sharedfiles
        msg_ok "$(translate "Created sharedfiles group (GID: 101000)")"
    else
        local current_gid=$(pct exec "$ctid" -- getent group sharedfiles | cut -d: -f3)
        if [[ "$current_gid" != "101000" ]]; then
            pct exec "$ctid" -- groupmod -g 101000 sharedfiles
            msg_ok "$(translate "Updated sharedfiles group to GID: 101000")"
        else
            msg_ok "$(translate "Sharedfiles group already exists (GID: 101000)")"
        fi
    fi
    

    local lxc_users=$(pct exec "$ctid" -- awk -F: '$3 >= 1000 && $3 < 65534 {print $1 ":" $3}' /etc/passwd)
    

    if [[ -n "$lxc_users" ]]; then
        msg_info "$(translate "Adding existing users to sharedfiles group...")"
        while IFS=: read -r username uid; do
            if [[ -n "$username" ]]; then
                pct exec "$ctid" -- usermod -a -G sharedfiles "$username" 2>/dev/null || true
                msg_ok "$(translate "Added user") $username (UID: $uid) $(translate "to sharedfiles group")"
            fi
        done <<< "$lxc_users"
    fi
    

    msg_info "$(translate "Creating UID remapping for unprivileged container compatibility...")"
    local remapped_count=0
    
    if [[ -n "$lxc_users" ]]; then
        while IFS=: read -r username uid; do
            if [[ -n "$uid" ]]; then
                local remapped_uid=$((uid + 100000))
                local remapped_username="remap_${uid}"
                

                if ! pct exec "$ctid" -- id "$remapped_username" >/dev/null 2>&1; then
                    pct exec "$ctid" -- useradd -u "$remapped_uid" -g sharedfiles -s /bin/false -M "$remapped_username" 2>/dev/null || true
                    msg_ok "$(translate "Created remapped user") $remapped_username (UID: $remapped_uid)"
                    ((remapped_count++))
                else

                    pct exec "$ctid" -- usermod -g sharedfiles "$remapped_username" 2>/dev/null || true
                fi
            fi
        done <<< "$lxc_users"
    fi
    

    local common_uids=(33 1000 1001 1002)  
    for base_uid in "${common_uids[@]}"; do
        local remapped_uid=$((base_uid + 100000))
        local remapped_username="remap_${base_uid}"
        
        if ! pct exec "$ctid" -- id "$remapped_username" >/dev/null 2>&1; then
            pct exec "$ctid" -- useradd -u "$remapped_uid" -g sharedfiles -s /bin/false -M "$remapped_username" 2>/dev/null || true
            msg_ok "$(translate "Created common remapped user") $remapped_username (UID: $remapped_uid)"
            ((remapped_count++))
        fi
    done
    
    msg_ok "$(translate "Universal sharedfiles group configured with") $remapped_count $(translate "remapped users")"
}




select_mount_point() {
    while true; do
        METHOD=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Folder")" \
            --menu "$(translate "How do you want to select the folder to export?")" 15 60 5 \
            "auto" "$(translate "Select from folders inside /mnt")" \
            "manual" "$(translate "Enter path manually")" \
            3>&1 1>&2 2>&3)
        
        if [[ $? -ne 0 ]]; then
            return 1
        fi

        case "$METHOD" in
            auto)
                DIRS=$(pct exec "$CTID" -- find /mnt -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
                if [[ -z "$DIRS" ]]; then
                    whiptail --title "$(translate "No Folders")" --msgbox "$(translate "No folders found inside /mnt in the CT.")" 8 60
                    continue
                fi
                
                OPTIONS=()
                while IFS= read -r dir; do
                    name=$(basename "$dir")
                    OPTIONS+=("$dir" "$name")
                done <<< "$DIRS"
                
                MOUNT_POINT=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Folder")" \
                    --menu "$(translate "Choose a folder to export:")" 20 60 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                [[ -n "$MOUNT_POINT" ]] && return 0
                ;;
                manual)
                    CT_NAME=$(pct config "$CTID" | awk -F: '/hostname/ {print $2}' | xargs)
                    DEFAULT_MOUNT_POINT="/mnt/${CT_NAME}_nfs"
                    MOUNT_POINT=$(whiptail --title "$(translate "Mount Point")" \
                        --inputbox "$(translate "Enter the mount point for the NFS export (e.g., /mnt/mynfs):")" \
                        10 70 "$DEFAULT_MOUNT_POINT" 3>&1 1>&2 2>&3)
                    if [[ $? -ne 0 ]]; then
                        return 1
                    fi
                    if [[ -z "$MOUNT_POINT" ]]; then
                        whiptail --title "$(translate "Error")" \
                            --msgbox "$(translate "No mount point was specified.")" 8 50
                        continue
                    fi
                    pct exec "$CTID" -- mkdir -p "$MOUNT_POINT" 2>/dev/null
                    return 0
                    ;;
        esac
    done
}

get_network_config() {
    NETWORK=$(whiptail --backtitle "ProxMenux" --title "$(translate "Network Configuration")" --menu "\n$(translate "Select network access level:")" 15 70 4 \
    "1" "$(translate "Local network only (192.168.0.0/16)")" \
    "2" "$(translate "Specific subnet (enter manually)")" \
    "3" "$(translate "Specific host (enter IP)")" 3>&1 1>&2 2>&3)
    
    case "$NETWORK" in
        1)
            NETWORK_RANGE="192.168.0.0/16"
            ;;
        2)
            clear
            NETWORK_RANGE=$(whiptail --inputbox "$(translate "Enter subnet (e.g., 192.168.0.0/24):")" 10 60 "192.168.0.0/24" --title "$(translate "Subnet")" 3>&1 1>&2 2>&3)
            [[ -z "$NETWORK_RANGE" ]] && return 1
            ;;
        3)
            dialog
            NETWORK_RANGE=$(whiptail --inputbox "$(translate "Enter host IP (e.g., 192.168.0.100):")" 10 60 --title "$(translate "Host IP")" 3>&1 1>&2 2>&3)
            [[ -z "$NETWORK_RANGE" ]] && return 1
            ;;
        *)
            return 1
            ;;
    esac
    return 0
}







select_export_options() {
    EXPORT_OPTIONS=$(whiptail --title "$(translate "Export Options")" --menu \
        "\n$(translate "Select export permissions:")" 15 70 3 \
        "1" "$(translate "Read-Write (universal)")" \
        "2" "$(translate "Read-Only")" \
        "3" "$(translate "Custom options")" 3>&1 1>&2 2>&3)

    case "$EXPORT_OPTIONS" in
        1)
            OPTIONS="rw,sync,no_subtree_check,no_root_squash"
            ;;
        2)
            OPTIONS="ro,sync,no_subtree_check,no_root_squash"
            ;;
        3)
            OPTIONS=$(whiptail --inputbox "$(translate "Enter custom NFS options:")" \
                10 70 "rw,sync,no_subtree_check,no_root_squash" \
                --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
            [[ -z "$OPTIONS" ]] && OPTIONS="rw,sync,no_subtree_check,no_root_squash"
            ;;
        *)
            OPTIONS="rw,sync,no_subtree_check,no_root_squash"
            ;;
    esac
}





create_nfs_export() {

    show_proxmenux_logo
    msg_title "$(translate "Create LXC server NFS")"
    sleep 2


    select_mount_point || return
    get_network_config || return
    select_export_options || return


    msg_ok "$(translate "Directory successfully.")"


    if ! pct exec "$CTID" -- dpkg -s nfs-kernel-server &>/dev/null; then
        msg_info "$(translate "Installing NFS server packages inside the CT...")"
        pct exec "$CTID" -- bash -c "apt-get update && apt-get install -y nfs-kernel-server nfs-common rpcbind"
        pct exec "$CTID" -- systemctl enable --now rpcbind nfs-kernel-server
        msg_ok "$(translate "NFS server installed successfully.")"
    else
        msg_ok "$(translate "NFS server is already installed.")"
    fi


    setup_universal_sharedfiles_group "$CTID"


    msg_info "$(translate "Setting directory ownership and permissions...")"
    pct exec "$CTID" -- chown root:sharedfiles "$MOUNT_POINT"
    pct exec "$CTID" -- chmod 2775 "$MOUNT_POINT"  
    msg_ok "$(translate "Directory configured with sharedfiles group ownership")"



    EXPORT_LINE="$MOUNT_POINT $NETWORK_RANGE($OPTIONS)"


    if pct exec "$CTID" -- grep -q "^$MOUNT_POINT " /etc/exports; then
        if dialog --yesno "$(translate "Do you want to update the existing export?")" \
            10 60 --title "$(translate "Update Export")"; then
            pct exec "$CTID" -- sed -i "\|^$MOUNT_POINT |d" /etc/exports
            pct exec "$CTID" -- bash -c "echo '$EXPORT_LINE' >> /etc/exports"
            show_proxmenux_logo
            msg_title "$(translate "Create LXC server NFS")"
            msg_ok "$(translate "Directory successfully.")"
            msg_ok "$(translate "Export updated successfully.")"
            msg_ok "$(translate "NFS server is already installed.")"
            msg_ok "$(translate "Directory configured with sharedfiles group ownership")"

        fi
    else
        pct exec "$CTID" -- bash -c "echo '$EXPORT_LINE' >> /etc/exports"
        msg_ok "$(translate "Export added successfully.")"
    fi


    pct exec "$CTID" -- systemctl restart rpcbind nfs-kernel-server
    pct exec "$CTID" -- exportfs -ra


    CT_IP=$(pct exec "$CTID" -- hostname -I | awk '{print $1}')
    
    echo -e ""
    msg_ok "$(translate "NFS export created successfully!")"
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate "Connection details:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Server IP:")${CL}  ${BL}$CT_IP${CL}"
    echo -e "${TAB}${BGN}$(translate "Export path:")${CL} ${BL}$MOUNT_POINT${CL}"
    echo -e "${TAB}${BGN}$(translate "Mount options:")${CL} ${BL}$OPTIONS${CL}"
    echo -e "${TAB}${BGN}$(translate "Network access:")${CL} ${BL}$NETWORK_RANGE${CL}"
    echo -e "${TAB}${BGN}$(translate "NFS Version:")${CL} ${BL}Auto-negotiation (NFSv3/NFSv4)${CL}"
    echo -e ""
    
    echo -e "${TAB}${BOLD}$(translate "Mount Examples:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Auto-negotiate:")${CL} ${BL}mount -t nfs $CT_IP:$MOUNT_POINT /mnt/nfs${CL}"
    echo -e "${TAB}${BGN}$(translate "Force NFSv4:")${CL} ${BL}mount -t nfs4 $CT_IP:$MOUNT_POINT /mnt/nfs${CL}"
    echo -e "${TAB}${BGN}$(translate "Force NFSv3:")${CL} ${BL}mount -t nfs -o vers=3 $CT_IP:$MOUNT_POINT /mnt/nfs${CL}"
    echo ""
    
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

view_exports() {
    show_proxmenux_logo
    msg_title "$(translate "View Current Exports")"
    
    echo -e "$(translate "Current NFS exports in CT") $CTID:"
    echo "=================================="
    
    if pct exec "$CTID" -- test -f /etc/exports; then
        EXPORTS=$(pct exec "$CTID" -- cat /etc/exports | grep -v '^#' | grep -v '^$')
        if [[ -n "$EXPORTS" ]]; then
            echo "$EXPORTS"
            echo ""
            echo "$(translate "Active exports:")"
            pct exec "$CTID" -- showmount -e localhost 2>/dev/null || echo "$(translate "No active exports or showmount not available")"
            

            echo ""
            echo "$(translate "Universal Group Configuration:")"
            echo "=================================="
            if pct exec "$CTID" -- getent group sharedfiles >/dev/null 2>&1; then
                local group_members=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f4)
                local sharedfiles_gid=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f3)
                echo "$(translate "Shared group: sharedfiles (GID:") $sharedfiles_gid)"
                
                local member_count=$(echo "$group_members" | tr ',' '\n' | wc -l)
                echo "$(translate "Total members:") $member_count $(translate "users")"
                

                local remapped_users=$(pct exec "$CTID" -- getent passwd | grep "^remap_" | wc -l)
                if [[ "$remapped_users" -gt 0 ]]; then
                    echo "$(translate "Remapped users:") $remapped_users $(translate "users (for unprivileged compatibility)")"
                fi
                
                echo "$(translate "Universal compatibility: ENABLED")"
                echo "$(translate "NFS Version: Auto-negotiation (NFSv3/NFSv4)")"
            else
                echo "$(translate "Universal group: NOT CONFIGURED")"
            fi

            CT_IP=$(pct exec "$CTID" -- hostname -I | awk '{print $1}')
            
            echo ""
            echo "=================================="
            echo -e "${TAB}${BOLD}$(translate "Connection Details:")${CL}"
            echo -e "${TAB}${BGN}$(translate "Server IP:")${CL}  ${BL}$CT_IP${CL}"
            while IFS= read -r export_line; do
                if [[ -n "$export_line" ]]; then
                    EXPORT_PATH=$(echo "$export_line" | awk '{print $1}')
                    echo -e "${TAB}${BGN}$(translate "Export path:")${CL} ${BL}$EXPORT_PATH${CL}"
                    echo ""
                fi
            done <<< "$EXPORTS"
            
        else
            echo "$(translate "No exports configured.")"
        fi
    else
        echo "$(translate "/etc/exports file does not exist.")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

delete_export() {
    if ! pct exec "$CTID" -- test -f /etc/exports; then
        dialog --title "$(translate "Error")" --msgbox "\n$(translate "No exports file found.")" 8 50
        return
    fi

    EXPORTS=$(pct exec "$CTID" -- awk '!/^#|^$/ {print NR, $0}' /etc/exports)
    if [[ -z "$EXPORTS" ]]; then
        dialog --title "$(translate "No Exports")" --msgbox "$(translate "No exports found in /etc/exports.")" 8 60
        return
    fi

    OPTIONS=()
    while read -r line; do
        [[ -z "$line" ]] && continue
        NUM=$(echo "$line" | awk '{print $1}')
        EXPORT_LINE=$(echo "$line" | cut -d' ' -f2-)
        EXPORT_PATH=$(echo "$EXPORT_LINE" | awk '{print $1}')
        EXPORT_CLIENT=$(echo "$EXPORT_LINE" | awk '{print $2}' | cut -d'(' -f1)
        [[ -z "$EXPORT_PATH" || -z "$EXPORT_CLIENT" ]] && continue
        OPTIONS+=("$NUM" "$EXPORT_PATH $EXPORT_CLIENT")
    done <<< "$EXPORTS"

    SELECTED_NUM=$(dialog --title "$(translate "Delete Export")" --menu "$(translate "Select an export to delete:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [ -z "$SELECTED_NUM" ] && return

    EXPORT_LINE=$(echo "$EXPORTS" | awk -v num="$SELECTED_NUM" '$1 == num {$1=""; print substr($0,2)}')

    if whiptail --yesno "$(translate "Are you sure you want to delete this export?")\n\n$EXPORT_LINE" 10 70 --title "$(translate "Confirm Deletion")"; then
        show_proxmenux_logo
        msg_title "$(translate "Delete Export")"
        pct exec "$CTID" -- sed -i "${SELECTED_NUM}d" /etc/exports
        pct exec "$CTID" -- exportfs -ra
        pct exec "$CTID" -- systemctl restart nfs-kernel-server
        msg_ok "$(translate "Export deleted and NFS service restarted.")"
    fi
    
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

check_nfs_status() {
    show_proxmenux_logo
    msg_title "$(translate "Check NFS Status")"
    echo -e "$(translate "NFS Service Status in CT") $CTID:"
    echo "=================================="
    
    if pct exec "$CTID" -- dpkg -s nfs-kernel-server &>/dev/null; then
        echo "$(translate "NFS Server: INSTALLED")"
        
        if pct exec "$CTID" -- systemctl is-active --quiet nfs-kernel-server; then
            echo "$(translate "NFS Service: RUNNING")"
        else
            echo "$(translate "NFS Service: STOPPED")"
        fi
        
        if pct exec "$CTID" -- systemctl is-active --quiet rpcbind; then
            echo "$(translate "RPC Bind Service: RUNNING")"
        else
            echo "$(translate "RPC Bind Service: STOPPED")"
        fi
        

        echo ""
        echo "$(translate "NFS Version Configuration:")"
        echo "$(translate "Version: Auto-negotiation (NFSv3/NFSv4)")"
        echo "$(translate "Client determines best version to use")"
        

        echo ""
        echo "$(translate "Universal Group Configuration:")"
        if pct exec "$CTID" -- getent group sharedfiles >/dev/null 2>&1; then
            echo "$(translate "Shared group: CONFIGURED")"
            local group_members=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f4)
            local sharedfiles_gid=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f3)
            echo "$(translate "Group GID:") $sharedfiles_gid"
            
            local member_count=$(echo "$group_members" | tr ',' '\n' | wc -l)
            echo "$(translate "Total members:") $member_count $(translate "users")"
            
            local remapped_users=$(pct exec "$CTID" -- getent passwd | grep "^remap_" | wc -l)
            echo "$(translate "Remapped users:") $remapped_users $(translate "users")"
            
            echo "$(translate "Universal compatibility: ENABLED")"
        else
            echo "$(translate "Universal group: NOT CONFIGURED")"
        fi
        
        echo ""
        echo "$(translate "Listening ports:")"
        pct exec "$CTID" -- ss -tlnp | grep -E ':(111|2049|20048)' || echo "$(translate "No NFS ports found")"
        
    else
        echo "$(translate "NFS Server: NOT INSTALLED")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

uninstall_nfs() {
    if ! pct exec "$CTID" -- dpkg -s nfs-kernel-server &>/dev/null; then
        dialog --title "$(translate "NFS Not Installed")" --msgbox "\n$(translate "NFS server is not installed in this CT.")" 8 60
        return
    fi
    
    if ! whiptail --title "$(translate "Uninstall NFS Server")" \
        --yesno "$(translate "WARNING: This will completely remove NFS server from the CT.")\n\n$(translate "This action will:")\n$(translate "â€¢ Stop all NFS services")\n$(translate "â€¢ Remove all exports")\n$(translate "â€¢ Uninstall NFS packages")\n$(translate "â€¢ Remove universal sharedfiles group")\n$(translate "â€¢ Clean up remapped users")\n\n$(translate "Are you sure you want to continue?")" \
        18 70; then
        return
    fi
    
    show_proxmenux_logo
    msg_title "$(translate "Uninstall NFS Server")"

    msg_info "$(translate "Stopping NFS services...")"
    pct exec "$CTID" -- systemctl stop nfs-kernel-server 2>/dev/null || true
    pct exec "$CTID" -- systemctl stop rpcbind 2>/dev/null || true
    pct exec "$CTID" -- systemctl disable nfs-kernel-server 2>/dev/null || true
    pct exec "$CTID" -- systemctl disable rpcbind 2>/dev/null || true
    msg_ok "$(translate "NFS services stopped and disabled.")"
    
    if pct exec "$CTID" -- test -f /etc/exports; then
        pct exec "$CTID" -- truncate -s 0 /etc/exports
        msg_ok "$(translate "Exports cleared.")"
    fi    


    msg_info "$(translate "Removing remapped users...")"
    local remapped_users=$(pct exec "$CTID" -- getent passwd | grep "^remap_" | cut -d: -f1)
    if [[ -n "$remapped_users" ]]; then
        while IFS= read -r username; do
            if [[ -n "$username" ]]; then
                pct exec "$CTID" -- userdel "$username" 2>/dev/null || true
                msg_ok "$(translate "Removed remapped user:") $username"
            fi
        done <<< "$remapped_users"
    fi


    if pct exec "$CTID" -- getent group sharedfiles >/dev/null 2>&1; then
        local regular_members=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f4 | tr ',' '\n' | grep -v "^remap_" | wc -l)
        if [[ "$regular_members" -eq 0 ]]; then
            pct exec "$CTID" -- groupdel sharedfiles 2>/dev/null || true
            msg_ok "$(translate "Removed sharedfiles group.")"
        else
            msg_warn "$(translate "Kept sharedfiles group (has regular users assigned).")"
        fi
    fi

    pct exec "$CTID" -- apt-get remove --purge -y nfs-kernel-server nfs-common 2>/dev/null || true
    pct exec "$CTID" -- apt-get autoremove -y 2>/dev/null || true
    msg_ok "$(translate "NFS packages removed.")"
    
    msg_info "$(translate "Cleaning up remaining processes...")"
    pct exec "$CTID" -- pkill -f nfs 2>/dev/null || true
    pct exec "$CTID" -- pkill -f rpc 2>/dev/null || true
    sleep 2
    msg_ok "$(translate "Universal NFS server has been completely uninstalled!")"
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate "Uninstallation Summary:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Services:")${CL} ${BL}$(translate "Stopped and disabled")${CL}"
    echo -e "${TAB}${BGN}$(translate "Packages:")${CL} ${BL}$(translate "Removed")${CL}"
    echo -e "${TAB}${BGN}$(translate "Exports:")${CL} ${BL}$(translate "Cleared")${CL}"
    echo -e "${TAB}${BGN}$(translate "Universal Group:")${CL} ${BL}$(translate "Cleaned up")${CL}"
    echo -e "${TAB}${BGN}$(translate "Remapped Users:")${CL} ${BL}$(translate "Removed")${CL}"
    echo -e
    
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

# === Main Menu ===
while true; do
    CHOICE=$(dialog --title "$(translate "NFS LXC Manager - CT") $CTID" --menu "$(translate "Choose an option:")" 20 70 12 \
    "1" "$(translate "Create Universal NFS Export")" \
    "2" "$(translate "View Current Exports")" \
    "3" "$(translate "Delete Export")" \
    "4" "$(translate "Check NFS Status")" \
    "5" "$(translate "Uninstall NFS Server")" \
    "6" "$(translate "Exit")" 3>&1 1>&2 2>&3)
    
    case $CHOICE in
        1) create_nfs_export ;;
        2) view_exports ;;
        3) delete_export ;;
        4) check_nfs_status ;;
        5) uninstall_nfs ;;
        6) exit 0 ;;
        *) exit 0 ;;
    esac
done



================================================
FILE: scripts/share/samba_client.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux CT - Samba Client Manager for Proxmox LXC
# ==========================================================
# Based on ProxMenux by MacRimi
# ==========================================================
# Description:
# This script allows you to manage Samba/CIFS client mounts inside Proxmox CTs:
# - Mount Samba/CIFS shares (temporary and permanent)
# - View current mounts
# - Unmount and remove Samba shares
# - Auto-discover Samba servers
# - Manage credentials securely
# ==========================================================


# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
CREDENTIALS_DIR="/etc/samba/credentials"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi


SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    msg_error "$(translate "Could not load shared functions. Script cannot continue.")"
    exit 1
fi


load_language
initialize_cache


select_privileged_lxc


install_samba_client() {

    if pct exec "$CTID" -- dpkg -s cifs-utils &>/dev/null && pct exec "$CTID" -- dpkg -s smbclient &>/dev/null; then
        pct exec "$CTID" -- mkdir -p "$CREDENTIALS_DIR"
        pct exec "$CTID" -- chmod 700 "$CREDENTIALS_DIR"
        return 0
    fi

    show_proxmenux_logo
    msg_title "$(translate "Installing Samba Client")"
    msg_info "$(translate "Installing Samba/CIFS client packages...")"

    if ! pct exec "$CTID" -- apt-get update &>/dev/null; then
        msg_error "$(translate "Failed to update package list.")"
        return 1
    fi

    if ! pct exec "$CTID" -- apt-get install -y cifs-utils smbclient &>/dev/null; then
        msg_error "$(translate "Failed to install Samba client packages.")"
        return 1
    fi

    if ! pct exec "$CTID" -- which smbclient >/dev/null 2>&1; then
        msg_error "$(translate "smbclient command not found after installation.")"
        return 1
    fi
    if ! pct exec "$CTID" -- which mount.cifs >/dev/null 2>&1; then
        msg_error "$(translate "mount.cifs command not found after installation.")"
        return 1
    fi

    pct exec "$CTID" -- mkdir -p "$CREDENTIALS_DIR"
    pct exec "$CTID" -- chmod 700 "$CREDENTIALS_DIR"

    msg_ok "$(translate "Samba/CIFS client installed successfully.")"
    return 0
}


discover_samba_servers() {
    show_proxmenux_logo
    msg_title "$(translate "Samba LXC Manager")"
    msg_info "$(translate "Scanning network for Samba servers...")"


    HOST_IP=$(hostname -I | awk '{print $1}')
    NETWORK=$(echo "$HOST_IP" | cut -d. -f1-3).0/24


    for pkg in nmap samba-common-bin; do
        if ! which ${pkg%%-*} >/dev/null 2>&1; then
            apt-get install -y "$pkg" &>/dev/null
        fi
    done

    SERVERS=$(nmap -p 139,445 --open "$NETWORK" 2>/dev/null | grep -B 4 -E "(139|445)/tcp open" | grep "Nmap scan report" | awk '{print $5}' | sort -u || true)
    if [[ -z "$SERVERS" ]]; then
        cleanup
        whiptail --title "$(translate "No Servers Found")" --msgbox "$(translate "No Samba servers found on the network.")\n\n$(translate "You can add servers manually.")" 10 60
        return 1
    fi

    SERVER_LINES=()
    while IFS= read -r server; do
        [[ -z "$server" ]] && continue

        NB_NAME=$(nmblookup -A "$server" 2>/dev/null | awk '/<00> -.*B <ACTIVE>/ {print $1; exit}')

        if [[ -z "$NB_NAME" || "$NB_NAME" == "$server" || "$NB_NAME" == "address" || "$NB_NAME" == "-" ]]; then
            NB_NAME="Unknown"
        fi

        SERVER_LINES+=("$server|$NB_NAME ($server)")
    done <<< "$SERVERS"

    IFS=$'\n' SORTED=($(printf "%s\n" "${SERVER_LINES[@]}" | sort -t. -k1,1n -k2,2n -k3,3n -k4,4n))

    OPTIONS=()
    declare -A SERVER_IPS
    i=1
    for entry in "${SORTED[@]}"; do
        server="${entry%%|*}"
        label="${entry#*|}"
        OPTIONS+=("$i" "$label")
        SERVER_IPS["$i"]="$server"
        ((i++))
    done

    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        cleanup
        whiptail --title "$(translate "No Valid Servers")" --msgbox "$(translate "No accessible Samba servers found.")" 8 50
        return 1
    fi

    msg_ok "$(translate "Samba servers detected")"
    CHOICE=$(whiptail --title "$(translate "Select Samba Server")" \
        --menu "$(translate "Choose a Samba server:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)

    if [[ -n "$CHOICE" ]]; then
        SAMBA_SERVER="${SERVER_IPS[$CHOICE]}"
        
        return 0
    else
        
        return 1
    fi
    
}

select_samba_server() {
    METHOD=$(whiptail --title "$(translate "Samba Server Selection")" --menu "$(translate "How do you want to select the Samba server?")" 15 70 3 \
    "auto" "$(translate "Auto-discover servers on network")" \
    "manual" "$(translate "Enter server IP")" \
    "recent" "$(translate "Select from recent servers")" 3>&1 1>&2 2>&3)
    
    case "$METHOD" in
        auto)
            discover_samba_servers || return 1
            ;;
        manual)
            SAMBA_SERVER=$(whiptail --inputbox "$(translate "Enter Samba server IP:")" 10 60 --title "$(translate "Samba Server")" 3>&1 1>&2 2>&3)
            [[ -z "$SAMBA_SERVER" ]] && return 1
            ;;
        recent)

            RECENT=$(pct exec "$CTID" -- grep "cifs" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d/ -f3 | sort -u || true)
            if [[ -z "$RECENT" ]]; then
                whiptail --title "$(translate "No Recent Servers")" --msgbox "$(translate "No recent Samba servers found.")" 8 50
                return 1
            fi
            
            OPTIONS=()
            while IFS= read -r server; do
                [[ -n "$server" ]] && OPTIONS+=("$server" "$(translate "Recent Samba server")")
            done <<< "$RECENT"
            
            SAMBA_SERVER=$(whiptail --title "$(translate "Recent Samba Servers")" --menu "$(translate "Choose a recent server:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
            [[ -z "$SAMBA_SERVER" ]] && return 1
            ;;
        *)
            return 1
            ;;
    esac
    return 0
}






validate_guest_access() {
    local server="$1"
    
    show_proxmenux_logo
    msg_info "$(translate "Testing comprehensive guest access to server") $server..."
    
    GUEST_LIST_OUTPUT=$(smbclient -L "$server" -N 2>&1)
    GUEST_LIST_RESULT=$?
    
    if [[ $GUEST_LIST_RESULT -ne 0 ]]; then
        cleanup
        if echo "$GUEST_LIST_OUTPUT" | grep -qi "access denied\|logon failure"; then
            whiptail --title "$(translate "Guest Access Denied")" \
                   --msgbox "$(translate "Guest access is not allowed on this server.")\n\n$(translate "You need to use username and password authentication.")" \
                   10 70
        else
            whiptail --title "$(translate "Guest Access Error")" \
                   --msgbox "$(translate "Guest access failed.")\n\n$(translate "Error details:")\n$(echo "$GUEST_LIST_OUTPUT" | head -3)" \
                   12 70
        fi
        return 1
    fi
    sleep 2
    msg_ok "$(translate "Guest share listing successful")"

    GUEST_SHARES=$(echo "$GUEST_LIST_OUTPUT" | awk '/Disk/ && !/IPC\$/ && !/ADMIN\$/ && !/print\$/ {print $1}' | grep -v "^$")
    if [[ -z "$GUEST_SHARES" ]]; then
        whiptail --title "$(translate "No Guest Shares")" \
               --msgbox "$(translate "Guest access works for listing, but no shares are available.")\n\n$(translate "The server may require authentication for actual share access.")" \
               10 70
        return 1
    fi
    
    msg_ok "$(translate "Found guest-accessible shares:") $(echo "$GUEST_SHARES" | wc -l)"

    msg_info "$(translate "Step 2: Testing actual share access with guest...")"
    ACCESSIBLE_SHARES=""
    FAILED_SHARES=""
    sleep 1
    while IFS= read -r share; do
        if [[ -n "$share" ]]; then
            
            SHARE_TEST_OUTPUT=$(smbclient "//$server/$share" -N -c "ls" 2>&1)
            SHARE_TEST_RESULT=$?
            
            if [[ $SHARE_TEST_RESULT -eq 0 ]]; then
                echo -e
                msg_ok "$(translate "Guest access confirmed for share:") $share"
                echo -e
                ACCESSIBLE_SHARES="$ACCESSIBLE_SHARES$share\n"
            else
                msg_error "$(translate "Guest access denied for share:") $share"
                FAILED_SHARES="$FAILED_SHARES$share\n"
                
                if echo "$SHARE_TEST_OUTPUT" | grep -qi "access denied\|logon failure\|authentication"; then
                    msg_warn "  $(translate "Reason: Authentication required")"
                elif echo "$SHARE_TEST_OUTPUT" | grep -qi "permission denied"; then
                    msg_warn "  $(translate "Reason: Permission denied")"
                else
                    msg_warn "  $(translate "Reason: Access denied")"
                fi
            fi
        fi
    done <<< "$GUEST_SHARES"
    

    ACCESSIBLE_COUNT=$(echo -e "$ACCESSIBLE_SHARES" | grep -v "^$" | wc -l)
    FAILED_COUNT=$(echo -e "$FAILED_SHARES" | grep -v "^$" | wc -l)
    
    echo -e ""
    msg_info2 "$(translate "Guest Access Validation Results:")"
    echo -e "${TAB}${BGN}$(translate "Shares found:")${CL} ${BL}$(echo "$GUEST_SHARES" | wc -l)${CL}"
    echo -e "${TAB}${BGN}$(translate "Guest accessible:")${CL} ${GN}$ACCESSIBLE_COUNT${CL}"
    echo -e "${TAB}${BGN}$(translate "Authentication required:")${CL} ${YW}$FAILED_COUNT${CL}"
    
    if [[ $ACCESSIBLE_COUNT -gt 0 ]]; then
        msg_ok "$(translate "Guest access validated successfully!")"
        echo -e ""
        echo -e "${TAB}${BOLD}$(translate "Available shares for guest access:")${CL}"
        while IFS= read -r share; do
            [[ -n "$share" ]] && echo -e "${TAB}â€¢ ${BL}$share${CL}"
        done <<< "$(echo -e "$ACCESSIBLE_SHARES" | grep -v "^$")"
        echo -e
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        clear

        VALIDATED_GUEST_SHARES="$ACCESSIBLE_SHARES"
        return 0
    else
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        whiptail --title "$(translate "Guest Access Failed")" \
               --msgbox "$(translate "While the server allows guest listing, no shares are actually accessible without authentication.")\n\n$(translate "You need to use username and password authentication.")" \
               12 70
        clear       
        return 1
    fi
}






get_samba_credentials() {
    while true; do
        CHOICE=$(whiptail --title "$(translate "Samba Credentials")" \
            --menu "$(translate "Select authentication mode:")" 13 60 2 \
            "1" "$(translate "Configure with username and password")" \
            "2" "$(translate "Configure as guest (no authentication)")" \
            3>&1 1>&2 2>&3)

        if [[ $? -ne 0 ]]; then
            return 1
        fi

        case "$CHOICE" in
            1)

                while true; do
                    USERNAME=$(whiptail --inputbox "$(translate "Enter username for Samba server:")" 10 60 --title "$(translate "Username")" 3>&1 1>&2 2>&3)
                    if [[ $? -ne 0 ]]; then
                        break
                    fi
                    if [[ -z "$USERNAME" ]]; then
                        whiptail --title "$(translate "Error")" --msgbox "$(translate "Username cannot be empty.")" 8 50
                        continue
                    fi

                    while true; do
                        PASSWORD=$(whiptail --passwordbox "$(translate "Enter password for") $USERNAME:" 10 60 --title "$(translate "Password")" 3>&1 1>&2 2>&3)
                        if [[ $? -ne 0 ]]; then
                            break
                        fi
                        if [[ -z "$PASSWORD" ]]; then
                            whiptail --title "$(translate "Error")" --msgbox "$(translate "Password cannot be empty.")" 8 50
                            continue
                        fi

                        PASSWORD_CONFIRM=$(whiptail --passwordbox "$(translate "Confirm password for") $USERNAME:" 10 60 --title "$(translate "Confirm Password")" 3>&1 1>&2 2>&3)
                        if [[ $? -ne 0 ]]; then
                            continue
                        fi
                        if [[ -z "$PASSWORD_CONFIRM" ]]; then
                            whiptail --title "$(translate "Error")" --msgbox "$(translate "Password confirmation cannot be empty.")" 8 50
                            continue
                        fi

                        if [[ "$PASSWORD" == "$PASSWORD_CONFIRM" ]]; then

                            show_proxmenux_logo
                            msg_info "$(translate "Validating credentials with server") $SAMBA_SERVER..."
                            

                            TEMP_CRED="/tmp/validate_cred_$$"
                            cat > "$TEMP_CRED" << EOF
username=$USERNAME
password=$PASSWORD
EOF
                            chmod 600 "$TEMP_CRED"
                            

                            SHARES_OUTPUT=$(smbclient -L "$SAMBA_SERVER" -A "$TEMP_CRED" 2>&1)
                            SHARES_RESULT=$?
                            
                            if [[ $SHARES_RESULT -eq 0 ]]; then

                                FIRST_SHARE=$(echo "$SHARES_OUTPUT" | awk '/Disk/ && !/IPC\$/ && !/ADMIN\$/ && !/print\$/ {print $1; exit}')
                                
                                if [[ -n "$FIRST_SHARE" ]]; then

                                    SHARE_TEST_OUTPUT=$(smbclient "//$SAMBA_SERVER/$FIRST_SHARE" -A "$TEMP_CRED" -c "ls" 2>&1)
                                    SHARE_TEST_RESULT=$?
                                    
                                    rm -f "$TEMP_CRED"
                                    
                                    if [[ $SHARE_TEST_RESULT -eq 0 ]]; then

                                        cleanup
                                        if echo "$SHARE_TEST_OUTPUT" | grep -qi "guest"; then
                                            whiptail --title "$(translate "Authentication Error")" \
                                                   --msgbox "$(translate "The server connected you as guest instead of the specified user.")\n\n$(translate "This means the credentials are incorrect.")\n\n$(translate "Please check:")\nâ€¢ $(translate "Username is correct")\nâ€¢ $(translate "Password is correct")\nâ€¢ $(translate "User account exists on server")" \
                                                   14 70
                                        else
                                            msg_ok "$(translate "Credentials validated successfully")"
                                            USE_GUEST=false
                                            return 0
                                        fi
                                    else

                                        cleanup
                                        if echo "$SHARE_TEST_OUTPUT" | grep -qi "access denied\|logon failure\|authentication\|NT_STATUS_LOGON_FAILURE"; then
                                            whiptail --title "$(translate "Authentication Error")" \
                                                   --msgbox "$(translate "Invalid username or password.")\n\n$(translate "Error details:")\n$(echo "$SHARE_TEST_OUTPUT" | head -2)\n\n$(translate "Please check:")\nâ€¢ $(translate "Username is correct")\nâ€¢ $(translate "Password is correct")\nâ€¢ $(translate "User account exists on server")" \
                                                   16 70
                                        elif echo "$SHARE_TEST_OUTPUT" | grep -qi "connection refused\|network unreachable"; then
                                            whiptail --title "$(translate "Network Error")" \
                                                   --msgbox "$(translate "Cannot connect to server") $SAMBA_SERVER\n\n$(translate "Please check network connectivity.")" \
                                                   10 60
                                            return 1
                                        else
                                            whiptail --title "$(translate "Share Access Error")" \
                                                   --msgbox "$(translate "Failed to access share with provided credentials.")\n\n$(translate "Error details:")\n$(echo "$SHARE_TEST_OUTPUT" | head -3)" \
                                                   12 70
                                        fi
                                    fi
                                else

                                    cleanup
                                    whiptail --title "$(translate "No Shares Available")" \
                                           --msgbox "$(translate "Cannot validate credentials - no shares available for testing.")\n\n$(translate "The server may not have accessible shares.")" \
                                           10 70
                                fi
                            else

                                rm -f "$TEMP_CRED"
                                

                                if echo "$SHARES_OUTPUT" | grep -qi "access denied\|logon failure\|authentication\|NT_STATUS_LOGON_FAILURE"; then
                                    cleanup
                                    whiptail --title "$(translate "Authentication Error")" \
                                           --msgbox "$(translate "Invalid username or password.")\n\n$(translate "Please check:")\nâ€¢ $(translate "Username is correct")\nâ€¢ $(translate "Password is correct")\nâ€¢ $(translate "User account exists on server")\nâ€¢ $(translate "Account is not locked")" \
                                           12 70
                                elif echo "$SHARES_OUTPUT" | grep -qi "connection refused\|network unreachable"; then
                                    cleanup
                                    whiptail --title "$(translate "Network Error")" \
                                           --msgbox "$(translate "Cannot connect to server") $SAMBA_SERVER\n\n$(translate "Please check network connectivity.")" \
                                           10 60
                                    return 1
                                else
                                    cleanup
                                    whiptail --title "$(translate "Connection Error")" \
                                           --msgbox "$(translate "Failed to connect to server.")\n\n$(translate "Error details:")\n$(echo "$SHARES_OUTPUT" | head -3)" \
                                           12 70
                                fi
                            fi

                            break
                        else
                            cleanup
                            whiptail --title "$(translate "Password Mismatch")" \
                                     --msgbox "$(translate "Passwords do not match. Please try again.")" \
                                     8 50

                        fi
                    done

                    if [[ $? -ne 0 ]]; then
                        break
                    fi
                done
                ;;
            2)

                if validate_guest_access "$SAMBA_SERVER"; then
                    USE_GUEST=true
                    return 0
                fi
                ;;
            *)
                return 1
                ;;
        esac
        

        if ! whiptail --yesno "$(translate "Authentication failed.")\n\n$(translate "Do you want to try different credentials or authentication method?")" 10 70 --title "$(translate "Try Again")"; then
            return 1
        fi

    done
}






select_samba_share() {
    if ! which smbclient >/dev/null 2>&1; then
        whiptail --title "$(translate "SMB Client Error")" \
                 --msgbox "$(translate "smbclient command is not working properly.")\n\n$(translate "Please check the installation.")" \
                 10 60
        return 1
    fi
    

    if [[ "$USE_GUEST" == "true" ]]; then

        if [[ -n "$VALIDATED_GUEST_SHARES" ]]; then
            SHARES=$(echo -e "$VALIDATED_GUEST_SHARES" | grep -v "^$")
        else

            SHARES_OUTPUT=$(smbclient -L "$SAMBA_SERVER" -N 2>&1)
            SHARES_RESULT=$?
            if [[ $SHARES_RESULT -eq 0 ]]; then
                SHARES=$(echo "$SHARES_OUTPUT" | awk '/Disk/ && !/IPC\$/ && !/ADMIN\$/ && !/print\$/ {print $1}' | grep -v "^$")
            else
                show_proxmenux_logo
                msg_error "$(translate "Failed to get shares")"
                echo -e
                msg_success "$(translate "Press Enter to continue...")"
                read -r
                return 1
            fi
        fi
    else

        TEMP_CRED="/tmp/temp_smb_cred_$$"
        cat > "$TEMP_CRED" << EOF
username=$USERNAME
password=$PASSWORD
EOF
        chmod 600 "$TEMP_CRED"
        
        SHARES_OUTPUT=$(smbclient -L "$SAMBA_SERVER" -A "$TEMP_CRED" 2>&1)
        SHARES_RESULT=$?
        
        rm -f "$TEMP_CRED"
        
        if [[ $SHARES_RESULT -ne 0 ]]; then
            whiptail --title "$(translate "SMB Error")" \
                   --msgbox "$(translate "Failed to get shares from") $SAMBA_SERVER\n\n$(translate "This is unexpected since credentials were validated.")" \
                   12 80
            return 1
        fi
        
        SHARES=$(echo "$SHARES_OUTPUT" | awk '/Disk/ && !/IPC\$/ && !/ADMIN\$/ && !/print\$/ {print $1}' | grep -v "^$")
    fi
    
    if [[ -z "$SHARES" ]]; then
        whiptail --title "$(translate "No Shares Found")" \
               --msgbox "$(translate "No shares found on server") $SAMBA_SERVER\n\n$(translate "You can enter the share name manually.")" \
               12 70
    
        SAMBA_SHARE=$(whiptail --inputbox "$(translate "Enter Samba share name:")" 10 60 --title "$(translate "Share Name")" 3>&1 1>&2 2>&3)
        [[ -z "$SAMBA_SHARE" ]] && return 1
        return 0
    fi


    OPTIONS=()
    while IFS= read -r share; do
        if [[ -n "$share" && "$share" != "IPC$" && "$share" != "ADMIN$" && "$share" != "print$" ]]; then

            if [[ "$USE_GUEST" == "true" ]]; then
                if echo -e "$VALIDATED_GUEST_SHARES" | grep -q "^$share$"; then
                    OPTIONS+=("$share" "$(translate "Guest accessible share")")
                fi
            else

                OPTIONS+=("$share" "$(translate "Samba share")")
            fi
        fi
    done <<< "$SHARES"
    
    if [[ ${#OPTIONS[@]} -eq 0 ]]; then
        whiptail --title "$(translate "No Available Shares")" \
               --msgbox "$(translate "No accessible shares found.")\n\n$(translate "You can enter the share name manually.")" \
               10 70
        
        SAMBA_SHARE=$(whiptail --inputbox "$(translate "Enter Samba share name:")" 10 60 --title "$(translate "Share Name")" 3>&1 1>&2 2>&3)
        [[ -z "$SAMBA_SHARE" ]] && return 1
        return 0
    fi
    
    SAMBA_SHARE=$(whiptail --title "$(translate "Select Samba Share")" --menu "$(translate "Choose a share to mount:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -n "$SAMBA_SHARE" ]] && return 0 || return 1
}










select_mount_point() {
    while true; do
        METHOD=$(whiptail --title "$(translate "Select Mount Point")" --menu "$(translate "Where do you want to mount the Samba share?")" 15 70 3 \
        "1" "$(translate "Create new folder in /mnt")" \
        "2" "$(translate "Select from existing folders in /mnt")" \
        "3" "$(translate "Enter custom path")" 3>&1 1>&2 2>&3)
        
        case "$METHOD" in
            1)
                FOLDER_NAME=$(whiptail --inputbox "$(translate "Enter new folder name:")" 10 60 "${SAMBA_SHARE}" --title "$(translate "New Folder in /mnt")" 3>&1 1>&2 2>&3)
                if [[ -n "$FOLDER_NAME" ]]; then
                    MOUNT_POINT="/mnt/$FOLDER_NAME"
                    return 0
                fi
                ;;
            2)

                DIRS=$(pct exec "$CTID" -- find /mnt -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
                if [[ -z "$DIRS" ]]; then
                    whiptail --title "$(translate "No Folders")" --msgbox "$(translate "No folders found in /mnt. Please create a new folder.")" 8 60
                    continue
                fi
                
                OPTIONS=()
                while IFS= read -r dir; do
                    if [[ -n "$dir" ]]; then
                        name=$(basename "$dir")

                        if pct exec "$CTID" -- [ "$(ls -A "$dir" 2>/dev/null | wc -l)" -eq 0 ]; then
                            status="$(translate "Empty")"
                        else
                            status="$(translate "Contains files")"
                        fi
                        OPTIONS+=("$dir" "$name ($status)")
                    fi
                done <<< "$DIRS"
                
                MOUNT_POINT=$(whiptail --title "$(translate "Select Existing Folder")" --menu "$(translate "Choose a folder to mount the share:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
                
                if [[ -n "$MOUNT_POINT" ]]; then

                    if pct exec "$CTID" -- [ "$(ls -A "$MOUNT_POINT" 2>/dev/null | wc -l)" -gt 0 ]; then
                        FILE_COUNT=$(pct exec "$CTID" -- ls -A "$MOUNT_POINT" 2>/dev/null | wc -l)
                        if ! whiptail --yesno "$(translate "WARNING: The selected directory is not empty!")\n\n$(translate "Directory:"): $MOUNT_POINT\n$(translate "Contains:"): $FILE_COUNT $(translate "files/folders")\n\n$(translate "Mounting here will hide existing files until unmounted.")\n\n$(translate "Do you want to continue?")" 14 70 --title "$(translate "Directory Not Empty")"; then
                            continue
                        fi
                    fi
                    return 0
                fi
                ;;
            3)
                MOUNT_POINT=$(whiptail --inputbox "$(translate "Enter full path for mount point:")" 10 70 "/mnt/samba_share" --title "$(translate "Custom Path")" 3>&1 1>&2 2>&3)
                if [[ -n "$MOUNT_POINT" ]]; then
                    return 0
                fi
                ;;
            *)
                return 1
                ;;
        esac
    done
}

configure_mount_options() {
    MOUNT_TYPE=$(whiptail --title "$(translate "Mount Options")" --menu "$(translate "Select mount configuration:")" 15 70 4 \
    "1" "$(translate "Default options read/write")" \
    "2" "$(translate "Read-only mount")" \
    "3" "$(translate "Custom options")" 3>&1 1>&2 2>&3)
    
    case "$MOUNT_TYPE" in
        1)
            MOUNT_OPTIONS="rw,file_mode=0664,dir_mode=0775,iocharset=utf8"
            ;;
        1)
            MOUNT_OPTIONS="ro,file_mode=0444,dir_mode=0555,iocharset=utf8"
            ;;
        3)
            MOUNT_OPTIONS=$(whiptail --inputbox "$(translate "Enter custom mount options:")" 10 70 "rw,file_mode=0664,dir_mode=0775" --title "$(translate "Custom Options")" 3>&1 1>&2 2>&3)
            [[ -z "$MOUNT_OPTIONS" ]] && MOUNT_OPTIONS="rw,file_mode=0664,dir_mode=0775"
            ;;
        *)
            MOUNT_OPTIONS="rw,file_mode=0664,dir_mode=0775,iocharset=utf8"
            ;;
    esac
    

    if whiptail --yesno "$(translate "Do you want to make this mount permanent?")\n\n$(translate "This will add the mount to /etc/fstab so it persists after reboot.")" 10 70 --title "$(translate "Permanent Mount")"; then
        PERMANENT_MOUNT=true
    else
        PERMANENT_MOUNT=false
    fi
}

create_credentials_file() {
    if [[ "$USE_GUEST" == "true" ]]; then
        return 0
    fi
    

    CRED_FILE="$CREDENTIALS_DIR/${SAMBA_SERVER}_${SAMBA_SHARE}.cred"
    

    pct exec "$CTID" -- bash -c "cat > '$CRED_FILE' << EOF
username=$USERNAME
password=$PASSWORD
EOF"
    
    pct exec "$CTID" -- chmod 600 "$CRED_FILE"
    msg_ok "$(translate "Credentials file created securely.")"
}

validate_share_exists() {
    local server="$1"
    local share="$2"
    local use_guest="$3"
    local username="$4"
    local password="$5"
    
    
    if [[ "$use_guest" == "true" ]]; then
        VALIDATION_OUTPUT=$(pct exec "$CTID" -- smbclient -L "$server" -N 2>/dev/null | grep "^[[:space:]]*$share[[:space:]]")
    else
        TEMP_CRED="/tmp/validate_cred_$$"
        pct exec "$CTID" -- bash -c "cat > $TEMP_CRED << EOF
username=$username
password=$password
EOF"
        pct exec "$CTID" -- chmod 600 "$TEMP_CRED"
        
        VALIDATION_OUTPUT=$(pct exec "$CTID" -- smbclient -L "$server" -A "$TEMP_CRED" 2>/dev/null | grep "^[[:space:]]*$share[[:space:]]")
        pct exec "$CTID" -- rm -f "$TEMP_CRED"
    fi
    
    if [[ -n "$VALIDATION_OUTPUT" ]]; then
        return 0
    else
        show_proxmenux_logo
        msg_error "$(translate "Share not found on server:") $share"
        msg_success "$(translate "Press Enter to continue...")"
        read -r
        return 1
    fi
}

mount_samba_share() {
    # Step 0:
    install_samba_client || return
    
    # Step 1:
    select_samba_server || return
    
    # Step 2:
    get_samba_credentials || return
    
    # Step 3:
    select_samba_share || return
    
    if ! validate_share_exists "$SAMBA_SERVER" "$SAMBA_SHARE" "$USE_GUEST" "$USERNAME" "$PASSWORD"; then
        echo -e ""
        msg_error "$(translate "Cannot proceed with invalid share name.")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return
    fi
    
    # Step 4:
    select_mount_point || return
    
    # Step 5:
    configure_mount_options || return
    
    show_proxmenux_logo
    msg_title "$(translate "Installing Samba Client in LXC")"

    if ! pct exec "$CTID" -- test -d "$MOUNT_POINT"; then
        if pct exec "$CTID" -- mkdir -p "$MOUNT_POINT"; then
            msg_ok "$(translate "Mount point created.")"
        else
            msg_error "$(translate "Failed to create mount point.")"
            return 1
        fi
    fi
    

    if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
        msg_warn "$(translate "Something is already mounted at") $MOUNT_POINT"
        if ! whiptail --yesno "$(translate "Do you want to unmount it first?")" 8 60 --title "$(translate "Already Mounted")"; then
            return
        fi
        pct exec "$CTID" -- umount "$MOUNT_POINT" 2>/dev/null || true
    fi
    

    if [[ "$USE_GUEST" != "true" ]]; then
        create_credentials_file
        CRED_OPTION="credentials=$CRED_FILE"
    else
        CRED_OPTION="guest"
    fi
    
    FULL_OPTIONS="$MOUNT_OPTIONS,$CRED_OPTION"
    UNC_PATH="//$SAMBA_SERVER/$SAMBA_SHARE"
    

    #if pct exec "$CTID" -- mount -t cifs "$UNC_PATH" "$MOUNT_POINT" -o "$FULL_OPTIONS"; then
    if pct exec "$CTID" -- mount -t cifs "$UNC_PATH" "$MOUNT_POINT" -o "$FULL_OPTIONS" 2>/dev/null; then
        msg_ok "$(translate "Samba share mounted successfully!")"
        
        if pct exec "$CTID" -- touch "$MOUNT_POINT/.test_write" 2>/dev/null; then
            pct exec "$CTID" -- rm "$MOUNT_POINT/.test_write" 2>/dev/null
            msg_ok "$(translate "Write access confirmed.")"
        else
            msg_warn "$(translate "Read-only access (or no write permissions).")"
        fi
        

        if [[ "$PERMANENT_MOUNT" == "true" ]]; then
   

            pct exec "$CTID" -- sed -i "\|$MOUNT_POINT|d" /etc/fstab
            

            FSTAB_ENTRY="$UNC_PATH $MOUNT_POINT cifs $FULL_OPTIONS 0 0"
            pct exec "$CTID" -- bash -c "echo '$FSTAB_ENTRY' >> /etc/fstab"
            msg_ok "$(translate "Added to /etc/fstab for permanent mounting.")"
        fi
        

        echo -e ""
        echo -e "${TAB}${BOLD}$(translate "Mount Information:")${CL}"
        echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$SAMBA_SERVER${CL}"
        echo -e "${TAB}${BGN}$(translate "Share:")${CL} ${BL}$SAMBA_SHARE${CL}"
        echo -e "${TAB}${BGN}$(translate "Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
        echo -e "${TAB}${BGN}$(translate "Authentication:")${CL} ${BL}$([ "$USE_GUEST" == "true" ] && echo "Guest" || echo "User: $USERNAME")${CL}"
        echo -e "${TAB}${BGN}$(translate "Permanent:")${CL} ${BL}$PERMANENT_MOUNT${CL}"
        
    else
        msg_error "$(translate "Failed to mount Samba share.")"
        echo -e "${TAB}$(translate "Please check:")"
        echo -e "${TAB}â€¢ $(translate "Server is accessible:"): $SAMBA_SERVER"
        echo -e "${TAB}â€¢ $(translate "Share exists:"): $SAMBA_SHARE"
        echo -e "${TAB}â€¢ $(translate "Credentials are correct")"
        echo -e "${TAB}â€¢ $(translate "Network connectivity")"
        echo -e "${TAB}â€¢ $(translate "Samba server is running")"
        

        if [[ "$USE_GUEST" != "true" && -n "$CRED_FILE" ]]; then
            pct exec "$CTID" -- rm -f "$CRED_FILE" 2>/dev/null || true
        fi
    fi
    
    echo -e ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}



view_samba_mounts() {
    show_proxmenux_logo
    msg_title "$(translate "Current Samba Mounts")"
    
    echo -e "$(translate "Samba/CIFS mounts in CT") $CTID:"
    echo "=================================="
    

    CURRENT_MOUNTS=$(pct exec "$CTID" -- mount -t cifs 2>/dev/null || true)
    if [[ -n "$CURRENT_MOUNTS" ]]; then
        echo -e "${BOLD}$(translate "Currently Mounted:")${CL}"
        echo "$CURRENT_MOUNTS"
        echo ""
    else
        echo "$(translate "No Samba shares currently mounted.")"
        echo ""
    fi
    

    FSTAB_CIFS=$(pct exec "$CTID" -- grep "cifs" /etc/fstab 2>/dev/null || true)
    if [[ -n "$FSTAB_CIFS" ]]; then
        echo -e "${BOLD}$(translate "Permanent Mounts (fstab):")${CL}"
        echo "$FSTAB_CIFS"
        echo ""
        
        echo -e "${TAB}${BOLD}$(translate "Mount Details:")${CL}"
        while IFS= read -r fstab_line; do
            if [[ -n "$fstab_line" && ! "$fstab_line" =~ ^# ]]; then
                UNC_PATH=$(echo "$fstab_line" | awk '{print $1}')
                MOUNT_POINT=$(echo "$fstab_line" | awk '{print $2}')
                OPTIONS=$(echo "$fstab_line" | awk '{print $4}')
                

                SERVER=$(echo "$UNC_PATH" | cut -d/ -f3)
                SHARE=$(echo "$UNC_PATH" | cut -d/ -f4)
                
                echo -e "${TAB}${BGN}$(translate "Server:")${CL} ${BL}$SERVER${CL}"
                echo -e "${TAB}${BGN}$(translate "Share:")${CL} ${BL}$SHARE${CL}"
                echo -e "${TAB}${BGN}$(translate "Mount Point:")${CL} ${BL}$MOUNT_POINT${CL}"
                

                if echo "$OPTIONS" | grep -q "guest"; then
                    echo -e "${TAB}${BGN}$(translate "Authentication:")${CL} ${BL}Guest${CL}"
                elif echo "$OPTIONS" | grep -q "credentials="; then
                    CRED_FILE=$(echo "$OPTIONS" | grep -o "credentials=[^,]*" | cut -d= -f2)
                    echo -e "${TAB}${BGN}$(translate "Authentication:")${CL} ${BL}Credentials ($CRED_FILE)${CL}"
                fi
                

                if pct exec "$CTID" -- mount | grep -q "$MOUNT_POINT"; then
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${GN}$(translate "Mounted")${CL}"
                else
                    echo -e "${TAB}${BGN}$(translate "Status:")${CL} ${RD}$(translate "Not Mounted")${CL}"
                fi
                echo ""
            fi
        done <<< "$FSTAB_CIFS"
    else
        echo "$(translate "No permanent Samba mounts configured.")"
    fi
    

    CRED_FILES=$(pct exec "$CTID" -- find "$CREDENTIALS_DIR" -name "*.cred" 2>/dev/null || true)
    if [[ -n "$CRED_FILES" ]]; then
        echo -e "${BOLD}$(translate "Stored Credentials:")${CL}"
        while IFS= read -r cred_file; do
            if [[ -n "$cred_file" ]]; then
                FILENAME=$(basename "$cred_file")
                echo -e "${TAB}â€¢ $FILENAME"
            fi
        done <<< "$CRED_FILES"
        echo ""
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}






unmount_samba_share() {

    MOUNTS=$(pct exec "$CTID" -- mount -t cifs 2>/dev/null | awk '{print $3}' | sort -u || true)

    FSTAB_MOUNTS=$(pct exec "$CTID" -- grep -E "cifs" /etc/fstab 2>/dev/null | grep -v "^#" | awk '{print $2}' | sort -u || true)
    

    ALL_MOUNTS=$(echo -e "$MOUNTS\n$FSTAB_MOUNTS" | sort -u | grep -v "^$" || true)
    
    if [[ -z "$ALL_MOUNTS" ]]; then
        dialog --title "$(translate "No Mounts")" --msgbox "\n$(translate "No Samba mounts found.")" 8 50
        return
    fi
    
    OPTIONS=()
    while IFS= read -r mount_point; do
        [[ -n "$mount_point" ]] && OPTIONS+=("$mount_point" "")
    done <<< "$ALL_MOUNTS"
    
    SELECTED_MOUNT=$(dialog --title "$(translate "Unmount Samba Share")" --menu "$(translate "Select mount point to unmount:")" 20 80 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [[ -z "$SELECTED_MOUNT" ]] && return
    

    if whiptail --yesno "$(translate "Are you sure you want to unmount this Samba share?")\n\n$(translate "Mount Point:") $SELECTED_MOUNT\n\n$(translate "This will remove the mount from /etc/fstab and delete credentials if present.")" 14 80 --title "$(translate "Confirm Unmount")"; then
        
        show_proxmenux_logo
        msg_title "$(translate "Unmount Samba Share")"

        CRED_FILE=$(pct exec "$CTID" -- grep -E "\s+$SELECTED_MOUNT\s+" /etc/fstab 2>/dev/null | grep -o "credentials=[^, ]*" | cut -d= -f2 || true)
        pct exec "$CTID" -- sed -i "\|[[:space:]]$SELECTED_MOUNT[[:space:]]|d" /etc/fstab
        msg_ok "$(translate "Removed from /etc/fstab.")"
        
        if [[ -n "$CRED_FILE" && "$CRED_FILE" != "guest" ]]; then
            if pct exec "$CTID" -- test -f "$CRED_FILE"; then
                pct exec "$CTID" -- rm -f "$CRED_FILE"
                msg_ok "$(translate "Credentials file removed.")"
            fi
        fi

        echo -e ""


        msg_ok "$(translate "Samba share unmount successfully. Reboot LXC required to take effect.")"
        echo -e ""
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
    fi

}







test_samba_connectivity() {
    show_proxmenux_logo
    msg_title "$(translate "Test Samba Connectivity")"
    
    echo -e "$(translate "Samba/CIFS Client Status in CT") $CTID:"
    echo "=================================="
    

    if pct exec "$CTID" -- dpkg -s cifs-utils &>/dev/null; then
        echo "$(translate "CIFS Client: INSTALLED")"
        

        if pct exec "$CTID" -- which smbclient >/dev/null 2>&1; then
            echo "$(translate "SMB Client Tools: AVAILABLE")"
        else
            echo "$(translate "SMB Client Tools: NOT AVAILABLE")"
        fi
        
        echo ""
        echo "$(translate "Current CIFS mounts:")"
        CURRENT_MOUNTS=$(pct exec "$CTID" -- mount -t cifs 2>/dev/null || true)
        if [[ -n "$CURRENT_MOUNTS" ]]; then
            echo "$CURRENT_MOUNTS"
        else
            echo "$(translate "No CIFS mounts active.")"
        fi
        
        echo ""
        echo "$(translate "Testing network connectivity...")"
        

        FSTAB_SERVERS=$(pct exec "$CTID" -- grep "cifs" /etc/fstab 2>/dev/null | awk '{print $1}' | cut -d/ -f3 | sort -u || true)
        if [[ -n "$FSTAB_SERVERS" ]]; then
            while IFS= read -r server; do
                if [[ -n "$server" ]]; then
                    echo -n "$(translate "Testing") $server: "
                    if pct exec "$CTID" -- ping -c 1 -W 2 "$server" >/dev/null 2>&1; then
                        echo -e "${GN}$(translate "Reachable")${CL}"
                        

                        if pct exec "$CTID" -- nc -z -w 2 "$server" 445 2>/dev/null; then
                            echo "  $(translate "SMB port 445:"): ${GN}$(translate "Open")${CL}"
                        elif pct exec "$CTID" -- nc -z -w 2 "$server" 139 2>/dev/null; then
                            echo "  $(translate "NetBIOS port 139:"): ${GN}$(translate "Open")${CL}"
                        else
                            echo "  $(translate "SMB ports:"): ${RD}$(translate "Closed")${CL}"
                        fi
                        

                        echo -n "  $(translate "Guest access test:"): "
                        if pct exec "$CTID" -- smbclient -L "$server" -N >/dev/null 2>&1; then
                            echo -e "${GN}$(translate "Available")${CL}"
                        else
                            echo -e "${YW}$(translate "Requires authentication")${CL}"
                        fi
                    else
                        echo -e "${RD}$(translate "Unreachable")${CL}"
                    fi
                fi
            done <<< "$FSTAB_SERVERS"
        else
            echo "$(translate "No Samba servers configured to test.")"
        fi
        

        echo ""
        echo "$(translate "Stored credentials:")"
        CRED_FILES=$(pct exec "$CTID" -- find "$CREDENTIALS_DIR" -name "*.cred" 2>/dev/null || true)
        if [[ -n "$CRED_FILES" ]]; then
            while IFS= read -r cred_file; do
                if [[ -n "$cred_file" ]]; then
                    FILENAME=$(basename "$cred_file")
                    echo "  â€¢ $FILENAME"
                fi
            done <<< "$CRED_FILES"
        else
            echo "  $(translate "No stored credentials found.")"
        fi
        
    else
        echo "$(translate "CIFS Client: NOT INSTALLED")"
        echo ""
        echo "$(translate "Run 'Mount Samba Share' to install CIFS client automatically.")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

# === Main Menu ===
while true; do
    CHOICE=$(dialog --title "$(translate "Samba Client Manager - CT") $CTID" \
        --menu "$(translate "Choose an option:")" 20 70 12 \
        "1" "$(translate "Mount Samba Share")" \
        "2" "$(translate "View Current Mounts")" \
        "3" "$(translate "Unmount Samba Share")" \
        "4" "$(translate "Test Samba Connectivity")" \
        "5" "$(translate "Exit")" \
        3>&1 1>&2 2>&3)

    RETVAL=$?
    if [[ $RETVAL -ne 0 ]]; then
        exit 0
    fi

    case $CHOICE in
        1) mount_samba_share ;;
        2) view_samba_mounts ;;
        3) unmount_samba_share ;;
        4) test_samba_connectivity ;;
        5) exit 0 ;;
        *) exit 0 ;;
    esac
done



================================================
FILE: scripts/share/samba_lxc_server.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux CT - Samba Manager for Proxmox LXC
# ==========================================================
# Based on ProxMenux by MacRimi
# ==========================================================
# Description:
# This script allows you to manage Samba shares inside Proxmox CTs:
# - Create shared folders
# - View configured shares
# - Delete existing shares
# - Check Samba service status
# ==========================================================

# Configuration
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
CREDENTIALS_DIR="/etc/samba/credentials"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi


SHARE_COMMON_FILE="$LOCAL_SCRIPTS/global/share-common.func"
if ! source "$SHARE_COMMON_FILE" 2>/dev/null; then
    msg_error "$(translate "Could not load shared functions. Script cannot continue.")"
    exit 1
fi


load_language
initialize_cache


select_privileged_lxc


select_mount_point() {
    while true; do
        METHOD=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Folder")" \
            --menu "$(translate "How do you want to select the folder to share?")" 15 60 5 \
            "auto" "$(translate "Select from folders inside /mnt")" \
            "manual" "$(translate "Enter path manually")" \
            3>&1 1>&2 2>&3)
        
        if [[ $? -ne 0 ]]; then
            return 1
        fi
        
        case "$METHOD" in
            auto)
                DIRS=$(pct exec "$CTID" -- find /mnt -maxdepth 1 -mindepth 1 -type d 2>/dev/null)
                if [[ -z "$DIRS" ]]; then
                    whiptail --title "$(translate "No Folders")" --msgbox "$(translate "No folders found inside /mnt in the CT.")" 8 60
                    continue
                fi

                OPTIONS=()
                while IFS= read -r dir; do
                    name=$(basename "$dir")
                    OPTIONS+=("$dir" "$name")
                done <<< "$DIRS"
                
                MOUNT_POINT=$(whiptail --title "$(translate "Select Folder")" \
                    --menu "$(translate "Choose a folder to share:")" 20 60 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                [[ -n "$MOUNT_POINT" ]] && return 0
                ;;
            manual)
                CT_NAME=$(pct config "$CTID" | awk -F: '/hostname/ {print $2}' | xargs)
                DEFAULT_MOUNT_POINT="/mnt/${CT_NAME}_share"
                MOUNT_POINT=$(whiptail --title "$(translate "Mount Point")" \
                    --inputbox "$(translate "Enter the mount point for the shared folder (e.g., /mnt/myshare):")" \
                    10 70 "$DEFAULT_MOUNT_POINT" 3>&1 1>&2 2>&3)
                if [[ $? -ne 0 ]]; then
                    return 1
                fi
                clear
                if [[ -z "$MOUNT_POINT" ]]; then
                    whiptail --title "$(translate "Error")" --msgbox "\n$(translate "No mount point was specified.")" 8 50
                    continue
                else
                    return 0
                fi
                ;;
        esac
    done
}



create_share() {

    show_proxmenux_logo
    msg_title "$(translate "Create Samba server service")"
    sleep 2

    select_mount_point || return
    

    if ! pct exec "$CTID" -- test -d "$MOUNT_POINT"; then
        if whiptail --yesno "$(translate "The directory does not exist in the CT.")\n\n$MOUNT_POINT\n\n$(translate "Do you want to create it?")" 12 70 --title "$(translate "Create Directory")"; then
            pct exec "$CTID" -- mkdir -p "$MOUNT_POINT"
            msg_ok "$(translate "Directory created successfully.")"
        else
            msg_error "$(translate "Directory does not exist and was not created.")"
            return
        fi
    fi
    
    

    if pct exec "$CTID" -- dpkg -s samba &>/dev/null; then
        SAMBA_INSTALLED=true
    else
        SAMBA_INSTALLED=false
    fi
    

    if [ "$SAMBA_INSTALLED" = false ]; then
        echo -e "${TAB}$(translate "Installing Samba server packages inside the CT...")"
        pct exec "$CTID" -- bash -c "apt-get update && apt-get install -y samba samba-common-bin acl"
        
        USERNAME=$(whiptail --inputbox "$(translate "Enter the Samba username:")" 10 60 "proxmenux" --title "$(translate "Samba User")" 3>&1 1>&2 2>&3)
        [[ -z "$USERNAME" ]] && msg_error "$(translate "No username provided.")" && return
        
        while true; do
            PASSWORD1=$(whiptail --passwordbox "$(translate "Enter the password for Samba user:")" 10 60 --title "$(translate "Samba Password")" 3>&1 1>&2 2>&3)
            [[ -z "$PASSWORD1" ]] && msg_error "$(translate "No password provided.")" && return
            PASSWORD2=$(whiptail --passwordbox "$(translate "Confirm the password:")" 10 60 --title "$(translate "Confirm Password")" 3>&1 1>&2 2>&3)
            [[ -z "$PASSWORD2" ]] && msg_error "$(translate "Password confirmation is required.")" && return
            
            if [[ "$PASSWORD1" != "$PASSWORD2" ]]; then
                whiptail --title "$(translate "Password Mismatch")" --msgbox "$(translate "The passwords do not match. Please try again.")" 10 60
            else
                PASSWORD="$PASSWORD1"
                break
            fi
        done
        
        if ! pct exec "$CTID" -- id "$USERNAME" &>/dev/null; then
            pct exec "$CTID" -- adduser --disabled-password --gecos "" "$USERNAME"
        fi
        pct exec "$CTID" -- bash -c "echo -e '$PASSWORD\n$PASSWORD' | smbpasswd -a '$USERNAME'"
        
        msg_ok "$(translate "Samba server installed successfully.")"
    else
        USERNAME=$(pct exec "$CTID" -- pdbedit -L | awk -F: '{print $1}' | head -n1)
        msg_ok "$(translate "Samba server is already installed.")"
        echo -e "$(translate "Detected existing Samba user:") $USERNAME"
    fi
    

    IS_MOUNTED=$(pct exec "$CTID" -- mount | grep "$MOUNT_POINT" || true)
    if [[ -n "$IS_MOUNTED" ]]; then
        msg_info "$(translate "Detected a mounted directory from host. Setting up shared group...")"
        
        SHARE_GID=999
        GROUP_EXISTS=$(pct exec "$CTID" -- getent group sharedfiles || true)
        GID_IN_USE=$(pct exec "$CTID" -- getent group "$SHARE_GID" | cut -d: -f1 || true)
        
        if [[ -z "$GROUP_EXISTS" ]]; then
            if [[ -z "$GID_IN_USE" ]]; then
                pct exec "$CTID" -- groupadd -g "$SHARE_GID" sharedfiles
                msg_ok "$(translate "Group 'sharedfiles' created with GID $SHARE_GID")"
            else
                pct exec "$CTID" -- groupadd sharedfiles
                msg_warn "$(translate "GID $SHARE_GID already in use. Group 'sharedfiles' created with dynamic GID.")"
            fi
        else
            msg_ok "$(translate "Group 'sharedfiles' already exists inside the CT")"
        fi
        
        if pct exec "$CTID" -- getent group sharedfiles >/dev/null; then
            pct exec "$CTID" -- usermod -aG sharedfiles "$USERNAME"
            pct exec "$CTID" -- chown root:sharedfiles "$MOUNT_POINT"
            pct exec "$CTID" -- chmod 2775 "$MOUNT_POINT"
        else
            msg_error "$(translate "Group 'sharedfiles' was not created successfully. Skipping chown/usermod.")"
        fi
        
        HAS_ACCESS=$(pct exec "$CTID" -- su -s /bin/bash -c "test -w '$MOUNT_POINT' && echo yes || echo no" "$USERNAME" 2>/dev/null)
        if [ "$HAS_ACCESS" = "no" ]; then
            pct exec "$CTID" -- setfacl -R -m "u:$USERNAME:rwx" "$MOUNT_POINT"
            msg_warn "$(translate "ACL permissions applied to allow write access for user:") $USERNAME"
        else
            msg_ok "$(translate "Write access confirmed for user:") $USERNAME"
        fi
    else
        msg_ok "$(translate "No shared mount detected. Applying standard local access.")"
        pct exec "$CTID" -- chown -R "$USERNAME:$USERNAME" "$MOUNT_POINT"
        pct exec "$CTID" -- chmod -R 755 "$MOUNT_POINT"
        
        HAS_ACCESS=$(pct exec "$CTID" -- su -s /bin/bash -c "test -w '$MOUNT_POINT' && echo yes || echo no" "$USERNAME" 2>/dev/null)
        if [ "$HAS_ACCESS" = "no" ]; then
            pct exec "$CTID" -- setfacl -R -m "u:$USERNAME:rwx" "$MOUNT_POINT"
            msg_warn "$(translate "ACL permissions applied for local access for user:") $USERNAME"
        else
            msg_ok "$(translate "Write access confirmed for user:") $USERNAME"
        fi
    fi
    

    SHARE_OPTIONS=$(whiptail --title "$(translate "Share Options")" --menu "$(translate "Select share permissions:")" 15 70 3 \
    "rw" "$(translate "Read-Write access")" \
    "ro" "$(translate "Read-Only access")" \
    "custom" "$(translate "Custom options")" 3>&1 1>&2 2>&3)
    
    SHARE_NAME=$(basename "$MOUNT_POINT")
    
    case "$SHARE_OPTIONS" in
        rw)
            CONFIG=$(cat <<EOF
[$SHARE_NAME]
    comment = Shared folder for $USERNAME
    path = $MOUNT_POINT
    read only = no
    writable = yes
    browseable = yes
    guest ok = no
    valid users = $USERNAME
    force group = sharedfiles
    create mask = 0664
    directory mask = 2775
    force create mode = 0664
    force directory mode = 2775
    veto files = /lost+found/
EOF
)
            ;;
        ro)
            CONFIG=$(cat <<EOF
[$SHARE_NAME]
    comment = Read-only shared folder for $USERNAME
    path = $MOUNT_POINT
    read only = yes
    writable = no
    browseable = yes
    guest ok = no
    valid users = $USERNAME
    force group = sharedfiles
    veto files = /lost+found/
EOF
)
            ;;
        custom)
            CUSTOM_CONFIG=$(whiptail --inputbox "$(translate "Enter custom Samba configuration for this share:")" 15 80 "read only = no\nwritable = yes\nbrowseable = yes\nguest ok = no" --title "$(translate "Custom Configuration")" 3>&1 1>&2 2>&3)
            CONFIG=$(cat <<EOF
[$SHARE_NAME]
    comment = Custom shared folder for $USERNAME
    path = $MOUNT_POINT
    valid users = $USERNAME
    force group = sharedfiles
    $CUSTOM_CONFIG
    veto files = /lost+found/
EOF
)
            ;;
        *)
            CONFIG=$(cat <<EOF
[$SHARE_NAME]
    comment = Shared folder for $USERNAME
    path = $MOUNT_POINT
    read only = no
    writable = yes
    browseable = yes
    guest ok = no
    valid users = $USERNAME
    force group = sharedfiles
    create mask = 0664
    directory mask = 2775
    force create mode = 0664
    force directory mode = 2775
    veto files = /lost+found/
EOF
)
            ;;
    esac
    

    if pct exec "$CTID" -- grep -q "\[$SHARE_NAME\]" /etc/samba/smb.conf; then
        msg_warn "$(translate "The share already exists in smb.conf:") [$SHARE_NAME]"
        if whiptail --yesno "$(translate "Do you want to update the existing share?")" 10 60 --title "$(translate "Update Share")"; then
 
            pct exec "$CTID" -- sed -i "/^\[$SHARE_NAME\]/,/^$/d" /etc/samba/smb.conf
            pct exec "$CTID" -- bash -c "echo '$CONFIG' >> /etc/samba/smb.conf"
            msg_ok "$(translate "Share updated successfully.")"
        else
            return
        fi
    else
        msg_ok "$(translate "Adding new share to smb.conf...")"
        pct exec "$CTID" -- bash -c "echo '$CONFIG' >> /etc/samba/smb.conf"
        msg_ok "$(translate "Share added successfully.")"
    fi
    

    pct exec "$CTID" -- systemctl restart smbd.service
    

    CT_IP=$(pct exec "$CTID" -- hostname -I | awk '{print $1}')
    
    echo -e ""
    msg_ok "$(translate "Samba share created successfully!")"
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate "Connection details:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Server IP:")${CL}  ${BL}$CT_IP${CL}"
    echo -e "${TAB}${BGN}$(translate "Share name:")${CL} ${BL}$SHARE_NAME${CL}"
    echo -e "${TAB}${BGN}$(translate "Share path:")${CL} ${BL}$MOUNT_POINT${CL}"
    echo -e "${TAB}${BGN}$(translate "Username:")${CL} ${BL}$USERNAME${CL}"
    echo -e
    
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}




view_shares() {
    show_proxmenux_logo
    msg_title "$(translate "View Current Shares")"
    
    echo -e "$(translate "Current Samba shares in CT") $CTID:"
    echo "=================================="
    
    if pct exec "$CTID" -- test -f /etc/samba/smb.conf; then

        SHARES=$(pct exec "$CTID" -- awk '/^\[.*\]/ && !/^\[global\]/ && !/^\[homes\]/ && !/^\[printers\]/ {print $0}' /etc/samba/smb.conf)
        if [[ -n "$SHARES" ]]; then

            while IFS= read -r share_line; do
                if [[ -n "$share_line" ]]; then
                    SHARE_NAME=$(echo "$share_line" | sed 's/\[//g' | sed 's/\]//g')
                    SHARE_PATH=$(pct exec "$CTID" -- awk "/^\[$SHARE_NAME\]/,/^$/ {if(/path =/) print \$3}" /etc/samba/smb.conf)
                    echo "$share_line -> $SHARE_PATH"
                fi
            done <<< "$SHARES"
            

            CT_IP=$(pct exec "$CTID" -- hostname -I | awk '{print $1}')
            USERNAME=$(pct exec "$CTID" -- pdbedit -L | awk -F: '{print $1}' | head -n1)
            
            echo ""
            echo "=================================="
            echo -e "${TAB}${BOLD}$(translate "Connection Details:")${CL}"
            echo -e "${TAB}${BGN}$(translate "Server IP:")${CL}  ${BL}$CT_IP${CL}"
            echo -e "${TAB}${BGN}$(translate "Username:")${CL}  ${BL}$USERNAME${CL}"
            echo ""
            
            echo -e "${TAB}${BOLD}$(translate "Available Shares:")${CL}"
            while IFS= read -r share_line; do
                if [[ -n "$share_line" ]]; then
                    SHARE_NAME=$(echo "$share_line" | sed 's/\[//g' | sed 's/\]//g')
                    SHARE_PATH=$(pct exec "$CTID" -- awk "/^\[$SHARE_NAME\]/,/^$/ {if(/path =/) print \$3}" /etc/samba/smb.conf)
                    echo -e "${TAB}${BGN}$(translate "Share name:")${CL} ${BL}$SHARE_NAME${CL}"
                    echo -e "${TAB}${BGN}$(translate "Share path:")${CL} ${BL}$SHARE_PATH${CL}"
                    echo -e "${TAB}${BGN}$(translate "Windows path:")${CL} ${YW}\\\\$CT_IP\\$SHARE_NAME${CL}"
                    echo -e "${TAB}${BGN}$(translate "Linux/Mac path:")${CL} ${YW}smb://$CT_IP/$SHARE_NAME${CL}"
                    echo ""
                fi
            done <<< "$SHARES"
            
        else
            echo "$(translate "No shares configured.")"
        fi
    else
        echo "$(translate "/etc/samba/smb.conf file does not exist.")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}




delete_share() {
    if ! pct exec "$CTID" -- test -f /etc/samba/smb.conf; then
        dialog --backtitle "ProxMenux" --title "$(translate "Error")" --msgbox "\n$(translate "No smb.conf file found.")" 8 50
        return
    fi
    

    SHARES=$(pct exec "$CTID" -- awk '/^\[.*\]/ && !/^\[global\]/ && !/^\[homes\]/ && !/^\[printers\]/ {gsub(/\[|\]/, ""); print NR, $0}' /etc/samba/smb.conf)
    
    if [[ -z "$SHARES" ]]; then
        dialog --backtitle "ProxMenux" --title "$(translate "No Shares")" --msgbox "\n$(translate "No shares found in smb.conf.")" 8 60
        return
    fi
    
    OPTIONS=()
    while read -r line; do
        [[ -z "$line" ]] && continue
        NUM=$(echo "$line" | awk '{print $1}')
        SHARE_NAME=$(echo "$line" | awk '{print $2}')
        SHARE_PATH=$(pct exec "$CTID" -- awk "/^\[$SHARE_NAME\]/,/^$/ {if(/path =/) print \$3}" /etc/samba/smb.conf)
        [[ -z "$SHARE_NAME" ]] && continue
        OPTIONS+=("$SHARE_NAME" "$SHARE_NAME -> $SHARE_PATH")
    done <<< "$SHARES"
    
    SELECTED_SHARE=$(dialog --backtitle "ProxMenux" --title "$(translate "Delete Share")" --menu "$(translate "Select a share to delete:")" 20 70 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
    [ -z "$SELECTED_SHARE" ] && return
    
    SHARE_PATH=$(pct exec "$CTID" -- awk "/^\[$SELECTED_SHARE\]/,/^$/ {if(/path =/) print \$3}" /etc/samba/smb.conf)
    if whiptail --yesno "$(translate "Are you sure you want to delete this share?")\n\n$(translate "Share name:"): $SELECTED_SHARE\n$(translate "Share path:"): $SHARE_PATH" 12 70 --title "$(translate "Confirm Deletion")"; then
        show_proxmenux_logo
        msg_title "$(translate "Delete Share")"
        

        pct exec "$CTID" -- sed -i "/^\[$SELECTED_SHARE\]/,/^$/d" /etc/samba/smb.conf
        pct exec "$CTID" -- systemctl restart smbd.service
        msg_ok "$(translate "Share deleted and Samba service restarted.")"
    fi
    
    echo -e
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}

check_samba_status() {
    show_proxmenux_logo
    msg_title "$(translate "Check Samba Status")"
    
    echo -e "$(translate "Samba Service Status in CT") $CTID:"
    echo "=================================="
    

    if pct exec "$CTID" -- dpkg -s samba &>/dev/null; then
        echo "$(translate "Samba Server: INSTALLED")"
        

        if pct exec "$CTID" -- systemctl is-active --quiet smbd; then
            echo "$(translate "Samba Service: RUNNING")"
        else
            echo "$(translate "Samba Service: STOPPED")"
        fi
        

        if pct exec "$CTID" -- systemctl is-active --quiet nmbd; then
            echo "$(translate "NetBIOS Service: RUNNING")"
        else
            echo "$(translate "NetBIOS Service: STOPPED")"
        fi
        

        echo ""
        echo "$(translate "Listening ports:")"
        pct exec "$CTID" -- ss -tlnp | grep -E ':(139|445)' || echo "$(translate "No Samba ports found")"
        

        echo ""
        echo "$(translate "Samba users:")"
        pct exec "$CTID" -- pdbedit -L 2>/dev/null || echo "$(translate "No Samba users found")"
        
    else
        echo "$(translate "Samba Server: NOT INSTALLED")"
    fi
    
    echo ""
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}



uninstall_samba() {

    if ! pct exec "$CTID" -- dpkg -s samba &>/dev/null; then
        dialog --backtitle "ProxMenux" --title "$(translate "Samba Not Installed")" --msgbox "\n$(translate "Samba server is not installed in this CT.")" 8 60
        return
    fi
    
    if ! whiptail --title "$(translate "Uninstall Samba Server")" \
        --yesno "$(translate "WARNING: This will completely remove Samba server from the CT.")\n\n$(translate "This action will:")\n$(translate "â€¢ Stop all Samba services")\n$(translate "â€¢ Remove all shares")\n$(translate "â€¢ Remove all Samba users")\n$(translate "â€¢ Uninstall Samba packages")\n$(translate "â€¢ Remove Samba groups")\n\n$(translate "Are you sure you want to continue?")" \
        18 70; then
        return
    fi

    
    show_proxmenux_logo
    msg_title "$(translate "Uninstall Samba Server")"
    

    msg_info "$(translate "Stopping Samba services...")"
    pct exec "$CTID" -- systemctl stop smbd 2>/dev/null || true
    pct exec "$CTID" -- systemctl stop nmbd 2>/dev/null || true
    pct exec "$CTID" -- systemctl disable smbd 2>/dev/null || true
    pct exec "$CTID" -- systemctl disable nmbd 2>/dev/null || true
    msg_ok "$(translate "Samba services stopped and disabled.")"
    

    if pct exec "$CTID" -- test -f /etc/samba/smb.conf; then
        pct exec "$CTID" -- cp /etc/samba/smb.conf /etc/samba/smb.conf.backup.$(date +%Y%m%d_%H%M%S)
        msg_ok "$(translate "Samba configuration backed up.")"
    fi
    

    SAMBA_USERS=$(pct exec "$CTID" -- pdbedit -L 2>/dev/null | awk -F: '{print $1}' || true)
    if [[ -n "$SAMBA_USERS" ]]; then
        while IFS= read -r user; do
            if [[ -n "$user" ]]; then
                pct exec "$CTID" -- smbpasswd -x "$user" 2>/dev/null || true
            fi
        done <<< "$SAMBA_USERS"
        msg_ok "$(translate "Samba users removed.")"
    fi
    


    pct exec "$CTID" -- apt-get remove --purge -y samba samba-common-bin samba-common 2>/dev/null || true
    pct exec "$CTID" -- apt-get autoremove -y 2>/dev/null || true
    msg_ok "$(translate "Samba packages removed.")"
    


    if pct exec "$CTID" -- getent group sharedfiles >/dev/null 2>&1; then

        GROUP_USERS=$(pct exec "$CTID" -- getent group sharedfiles | cut -d: -f4)
        if [[ -z "$GROUP_USERS" ]]; then
            pct exec "$CTID" -- groupdel sharedfiles 2>/dev/null || true
            msg_ok "$(translate "Samba group removed.")"
        else
            msg_warn "$(translate "Samba group kept (has users assigned).")"
        fi
    fi
    
    msg_info "$(translate "Cleaning up Samba directories...")"
    pct exec "$CTID" -- pkill -f smbd 2>/dev/null || true
    pct exec "$CTID" -- pkill -f nmbd 2>/dev/null || true
    
    pct exec "$CTID" -- rm -rf /var/lib/samba 2>/dev/null || true
    pct exec "$CTID" -- rm -rf /var/cache/samba 2>/dev/null || true
    
    sleep 2
    msg_ok "$(translate "Samba server has been completely uninstalled!")"
    echo -e ""
    echo -e "${TAB}${BOLD}$(translate "Uninstallation Summary:")${CL}"
    echo -e "${TAB}${BGN}$(translate "Services:")${CL} ${BL}$(translate "Stopped and disabled")${CL}"
    echo -e "${TAB}${BGN}$(translate "Packages:")${CL} ${BL}$(translate "Removed")${CL}"
    echo -e "${TAB}${BGN}$(translate "Users:")${CL} ${BL}$(translate "Removed")${CL}"
    echo -e "${TAB}${BGN}$(translate "Configuration:")${CL} ${BL}$(translate "Backed up and cleared")${CL}"
    echo -e "${TAB}${BGN}$(translate "Groups:")${CL} ${BL}$(translate "Cleaned up")${CL}"
    echo -e
    
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
}


# === Main Menu ===
while true; do
    CHOICE=$(dialog --backtitle "ProxMenux" --title "$(translate "Samba Manager - CT") $CTID" --menu "$(translate "Choose an option:")" 20 70 12 \
    "1" "$(translate "Create Samba server service")" \
    "2" "$(translate "View Current Shares")" \
    "3" "$(translate "Delete Share")" \
    "4" "$(translate "Check Samba Status")" \
    "5" "$(translate "Uninstall Samba Server")" \
    "6" "$(translate "Exit")" 3>&1 1>&2 2>&3)
    
    case $CHOICE in
        1) create_share ;;
        2) view_shares ;;
        3) delete_share ;;
        4) check_samba_status ;;
        5) uninstall_samba ;;
        6) exit 0 ;;
        *) exit 0 ;;
    esac
done



================================================
FILE: scripts/storage/disk-passthrough.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks to existing
# Proxmox virtual machines (VMs) through an interactive menu.
# - Detects the system disk and excludes it from selection.
# - Lists all available VMs for the user to choose from.
# - Identifies and displays unassigned physical disks.
# - Allows the user to select multiple disks and attach them to a VM.
# - Supports interface types: SATA, SCSI, VirtIO, and IDE.
# - Ensures that disks are not already assigned to active VMs.
# - Warns about disk sharing between multiple VMs to avoid data corruption.
# - Configures the selected disks for the VM and verifies the assignment.
#
# The goal of this script is to simplify the process of assigning
# physical disks to Proxmox VMs, reducing manual configurations
# and preventing potential errors.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================



get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}


VM_LIST=$(qm list | awk 'NR>1 {print $1, $2}')
if [ -z "$VM_LIST" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VMs available in the system.")" 8 40
    exit 1
fi


VMID=$(whiptail --title "$(translate "Select VM")" --menu "$(translate "Select the VM to which you want to add disks:")" 15 60 8 $VM_LIST 3>&1 1>&2 2>&3)

if [ -z "$VMID" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VM was selected.")" 8 40
    exit 1
fi

VMID=$(echo "$VMID" | tr -d '"')


msg_ok "$(translate "VM selected successfully.")"


VM_STATUS=$(qm status "$VMID" | awk '{print $2}')
if [ "$VM_STATUS" == "running" ]; then
    whiptail --title "$(translate "Warning")" --msgbox "$(translate "The VM is powered on. Turn it off before adding disks.")" 12 60
    exit 1
fi


##########################################

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do

    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi


    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)


is_disk_in_use() {
    local disk="$1"


    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac

        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)


    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi

    return 1
}




FREE_DISKS=()

LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)
RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do

    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi



    USED_BY=""
    REAL_PATH=$(readlink -f "$DISK")
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi




    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi


    if $IS_ZFS; then
        SHOW_DISK=false
    fi


    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi


    if qm config "$VMID" | grep -vE '^\s*#|^description:' | grep -q "$DISK"; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"

        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)



if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks available for this VM.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"



######################################################




MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))

if [ $TOTAL_WIDTH -lt 50 ]; then
    TOTAL_WIDTH=50
fi


SELECTED=$(whiptail --title "$(translate "Select Disks")" --checklist \
    "$(translate "Select the disks you want to add:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 64
    clear
    exit 1
fi

msg_ok "$(translate "Disks selected successfully.")"


INTERFACE=$(whiptail --title "$(translate "Interface Type")" --menu "$(translate "Select the interface type for all disks:")" 15 40 4 \
    "sata" "$(translate "Add as SATA")" \
    "scsi" "$(translate "Add as SCSI")" \
    "virtio" "$(translate "Add as VirtIO")" \
    "ide" "$(translate "Add as IDE")" 3>&1 1>&2 2>&3)

if [ -z "$INTERFACE" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No interface type was selected for the disks.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Interface type selected: $INTERFACE")"

DISKS_ADDED=0
ERROR_MESSAGES=""
SUCCESS_MESSAGES=""



msg_info "$(translate "Processing selected disks...")"

for DISK in $SELECTED; do
    DISK=$(echo "$DISK" | tr -d '"')
    DISK_INFO=$(get_disk_info "$DISK")

    ASSIGNED_TO=""
    RUNNING_VMS=""
    RUNNING_CTS=""

  
    while read -r VM_ID VM_NAME; do
        if [[ "$VM_ID" =~ ^[0-9]+$ ]] && qm config "$VM_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="VM $VM_ID $VM_NAME\n"
            VM_STATUS=$(qm status "$VM_ID" | awk '{print $2}')
            if [ "$VM_STATUS" == "running" ]; then
                RUNNING_VMS+="VM $VM_ID $VM_NAME\n"
            fi
        fi
    done < <(qm list | awk 'NR>1 {print $1, $2}')


    while read -r CT_ID CT_NAME; do
        if [[ "$CT_ID" =~ ^[0-9]+$ ]] && pct config "$CT_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="CT $CT_ID $CT_NAME\n"
            CT_STATUS=$(pct status "$CT_ID" | awk '{print $2}')
            if [ "$CT_STATUS" == "running" ]; then
                RUNNING_CTS+="CT $CT_ID $CT_NAME\n"
            fi
        fi
    done < <(pct list | awk 'NR>1 {print $1, $2}')

    if [ -n "$RUNNING_VMS" ] || [ -n "$RUNNING_CTS" ]; then
        ERROR_MESSAGES+="$(translate "The disk") $DISK_INFO $(translate "is currently in use by the following running VM(s) or CT(s):")\\n$RUNNING_VMS$RUNNING_CTS\\n\\n$(translate "You cannot add this disk while the VM or CT is running.")\\n$(translate "Please shut it down first and run this script again to add the disk.")\\n\\n"
        continue
    fi

    if [ -n "$ASSIGNED_TO" ]; then
        cleanup
        whiptail --title "$(translate "Disk Already Assigned")" --yesno "$(translate "The disk") $DISK_INFO $(translate "is already assigned to the following VM(s) or CT(s):")\\n$ASSIGNED_TO\\n\\n$(translate "Do you want to continue anyway?")" 15 70
        if [ $? -ne 0 ]; then
            sleep 1
            exec "$0"
        fi
    fi


    INDEX=0
    while qm config "$VMID" | grep -q "${INTERFACE}${INDEX}"; do
        ((INDEX++))
    done

    RESULT=$(qm set "$VMID" -${INTERFACE}${INDEX} "$DISK" 2>&1)

    if [ $? -eq 0 ]; then
        MESSAGE="$(translate "The disk") $DISK_INFO $(translate "has been successfully added to VM") $VMID."
        if [ -n "$ASSIGNED_TO" ]; then
            MESSAGE+="\\n\\n$(translate "WARNING: This disk is also assigned to the following VM(s):")\\n$ASSIGNED_TO"
            MESSAGE+="\\n$(translate "Make sure not to start VMs that share this disk at the same time to avoid data corruption.")"
        fi
        SUCCESS_MESSAGES+="$MESSAGE\\n\\n"
        ((DISKS_ADDED++))
    else
        ERROR_MESSAGES+="$(translate "Could not add disk") $DISK_INFO $(translate "to VM") $VMID.\\n$(translate "Error:") $RESULT\\n\\n"
    fi
done

msg_ok "$(translate "Disk processing completed.")"



if [ -n "$SUCCESS_MESSAGES" ]; then
    MSG_LINES=$(echo "$SUCCESS_MESSAGES" | wc -l)
    whiptail --title "$(translate "Successful Operations")" --msgbox "$SUCCESS_MESSAGES" 16 70
fi

if [ -n "$ERROR_MESSAGES" ]; then
    whiptail --title "$(translate "Warnings and Errors")" --msgbox "$ERROR_MESSAGES" 16 70
fi



exit 0



================================================
FILE: scripts/storage/disk-passthrough_ct.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.2
# Last Updated: 30/07/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks to existing
# Proxmox containers (CTs) through an interactive menu.
# - Detects the system disk and excludes it from selection.
# - Lists all available CTs for the user to choose from.
# - Identifies and displays unassigned physical disks.
# - Allows the user to select multiple disks and attach them to a CT.
# - Configures the selected disks for the CT and verifies the assignment.
# - Uses persistent device paths to avoid issues with device order changes.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# Get OS codename for repository configuration
OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs )"

# ==========================================================

# Function to get persistent device path
get_persistent_path() {
    local device="$1"
    local persistent_path=""
    
    # Try by-id first (most reliable)
    for path in /dev/disk/by-id/*; do
        if [[ -e "$path" && "$(readlink -f "$path")" == "$device" ]]; then
            # Prefer ata- or scsi- over wwn- for readability
            if [[ "$path" =~ ata-|scsi- ]]; then
                echo "$path"
                return 0
            elif [[ -z "$persistent_path" ]]; then
                persistent_path="$path"
            fi
        fi
    done
    
    # Return the first found by-id path if any
    if [[ -n "$persistent_path" ]]; then
        echo "$persistent_path"
        return 0
    fi
    
    # Try by-path as fallback
    for path in /dev/disk/by-path/*; do
        if [[ -e "$path" && "$(readlink -f "$path")" == "$device" ]]; then
            echo "$path"
            return 0
        fi
    done
    
    # Fallback to original device if no persistent path found
    msg_warn "$(translate "No persistent path found for") $device, $(translate "using direct path")"
    echo "$device"
}

# Function to ensure repositories are properly configured
ensure_repositories() {
    local sources_file="/etc/apt/sources.list"
    local need_update=false
    
    # Only verify the main repository with contrib and non-free
    if ! grep -q "deb.*${OS_CODENAME}.*main" "$sources_file"; then
        echo "deb http://deb.debian.org/debian ${OS_CODENAME} main contrib non-free non-free-firmware" >> "$sources_file"
        need_update=true
    fi
    
    if [ "$need_update" = true ]; then
        apt update >/dev/null 2>&1
    fi
    
    return 0
}

get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}

# Ensure repositories are configured
ensure_repositories

CT_LIST=$(pct list | awk 'NR>1 {print $1, $3}')
if [ -z "$CT_LIST" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No CTs available in the system.")" 8 40
    exit 1
fi

CTID=$(whiptail --title "$(translate "Select CT for destination disk")" --menu "$(translate "Select the CT to which you want to add disks:")" 15 60 8 $CT_LIST 3>&1 1>&2 2>&3)

if [ -z "$CTID" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No CT was selected.")" 8 40
    exit 1
fi

CTID=$(echo "$CTID" | tr -d '"')

clear
show_proxmenux_logo
echo -e
msg_title "$(translate "Add Disk") Passthrough $(translate "to a LXC")"
echo -e
msg_ok "$(translate "CT selected successfully.")"

CT_STATUS=$(pct status "$CTID" | awk '{print $2}')
if [ "$CT_STATUS" != "running" ]; then
    msg_info "$(translate "Starting CT") $CTID..."
    pct start "$CTID"
    sleep 2
    if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
        msg_error "$(translate "Failed to start the CT.")"
        sleep 2
        exit 1
    fi
    msg_ok "$(translate "CT started successfully.")"
fi

CONF_FILE="/etc/pve/lxc/$CTID.conf"
if grep -q '^unprivileged: 1' "$CONF_FILE"; then
    if whiptail --title "$(translate "Privileged Container")" \
        --yesno "$(translate "The selected container is unprivileged. A privileged container is required for direct device passthrough.")\\n\\n$(translate "Do you want to convert it to a privileged container now?")" 12 70; then
        
        msg_info "$(translate "Stopping container") $CTID..."
        pct shutdown "$CTID" &>/dev/null
        for i in {1..10}; do
            sleep 1
            if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
                break
            fi
        done
        
        if [ "$(pct status "$CTID" | awk '{print $2}')" == "running" ]; then
            msg_error "$(translate "Failed to stop the container.")"
            exit 1
        fi
        msg_ok "$(translate "Container stopped.")"
        
        cp "$CONF_FILE" "$CONF_FILE.bak"
        sed -i '/^unprivileged: 1/d' "$CONF_FILE"
        echo "unprivileged: 0" >> "$CONF_FILE"
        msg_ok "$(translate "Container successfully converted to privileged.")"
        
        msg_info "$(translate "Starting container") $CTID..."
        pct start "$CTID" &>/dev/null
        sleep 2
        if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
            msg_error "$(translate "Failed to start the container.")"
            exit 1
        fi
        msg_ok "$(translate "Container started successfully.")"
    else
        whiptail --title "$(translate "Aborted")" \
            --msgbox "$(translate "Operation cancelled. Cannot continue with an unprivileged container.")" 10 60
        exit 1
    fi
fi

##########################################
msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')
for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi
    
    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done
ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)

is_disk_in_use() {
    local disk="$1"
    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac
        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)
    
    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi
    return 1
}

FREE_DISKS=()
LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -r -n1 readlink -f | sort -u)

if [[ -n "$LVM_DEVICES" ]] && echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
    IS_MOUNTED=true
fi

RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue
    
    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true
    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false
    
    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)
    
    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi
    
    USED_BY=""
    REAL_PATH=$(readlink -f "$DISK")
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)
    
    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi
    
    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi
    
    if $IS_ZFS; then
        SHOW_DISK=false
    fi
    
    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi
    
    # Check if disk is already assigned to this CT using persistent paths
    if pct config "$CTID" | grep -vE '^\s*#|^description:' | grep -q "$DISK"; then
        SHOW_DISK=false
    else
        # Also check persistent paths
        PERSISTENT_DISK=$(get_persistent_path "$DISK")
        if [[ "$PERSISTENT_DISK" != "$DISK" ]] && pct config "$CTID" | grep -vE '^\s*#|^description:' | grep -q "$PERSISTENT_DISK"; then
            SHOW_DISK=false
        fi
    fi
    
    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
        
        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)

if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks available for this CT.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"

######################################################
MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))
if [ $TOTAL_WIDTH -lt 50 ]; then
    TOTAL_WIDTH=50
fi

SELECTED=$(whiptail --title "$(translate "Select Disks")" --radiolist \
    "$(translate "Select the disks you want to add:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 64
    clear
    exit 1
fi

msg_ok "$(translate "Disks selected successfully.")"

DISKS_ADDED=0
ERROR_MESSAGES=""
SUCCESS_MESSAGES=""

msg_info "$(translate "Processing selected disks...")"

for DISK in $SELECTED; do
    DISK=$(echo "$DISK" | tr -d '"')
    DISK_INFO=$(get_disk_info "$DISK")
    
    ASSIGNED_TO=""
    RUNNING_CTS=""
    RUNNING_VMS=""
    
    while read -r CT_ID CT_NAME; do
        if [[ "$CT_ID" =~ ^[0-9]+$ ]] && pct config "$CT_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="CT $CT_ID $CT_NAME\n"
            CT_STATUS=$(pct status "$CT_ID" | awk '{print $2}')
            if [ "$CT_STATUS" == "running" ]; then
                RUNNING_CTS+="CT $CT_ID $CT_NAME\n"
            fi
        fi
    done < <(pct list | awk 'NR>1 {print $1, $3}')
    
    while read -r VM_ID VM_NAME; do
        if [[ "$VM_ID" =~ ^[0-9]+$ ]] && qm config "$VM_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="VM $VM_ID $VM_NAME\n"
            VM_STATUS=$(qm status "$VM_ID" | awk '{print $2}')
            if [ "$VM_STATUS" == "running" ]; then
                RUNNING_VMS+="VM $VM_ID $VM_NAME\n"
            fi
        fi
    done < <(qm list | awk 'NR>1 {print $1, $2}')
    
    if [ -n "$RUNNING_CTS" ] || [ -n "$RUNNING_VMS" ]; then
        ERROR_MESSAGES+="$(translate "The disk") $DISK_INFO $(translate "is in use by the following running VM(s) or CT(s):")\\n$RUNNING_CTS$RUNNING_VMS\\n\\n"
        continue
    fi
    
    if [ -n "$ASSIGNED_TO" ]; then
        cleanup
        whiptail --title "$(translate "Disk Already Assigned")" --yesno "$(translate "The disk") $DISK_INFO $(translate "is already assigned to the following VM(s) or CT(s):")\\n$ASSIGNED_TO\\n\\n$(translate "Do you want to continue anyway?")" 15 70
        if [ $? -ne 0 ]; then
            sleep 1
            exec "$0"
        fi
    fi
    
    cleanup
    
    if lsblk "$DISK" | grep -q "raid" || grep -q "${DISK##*/}" /proc/mdstat; then
        whiptail --title "$(translate "RAID Detected")" --msgbox "$(translate "The disk") $DISK_INFO $(translate "appears to be part of a") RAID. $(translate "For security reasons, the system cannot format it.")\\n\\n$(translate "If you are sure you want to use it, please remove the") RAID metadata $(translate "or format it manually using external tools.")\\n\\n$(translate "After that, run this script again to add it.")" 18 70
        clear
        exit
    fi
    
    MOUNT_POINT=$(whiptail --title "$(translate "Mount Point")" --inputbox "$(translate "Enter the mount point for the disk (e.g., /mnt/disk_passthrough):")" 10 60 "/mnt/disk_passthrough" 3>&1 1>&2 2>&3)
    
    if [ -z "$MOUNT_POINT" ]; then
        whiptail --title "$(translate "Error")" --msgbox "$(translate "No mount point was specified.")" 8 40
        continue
    fi
    
    msg_ok "$(translate "Mount point specified: $MOUNT_POINT")"
    
    PARTITION=$(lsblk -rno NAME "$DISK" | awk -v disk="$(basename "$DISK")" '$1 != disk {print $1; exit}')
    SKIP_FORMAT=false
    
    if [ -n "$PARTITION" ]; then
        PARTITION="/dev/$PARTITION"
        CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION."
        else
            whiptail --title "$(translate "Unsupported Filesystem")" --yesno "$(translate "The partition") $PARTITION $(translate "has an unsupported filesystem ($CURRENT_FS).\\nDo you want to format it?")" 10 70
            if [ $? -ne 0 ]; then
                continue
            fi
        fi
    else
        CURRENT_FS=$(lsblk -no FSTYPE "$DISK" | xargs)
        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            PARTITION="$DISK"
            msg_ok "$(translate "Detected filesystem") $CURRENT_FS $(translate "directly on disk") $DISK."
        else
            whiptail --title "$(translate "No Valid Partitions")" --yesno "$(translate "The disk has no partitions and no valid filesystem. Do you want to create a new partition and format it?")" 10 70
            if [ $? -ne 0 ]; then
                continue
            fi
            
            echo -e "$(translate "Creating partition table and partition...")"
            parted -s "$DISK" mklabel gpt
            parted -s "$DISK" mkpart primary 0% 100%
            sleep 2
            partprobe "$DISK"
            sleep 2
            
            PARTITION=$(lsblk -rno NAME "$DISK" | awk -v disk="$(basename "$DISK")" '$1 != disk {print $1; exit}')
            if [ -n "$PARTITION" ]; then
                PARTITION="/dev/$PARTITION"
            else
                whiptail --title "$(translate "Partition Error")" --msgbox "$(translate "Failed to create partition on disk") $DISK_INFO." 8 70
                continue
            fi
        fi
    fi
    
    if [ "$SKIP_FORMAT" != true ]; then
        CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
        if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
            SKIP_FORMAT=true
            msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION. $(translate "Skipping format.")"
        else
            FORMAT_TYPE=$(whiptail --title "$(translate "Select Format Type")" --menu "$(translate "Select the filesystem type for") $DISK_INFO:" 15 60 6 \
                "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
                "xfs" "$(translate "XFS Filesystem")" \
                "btrfs" "$(translate "Btrfs Filesystem")" 3>&1 1>&2 2>&3)
            
            if [ -z "$FORMAT_TYPE" ]; then
                whiptail --title "$(translate "Format Cancelled")" --msgbox "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
                continue
            fi
            
            whiptail --title "$(translate "WARNING")" --yesno "$(translate "WARNING: This operation will FORMAT the disk") $DISK_INFO $(translate "with") $FORMAT_TYPE.\\n\\n$(translate "ALL DATA ON THIS DISK WILL BE PERMANENTLY LOST!")\\n\\n$(translate "Are you sure you want to continue")" 15 70
            if [ $? -ne 0 ]; then
                whiptail --title "$(translate "Format Cancelled")" --msgbox "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
                continue
            fi
        fi
    fi
    
    if [ "$SKIP_FORMAT" != true ]; then
        echo -e "$(translate "Formatting partition") $PARTITION $(translate "with") $FORMAT_TYPE..."
        case "$FORMAT_TYPE" in
            "ext4") mkfs.ext4 -F "$PARTITION" ;;
            "xfs") mkfs.xfs -f "$PARTITION" ;;
            "btrfs") mkfs.btrfs -f "$PARTITION" ;;
        esac
        
        if [ $? -ne 0 ]; then
            whiptail --title "$(translate "Format Failed")" --msgbox "$(translate "Failed to format partition") $PARTITION $(translate "with") $FORMAT_TYPE.\\n\\n$(translate "The disk may be in use by the system or have hardware issues.")" 12 70
            continue
        else
            msg_ok "$(translate "Partition") $PARTITION $(translate "successfully formatted with") $FORMAT_TYPE."
            partprobe "$DISK"
            sleep 2
        fi
    fi
    
    INDEX=0
    while pct config "$CTID" | grep -q "mp${INDEX}:"; do
        ((INDEX++))
    done
    
    # Determine the filesystem type for mount options
    CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
    if [[ -n "$CURRENT_FS" ]]; then
        FORMAT_TYPE="$CURRENT_FS"
    fi
    
    # Install filesystem tools in container if needed
    FS_PKG=""
    FS_BIN=""
    if [[ "$FORMAT_TYPE" == "xfs" ]]; then
        FS_PKG="xfsprogs"
        FS_BIN="mkfs.xfs"
    elif [[ "$FORMAT_TYPE" == "btrfs" ]]; then
        FS_PKG="btrfs-progs"
        FS_BIN="mkfs.btrfs"
    fi
    
    if [[ -n "$FS_PKG" && -n "$FS_BIN" ]]; then
        if ! pct exec "$CTID" -- sh -c "command -v $FS_BIN >/dev/null 2>&1"; then
            msg_info "$(translate "Installing required tools for $FORMAT_TYPE in CT $CTID...")"
            if pct exec "$CTID" -- sh -c "[ -f /etc/alpine-release ]"; then
                pct exec "$CTID" -- sh -c "apk update >/dev/null && apk add --no-progress $FS_PKG >/dev/null"
            elif pct exec "$CTID" -- sh -c "[ -f /etc/os-release ] && (grep -qE 'debian|ubuntu' /etc/os-release)"; then
                pct exec "$CTID" -- sh -c "apt-get update -qq >/dev/null && apt-get install -y -qq $FS_PKG >/dev/null"
            fi
            msg_ok "$(translate "Required tools for $FORMAT_TYPE installed in CT $CTID.")"
        fi
    fi
    
    ##############################################################################
    # Get persistent path for the partition
    PERSISTENT_PARTITION=$(get_persistent_path "$PARTITION")
    
    # Apply passthrough with persistent path
    CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
    if [ "$CURRENT_FS" == "xfs" ] || [ "$FORMAT_TYPE" == "xfs" ]; then
        RESULT=$(pct set "$CTID" -mp${INDEX} "$PERSISTENT_PARTITION,mp=$MOUNT_POINT,backup=0,ro=0" 2>&1)
    else
        RESULT=$(pct set "$CTID" -mp${INDEX} "$PERSISTENT_PARTITION,mp=$MOUNT_POINT,backup=0,ro=0,acl=1" 2>&1)
    fi
    
    # Adjust permissions inside the CT
    pct exec "$CTID" -- chmod -R 775 "$MOUNT_POINT" 2>/dev/null || true
    
    # Show confirmation with persistent identifier
    msg_ok "$(translate "Assigned using") $PERSISTENT_PARTITION"
    ##############################################################################
    
    if [ $? -eq 0 ]; then
        MESSAGE="$(translate "The disk") $DISK_INFO $(translate "has been successfully added to CT") $CTID $(translate "as a mount point at") $MOUNT_POINT."
        MESSAGE+="\\n$(translate "Using persistent path"): $PERSISTENT_PARTITION"
        
        if [ -n "$ASSIGNED_TO" ]; then
            MESSAGE+="\\n\\n$(translate "WARNING: This disk is also assigned to the following CT(s):")\\n$ASSIGNED_TO"
            MESSAGE+="\\n$(translate "Make sure not to start CTs that share this disk at the same time to avoid data corruption.")"
        fi
        
        SUCCESS_MESSAGES+="$MESSAGE\\n\\n"
        ((DISKS_ADDED++))
    else
        ERROR_MESSAGES+="$(translate "Could not add disk") $DISK_INFO $(translate "to CT") $CTID.\\n$(translate "Error:") $RESULT\\n\\n"
    fi
done

msg_ok "$(translate "Disk processing completed.")"

if [ -n "$SUCCESS_MESSAGES" ]; then
    MSG_LINES=$(echo "$SUCCESS_MESSAGES" | wc -l)
    whiptail --title "$(translate "Successful Operations")" --msgbox "$SUCCESS_MESSAGES" 16 70
fi

if [ -n "$ERROR_MESSAGES" ]; then
    whiptail --title "$(translate "Warnings and Errors")" --msgbox "$ERROR_MESSAGES" 16 70
fi

msg_success "$(translate "Press Enter to return to menu...")"
read -r
exit 0



================================================
FILE: scripts/storage/format-disk.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description : Select and format physical disks
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================




get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi

    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi

done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)
CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

FREE_DISKS=()

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    REAL_PATH=$(readlink -f "$DISK")
    USED_BY=""
    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_LVM=true
    fi

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi

    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi

    if $IS_ZFS || $IS_MOUNTED; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi

done < <(lsblk -dn -e 7,11 -o PATH)

cleanup

if [ ${#FREE_DISKS[@]} -eq 0 ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No available disks found on the host.")" 8 50
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"

MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))
TOTAL_WIDTH=$((TOTAL_WIDTH < 50 ? 50 : TOTAL_WIDTH))

SELECTED=$(whiptail --title "$(translate "Select Disk")" --radiolist \
    "$(translate "Select the disk you want to format:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 64
    clear
    exit 1
fi

SELECTED=$(echo "$SELECTED" | tr -d '"')
SELECTED_DISK="$SELECTED"


REAL_PATH=$(readlink -f "$SELECTED")
CT_MATCH=""
VM_MATCH=""

while read -r CT_ID CT_NAME; do
    if pct config "$CT_ID" | grep -q "$REAL_PATH"; then
        STATUS=$(pct status "$CT_ID" | awk '{print $2}')
        if [[ "$STATUS" == "running" ]]; then
            CT_MATCH="CT $CT_ID ($CT_NAME)"
            break
        fi
    fi
done < <(pct list | awk 'NR>1 {print $1, $3}')

while read -r VM_ID VM_NAME; do
    if qm config "$VM_ID" | grep -q "$REAL_PATH"; then
        STATUS=$(qm status "$VM_ID" | awk '{print $2}')
        if [[ "$STATUS" == "running" ]]; then
            VM_MATCH="VM $VM_ID ($VM_NAME)"
            break
        fi
    fi
done < <(qm list | awk 'NR>1 {print $1, $2}')

if [[ -n "$CT_MATCH" || -n "$VM_MATCH" ]]; then
    whiptail --title "$(translate "Disk In Use")" --msgbox "$(translate "The selected disk is currently assigned to:")\n\n$CT_MATCH $VM_MATCH\n\n$(translate "You must power off the VM or CT before formatting.")" 12 70
    exit 1
fi








#########################################################




SELECTED_DISK=$(echo "$SELECTED_DISK" | tr -d '"')

WARNING_FLAGS=""
if lsblk -no FSTYPE "$SELECTED_DISK" | grep -q "linux_raid_member"; then
    WARNING_FLAGS+=" RAID"
fi
if lsblk -no FSTYPE "$SELECTED_DISK" | grep -q "LVM2_member"; then
    WARNING_FLAGS+=" LVM"
fi
if lsblk -no FSTYPE "$SELECTED_DISK" | grep -q "zfs_member"; then
    WARNING_FLAGS+=" ZFS"
fi

if [ -n "$WARNING_FLAGS" ]; then
    whiptail --title "$(translate "Warning")" --msgbox "$(translate "This disk appears to have the following metadata:")$WARNING_FLAGS\\n\\n$(translate "They will be erased during formatting.")" 10 60
fi

whiptail --title "$(translate "Confirm Format")" --yesno "$(translate "WARNING: You are about to erase all data on")\\n$SELECTED_DISK\\n\\n$(translate "Are you sure you want to continue?")" 10 70 || exit 0

whiptail --title "$(translate "Final Confirmation")" --yesno "$(translate "FINAL WARNING: This operation will completely format the disk")\\n$SELECTED_DISK\\n\\n$(translate "ALL DATA WILL BE LOST. Proceed?")" 10 70 || exit 0




########################################



echo -e "$(translate "Stopping residual RAID or device mappings...")"

mdadm --misc --stop /dev/md* >/dev/null 2>&1
dmsetup remove_all >/dev/null 2>&1

echo -e "$(translate "Wiping disk metadata and old RAID signatures...")"

sgdisk --zap-all "$SELECTED_DISK" >/dev/null 2>&1
wipefs -a "$SELECTED_DISK" >/dev/null 2>&1

udevadm settle
partprobe "$SELECTED_DISK"
sleep 2

echo -e "$(translate "Creating partition table and partition...")"

parted -s "$SELECTED_DISK" mklabel gpt
parted -s "$SELECTED_DISK" mkpart primary 0% 100%

udevadm settle
partprobe "$SELECTED_DISK"
sleep 2






###########################################



udevadm settle
partprobe "$SELECTED_DISK"
sleep 2


PARTITION=$(lsblk -rno NAME "$SELECTED_DISK" | awk -v disk="$(basename "$SELECTED_DISK")" '$1 != disk {print $1; exit}')
if [ -z "$PARTITION" ]; then
    whiptail --title "$(translate "Partition Error")" --msgbox "$(translate "Failed to create partition on disk.")" 8 60
    exit 1
fi
PARTITION="/dev/$PARTITION"

FORMAT_TYPE=$(whiptail --title "$(translate "Select Filesystem")" --menu "$(translate "Choose the filesystem for the disk:")" 15 60 5 \
    "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
    "xfs" "XFS" \
    "btrfs" "Btrfs" 3>&1 1>&2 2>&3)

[[ -z "$FORMAT_TYPE" ]] && exit 0

echo -e "$(translate "Formatting partition") $PARTITION $(translate "as") $FORMAT_TYPE..."

case "$FORMAT_TYPE" in
    ext4) mkfs.ext4 -F "$PARTITION" ;;
    xfs) mkfs.xfs -f "$PARTITION" ;;
    btrfs) mkfs.btrfs -f "$PARTITION" ;;
esac

if [ $? -eq 0 ]; then
    msg_ok "$(translate "Disk formatted successfully:") $PARTITION"
    whiptail --title "$(translate "Success")" --msgbox "$(translate "Disk has been formatted successfully.")" 8 50
else
    whiptail --title "$(translate "Error")" --msgbox "$(translate "Failed to format the disk.")" 8 60
    exit 1
fi



================================================
FILE: scripts/storage/import-disk-image.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 29/05/2025
# ==========================================================
# Description:
# This script automates the process of importing disk images into Proxmox VE virtual machines (VMs), 
# making it easy to attach pre-existing disk files without manual configuration.
#
# Before running the script, ensure that disk images are available in /var/lib/vz/template/images/. 
# The script scans this directory for compatible formats (.img, .qcow2, .vmdk, .raw) and lists the available files.
#
# Using an interactive menu, you can:
# - Select a VM to attach the imported disk.
# - Choose one or multiple disk images for import.
# - Pick a storage volume in Proxmox for disk placement.
# - Assign a suitable interface (SATA, SCSI, VirtIO, or IDE).
# - Enable optional settings like SSD emulation or bootable disk configuration.
#
# Once completed, the script ensures the selected images are correctly attached and ready to use.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"
load_language
initialize_cache
# Configuration ============================================



detect_image_dir() {
  for store in $(pvesm status -content images | awk 'NR>1 {print $1}'); do
    path=$(pvesm path "${store}:template" 2>/dev/null)
    if [[ -d "$path" ]]; then
      for ext in raw img qcow2 vmdk; do
        if compgen -G "$path/*.$ext" > /dev/null; then
          echo "$path"
          return 0
        fi
      done
      for sub in images iso; do
        dir="$path/$sub"
        if [[ -d "$dir" ]]; then
          for ext in raw img qcow2 vmdk; do
            if compgen -G "$dir/*.$ext" > /dev/null; then
              echo "$dir"
              return 0
            fi
          done
        fi
      done
    fi
  done
  for fallback in /var/lib/vz/template/images /var/lib/vz/template/iso; do
    if [[ -d "$fallback" ]]; then
      for ext in raw img qcow2 vmdk; do
        if compgen -G "$fallback/*.$ext" > /dev/null; then
          echo "$fallback"
          return 0
        fi
      done
    fi
  done
  return 1
}


IMAGES_DIR=$(detect_image_dir)
if [[ -z "$IMAGES_DIR" ]]; then
  dialog --title "$(translate 'No Images Found')" \
         --msgbox "$(translate 'Could not find any directory containing disk images')\n\n$(translate 'Make sure there is at least one file with extension .img, .qcow2, .vmdk or .raw')" 15 60
  exit 1
fi

IMAGES=$(ls -A "$IMAGES_DIR" | grep -E "\.(img|qcow2|vmdk|raw)$")
if [ -z "$IMAGES" ]; then
  dialog --title "$(translate 'No Disk Images Found')" \
         --msgbox "$(translate 'No compatible disk images found in:')\n\n$IMAGES_DIR\n\n$(translate 'Supported formats: .img, .qcow2, .vmdk, .raw')" 15 60
  exit 1
fi


# 1. Select VM
msg_info "$(translate 'Getting VM list')"
VM_LIST=$(qm list | awk 'NR>1 {print $1" "$2}')
if [ -z "$VM_LIST" ]; then
    msg_error "$(translate 'No VMs available in the system')"
    exit 1
fi
msg_ok "$(translate 'VM list obtained')"

VMID=$(whiptail --title "$(translate 'Select VM')" --menu "$(translate 'Select the VM where you want to import the disk image:')" 15 60 8 $VM_LIST 3>&1 1>&2 2>&3)

if [ -z "$VMID" ]; then
   
    exit 1
fi



# 2. Select storage volume
msg_info "$(translate 'Getting storage volumes')"
STORAGE_LIST=$(pvesm status -content images | awk 'NR>1 {print $1}')
if [ -z "$STORAGE_LIST" ]; then
    msg_error "$(translate 'No storage volumes available')"
    exit 1
fi
msg_ok "$(translate 'Storage volumes obtained')"


STORAGE_OPTIONS=()
while read -r storage; do
    STORAGE_OPTIONS+=("$storage" "")
done <<< "$STORAGE_LIST"

STORAGE=$(whiptail --title "$(translate 'Select Storage')" --menu "$(translate 'Select the storage volume for disk import:')" 15 60 8 "${STORAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$STORAGE" ]; then
    
    exit 1
fi



# 3. Select disk images
msg_info "$(translate 'Scanning disk images')"
if [ -z "$IMAGES" ]; then
    msg_warn "$(translate 'No compatible disk images found in') $IMAGES_DIR"
    exit 0
fi
msg_ok "$(translate 'Disk images found')"

IMAGE_OPTIONS=()
while read -r img; do
    IMAGE_OPTIONS+=("$img" "" "OFF")
done <<< "$IMAGES"

SELECTED_IMAGES=$(whiptail --title "$(translate 'Select Disk Images')" --checklist "$(translate 'Select the disk images to import:')" 20 60 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED_IMAGES" ]; then
   
    exit 1
fi



# 4. Import each selected image
for IMAGE in $SELECTED_IMAGES; do


    IMAGE=$(echo "$IMAGE" | tr -d '"')


    INTERFACE=$(whiptail --title "$(translate 'Interface Type')" --menu "$(translate 'Select the interface type for the image:') $IMAGE" 15 40 4 \
    "sata" "SATA" \
    "scsi" "SCSI" \
    "virtio" "VirtIO" \
    "ide" "IDE" 3>&1 1>&2 2>&3)

    if [ -z "$INTERFACE" ]; then
        msg_error "$(translate 'No interface type selected for') $IMAGE"
        continue
    fi

    FULL_PATH="$IMAGES_DIR/$IMAGE"


    msg_info "$(translate 'Importing image:')"


    TEMP_DISK_FILE=$(mktemp)


    qm importdisk "$VMID" "$FULL_PATH" "$STORAGE" 2>&1 | while read -r line; do
        if [[ "$line" =~ transferred ]]; then

            PERCENT=$(echo "$line" | grep -oP "\d+\.\d+(?=%)")
 
            echo -ne "\r${TAB}${BL}-$(translate 'Importing image:') $IMAGE-${CL} ${PERCENT}%"
        elif [[ "$line" =~ successfully\ imported\ disk ]]; then

            echo "$line" | grep -oP "(?<=successfully imported disk ').*(?=')" > "$TEMP_DISK_FILE"
        fi
    done
    echo -ne "\n" 

    IMPORT_STATUS=${PIPESTATUS[0]} 

    if [ $IMPORT_STATUS -eq 0 ]; then
        msg_ok "$(translate 'Image imported successfully')"


        IMPORTED_DISK=$(cat "$TEMP_DISK_FILE")
        rm -f "$TEMP_DISK_FILE" 

   
        if [ -z "$IMPORTED_DISK" ]; then
   
            STORAGE_TYPE=$(pvesm status -storage "$STORAGE" | awk 'NR>1 {print $2}')

            if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
   
                UNUSED_LINE=$(qm config "$VMID" | grep -E '^unused[0-9]+:')
                IMPORTED_ID=$(echo "$UNUSED_LINE" | cut -d: -f1)
                IMPORTED_DISK=$(echo "$UNUSED_LINE" | cut -d: -f2- | xargs)
            else
   
                IMPORTED_DISK=$(qm config "$VMID" | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f2- | xargs)
                IMPORTED_ID=$(qm config "$VMID" | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)
            fi
        fi

        if [ -n "$IMPORTED_DISK" ]; then
       
            EXISTING_DISKS=$(qm config "$VMID" | grep -oP "${INTERFACE}\d+" | sort -n)
            if [ -z "$EXISTING_DISKS" ]; then
                NEXT_SLOT=0
            else
                LAST_SLOT=$(echo "$EXISTING_DISKS" | tail -n1 | sed "s/${INTERFACE}//")
                NEXT_SLOT=$((LAST_SLOT + 1))
            fi

   
            if [ "$INTERFACE" != "virtio" ]; then
                if (whiptail --title "$(translate 'SSD Emulation')" --yesno "$(translate 'Do you want to use SSD emulation for this disk?')" 10 60); then
                    SSD_OPTION=",ssd=1"
                else
                    SSD_OPTION=""
                fi
            else
                SSD_OPTION=""
            fi

            msg_info "$(translate 'Configuring disk')"

 
            if qm set "$VMID" --${INTERFACE}${NEXT_SLOT} "$IMPORTED_DISK${SSD_OPTION}" &>/dev/null; then
                msg_ok "$(translate 'Image') $IMAGE $(translate 'configured as') ${INTERFACE}${NEXT_SLOT}"

   
                if [[ -n "$IMPORTED_ID" ]]; then
                    qm set "$VMID" -delete "$IMPORTED_ID" >/dev/null 2>&1
                fi

  
                if (whiptail --title "$(translate 'Make Bootable')" --yesno "$(translate 'Do you want to make this disk bootable?')" 10 60); then
                    msg_info "$(translate 'Configuring disk as bootable')"

                    if qm set "$VMID" --boot c --bootdisk ${INTERFACE}${NEXT_SLOT} &>/dev/null; then
                        msg_ok "$(translate 'Disk configured as bootable')"
                    else
                        msg_error "$(translate 'Could not configure the disk as bootable')"
                    fi
                fi
            else
                msg_error "$(translate 'Could not configure disk') ${INTERFACE}${NEXT_SLOT} $(translate 'for VM') $VMID"
                echo "DEBUG: Tried to configure: --${INTERFACE}${NEXT_SLOT} \"$IMPORTED_DISK${SSD_OPTION}\""
                echo "DEBUG: VM config after import:"
                qm config "$VMID" | grep -E "(unused|${INTERFACE})"
            fi
        else
            msg_error "$(translate 'Could not find the imported disk')"
            echo "DEBUG: VM config after import:"
            qm config "$VMID"
        fi
    else
        msg_error "$(translate 'Could not import') $IMAGE"
    fi
done



msg_ok "$(translate 'All selected images have been processed')"
msg_success "$(translate "Press Enter to return to menu...")"
read -r



================================================
FILE: scripts/storage/mount-disk-on-host.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - Mount independent disk on Proxmox host
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 08/04/2025
# ==========================================================
# Description:
# This script detects unassigned physical disks and allows
# the user to mount one of them on the host Proxmox system.
# - Detects unmounted and unassigned disks.
# - Filters out ZFS, LVM, RAID and system disks.
# - Allows selecting a disk.
# - Prepares partition and filesystem if needed.
# - Mounts the disk in the host at a defined mount point.
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi

    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)

is_disk_in_use() {
    local disk="$1"

    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac

        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)

    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi

    return 1
}


FREE_DISKS=()

LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)
RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi


    USED_BY=""
    REAL_PATH=$(readlink -f "$DISK")
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi



    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi

    if $IS_ZFS; then
        SHOW_DISK=false
    fi

    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"

        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi

done < <(lsblk -dn -e 7,11 -o PATH)

if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No available disks found on the host.")" 8 50
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"

MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))
TOTAL_WIDTH=$((TOTAL_WIDTH < 50 ? 50 : TOTAL_WIDTH))

SELECTED=$(whiptail --title "$(translate "Select Disk")" --radiolist \
    "$(translate "Select the disk you want to mount on the host:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disk was selected.")" 10 50
    clear
    exit 1
fi



msg_ok "$(translate "Disk selected successfully:") $SELECTED"





################################################################




PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')

SKIP_FORMAT=false
DEFAULT_MOUNT="/mnt/data_shared"

if [ -n "$PARTITION" ]; then
    PARTITION="/dev/$PARTITION"
    CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)

    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
        msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION."
    else
        whiptail --title "$(translate "Unsupported Filesystem")" --yesno "$(translate "The partition") $PARTITION $(translate "has an unsupported filesystem ($CURRENT_FS).\\nDo you want to format it?")" 10 70
        if [ $? -ne 0 ]; then
            exit 0
        fi
    fi
else
    CURRENT_FS=$(lsblk -no FSTYPE "$SELECTED" | xargs)

    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
        PARTITION="$SELECTED"
        msg_ok "$(translate "Detected filesystem") $CURRENT_FS $(translate "directly on disk") $SELECTED."
    else
        whiptail --title "$(translate "No Valid Partitions")" --yesno "$(translate "The disk has no partitions and no valid filesystem. Do you want to create a new partition and format it?")" 10 70
        if [ $? -ne 0 ]; then
            exit 0
        fi

        echo -e "$(translate "Creating partition table and partition...")"
        parted -s "$SELECTED" mklabel gpt
        parted -s "$SELECTED" mkpart primary 0% 100%
        sleep 2
        partprobe "$SELECTED"
        sleep 2

        PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')
        if [ -n "$PARTITION" ]; then
            PARTITION="/dev/$PARTITION"
        else
            whiptail --title "$(translate "Partition Error")" --msgbox "$(translate "Failed to create partition on disk") $SELECTED." 8 70
            exit 1
        fi
    fi
fi

if [ "$SKIP_FORMAT" != true ]; then
    FORMAT_TYPE=$(whiptail --title "$(translate "Select Format Type")" --menu "$(translate "Select the filesystem type for") $PARTITION:" 15 60 5 \
        "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
        "xfs" "XFS" \
        "btrfs" "Btrfs" 3>&1 1>&2 2>&3)

    if [ -z "$FORMAT_TYPE" ]; then
        whiptail --title "$(translate "Format Cancelled")" --msgbox "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
        exit 0
    fi

    whiptail --title "$(translate "WARNING")" --yesno "$(translate "WARNING: This operation will FORMAT the disk") $PARTITION $(translate "with") $FORMAT_TYPE.\\n\\n$(translate "ALL DATA ON THIS DISK WILL BE PERMANENTLY LOST!")\\n\\n$(translate "Are you sure you want to continue")" 15 70
    if [ $? -ne 0 ]; then
        exit 0
    fi

    echo -e "$(translate "Formatting partition") $PARTITION $(translate "with") $FORMAT_TYPE..."
    case "$FORMAT_TYPE" in
        "ext4") mkfs.ext4 -F "$PARTITION" ;;
        "xfs") mkfs.xfs -f "$PARTITION" ;;
        "btrfs") mkfs.btrfs -f "$PARTITION" ;;
    esac

    if [ $? -ne 0 ]; then
        cleanup
        whiptail --title "$(translate "Format Failed")" --msgbox "$(translate "Failed to format partition") $PARTITION $(translate "with") $FORMAT_TYPE." 12 70
        exit 1
    else
        msg_ok "$(translate "Partition") $PARTITION $(translate "successfully formatted with") $FORMAT_TYPE."
        partprobe "$SELECTED"
        sleep 2
    fi
fi




################################################################





MOUNT_POINT=$(whiptail --title "$(translate "Mount Point")" \
    --inputbox "$(translate "Enter the mount point for the disk (e.g., /mnt/data_shared):")" \
    10 60 "$DEFAULT_MOUNT" 3>&1 1>&2 2>&3)

if [ -z "$MOUNT_POINT" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No mount point was specified.")" 8 40
    exit 1
fi

msg_ok "$(translate "Mount point specified:") $MOUNT_POINT"

mkdir -p "$MOUNT_POINT"

UUID=$(blkid -s UUID -o value "$PARTITION")

# Obtener sistema de archivos real
FS_TYPE=$(lsblk -no FSTYPE "$PARTITION" | xargs)

FSTAB_ENTRY="UUID=$UUID $MOUNT_POINT $FS_TYPE defaults 0 0"

if grep -q "UUID=$UUID" /etc/fstab; then
    sed -i "s|^.*UUID=$UUID.*|$FSTAB_ENTRY|" /etc/fstab
    msg_ok "$(translate "fstab entry updated for") $UUID"
else
    echo "$FSTAB_ENTRY" >> /etc/fstab
    msg_ok "$(translate "fstab entry added for") $UUID"
fi


##################################################################

mount "$MOUNT_POINT" 2> >(grep -v "systemd still uses")

##################################################################


if [ $? -eq 0 ]; then
    if ! getent group sharedfiles >/dev/null; then
        groupadd sharedfiles
        msg_ok "$(translate "Group 'sharedfiles' created")"
    else
        msg_ok "$(translate "Group 'sharedfiles' already exists")"
    fi

    chown root:sharedfiles "$MOUNT_POINT"
    chmod 2775 "$MOUNT_POINT"

    whiptail --title "$(translate "Success")" --msgbox "$(translate "The disk has been successfully mounted at") $MOUNT_POINT" 8 60
    msg_ok "$(translate "Disk mounted at") $MOUNT_POINT"
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
else
    whiptail --title "$(translate "Mount Error")" --msgbox "$(translate "Failed to mount the disk at") $MOUNT_POINT" 8 60
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
    exit 1
fi



================================================
FILE: scripts/storage/mount-point-to-ct.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - Mount point from host into LXC container (CT)
# ==========================================================
# Author      : MacRimi
# License     : MIT
# Description : Mount a folder from /mnt on the host to a mount point in a CT
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache

#######################################################

CT_LIST=($(pct list | awk 'NR>1 {print $1":"$3}'))

if [[ ${#CT_LIST[@]} -eq 0 ]]; then
    whiptail --title "$(translate "No CTs")" --msgbox "$(translate "No containers found.")" 8 40
    exit 0
fi

CT_OPTIONS=()
for entry in "${CT_LIST[@]}"; do
    ID="${entry%%:*}"
    NAME="${entry##*:}"
    CT_OPTIONS+=("$ID" "$NAME")
done

CTID=$(whiptail --title "$(translate "Select CT")" --menu "$(translate "Select the container:")" 20 60 10 "${CT_OPTIONS[@]}" 3>&1 1>&2 2>&3)
[[ -z "$CTID" ]] && exit 0

CT_STATUS=$(pct status "$CTID" | awk '{print $2}')
if [ "$CT_STATUS" != "running" ]; then
    msg_info "$(translate "Starting CT") $CTID..."
    pct start "$CTID"
    sleep 2
    if [ "$(pct status "$CTID" | awk '{print $2}')" != "running" ]; then
        msg_error "$(translate "Failed to start the CT.")"
        exit 1
    fi
    msg_ok "$(translate "CT started successfully.")"
fi

#######################################################

select_origin_path() {
    METHOD=$(whiptail --title "$(translate "Select Host Folder")" --menu "$(translate "How do you want to select the host folder to mount?")" 15 60 5 \
    "auto" "$(translate "Select from /mnt")" \
    "manual" "$(translate "Enter path manually")" 3>&1 1>&2 2>&3)

    case "$METHOD" in
        auto)
            HOST_DIRS=(/mnt/*)
            OPTIONS=()
            for dir in "${HOST_DIRS[@]}"; do
                [[ -d "$dir" ]] && OPTIONS+=("$dir" "")
            done

            ORIGIN=$(whiptail --title "$(translate "Select Host Folder")" --menu "$(translate "Select the folder to mount:")" 20 60 10 "${OPTIONS[@]}" 3>&1 1>&2 2>&3)
            [[ -z "$ORIGIN" ]] && return 1
            ;;

        manual)
            ORIGIN=$(whiptail --title "$(translate "Enter Path")" --inputbox "$(translate "Enter the full path to the host folder:")" 10 60 "/mnt/" 3>&1 1>&2 2>&3)
            [[ -z "$ORIGIN" ]] && return 1
            ;;
    esac

    if [[ ! -d "$ORIGIN" ]]; then
        whiptail --title "$(translate "Error")" --msgbox "$(translate "The selected path is not a valid directory:")\n$ORIGIN" 8 60
        return 1
    fi

    # Preparar permisos en el host para uso compartido
    SHARE_GID=999
    if ! getent group sharedfiles >/dev/null; then
        groupadd -g "$SHARE_GID" sharedfiles
        msg_ok "$(translate "Group 'sharedfiles' created in the host with GID $SHARE_GID")"
    else
        msg_ok "$(translate "Group 'sharedfiles' already exists in the host")"
    fi

    chown root:sharedfiles "$ORIGIN"
    chmod 2775 "$ORIGIN"
    setfacl -d -m g:sharedfiles:rwx "$ORIGIN"
    setfacl -m g:sharedfiles:rwx "$ORIGIN"

    msg_ok "$(translate "Host folder prepared with shared group and permissions.")"

    return 0
}

select_origin_path || exit 0

#######################################################

CT_NAME=$(pct config "$CTID" | awk -F: '/hostname/ {print $2}' | xargs)
DEFAULT_MOUNT_POINT="/mnt/host_share"

MOUNT_POINT=$(whiptail --title "$(translate "Mount Point to CT")" \
--inputbox "$(translate "Enter the mount point inside the CT (e.g., /mnt/host_share):")" \
10 70 "$DEFAULT_MOUNT_POINT" 3>&1 1>&2 2>&3)

if [[ -z "$MOUNT_POINT" ]]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No mount point specified.")" 8 60
    exit 1
fi

if ! pct exec "$CTID" -- test -d "$MOUNT_POINT"; then
    if whiptail --yesno "$(translate "Directory does not exist in the CT.")\n\n$MOUNT_POINT\n\n$(translate "Do you want to create it?")" 12 70 --title "$(translate "Create Directory")"; then
        pct exec "$CTID" -- mkdir -p "$MOUNT_POINT"
        msg_ok "$(translate "Directory created inside CT:") $MOUNT_POINT"
    else
        msg_error "$(translate "Directory not created. Operation cancelled.")"
        exit 1
    fi
fi

INDEX=0
while pct config "$CTID" | grep -q "mp${INDEX}:"; do
    ((INDEX++))
    [[ $INDEX -ge 100 ]] && msg_error "Too many mount points." && exit 1
done

msg_info "$(translate "Mounting folder from host to CT...")"
RESULT=$(pct set "$CTID" -mp${INDEX} "$ORIGIN,mp=$MOUNT_POINT,backup=0,ro=0,acl=1" 2>&1)

if [[ $? -eq 0 ]]; then
    msg_ok "$(translate "Successfully mounted:")\n$ORIGIN â†’ $CT_NAME:$MOUNT_POINT"
else
    msg_error "$(translate "Error mounting folder:")\n$RESULT"
    exit 1
fi

msg_success "$(translate "Press Enter to return to menu...")"
read -r

exit 0



================================================
FILE: scripts/storage/mount_disk_host_bk.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - Mount independent disk on Proxmox host
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 1.3-dialog
# Last Updated: 13/12/2024
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache


mount_disk_host_bk() {



get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}


is_usb_disk() {
    local disk=$1
    local disk_name=$(basename "$disk")
    

    if readlink -f "/sys/block/$disk_name/device" 2>/dev/null | grep -q "usb"; then
        return 0 
    fi
    

    if udevadm info --query=property --name="$disk" 2>/dev/null | grep -q "ID_BUS=usb"; then
        return 0  
    fi
    
    return 1
}


is_system_disk() {
    local disk=$1
    local disk_name=$(basename "$disk")
    

    local system_mounts=$(df -h | grep -E '^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(/|/boot|/usr|/var|/home)$' | awk '{print $1}')
    

    for mount_dev in $system_mounts; do
   
        local mount_disk=""
        if [[ "$mount_dev" =~ ^/dev/mapper/ ]]; then
     
            local vg_name=$(lvs --noheadings -o vg_name "$mount_dev" 2>/dev/null | xargs)
            if [[ -n "$vg_name" ]]; then
                local pvs_list=$(pvs --noheadings -o pv_name -S vg_name="$vg_name" 2>/dev/null | xargs)
                for pv in $pvs_list; do
                    if [[ -n "$pv" && -e "$pv" ]]; then
                        mount_disk=$(lsblk -no PKNAME "$pv" 2>/dev/null)
                        if [[ -n "$mount_disk" && "/dev/$mount_disk" == "$disk" ]]; then
                            return 0  
                        fi
                    fi
                done
            fi
        elif [[ "$mount_dev" =~ ^/dev/[hsv]d[a-z][0-9]* || "$mount_dev" =~ ^/dev/nvme[0-9]+n[0-9]+p[0-9]+ ]]; then
      
            mount_disk=$(lsblk -no PKNAME "$mount_dev" 2>/dev/null)
            if [[ -n "$mount_disk" && "/dev/$mount_disk" == "$disk" ]]; then
                return 0  
            fi
        fi
    done
    

    local fs_type=$(lsblk -no FSTYPE "$disk" 2>/dev/null | head -1)
    if [[ "$fs_type" == "btrfs" ]]; then

        local temp_mount=$(mktemp -d)
        if mount -o ro "$disk" "$temp_mount" 2>/dev/null; then
   
            if btrfs subvolume list "$temp_mount" 2>/dev/null | grep -qE '(@|@home|@var|@boot|@root|root)'; then
                umount "$temp_mount" 2>/dev/null
                rmdir "$temp_mount" 2>/dev/null
                return 0  
            fi
            umount "$temp_mount" 2>/dev/null
        fi
        rmdir "$temp_mount" 2>/dev/null
        

        while read -r part; do
            if [[ -n "$part" ]]; then
                local part_fs=$(lsblk -no FSTYPE "/dev/$part" 2>/dev/null)
                if [[ "$part_fs" == "btrfs" ]]; then
                    local mount_point=$(lsblk -no MOUNTPOINT "/dev/$part" 2>/dev/null)
                    if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
                        return 0  
                    fi
                fi
            fi
        done < <(lsblk -ln -o NAME "$disk" | tail -n +2)
    fi
    

    local disk_uuid=$(blkid -s UUID -o value "$disk" 2>/dev/null)
    local part_uuids=()
    while read -r part; do
        if [[ -n "$part" ]]; then
            local uuid=$(blkid -s UUID -o value "/dev/$part" 2>/dev/null)
            if [[ -n "$uuid" ]]; then
                part_uuids+=("$uuid")
            fi
        fi
    done < <(lsblk -ln -o NAME "$disk" | tail -n +2)
    
 
    for uuid in "${part_uuids[@]}" "$disk_uuid"; do
        if [[ -n "$uuid" ]] && grep -q "UUID=$uuid" /etc/fstab; then
            local mount_point=$(grep "UUID=$uuid" /etc/fstab | awk '{print $2}')
            if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
                return 0  
            fi
        fi
    done
    

    if grep -q "$disk" /etc/fstab; then
        local mount_point=$(grep "$disk" /etc/fstab | awk '{print $2}')
        if [[ "$mount_point" == "/" || "$mount_point" == "/boot" || "$mount_point" == "/home" || "$mount_point" == "/var" ]]; then
            return 0 
        fi
    fi
    

    local disk_count=$(lsblk -dn -e 7,11 -o PATH | wc -l)
    if [[ "$disk_count" -eq 1 ]]; then
        return 0 
    fi
    
    return 1 
}

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do
    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi

    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)

LVM_DEVICES=$(
    pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') |
    while read -r dev; do
        [[ -n "$dev" && -e "$dev" ]] && readlink -f "$dev"
    done | sort -u
)

FREE_DISKS=()

while read -r DISK; do
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false
    IS_SYSTEM=false
    IS_USB=false

 
    if is_system_disk "$DISK"; then
        IS_SYSTEM=true
    fi

  
    if is_usb_disk "$DISK"; then
        IS_USB=true
    fi

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=""
    if [[ -n "$DISK" && -e "$DISK" ]]; then
        REAL_PATH=$(readlink -f "$DISK")
    fi
    if [[ -n "$REAL_PATH" ]] && echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi

    USED_BY=""
    REAL_PATH=""
    if [[ -n "$DISK" && -e "$DISK" ]]; then
        REAL_PATH=$(readlink -f "$DISK")
    fi
    CONFIG_DATA=$(grep -vE '^\s*#' /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

    if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
        USED_BY="âš  $(translate "In use")"
    else
        for SYMLINK in /dev/disk/by-id/*; do
            [[ -e "$SYMLINK" ]] || continue
            if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                    USED_BY="âš  $(translate "In use")"
                    break
                fi
            fi
        done
    fi

    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi
    if $IS_ZFS; then SHOW_DISK=false; fi
    if $IS_MOUNTED; then SHOW_DISK=false; fi
    if $IS_SYSTEM; then SHOW_DISK=false; fi  

    if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
        
        
        if $IS_USB; then
            LABEL+="  USB"
        else
            LABEL+="  $(translate "Internal")"
        fi
        
        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "off")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)

if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    dialog --title "$(translate "Error")" --msgbox "$(translate "No available disks found on the host.")" 8 60
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"

# Building the array for dialog (format: tag item on/off tag item on/off...)
DLG_LIST=()
for ((i=0; i<${#FREE_DISKS[@]}; i+=3)); do
    DLG_LIST+=("${FREE_DISKS[i]}" "${FREE_DISKS[i+1]}" "${FREE_DISKS[i+2]}")
done

SELECTED=$(dialog --clear --backtitle "ProxMenux" --title "$(translate "Select Disk")" \
    --radiolist "\n$(translate "Select the disk you want to mount on the host:")" 20 90 10 \
    "${DLG_LIST[@]}" 2>&1 >/dev/tty)

if [ -z "$SELECTED" ]; then
    dialog --title "$(translate "Error")" --msgbox "$(translate "No disk was selected.")" 8 50
    clear
    exit 1
fi

msg_ok "$(translate "Disk selected successfully:") $SELECTED"

# ------------------- Partitions and formatting ------------------------

PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')
SKIP_FORMAT=false
DEFAULT_MOUNT="/mnt/backup"

if [ -n "$PARTITION" ]; then
    PARTITION="/dev/$PARTITION"
    CURRENT_FS=$(lsblk -no FSTYPE "$PARTITION" | xargs)
    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
        msg_ok "$(translate "Detected existing filesystem") $CURRENT_FS $(translate "on") $PARTITION."
    else
        dialog --title "$(translate "Unsupported Filesystem")" --yesno \
        "$(translate "The partition") $PARTITION $(translate "has an unsupported filesystem ($CURRENT_FS).\nDo you want to format it?")" 10 70
        if [ $? -ne 0 ]; then exit 0; fi
    fi
else
    CURRENT_FS=$(lsblk -no FSTYPE "$SELECTED" | xargs)
    if [[ "$CURRENT_FS" == "ext4" || "$CURRENT_FS" == "xfs" || "$CURRENT_FS" == "btrfs" ]]; then
        SKIP_FORMAT=true
        PARTITION="$SELECTED"
        msg_ok "$(translate "Detected filesystem") $CURRENT_FS $(translate "directly on disk") $SELECTED."
    else
        dialog --title "$(translate "No Valid Partitions")" --yesno \
        "$(translate "The disk has no partitions and no valid filesystem. Do you want to create a new partition and format it?")" 10 70
        if [ $? -ne 0 ]; then exit 0; fi

        echo -e "$(translate "Creating partition table and partition...")"
        parted -s "$SELECTED" mklabel gpt
        parted -s "$SELECTED" mkpart primary 0% 100%
        sleep 2
        partprobe "$SELECTED"
        sleep 2

        PARTITION=$(lsblk -rno NAME "$SELECTED" | awk -v disk="$(basename "$SELECTED")" '$1 != disk {print $1; exit}')
        if [ -n "$PARTITION" ]; then
            PARTITION="/dev/$PARTITION"
        else
            dialog --title "$(translate "Partition Error")" --msgbox \
            "$(translate "Failed to create partition on disk") $SELECTED." 8 70
            exit 1
        fi
    fi
fi

if [ "$SKIP_FORMAT" != true ]; then
    FORMAT_TYPE=$(dialog --title "$(translate "Select Format Type")" --menu \
        "$(translate "Select the filesystem type for") $PARTITION:" 15 60 5 \
        "ext4" "$(translate "Extended Filesystem 4 (recommended)")" \
        "xfs" "XFS" \
        "btrfs" "Btrfs" 2>&1 >/dev/tty)
    if [ -z "$FORMAT_TYPE" ]; then
        dialog --title "$(translate "Format Cancelled")" --msgbox \
        "$(translate "Format operation cancelled. The disk will not be added.")" 8 60
        exit 0
    fi

    dialog --title "$(translate "WARNING")" --yesno \
    "$(translate "WARNING: This operation will FORMAT the disk") $PARTITION $(translate "with") $FORMAT_TYPE.\n\n$(translate "ALL DATA ON THIS DISK WILL BE PERMANENTLY LOST!")\n\n$(translate "Are you sure you want to continue")" 15 70
    if [ $? -ne 0 ]; then exit 0; fi

    echo -e "$(translate "Formatting partition") $PARTITION $(translate "with") $FORMAT_TYPE..."
    case "$FORMAT_TYPE" in
        "ext4") mkfs.ext4 -F "$PARTITION" ;;
        "xfs") mkfs.xfs -f "$PARTITION" ;;
        "btrfs") mkfs.btrfs -f "$PARTITION" ;;
    esac

    if [ $? -ne 0 ]; then
        cleanup
        dialog --title "$(translate "Format Failed")" --msgbox \
        "$(translate "Failed to format partition") $PARTITION $(translate "with") $FORMAT_TYPE." 12 70
        exit 1
    else
        msg_ok "$(translate "Partition") $PARTITION $(translate "successfully formatted with") $FORMAT_TYPE."
        partprobe "$SELECTED"
        sleep 2
    fi
fi

# ------------------- Mount point and permissions -------------------

MOUNT_POINT=$(dialog --title "$(translate "Mount Point")" \
    --inputbox "$(translate "Enter the mount point for the disk (e.g., /mnt/backup):")" \
    10 60 "$DEFAULT_MOUNT" 2>&1 >/dev/tty)
if [ -z "$MOUNT_POINT" ]; then
    dialog --title "$(translate "Error")" --msgbox "$(translate "No mount point was specified.")" 8 40
    exit 1
fi

msg_ok "$(translate "Mount point specified:") $MOUNT_POINT"

mkdir -p "$MOUNT_POINT"

UUID=$(blkid -s UUID -o value "$PARTITION")
FS_TYPE=$(lsblk -no FSTYPE "$PARTITION" | xargs)
FSTAB_ENTRY="UUID=$UUID $MOUNT_POINT $FS_TYPE defaults 0 0"

if grep -q "UUID=$UUID" /etc/fstab; then
    sed -i "s|^.*UUID=$UUID.*|$FSTAB_ENTRY|" /etc/fstab
    msg_ok "$(translate "fstab entry updated for") $UUID"
else
    echo "$FSTAB_ENTRY" >> /etc/fstab
    msg_ok "$(translate "fstab entry added for") $UUID"
fi

mount "$MOUNT_POINT" 2> >(grep -v "systemd still uses")

if [ $? -eq 0 ]; then
    if ! getent group sharedfiles >/dev/null; then
        groupadd sharedfiles
        msg_ok "$(translate "Group 'sharedfiles' created")"
    else
        msg_ok "$(translate "Group 'sharedfiles' already exists")"
    fi

    chown root:sharedfiles "$MOUNT_POINT"
    chmod 2775 "$MOUNT_POINT"

    dialog --title "$(translate "Success")" --msgbox "$(translate "The disk has been successfully mounted at") $MOUNT_POINT" 8 60
    echo "$MOUNT_POINT" > /usr/local/share/proxmenux/last_backup_mount.txt
    msg_ok "$(translate "Disk mounted at") $MOUNT_POINT"
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
else
    dialog --title "$(translate "Mount Error")" --msgbox "$(translate "Failed to mount the disk at") $MOUNT_POINT" 8 60
    msg_success "$(translate "Press Enter to return to menu...")"
    read -r
    exit 1
fi


}




================================================
FILE: scripts/storage/notes.txt
================================================
[Binary file]


================================================
FILE: scripts/storage/unmount-disk-from-host.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# Description : Allows unmounting a previously mounted disk
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache


MOUNTED_DISKS=($(mount | grep '^/dev/' | grep 'on /mnt/' | awk '{print $3}'))

if [[ ${#MOUNTED_DISKS[@]} -eq 0 ]]; then
    whiptail --title "$(translate "No Disks")" --msgbox "$(translate "No mounted disks found under /mnt.")" 8 50
    exit 0
fi


MENU_ITEMS=()
for MNT in "${MOUNTED_DISKS[@]}"; do
    UUID=$(blkid | grep "$MNT" | awk '{print $2}' | tr -d '"')
    DESC="$MNT $UUID"
    MENU_ITEMS+=("$MNT" "$DESC")
done

SELECTED=$(whiptail --title "$(translate "Unmount Disk")" --menu "$(translate "Select the disk you want to unmount:")" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3)

[[ -z "$SELECTED" ]] && exit 0


whiptail --title "$(translate "Confirm Unmount")" --yesno "$(translate "Are you sure you want to unmount") $SELECTED?" 10 60 || exit 0


umount "$SELECTED" 2>/dev/null
if [ $? -ne 0 ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "Failed to unmount disk at") $SELECTED" 8 60
    exit 1
else
    msg_ok "$(translate "Unmounted:") $SELECTED"
fi


whiptail --title "$(translate "Delete Mount Folder")" --yesno "$(translate "Do you want to delete the mount point folder") $SELECTED?" 10 60
if [ $? -eq 0 ]; then
    rm -rf "$SELECTED"
    msg_ok "$(translate "Deleted folder:") $SELECTED"
fi


DEVICE=$(findmnt -no SOURCE "$SELECTED")
UUID=$(blkid -s UUID -o value "$DEVICE")

if [ -n "$UUID" ]; then
    sed -i "/UUID=$UUID/d" /etc/fstab
    msg_ok "$(translate "fstab entry removed for") $UUID"
fi

whiptail --title "$(translate "Done")" --msgbox "$(translate "Disk unmounted and cleaned successfully.")" 8 60




================================================
FILE: scripts/test/debug_disks.sh
================================================
#!/bin/bash

VMID="105"

echo -e "\n=== ğŸ“¦ Discos fÃ­sicos detectados (lsblk) ==="
lsblk -dn -o PATH,TYPE | awk '$2 == "disk" {print $1}'

echo -e "\n=== ğŸ“Œ Discos montados ==="
mount | grep /dev/sd || echo "Ninguno"

echo -e "\n=== ğŸ§± Discos en uso por LVM (pvs) ==="
pvs --noheadings -o pv_name | xargs -n1 readlink -f | sort -u || echo "Ninguno"

echo -e "\n=== âš  RAID activos (mdstat) ==="
awk '/^md/ {for (i=4; i<=NF; i++) print $i}' /proc/mdstat || echo "Ninguno"

echo -e "\n=== ğŸ’» Discos ya asignados a la VM ID $VMID ==="
qm config "$VMID" | grep -E '^(scsi|sata|virtio|ide)[0-9]+:' | awk -F ':' '{print $2}' | cut -d',' -f1

echo -e "\n=== ğŸ§ª FSTYPE de cada disco ==="
for disk in $(lsblk -dn -o PATH,TYPE | awk '$2 == "disk" {print $1}'); do
    echo -e "\nâ†’ $disk"
    lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2
done



echo "ğŸ“‹ Analizando discos fÃ­sicos..."
ACTIVE_MD_DEVICES=$(awk '/^md/ {for (i=4; i<=NF; i++) print $i}' /proc/mdstat)
LVM_DEVICES=$(pvs --noheadings -o pv_name | xargs -n1 readlink -f | sed 's/ *$//' | sort -u)
MOUNTED_DISKS=$(mount | grep /dev/sd | awk '{print $1}' | sort -u)

for DISK in $(lsblk -dn -o PATH,TYPE | awk '$2 == "disk" {print $1}'); do
    echo -e "\nğŸ” Disco: $DISK"
    echo " - En LVM: $(echo "$LVM_DEVICES" | grep -Fxq "$DISK" && echo 'SÃ' || echo 'NO')"
    echo " - Es ZVOL (zd*): $( [[ $(basename "$DISK") == zd* ]] && echo 'SÃ' || echo 'NO')"
    echo " - Ya estÃ¡ en la VM: $(qm config "$VMID" | grep -q "$DISK" && echo 'SÃ' || echo 'NO')"

    IS_MOUNTED=false
    IS_RAID=false
    IS_RAID_ACTIVE=false
    IS_ZFS=false

    while read -r part fstype; do
        full_path="/dev/$part"
        real_path=$(readlink -f "$full_path")

        [[ -z "$fstype" ]] && continue

        echo "   â¤ ParticiÃ³n: $part ($fstype)"
        if echo "$MOUNTED_DISKS" | grep -q "$full_path"; then
            echo "     â›” Montado en el sistema"
            IS_MOUNTED=true
        fi

        if echo "$LVM_DEVICES" | grep -Fxq "$real_path"; then
            echo "     â›” En uso por LVM"
            IS_MOUNTED=true
        fi

        if [[ "$fstype" == "linux_raid_member" ]]; then
            IS_RAID=true
            if echo "$ACTIVE_MD_DEVICES" | grep -q "$part"; then
                IS_RAID_ACTIVE=true
                echo "     â›” RAID activo"
            else
                echo "     âš  RAID pasivo"
            fi
        fi

        if [[ "$fstype" == "zfs_member" ]]; then
            IS_ZFS=true
            echo "     â›” ZFS detectado"
        fi

    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    echo "Resumen:"
    echo " - Montado: $IS_MOUNTED"
    echo " - RAID activo: $IS_RAID_ACTIVE"
    echo " - RAID pasivo: $IS_RAID"
    echo " - ZFS: $IS_ZFS"
done




================================================
FILE: scripts/test/debug_disks1.sh
================================================
#!/bin/bash

VMID="105"

echo -e "\n=== ğŸ“¦ Discos fÃ­sicos detectados (lsblk) ==="
lsblk -dn -o PATH,TYPE | awk '$2 == "disk" {print $1}'

echo -e "\n=== ğŸ“Œ Discos montados ==="
mount | grep /dev/sd || echo "Ninguno"

echo -e "\n=== ğŸ§± Discos en uso por LVM (pvs) ==="
pvs --noheadings -o pv_name | xargs -n1 readlink -f | sort -u || echo "Ninguno"

echo -e "\n=== âš  RAID activos (mdstat) ==="
awk '/^md/ {for (i=4; i<=NF; i++) print $i}' /proc/mdstat || echo "Ninguno"

echo -e "\n=== ğŸ’» Discos ya asignados a la VM ID $VMID ==="
qm config "$VMID" | grep -E '^(scsi|sata|virtio|ide)[0-9]+:' | awk -F ':' '{print $2}' | cut -d',' -f1

echo -e "\n=== ğŸ§ª FSTYPE de cada disco ==="
for disk in $(lsblk -dn -o PATH,TYPE | awk '$2 == "disk" {print $1}'); do
    echo -e "\nâ†’ $disk"
    lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2
done



================================================
FILE: scripts/test/helpers-menu.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 04/06/2025
# ==========================================================
# Description:
# This script provides a simple and efficient way to access and execute Proxmox VE scripts
# from the Community Scripts project (https://community-scripts.github.io/ProxmoxVE/).
#
# It serves as a convenient tool to run key automation scripts that simplify system management,
# continuing the great work and legacy of tteck in making Proxmox VE more accessible.
# A streamlined solution for executing must-have tools in Proxmox VE.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache
# ==========================================================

HELPERS_JSON_URL="https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/json/helpers_cache.json"
METADATA_URL="https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/frontend/public/json/metadata.json"

for cmd in curl jq dialog; do
  if ! command -v "$cmd" >/dev/null; then
    echo "Missing required command: $cmd"
    exit 1
  fi
done

CACHE_JSON=$(curl -s "$HELPERS_JSON_URL")
META_JSON=$(curl -s "$METADATA_URL")

declare -A CATEGORY_NAMES
while read -r id name; do
  CATEGORY_NAMES[$id]="$name"
done < <(echo "$META_JSON" | jq -r '.categories[] | "\(.id)\t\(.name)"')

declare -A CATEGORY_COUNT
for id in $(echo "$CACHE_JSON" | jq -r '.[].categories[]'); do
  ((CATEGORY_COUNT[$id]++))
done

get_type_label() {
  local type="$1"
  case "$type" in
    ct) echo $'\Z1LXC\Zn' ;;
    vm) echo $'\Z4VM\Zn' ;;
    pve) echo $'\Z3PVE\Zn' ;;
    addon) echo $'\Z2ADDON\Zn' ;;
    *) echo $'\Z7GEN\Zn' ;;
  esac
}

download_script() {
  local url="$1"
  local fallback_pve="${url/misc\/tools\/pve}"
  local fallback_addon="${url/misc\/tools\/addon}"
  local fallback_copydata="${url/misc\/tools\/copy-data}"

  if curl --silent --head --fail "$url" >/dev/null; then
      bash <(curl -s "$url")
  elif curl --silent --head --fail "$fallback_pve" >/dev/null; then
      bash <(curl -s "$fallback_pve")
  elif curl --silent --head --fail "$fallback_addon" >/dev/null; then
      bash <(curl -s "$fallback_addon")
  elif curl --silent --head --fail "$fallback_copydata" >/dev/null; then
      bash <(curl -s "$fallback_copydata")
  else
      dialog --title "Helper Scripts" --msgbox "Error: Failed to download the script." 12 70
  fi
}

RETURN_TO_MAIN=false

format_credentials() {
  local script_info="$1"
  local credentials_info=""
  
  local has_credentials
  has_credentials=$(echo "$script_info" | base64 --decode | jq -r 'has("default_credentials")')
  
  if [[ "$has_credentials" == "true" ]]; then
    local username password
    username=$(echo "$script_info" | base64 --decode | jq -r '.default_credentials.username // empty')
    password=$(echo "$script_info" | base64 --decode | jq -r '.default_credentials.password // empty')
    
    if [[ -n "$username" && -n "$password" ]]; then
      credentials_info="Username: $username | Password: $password"
    elif [[ -n "$username" ]]; then
      credentials_info="Username: $username"
    elif [[ -n "$password" ]]; then
      credentials_info="Password: $password"
    fi
  fi
  
  echo "$credentials_info"
}


run_script_by_slug() {
  local slug="$1"
  local script_info
  script_info=$(echo "$CACHE_JSON" | jq -r --arg slug "$slug" '.[] | select(.slug == $slug) | @base64')

  decode() {
    echo "$1" | base64 --decode | jq -r "$2"
  }

  local name desc script_url notes
  name=$(decode "$script_info" ".name")
  desc=$(decode "$script_info" ".desc")
  script_url=$(decode "$script_info" ".script_url")
  notes=$(decode "$script_info" ".notes | join(\"\n\")")


  local notes_dialog=""
  if [[ -n "$notes" ]]; then
    while IFS= read -r line; do
      notes_dialog+="â€¢ $line\n"
    done <<< "$notes"
    notes_dialog="${notes_dialog%\\n}" 
  fi


  local credentials
  credentials=$(format_credentials "$script_info")


  local msg="\Zb\Z4DescripciÃ³n:\Zn\n$desc"
  [[ -n "$notes_dialog" ]] && msg+="\n\n\Zb\Z4Notes:\Zn\n$notes_dialog"
  [[ -n "$credentials" ]] && msg+="\n\n\Zb\Z4Default Credentials:\Zn\n$credentials"

  dialog --clear --colors --backtitle "ProxMenux" --title "$name" --yesno "$msg\n\nExecute this script?" 22 85
  if [[ $? -eq 0 ]]; then
    download_script "$script_url"
    echo
    echo

    if [[ -n "$desc" || -n "$notes" || -n "$credentials" ]]; then
      echo -e "$TAB\e[1;36mScript Information:\e[0m"



      if [[ -n "$notes" ]]; then
        echo -e "$TAB\e[1;33mNotes:\e[0m"
        while IFS= read -r line; do
          [[ -z "$line" ]] && continue
          echo -e "$TABâ€¢ $line"
        done <<< "$notes"
        echo
      fi

 
      if [[ -n "$credentials" ]]; then
        echo -e "$TAB\e[1;32mDefault Credentials:\e[0m"
        echo "$TAB$credentials"
        echo
      fi
    fi

    msg_success "Press Enter to return to the main menu..."
    read -r
    RETURN_TO_MAIN=true
  fi
}


search_and_filter_scripts() {
  local search_term=""
  
  while true; do
    search_term=$(dialog --inputbox "Enter search term (leave empty to show all scripts):" \
              8 65 "$search_term" 3>&1 1>&2 2>&3)
    
    [[ $? -ne 0 ]] && return
    
    local filtered_json
    if [[ -z "$search_term" ]]; then
      filtered_json="$CACHE_JSON"
    else
      local search_lower
      search_lower=$(echo "$search_term" | tr '[:upper:]' '[:lower:]')
      filtered_json=$(echo "$CACHE_JSON" | jq --arg term "$search_lower" '
        [.[] | select(
          (.name | ascii_downcase | contains($term)) or
          (.desc | ascii_downcase | contains($term))
        )]')
    fi
    
    local count
    count=$(echo "$filtered_json" | jq length)
    
    if [[ $count -eq 0 ]]; then
      dialog --msgbox "No scripts found for: '$search_term'\n\nTry a different search term." 8 50
      continue
    fi

    while true; do
      declare -A index_to_slug
      local menu_items=()
      local i=1
      
      while IFS=$'\t' read -r slug name type; do
        index_to_slug[$i]="$slug"
        local label
        label=$(get_type_label "$type")
        local padded_name
        padded_name=$(printf "%-42s" "$name")
        local entry="$padded_name $label"
        menu_items+=("$i" "$entry")
        ((i++))
      done < <(echo "$filtered_json" | jq -r '
        sort_by(.name)[] | [.slug, .name, .type] | @tsv')
      
      menu_items+=("" "")
      menu_items+=("new_search" "New Search")
      menu_items+=("show_all" "Show All Scripts")
      
      local title="Search Results"
      if [[ -n "$search_term" ]]; then
        title="Search Results for: '$search_term' ($count found)"
      else
        title="All Available Scripts ($count total)"
      fi
      
      local selected
      selected=$(dialog --colors --backtitle "ProxMenux" \
                 --title "$title" \
                 --menu "Select a script or action:" \
                 22 75 15 "${menu_items[@]}" 3>&1 1>&2 2>&3)
      
      if [[ $? -ne 0 ]]; then
        return
      fi
      
      case "$selected" in
        "new_search")
          break  
          ;;
        "show_all")
          search_term=""
          filtered_json="$CACHE_JSON"
          count=$(echo "$filtered_json" | jq length)
          continue
          ;;
        "back"|"")
          return  
          ;;
        *)
          if [[ -n "${index_to_slug[$selected]}" ]]; then
            run_script_by_slug "${index_to_slug[$selected]}"
            [[ "$RETURN_TO_MAIN" == true ]] && { RETURN_TO_MAIN=false; return; }
          fi
          ;;
      esac
    done
  done
}

while true; do
  MENU_ITEMS=()
  
  MENU_ITEMS+=("search" "Search/Filter Scripts")
  MENU_ITEMS+=("" "")
  
  for id in $(printf "%s\n" "${!CATEGORY_COUNT[@]}" | sort -n); do
    name="${CATEGORY_NAMES[$id]:-Category $id}"
    count="${CATEGORY_COUNT[$id]}"
    padded_name=$(printf "%-35s" "$name")
    padded_count=$(printf "(%2d)" "$count")
    MENU_ITEMS+=("$id" "$padded_name $padded_count")
  done

  SELECTED=$(dialog --backtitle "ProxMenux" --title "Proxmox VE Helper-Scripts" --menu \
    "Select a category or search for scripts:" 20 70 14 \
    "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || {
     dialog --title "Proxmox VE Helper-Scripts" \
         --msgbox "\n\n$(translate "Visit the website to discover more scripts, stay updated with the latest updates, and support the project:")\n\nhttps://community-scripts.github.io/ProxmoxVE" 15 70
      clear
      break
  }
 
  if [[ "$SELECTED" == "search" ]]; then
    search_and_filter_scripts
    continue
  fi

  while true; do
    declare -A INDEX_TO_SLUG
    SCRIPTS=()
    i=1
    while IFS=$'\t' read -r slug name type; do
      INDEX_TO_SLUG[$i]="$slug"
      label=$(get_type_label "$type")
      padded_name=$(printf "%-42s" "$name")
      entry="$padded_name $label"
      SCRIPTS+=("$i" "$entry") 
      ((i++))
    done < <(echo "$CACHE_JSON" | jq -r --argjson id "$SELECTED" \
      '[.[] | select(.categories | index($id)) | {slug, name, type}] | sort_by(.name)[] | [.slug, .name, .type] | @tsv')

    SCRIPT_INDEX=$(dialog --colors --backtitle "ProxMenux" --title "Scripts in ${CATEGORY_NAMES[$SELECTED]}" --menu \
      "Choose a script to execute:" 20 70 14 \
      "${SCRIPTS[@]}" 3>&1 1>&2 2>&3) || break

    SCRIPT_SELECTED="${INDEX_TO_SLUG[$SCRIPT_INDEX]}"
    run_script_by_slug "$SCRIPT_SELECTED"
    
    [[ "$RETURN_TO_MAIN" == true ]] && { RETURN_TO_MAIN=false; break; }
  done
done


================================================
FILE: scripts/test/id.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 28/01/2025
# ==========================================================
# Description:
# This script allows users to assign physical disks to existing
# Proxmox virtual machines (VMs) through an interactive menu.
# - Detects the system disk and excludes it from selection.
# - Lists all available VMs for the user to choose from.
# - Identifies and displays unassigned physical disks.
# - Allows the user to select multiple disks and attach them to a VM.
# - Supports interface types: SATA, SCSI, VirtIO, and IDE.
# - Ensures that disks are not already assigned to active VMs.
# - Warns about disk sharing between multiple VMs to avoid data corruption.
# - Configures the selected disks for the VM and verifies the assignment.
#
# The goal of this script is to simplify the process of assigning
# physical disks to Proxmox VMs, reducing manual configurations
# and preventing potential errors.
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================




# Function to get detailed disk information
get_disk_info() {
    local disk=$1
    MODEL=$(lsblk -dn -o MODEL "$disk" | xargs)
    SIZE=$(lsblk -dn -o SIZE "$disk" | xargs)
    echo "$MODEL" "$SIZE"
}




# Display list of available VMs
VM_LIST=$(qm list | awk 'NR>1 {print $1, $2}')
if [ -z "$VM_LIST" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VMs available in the system.")" 8 40
    exit 1
fi

# Select VM
VMID=$(whiptail --title "$(translate "Select VM")" --menu "$(translate "Select the VM to which you want to add disks:")" 15 60 8 $VM_LIST 3>&1 1>&2 2>&3)

if [ -z "$VMID" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No VM was selected.")" 8 40
    exit 1
fi

VMID=$(echo "$VMID" | tr -d '"')



#clear
msg_ok "$(translate "VM selected successfully.")"


VM_STATUS=$(qm status "$VMID" | awk '{print $2}')
if [ "$VM_STATUS" == "running" ]; then
    whiptail --title "$(translate "Warning")" --msgbox "$(translate "The VM is powered on. Turn it off before adding disks.")" 12 60
    exit 1
fi


##########################################

msg_info "$(translate "Detecting available disks...")"

USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')

MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

ZFS_DISKS=""
ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

for entry in $ZFS_RAW; do

    path=""
    if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
        if [ -e "/dev/disk/by-id/$entry" ]; then
            path=$(readlink -f "/dev/disk/by-id/$entry")
        fi
    elif [[ "$entry" == /dev/* ]]; then
        path="$entry"
    fi


    if [ -n "$path" ]; then
        base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
        if [ -n "$base_disk" ]; then
            ZFS_DISKS+="/dev/$base_disk"$'\n'
        fi
    fi
done

ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)


is_disk_in_use() {
    local disk="$1"


    while read -r part fstype; do
        case "$fstype" in
            zfs_member|linux_raid_member)
                return 0 ;;
        esac

        if echo "$MOUNTED_DISKS" | grep -q "/dev/$part"; then
            return 0
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$disk" | tail -n +2)


    if echo "$USED_DISKS" | grep -q "$disk" || echo "$ZFS_DISKS" | grep -q "$disk"; then
        return 0
    fi

    return 1
}




FREE_DISKS=()

LVM_DEVICES=$(pvs --noheadings -o pv_name | xargs -n1 readlink -f | sort -u)
RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

while read -r DISK; do
    # Saltar ZVOLs
    [[ "$DISK" =~ /dev/zd ]] && continue

    INFO=($(get_disk_info "$DISK"))
    MODEL="${INFO[@]::${#INFO[@]}-1}"
    SIZE="${INFO[-1]}"
    LABEL=""
    SHOW_DISK=true

    IS_MOUNTED=false
    IS_RAID=false
    IS_ZFS=false
    IS_LVM=false

    while read -r part fstype; do
        [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
        [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
        [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
        if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
            IS_MOUNTED=true
        fi
    done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

    REAL_PATH=$(readlink -f "$DISK")
    if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
        IS_MOUNTED=true
    fi

    # RAID activo â†’ no mostrar
    if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)"; then
        if grep -q "active raid" /proc/mdstat; then
            SHOW_DISK=false
        fi
    fi

    # ZFS no mostrar nunca
    if $IS_ZFS; then
        SHOW_DISK=false
    fi

    # Si estÃ¡ montado â†’ ocultar
    if $IS_MOUNTED; then
        SHOW_DISK=false
    fi

    # Ya asignado a la VM actual
    if qm config "$VMID" | grep -q "$DISK"; then
        SHOW_DISK=false
    fi

    if $SHOW_DISK; then
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  with partitions"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"

        DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
        FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
    fi
done < <(lsblk -dn -e 7,11 -o PATH)










if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks available for this VM.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Available disks detected.")"



######################################################




MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
TOTAL_WIDTH=$((MAX_WIDTH + 20))

if [ $TOTAL_WIDTH -lt 70 ]; then
    TOTAL_WIDTH=70
fi


SELECTED=$(whiptail --title "$(translate "Select Disks")" --checklist \
    "$(translate "Select the disks you want to add:")" 20 $TOTAL_WIDTH 10 "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

if [ -z "$SELECTED" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No disks were selected.")" 10 $TOTAL_WIDTH
    clear
    exit 1
fi

msg_ok "$(translate "Disks selected successfully.")"


INTERFACE=$(whiptail --title "$(translate "Interface Type")" --menu "$(translate "Select the interface type for all disks:")" 15 40 4 \
    "sata" "$(translate "Add as SATA")" \
    "scsi" "$(translate "Add as SCSI")" \
    "virtio" "$(translate "Add as VirtIO")" \
    "ide" "$(translate "Add as IDE")" 3>&1 1>&2 2>&3)

if [ -z "$INTERFACE" ]; then
    whiptail --title "$(translate "Error")" --msgbox "$(translate "No interface type was selected for the disks.")" 8 40
    clear
    exit 1
fi

msg_ok "$(translate "Interface type selected: $INTERFACE")"

DISKS_ADDED=0
ERROR_MESSAGES=""
SUCCESS_MESSAGES=""






msg_info "$(translate "Processing selected disks...")"

for DISK in $SELECTED; do
    DISK=$(echo "$DISK" | tr -d '"')
    DISK_INFO=$(get_disk_info "$DISK")

    ASSIGNED_TO=""
    RUNNING_VMS=""

    while read -r VM_ID VM_NAME; do
        if [[ "$VM_ID" =~ ^[0-9]+$ ]] && qm config "$VM_ID" | grep -q "$DISK"; then
            ASSIGNED_TO+="$VM_ID $VM_NAME\n"
            VM_STATUS=$(qm status "$VM_ID" | awk '{print $2}')
            if [ "$VM_STATUS" == "running" ]; then
                RUNNING_VMS+="$VM_ID $VM_NAME\n"
            fi
        fi
    done < <(qm list | awk 'NR>1 {print $1, $2}')

    if [ -n "$RUNNING_VMS" ]; then
        ERROR_MESSAGES+="$(translate "The disk") $DISK_INFO $(translate "is in use by the following running VM(s):")\\n$RUNNING_VMS\\n\\n"
        continue
    fi


    if [ -n "$ASSIGNED_TO" ]; then
        cleanup
        whiptail --title "$(translate "Disk Already Assigned")" --yesno "$(translate "The disk") $DISK_INFO $(translate "is already assigned to the following VM(s):")\\n$ASSIGNED_TO\\n\\n$(translate "Do you want to continue anyway?")" 15 70
        if [ $? -ne 0 ]; then
            sleep 1
            exec "$0"
        fi
    fi


    INDEX=0
    while qm config "$VMID" | grep -q "${INTERFACE}${INDEX}"; do
        ((INDEX++))
    done

    RESULT=$(qm set "$VMID" -${INTERFACE}${INDEX} "$DISK" 2>&1)

    if [ $? -eq 0 ]; then
        MESSAGE="$(translate "The disk") $DISK_INFO $(translate "has been successfully added to VM") $VMID."
        if [ -n "$ASSIGNED_TO" ]; then
            MESSAGE+="\\n\\n$(translate "WARNING: This disk is also assigned to the following VM(s):")\\n$ASSIGNED_TO"
            MESSAGE+="\\n$(translate "Make sure not to start VMs that share this disk at the same time to avoid data corruption.")"
        fi
        SUCCESS_MESSAGES+="$MESSAGE\\n\\n"
        ((DISKS_ADDED++))
    else
        ERROR_MESSAGES+="$(translate "Could not add disk") $DISK_INFO $(translate "to VM") $VMID.\\n$(translate "Error:") $RESULT\\n\\n"
    fi
done

msg_ok "$(translate "Disk processing completed.")"







if [ -n "$SUCCESS_MESSAGES" ]; then
    MSG_LINES=$(echo "$SUCCESS_MESSAGES" | wc -l)
    whiptail --title "$(translate "Successful Operations")" --msgbox "$SUCCESS_MESSAGES" 16 70
fi

if [ -n "$ERROR_MESSAGES" ]; then
    whiptail --title "$(translate "Warnings and Errors")" --msgbox "$ERROR_MESSAGES" 16 70
fi



exit 0



================================================
FILE: scripts/test/Iso.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenux - UUP Dump ISO Creator
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the ProxMenux tools for Proxmox VE.
# It allows downloading and converting official Windows ISO images 
# from UUP Dump using a shared link (with ID, pack, and edition).
#
# Key features:
# - Automatically installs and verifies required dependencies (aria2c, cabextract, wimlib-imagexâ€¦)
# - Downloads the selected Windows edition from UUP Dump using aria2
# - Converts the downloaded files into a bootable ISO
# - Stores the resulting ISO in the default template path (/var/lib/vz/template/iso)
# - Provides a graphical prompt via whiptail for user-friendly usage
#
# This tool simplifies the creation of official Windows ISOs
# for use in virtual machines within Proxmox VE.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

clear
show_proxmenux_logo

# ==========================================================


detect_iso_dir() {
  for store in $(pvesm status -content iso | awk 'NR>1 {print $1}'); do
    for ext in iso img; do
      volid=$(pvesm list "$store" --content iso | awk -v ext="$ext" 'NR>1 && $2 ~ ext {print $1; exit}')
      if [[ -n "$volid" ]]; then
        path=$(pvesm path "$volid" 2>/dev/null)
        dir=$(dirname "$path")
        [[ -d "$dir" ]] && echo "$dir" && return 0
      fi
    done
  done

  if [[ -d /var/lib/vz/template/iso ]]; then
    echo "/var/lib/vz/template/iso"
    return 0
  fi

  return 1
}


function run_uupdump_creator() {


    local DEPS=(curl aria2 cabextract wimtools genisoimage chntpw)
    local CMDS=(curl aria2c cabextract wimlib-imagex genisoimage chntpw)
    local MISSING=()
    local FAILED=()

    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            MISSING+=("${DEPS[$i]}")
        fi
    done

    if [[ ${#MISSING[@]} -gt 0 ]]; then
        msg_info "$(translate "Installing dependencies: ${MISSING[*]}")"
        apt-get update -qq >/dev/null 2>&1
        if ! apt-get install -y "${MISSING[@]}" >/dev/null 2>&1; then
            msg_error "$(translate "Failed to install: ${MISSING[*]}")"
            exit 1
        fi
    fi

    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            FAILED+=("${CMDS[$i]}")
        fi
    done

    if [[ ${#FAILED[@]} -eq 0 ]]; then
        msg_ok "$(translate "All dependencies installed and verified.")"
    else
        msg_error "$(translate "Missing commands after installation: ${FAILED[*]}")"
        exit 1
    fi


ISO_DIR=$(detect_iso_dir)
if [[ -z "$ISO_DIR" ]]; then
  msg_error "$(translate "Could not determine a valid ISO storage directory.")"
  exit 1
fi


mkdir -p "$ISO_DIR"

TMP_DIR=$(dialog --inputbox "Enter temporary folder path (default: /root/uup-temp):" 10 60 "/root/uup-temp" 3>&1 1>&2 2>&3)
if [[ $? -ne 0 || -z "$TMP_DIR" ]]; then
  TMP_DIR="/root/uup-temp"
fi

OUT_DIR="$ISO_DIR"
CONVERTER="/root/uup-converter"

mkdir -p "$TMP_DIR" "$OUT_DIR"
cd "$TMP_DIR" || exit 1


UUP_URL=$(whiptail --inputbox "$(translate "Paste the UUP Dump URL here")" 10 90 3>&1 1>&2 2>&3)
if [[ $? -ne 0 || -z "$UUP_URL" ]]; then
  msg_warn "$(translate "Cancelled by user or empty URL.")"
  return 1  
fi

if [[ ! "$UUP_URL" =~ id=.+\&pack=.+\&edition=.+ ]]; then
  msg_error "$(translate "The URL does not contain the required parameters (id, pack, edition).")"
  sleep 2
  return 1 
fi


BUILD_ID=$(echo "$UUP_URL" | grep -oP 'id=\K[^&]+')
LANG=$(echo "$UUP_URL" | grep -oP 'pack=\K[^&]+')
EDITION=$(echo "$UUP_URL" | grep -oP 'edition=\K[^&]+')
ARCH="amd64"

echo -e "\n${BGN}=============== UUP Dump Creator ===============${CL}"
echo -e "    ${BGN}ğŸ†” ID:${CL} ${DGN}$BUILD_ID${CL}"
echo -e "    ${BGN}ğŸŒ Language:${CL} ${DGN}$LANG${CL}"
echo -e "    ${BGN}ğŸ’¿ Edition:${CL} ${DGN}$EDITION${CL}"
echo -e "    ${BGN}ğŸ–¥ï¸ Architecture:${CL} ${DGN}$ARCH${CL}"
echo -e "${BGN}===============================================${CL}\n"


if [[ ! -f "$CONVERTER/convert.sh" ]]; then
  echo "ğŸ“¦ $(translate "Downloading UUP converter...")"
  mkdir -p "$CONVERTER"
  cd "$CONVERTER" || exit 1
  wget -q https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz -O converter.tar.gz
  tar -xzf converter.tar.gz --strip-components=1
  chmod +x convert.sh
  cd "$TMP_DIR" || exit 1
fi


cat > uup_download_linux.sh <<EOF
#!/bin/bash
mkdir -p files
echo "https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz" > files/converter_multi

for prog in aria2c cabextract wimlib-imagex chntpw; do
  which \$prog &>/dev/null || { echo "\$prog not found."; exit 1; }
done
which genisoimage &>/dev/null || which mkisofs &>/dev/null || { echo "genisoimage/mkisofs not found."; exit 1; }

destDir="UUPs"
tempScript="aria2_script.\$RANDOM.txt"

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j2 --allow-overwrite=true --auto-file-renaming=false -d"files" -i"files/converter_multi" || exit 1

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -o"\$tempScript" --allow-overwrite=true --auto-file-renaming=false \
  "https://uupdump.net/get.php?id=$BUILD_ID&pack=$LANG&edition=$EDITION&aria2=2" || exit 1

grep '#UUPDUMP_ERROR:' "\$tempScript" && { echo "âŒ Error generating UUP download list."; exit 1; }

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j5 -c -R -d"\$destDir" -i"\$tempScript" || exit 1
EOF

chmod +x uup_download_linux.sh



# ==========================
./uup_download_linux.sh
# ==========================



UUP_FOLDER=$(find "$TMP_DIR" -type d -name "UUPs" | head -n1)
[[ -z "$UUP_FOLDER" ]] && msg_error "$(translate "No UUP folder found.")" && exit 1


echo -e "\n${GN}=======================================${CL}"
echo -e "    ğŸ’¿ ${GN}Starting ISO conversion...${CL}"
echo -e "${GN}=======================================${CL}\n"

"$CONVERTER/convert.sh" wim "$UUP_FOLDER" 1


ISO_FILE=$(find "$TMP_DIR" "$CONVERTER" "$UUP_FOLDER" -maxdepth 1 -iname "*.iso" | head -n1)
if [[ -f "$ISO_FILE" ]]; then
  mv "$ISO_FILE" "$OUT_DIR/"
  msg_ok "$(translate "ISO created successfully:") $OUT_DIR/$(basename "$ISO_FILE")"


  msg_ok "$(translate "Cleaning temporary files...")"
  rm -rf "$TMP_DIR" "$CONVERTER"
    
  export OS_TYPE="windows"
  export LANGUAGE=C
  export LANG=C
  export LC_ALL=C
  load_language
  initialize_cache

  msg_success "$(translate "Press Enter to return to menu...")"
  read -r

else
  msg_warn "$(translate "No ISO was generated.")"
  rm -rf "$TMP_DIR" "$CONVERTER"
  export LANGUAGE=C
  export LANG=C
  export LC_ALL=C
  load_language
  initialize_cache
  msg_success "$(translate "Press Enter to return to menu...")"
  read -r
  return 1
fi

}



================================================
FILE: scripts/test/repair_network_safe.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenu - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : MIT
# Version     : 1.1
# Last Updated: 30/04/2025
# ==========================================================
# Description:
# This script allows users to repair or verify network configuration in Proxmox.
# It avoids making changes if the system is already connected to the internet.
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

detect_physical_interfaces() {
    physical_interfaces=$(ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy|bond|tap|fw|vmbr|br)/ {print $2}')
    whiptail --title "$(translate 'Network Interfaces')" --msgbox "$physical_interfaces" 10 78
}

get_relevant_interfaces() {
    echo $(ip -o link show | awk -F': ' '$2 !~ /^(lo|veth|dummy)/ {print $2}')
}

check_and_fix_bridges() {
    local output=""
    output+="$(translate 'Checking bridges')\n\n"

    bridges=$(grep "^auto vmbr" /etc/network/interfaces | awk '{print $2}')

    for bridge in $bridges; do
        old_port=$(grep -A1 "iface $bridge" /etc/network/interfaces | grep "bridge-ports" | awk '{print $2}')

        if ! ip link show "$old_port" &>/dev/null; then
            output+="$(translate 'Bridge port missing'): $bridge - $old_port\n"

            new_port=$(whiptail --title "$(translate 'Missing Port Detected')"                 --menu "$(translate 'The bridge') $bridge $(translate 'is using a missing port') ($old_port).\n\n$(translate 'Select a replacement interface:')"                 20 60 10                 $(echo "$physical_interfaces" | tr ' ' '\n' | grep -v "vmbr" | awk '{print $1 " " $1}')                 3>&1 1>&2 2>&3)

            if [ -n "$new_port" ]; then
                sed -i "/iface $bridge/,/bridge-ports/ s/bridge-ports.*/bridge-ports $new_port/" /etc/network/interfaces
                output+="$(translate 'Bridge port updated'): $bridge - $old_port -> $new_port\n"
            else
                output+="$(translate 'No replacement selected. Skipping update for') $bridge\n"
            fi
        else
            output+="$(translate 'Bridge port OK'): $bridge - $old_port\n"
        fi
    done

    whiptail --title "$(translate 'Checking Bridges')" --msgbox "$output" 20 78
}

clean_nonexistent_interfaces() {
    local output=""
    output+="$(translate 'Cleaning interfaces')\n\n"
    configured_interfaces=$(grep "^iface" /etc/network/interfaces | awk '{print $2}' | grep -v "lo")
    for iface in $configured_interfaces; do
        if [[ ! $iface =~ ^(vmbr|bond) ]] && ! ip link show "$iface" &>/dev/null; then
            sed -i "/iface $iface/,/^$/d" /etc/network/interfaces
            output+="$(translate 'Interface removed'): $iface\n"
        fi
    done
    whiptail --title "$(translate 'Cleaning Interfaces')" --msgbox "$output" 15 78
}

configure_physical_interfaces() {
    local output=""
    output+="$(translate 'Configuring interfaces')\n\n"
    for iface in $physical_interfaces; do
        if ! grep -q "iface $iface" /etc/network/interfaces; then
            echo -e "\niface $iface inet manual" >> /etc/network/interfaces
            output+="$(translate 'Interface added'): $iface\n"
        fi
    done
    whiptail --title "$(translate 'Configuring Interfaces')" --msgbox "$output" 15 78
}

restart_networking() {
    if (whiptail --title "$(translate 'Restarting Network')" --yesno "$(translate 'Do you want to restart the network service?')" 10 60); then
        clear
        msg_info "$(translate 'The network service is about to restart. You may experience a brief disconnection.')"
        systemctl restart networking
        if [ $? -eq 0 ]; then
            msg_ok "$(translate 'Network service restarted successfully')"
        else
            msg_error "$(translate 'Failed to restart network service')"
        fi
    else
        msg_ok "$(translate 'Network restart canceled')"
    fi
}

check_network_connectivity() {
    if ping -c 4 8.8.8.8 &> /dev/null; then
        msg_ok "$(translate 'Network connectivity OK')"
        return 0
    else
        msg_error "$(translate 'Network connectivity failed')"
        return 1
    fi
}

show_ip_info() {
    whiptail --title "$(translate 'IP Information')" --infobox "$(translate 'Gathering IP information...')" 8 78
    local ip_info=""
    ip_info+="$(translate 'IP Information')\n\n"

    local interfaces=$(get_relevant_interfaces)

    for interface in $interfaces; do
        local interface_ip=$(ip -4 addr show $interface 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
        if [ -n "$interface_ip" ]; then
            ip_info+="$interface: $interface_ip\n"
        else
            ip_info+="$interface: $(translate 'No IP assigned')\n"
        fi
    done

    whiptail --title "$(translate 'Result')" --msgbox "${ip_info}\n\n$(translate 'IP information gathering completed')\n\n$(translate 'Press Enter to continue')" 20 78
}

repair_network() {
    if check_network_connectivity; then
        msg_ok "$(translate 'Network is already working. No repair needed.')"
        whiptail --title "$(translate 'Network Status')" --msgbox "$(translate 'Network is already connected. No action will be taken.')" 10 78
        return
    fi

    whiptail --title "$(translate 'Network Repair Started')" --infobox "$(translate 'Repairing network...')" 8 78
    echo -ne "${TAB}${YW}-$(translate 'Repairing network...') ${CL}"
    sleep 3
    detect_physical_interfaces
    clean_nonexistent_interfaces
    check_and_fix_bridges
    configure_physical_interfaces
    restart_networking

    if check_network_connectivity; then
        show_ip_info
        msg_ok "$(translate 'Network repair completed successfully')"
    else
        msg_error "$(translate 'Network repair failed')"
    fi

    whiptail --title "$(translate 'Result')" --msgbox "$(translate 'Repair process completed')\n\n$(translate 'Press Enter to continue')" 10 78
}

verify_network() {
    whiptail --title "$(translate 'Network Verification Started')" --infobox "$(translate 'Verifying network...')" 8 78
    echo -ne "${TAB}${YW}-$(translate 'Verifying network...') ${CL}"
    detect_physical_interfaces
    show_ip_info
    if check_network_connectivity; then
        msg_ok "$(translate 'Network verification completed successfully')"
    else
        msg_error "$(translate 'Network verification failed')"
    fi
    whiptail --title "$(translate 'Result')" --msgbox "$(translate 'Verification process completed')\n\n$(translate 'Press Enter to continue')" 10 78
}

show_main_menu() {
    while true; do
        OPTION=$(whiptail --title "$(translate 'Network Repair Menu')" --menu "$(translate 'Choose an option:')" 15 60 4 \
        "1" "$(translate 'Repair Network')" \
        "2" "$(translate 'Verify Network')" \
        "3" "$(translate 'Show IP Information')" \
        "4" "$(translate "Return to Main Menu")" 3>&1 1>&2 2>&3)

        case $OPTION in
            1) repair_network ;;
            2) verify_network ;;
            3) show_ip_info ;;
            4) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
            *) exec bash "$LOCAL_SCRIPTS/menus/main_menu.sh" ;;
        esac
    done
}

clear
show_proxmenux_logo
show_main_menu



================================================
FILE: scripts/test/res.sh
================================================
#!/usr/bin/env bash

# ==============================================
# ProxMenux - MenÃº de RestauraciÃ³n de Backups
# ==============================================

BACKUP_DIR="/root/backups"
PBS_REPO="root@pbs@192.168.100.10:host-backups"
HOSTNAME=$(hostname)

main_menu() {
  OPTION=$(whiptail --title "Restaurar Backup del Host" --menu "Â¿Desde dÃ³nde quieres restaurar?" 15 60 5 \\
    "1" "Restaurar desde archivo local (.tar.gz)" \\
    "2" "Restaurar desde PBS (.pxar)" \\
    "3" "Salir" 3>&1 1>&2 2>&3)

  case "$OPTION" in
    "1") restore_from_local ;;
    "2") restore_from_pbs ;;
    "3") clear; exit 0 ;;
  esac
}

restore_from_local() {
  mapfile -t TAR_FILES < <(find "$BACKUP_DIR" -name "*.tar.gz" 2>/dev/null)

  if [ ${#TAR_FILES[@]} -eq 0 ]; then
    whiptail --msgbox "No se encontraron archivos .tar.gz en $BACKUP_DIR" 10 60
    return
  fi

  MENU_ITEMS=()
  for f in "${TAR_FILES[@]}"; do
    MENU_ITEMS+=("$f" "")
  done

  SELECTED_TAR=$(whiptail --title "Selecciona backup local" --menu "Elige el archivo a restaurar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  mapfile -t FILE_CONTENT < <(tar -tzf "$SELECTED_TAR")
  MENU_CONTENT=()
  for item in "${FILE_CONTENT[@]}"; do
    MENU_CONTENT+=("$item" "OFF")
  done

  SELECTED_DIRS=$(whiptail --title "Contenido del backup" --checklist "Selecciona quÃ© restaurar (Espacio = seleccionar):" 20 80 15 \\
    "ALL" "Restaurar todo el contenido" OFF \\
    "${MENU_CONTENT[@]}" 3>&1 1>&2 2>&3) || return

  if echo "$SELECTED_DIRS" | grep -q "ALL"; then
    tar -xzf "$SELECTED_TAR" -C /
    whiptail --msgbox "RestauraciÃ³n completa realizada con Ã©xito." 10 60
  else
    for item in $SELECTED_DIRS; do
      item_cleaned=$(echo "$item" | tr -d '"')
      tar -xzf "$SELECTED_TAR" -C / "$item_cleaned"
    done
    whiptail --msgbox "RestauraciÃ³n parcial realizada con Ã©xito." 10 60
  fi
}

restore_from_pbs() {
  mapfile -t BACKUPS < <(proxmox-backup-client list --repository "$PBS_REPO" | grep "$HOSTNAME" | awk '{print $3}')

  if [ ${#BACKUPS[@]} -eq 0 ]; then
    whiptail --msgbox "No se encontraron backups de $HOSTNAME en PBS." 10 60
    return
  fi

  MENU_ITEMS=()
  for backup in "${BACKUPS[@]}"; do
    MENU_ITEMS+=("$backup" "")
  done

  SELECTED_BACKUP=$(whiptail --title "Seleccionar backup en PBS" --menu "Elige un snapshot para restaurar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  mapfile -t FILES < <(proxmox-backup-client catalog --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP" | awk '{print $1}' | grep ".pxar")

  if [ ${#FILES[@]} -eq 0 ]; then
    whiptail --msgbox "No se encontraron archivos .pxar en ese snapshot." 10 60
    return
  fi

  FILE_OPTIONS=("ALL" "Restaurar todos los archivos" OFF)
  for file in "${FILES[@]}"; do
    FILE_OPTIONS+=("$file" "OFF")
  done

  SELECTED_FILES=$(whiptail --title "Contenido del snapshot PBS" --checklist "Selecciona quÃ© restaurar:" 20 80 15 "${FILE_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return

  RESTORE_DIR="/tmp/pbs-restore-${SELECTED_BACKUP}"
  mkdir -p "$RESTORE_DIR"

  if echo "$SELECTED_FILES" | grep -q "ALL"; then
    for file in "${FILES[@]}"; do
      proxmox-backup-client restore "$file" "$RESTORE_DIR/$(basename "$file" .pxar)" --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP"
    done
    whiptail --msgbox "RestauraciÃ³n completa a $RESTORE_DIR." 10 60
  else
    for file in $SELECTED_FILES; do
      file_cleaned=$(echo "$file" | tr -d '"')
      proxmox-backup-client restore "$file_cleaned" "$RESTORE_DIR/$(basename "$file_cleaned" .pxar)" --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP"
    done
    whiptail --msgbox "RestauraciÃ³n parcial a $RESTORE_DIR." 10 60
  fi
}

# Lanzar menÃº principal
while true; do main_menu; done
""")

unified_script_path = Path("/mnt/data/restore-unified-menu.sh")
unified_script_path.write_text(unified_restore_script)
unified_script_path.chmod(0o755)
unified_script_path


================================================
FILE: scripts/test/res2.sh
================================================
#!/usr/bin/env bash

# ========================================
# ProxMenux - MenÃº completo de restauraciÃ³n
# ========================================

BACKUP_DIR="/root/backups"
PBS_REPO="root@pbs@192.168.100.10:host-backups"
HOSTNAME=$(hostname)

main_menu() {
  OPTION=$(whiptail --title "Restaurar Backup del Host" --menu "Selecciona el origen del backup:" 15 60 4 \\
    "1" "Restaurar desde archivo local (.tar.gz)" \\
    "2" "Restaurar desde PBS (.pxar)" \\
    "3" "Salir" 3>&1 1>&2 2>&3)

  case "$OPTION" in
    "1") local_restore_menu ;;
    "2") pbs_restore_menu ;;
    "3") clear; exit 0 ;;
  esac
}

local_restore_menu() {
  OPTION=$(whiptail --title "Restaurar desde archivo local" --menu "Selecciona el tipo de restauraciÃ³n:" 15 60 2 \\
    "1" "RestauraciÃ³n completa del sistema" \\
    "2" "RestauraciÃ³n manual (archivos o directorios)" 3>&1 1>&2 2>&3)

  case "$OPTION" in
    "1") restore_local_full ;;
    "2") restore_local_manual ;;
  esac
}

pbs_restore_menu() {
  OPTION=$(whiptail --title "Restaurar desde PBS" --menu "Selecciona el tipo de restauraciÃ³n:" 15 60 2 \\
    "1" "RestauraciÃ³n completa del sistema" \\
    "2" "RestauraciÃ³n manual (archivos o directorios)" 3>&1 1>&2 2>&3)

  case "$OPTION" in
    "1") restore_pbs_full ;;
    "2") restore_pbs_manual ;;
  esac
}

restore_local_full() {
  mapfile -t TAR_FILES < <(find "$BACKUP_DIR" -name "*.tar.gz" 2>/dev/null)
  [[ ${#TAR_FILES[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron backups en $BACKUP_DIR" 10 60 && return

  MENU_ITEMS=()
  for f in "${TAR_FILES[@]}"; do MENU_ITEMS+=("$f" ""); done

  SELECTED=$(whiptail --title "Seleccionar backup" --menu "Elige el archivo para restaurar completamente:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  CONFIRM=$(whiptail --title "Confirmar restauraciÃ³n" --yesno "Â¿Deseas sobrescribir el sistema con este backup?" 10 60)
  [[ $? -ne 0 ]] && return

  tar -xzf "$SELECTED" -C /
  whiptail --msgbox "RestauraciÃ³n completa realizada con Ã©xito." 10 60
}

restore_local_manual() {
  mapfile -t TAR_FILES < <(find "$BACKUP_DIR" -name "*.tar.gz" 2>/dev/null)
  [[ ${#TAR_FILES[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron backups en $BACKUP_DIR" 10 60 && return

  MENU_ITEMS=()
  for f in "${TAR_FILES[@]}"; do MENU_ITEMS+=("$f" ""); done

  SELECTED=$(whiptail --title "Seleccionar backup" --menu "Elige el archivo a examinar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return
  mapfile -t CONTENT < <(tar -tzf "$SELECTED")
  MENU_CONTENT=()
  for item in "${CONTENT[@]}"; do MENU_CONTENT+=("$item" "OFF"); done

  SELECTED_ITEMS=$(whiptail --title "Seleccionar contenido" --checklist "Selecciona quÃ© restaurar:" 20 80 15 "${MENU_CONTENT[@]}" 3>&1 1>&2 2>&3) || return

  for item in $SELECTED_ITEMS; do
    CLEAN_ITEM=$(echo "$item" | tr -d '"')
    tar -xzf "$SELECTED" -C / "$CLEAN_ITEM"
  done

  whiptail --msgbox "RestauraciÃ³n parcial realizada con Ã©xito." 10 60
}

restore_pbs_full() {
  mapfile -t BACKUPS < <(proxmox-backup-client list --repository "$PBS_REPO" | grep "$HOSTNAME" | awk '{print $3}')
  [[ ${#BACKUPS[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron backups en PBS." 10 60 && return

  MENU_ITEMS=()
  for backup in "${BACKUPS[@]}"; do MENU_ITEMS+=("$backup" ""); done

  SELECTED_BACKUP=$(whiptail --title "Snapshot PBS" --menu "Selecciona el snapshot para restaurar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  mapfile -t FILES < <(proxmox-backup-client catalog --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP" | awk '{print $1}' | grep ".pxar")
  [[ ${#FILES[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron archivos .pxar." 10 60 && return

  FILE_OPTIONS=()
  for file in "${FILES[@]}"; do FILE_OPTIONS+=("$file" "OFF"); done
  SELECTED_FILE=$(whiptail --title "Archivo .pxar" --radiolist "Selecciona el archivo para restaurar completamente:" 20 80 10 "${FILE_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return
  FILE_CLEAN=$(echo "$SELECTED_FILE" | tr -d '"')

  CONFIRM=$(whiptail --title "Confirmar restauraciÃ³n" --yesno "Â¿Deseas sobrescribir el sistema con ${FILE_CLEAN}?" 10 70)
  [[ $? -ne 0 ]] && return

  proxmox-backup-client restore "$FILE_CLEAN" / --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP"
  whiptail --msgbox "RestauraciÃ³n completa realizada con Ã©xito." 10 60
}

restore_pbs_manual() {
  mapfile -t BACKUPS < <(proxmox-backup-client list --repository "$PBS_REPO" | grep "$HOSTNAME" | awk '{print $3}')
  [[ ${#BACKUPS[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron backups en PBS." 10 60 && return

  MENU_ITEMS=()
  for backup in "${BACKUPS[@]}"; do MENU_ITEMS+=("$backup" ""); done

  SELECTED_BACKUP=$(whiptail --title "Snapshot PBS" --menu "Selecciona el snapshot para explorar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  mapfile -t FILES < <(proxmox-backup-client catalog --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP" | awk '{print $1}' | grep ".pxar")
  [[ ${#FILES[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron archivos .pxar." 10 60 && return

  FILE_OPTIONS=()
  for file in "${FILES[@]}"; do FILE_OPTIONS+=("$file" "OFF"); done
  SELECTED_FILE=$(whiptail --title "Archivo .pxar" --radiolist "Selecciona el archivo para restaurar parcialmente:" 20 80 10 "${FILE_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return
  FILE_CLEAN=$(echo "$SELECTED_FILE" | tr -d '"')

  TMP_DIR="/tmp/restore-${RANDOM}"
  mkdir -p "$TMP_DIR"
  proxmox-backup-client restore "$FILE_CLEAN" "$TMP_DIR" --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP"

  mapfile -t CONTENT < <(cd "$TMP_DIR" && find . -type f -o -type d)
  RESTORE_ITEMS=()
  for entry in "${CONTENT[@]}"; do RESTORE_ITEMS+=("$entry" "OFF"); done

  SELECTED_ITEMS=$(whiptail --title "Contenido del backup" --checklist "Selecciona quÃ© restaurar en el sistema:" 20 80 15 "${RESTORE_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  for item in $SELECTED_ITEMS; do
    CLEAN_ITEM=$(echo "$item" | tr -d '"')
    cp -r "$TMP_DIR/$CLEAN_ITEM" "/$CLEAN_ITEM"
  done

  rm -rf "$TMP_DIR"
  whiptail --msgbox "RestauraciÃ³n parcial completada y archivos temporales eliminados." 10 60
}

while true; do main_menu; done
""")

script_path = Path("/mnt/data/proxmox-restore-menu.sh")
script_path.write_text(full_menu_script)
script_path.chmod(0o755)
script_path


================================================
FILE: scripts/test/res3.sh
================================================
#!/usr/bin/env bash

# ================================
# ProxMenux - RestauraciÃ³n completa desde PBS con autoreparaciÃ³n
# ================================

PBS_REPO="root@pbs@192.168.100.10:host-backups"
HOSTNAME=$(hostname)

restore_pbs_full() {
  mapfile -t BACKUPS < <(proxmox-backup-client list --repository "$PBS_REPO" | grep "$HOSTNAME" | awk '{print $3}')
  [[ ${#BACKUPS[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron backups en PBS." 10 60 && return

  MENU_ITEMS=()
  for backup in "${BACKUPS[@]}"; do MENU_ITEMS+=("$backup" ""); done

  SELECTED_BACKUP=$(whiptail --title "Snapshot PBS" --menu "Selecciona el snapshot para restaurar:" 20 70 10 "${MENU_ITEMS[@]}" 3>&1 1>&2 2>&3) || return

  mapfile -t FILES < <(proxmox-backup-client catalog --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP" | awk '{print $1}' | grep ".pxar")
  [[ ${#FILES[@]} -eq 0 ]] && whiptail --msgbox "No se encontraron archivos .pxar." 10 60 && return

  FILE_OPTIONS=()
  for file in "${FILES[@]}"; do FILE_OPTIONS+=("$file" "OFF"); done
  SELECTED_FILE=$(whiptail --title "Archivo .pxar" --radiolist "Selecciona el archivo para restaurar completamente:" 20 80 10 "${FILE_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return
  FILE_CLEAN=$(echo "$SELECTED_FILE" | tr -d '"')

  CONFIRM=$(whiptail --title "Confirmar restauraciÃ³n" --yesno "Â¿Deseas sobrescribir el sistema con ${FILE_CLEAN}?\nEsto restaurarÃ¡ todos los archivos y puede requerir reinstalar GRUB y el kernel." 12 70)
  [[ $? -ne 0 ]] && return

  # RestauraciÃ³n principal
  proxmox-backup-client restore "$FILE_CLEAN" / --repository "$PBS_REPO" --backup-id "$HOSTNAME" --backup-time "$SELECTED_BACKUP"
  RESTORE_STATUS=$?

  if [ $RESTORE_STATUS -eq 0 ]; then
    whiptail --msgbox "RestauraciÃ³n completa realizada con Ã©xito. Ahora se ejecutarÃ¡n pasos de autoreparaciÃ³n (GRUB, kernel, DKMS)..." 10 70

    # ReparaciÃ³n post-restauraciÃ³n
    {
      echo "[INFO] Reinstalando GRUB en /dev/sda..."
      grub-install /dev/sda && update-grub

      echo "[INFO] Reinstalando kernel actual..."
      apt install --reinstall -y pve-kernel-$(uname -r)

      echo "[INFO] Reconstruyendo mÃ³dulos DKMS..."
      dkms autoinstall || true
    } >> /var/log/proxmox-restore.log 2>&1

    whiptail --yesno "RestauraciÃ³n y autoreparaciÃ³n completadas.\nÂ¿Deseas reiniciar ahora el sistema?" 10 60 && reboot
  else
    whiptail --msgbox "Error durante la restauraciÃ³n. Verifica los logs para mÃ¡s detalles." 10 60
  fi
}

restore_pbs_full
"""

pbs_autorepair_path.write_text(pbs_restore_autorepair_script)
pbs_autorepair_path.chmod(0o755)
pbs_autorepair_path


================================================
FILE: scripts/test/t2pbs.sh
================================================
#!/usr/bin/env bash

# =======================================
# ProxMenux - Backup Menu for Proxmox VE
# =======================================

# CONFIGURACIÃ“N DINÃMICA
# Solicitar datos de conexiÃ³n a PBS por separado y construir el repositorio final
PBS_REPO_FILE="/etc/proxmenux/pbs-repo.conf"

if [[ -f "$PBS_REPO_FILE" ]]; then
 PBS_REPO=$(tr -d '
[:space:]' < "$PBS_REPO_FILE")
else
  PBS_USER=$(whiptail --inputbox "Introduce el nombre de usuario para el PBS:" 10 60 "root" 3>&1 1>&2 2>&3) || exit
  PBS_HOST=$(whiptail --inputbox "Introduce la IP o nombre del host del PBS:" 10 60 "192.168.0.42" 3>&1 1>&2 2>&3) || exit
  PBS_DATASTORE=$(whiptail --inputbox "Introduce el nombre del datastore PBS:" 10 60 "t6pbs" 3>&1 1>&2 2>&3) || exit

  PBS_REPO="${PBS_USER}@pam@${PBS_HOST}:${PBS_DATASTORE}"
  mkdir -p "$(dirname "$PBS_REPO_FILE")"
  echo "$PBS_REPO" > "$PBS_REPO_FILE"
fi

HOSTNAME=$(hostname)
TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"
BACKUP_DIR="/var/backups/proxmox-host/tar"

declare -A BACKUP_PATHS=(
    [etc-pve]="/etc/pve"
    [etc-network]="/etc/network"
    [var-lib-pve-cluster]="/var/lib/pve-cluster"
    [root-dir]="/root"
    [etc-ssh]="/etc/ssh"
    [home]="/home"
    [local-bin]="/usr/local/bin"
    [cron]="/etc/cron.d"
    [custom-systemd]="/etc/systemd/system"
)

main_menu() {
    OPTION=$(whiptail --title "Proxmox Host Backup" --menu "Elige una opciÃ³n de respaldo:" 20 78 10 \
        "1" "Backup rÃ¡pido personalizado (tar.gz, local)" \
        "2" "Backup rÃ¡pido personalizado (PBS)" \
        "3" "Backup completo del sistema (tar.gz, local)" \
        "4" "Backup completo del sistema (PBS)" \
        "5" "Backup mÃ­nimo automÃ¡tico (tar.gz, local)" \
        "6" "Salir" 3>&1 1>&2 2>&3)

    case "$OPTION" in
        "1") backup_local_tar_checklist ;;
        "2") backup_modular_pbs_checklist ;;
        "3") backup_full_local_root ;;
        "4") backup_full_pbs_root ;;
        "5") backup_min_local_tar ;;
        "6") clear; exit 0 ;;
    esac
}

backup_local_tar_checklist() {
    mkdir -p "$BACKUP_DIR"

    MENU_OPTIONS=("ALL" "Respaldar todos los directorios sugeridos" OFF)
    for name in "${!BACKUP_PATHS[@]}"; do
        MENU_OPTIONS+=("$name" "${BACKUP_PATHS[$name]}" OFF)
    done

    CHOICES=$(whiptail --checklist "Selecciona los directorios a respaldar:" 20 78 12 "${MENU_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return

    SELECTED=()
    if echo "$CHOICES" | grep -q "ALL"; then
        for path in "${BACKUP_PATHS[@]}"; do SELECTED+=("$path"); done
    else
        for choice in $CHOICES; do
            key=$(echo "$choice" | tr -d '"')
            SELECTED+=("${BACKUP_PATHS[$key]}")
        done
    fi

    BACKUP_FILE="${BACKUP_DIR}/${HOSTNAME}-local-backup-${TIMESTAMP}.tar.gz"
    tar --exclude="$BACKUP_FILE" -czf "$BACKUP_FILE" --absolute-names "${SELECTED[@]}" && \
    echo -e "\nBackup guardado en: $BACKUP_FILE" || \
    echo -e "\nError al crear el backup local."
    read -p "Pulsa ENTER para continuar..."
}

backup_modular_pbs_checklist() {
    MENU_OPTIONS=("ALL" "Respaldar todos los directorios sugeridos" OFF)
    for name in "${!BACKUP_PATHS[@]}"; do
        MENU_OPTIONS+=("$name" "${BACKUP_PATHS[$name]}" OFF)
    done

    CHOICES=$(whiptail --checklist "Selecciona quÃ© enviar al PBS:" 20 78 12 "${MENU_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return

    SELECTED=()
    if echo "$CHOICES" | grep -q "ALL"; then
        for name in "${!BACKUP_PATHS[@]}"; do
        safe_name=$(echo "$name" | tr '.-' '_')
        SELECTED+=("${safe_name}.pxar:${BACKUP_PATHS[$name]}")
        done
    else
        for choice in $CHOICES; do
        key=$(echo "$choice" | tr -d '"')
        safe_key=$(echo "$key" | tr '.-' '_')
        SELECTED+=("${safe_key}.pxar:${BACKUP_PATHS[$key]}")
        done
    fi

    for entry in "${SELECTED[@]}"; do
      if [[ "$entry" =~ ^[a-zA-Z0-9_-]+\.pxar:/.* ]]; then
        echo ">> Enviando: $entry"
        echo ">> REPO: '$PBS_REPO'"
        proxmox-backup-client backup "$entry" \
          --repository "$PBS_REPO" \
          --backup-type host \
          --backup-id "${HOSTNAME}-$(echo "$entry" | cut -d'.' -f1)" \
          --backup-time "$(date +%s)" \
          --incremental true
      else
        echo ">> Saltado (mal formado): $entry"
      fi
    done

    echo -e "\nBackup modular al PBS finalizado."
    read -p "Pulsa ENTER para continuar..."
}

backup_full_local_root() {
    mkdir -p "$BACKUP_DIR"
    BACKUP_FILE="${BACKUP_DIR}/${HOSTNAME}-full-backup-${TIMESTAMP}.tar.gz"
    echo "Creando backup completo local (excluyendo /proc, /sys, /dev, /run, /mnt, /tmp)..."
    tar --exclude="$BACKUP_DIR" --exclude=/proc --exclude=/sys --exclude=/dev --exclude=/run --exclude=/mnt --exclude=/tmp \
        -czf "$BACKUP_FILE" / && \
    echo -e "\nBackup completo guardado en: $BACKUP_FILE" || \
    echo -e "\nError durante el backup completo."
    read -p "Pulsa ENTER para continuar..."
}

backup_full_pbs_root() {
    proxmox-backup-client backup \
        --include-dev /boot/efi \
        --include-dev /etc/pve \
        root-${HOSTNAME}.pxar:/ \
        --repository "$PBS_REPO" \
        --backup-type host \
        --backup-id "$HOSTNAME" \
        --backup-time "$(date +%s)" && \
    echo -e "
Backup completo al PBS finalizado correctamente." || \
    echo -e "
Error durante el backup completo."
    read -p "Pulsa ENTER para continuar..."
    echo -e "\nBackup completo al PBS finalizado correctamente." || \
    echo -e "\nError durante el backup completo."
    read -p "Pulsa ENTER para continuar..."
}

backup_min_local_tar() {
    mkdir -p "$BACKUP_DIR"
    BACKUP_FILE="${BACKUP_DIR}/${HOSTNAME}-minimal-${TIMESTAMP}.tar.gz"
    tar --exclude="$BACKUP_FILE" -czf "$BACKUP_FILE" --absolute-names /etc/pve /etc/network /var/lib/pve-cluster /root && \
    echo -e "\nBackup mÃ­nimo guardado en: $BACKUP_FILE" || \
    echo -e "\nError durante el backup mÃ­nimo."
    read -p "Pulsa ENTER para continuar..."
}

main_menu



================================================
FILE: scripts/test/tpbs.sh
================================================
#!/usr/bin/env bash

# =======================================
# ProxMenux - Backup Menu for Proxmox VE
# =======================================

# CONFIGURACIÃ“N
PBS_REPO="root@pbs@192.168.100.10:host-backups"  # Cambiar IP/datastore si es necesario
HOSTNAME=$(hostname)
TIMESTAMP=$(date +%Y-%m-%d_%H-%M)
SNAPSHOT="${HOSTNAME}-${TIMESTAMP}"

# LISTA DE DIRECTORIOS RECOMENDADOS
declare -A BACKUP_PATHS=(
    [etc-pve]="/etc/pve"
    [etc-network]="/etc/network"
    [var-lib-pve-cluster]="/var/lib/pve-cluster"
    [root-dir]="/root"
    [etc-ssh]="/etc/ssh"
    [home]="/home"
    [local-bin]="/usr/local/bin"
    [cron]="/etc/cron.d"
    [custom-systemd]="/etc/systemd/system"
)

main_menu() {
    OPTION=$(whiptail --title "Proxmox Host Backup" --menu "Elige una opciÃ³n de respaldo:" 20 78 10 \
        "1" "Backup rÃ¡pido personalizado (tar.gz, local)" \
        "2" "Backup completo del sistema (PBS, backup-client)" \
        "3" "Backup modular al PBS (checklist)" \
        "4" "Backup mÃ­nimo automÃ¡tico (tar.gz, local)" \
        "5" "Salir" 3>&1 1>&2 2>&3)

    case "$OPTION" in
        "1") backup_local_tar_checklist ;;
        "2") backup_full_pbs_root ;;
        "3") backup_modular_pbs_checklist ;;
        "4") backup_min_local_tar ;;
        "5") clear; exit 0 ;;
    esac
}

backup_local_tar_checklist() {
    BACKUP_DIR=$(whiptail --inputbox "Â¿DÃ³nde guardar el backup local? (por defecto /root/backups)" 10 60 3>&1 1>&2 2>&3)
    BACKUP_DIR="${BACKUP_DIR:-/root/backups}"
    mkdir -p "$BACKUP_DIR"

    MENU_OPTIONS=("ALL" "Respaldar todos los directorios sugeridos" OFF)
    for name in "${!BACKUP_PATHS[@]}"; do
        MENU_OPTIONS+=("$name" "${BACKUP_PATHS[$name]}" OFF)
    done

    CHOICES=$(whiptail --checklist "Selecciona los directorios a respaldar:" 20 78 12 "${MENU_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return

    SELECTED=()
    if echo "$CHOICES" | grep -q "ALL"; then
        for path in "${BACKUP_PATHS[@]}"; do SELECTED+=("$path"); done
    else
        for choice in $CHOICES; do
            key=$(echo "$choice" | tr -d '"')
            SELECTED+=("${BACKUP_PATHS[$key]}")
        done
    fi

    BACKUP_FILE="${BACKUP_DIR}/${HOSTNAME}-local-backup-${TIMESTAMP}.tar.gz"
    tar -czf "$BACKUP_FILE" --absolute-names "${SELECTED[@]}" && \
    echo -e "\\nBackup guardado en: $BACKUP_FILE" || \
    echo -e "\\nError al crear el backup local."
    read -p "Pulsa ENTER para continuar..."
}

backup_full_pbs_root() {
    proxmox-backup-client backup \\
        --include-dev /boot/efi \\
        --include-dev /etc/pve \\
        root-${HOSTNAME}.pxar:/ \\
        --repository "$PBS_REPO" && \
    echo -e "\\nBackup completo al PBS finalizado correctamente." || \
    echo -e "\\nError durante el backup completo."
    read -p "Pulsa ENTER para continuar..."
}

backup_modular_pbs_checklist() {
    MENU_OPTIONS=("ALL" "Respaldar todos los directorios sugeridos" OFF)
    for name in "${!BACKUP_PATHS[@]}"; do
        MENU_OPTIONS+=("$name" "${BACKUP_PATHS[$name]}" OFF)
    done

    CHOICES=$(whiptail --checklist "Selecciona quÃ© enviar al PBS:" 20 78 12 "${MENU_OPTIONS[@]}" 3>&1 1>&2 2>&3) || return

    SELECTED=()
    if echo "$CHOICES" | grep -q "ALL"; then
        for name in "${!BACKUP_PATHS[@]}"; do
            SELECTED+=("${name}.pxar:${BACKUP_PATHS[$name]}")
        done
    else
        for choice in $CHOICES; do
            key=$(echo "$choice" | tr -d '"')
            SELECTED+=("${key}.pxar:${BACKUP_PATHS[$key]}")
        done
    fi

    for entry in "${SELECTED[@]}"; do
        proxmox-backup-client backup "$entry" \\
            --repository "$PBS_REPO" \\
            --backup-type host \\
            --backup-id "$HOSTNAME" \\
            --backup-time "$TIMESTAMP"
    done
    echo -e "\\nBackup modular al PBS finalizado."
    read -p "Pulsa ENTER para continuar..."
}

backup_min_local_tar() {
    BACKUP_DIR="/root/backups"
    mkdir -p "$BACKUP_DIR"
    BACKUP_FILE="${BACKUP_DIR}/${HOSTNAME}-minimal-${TIMESTAMP}.tar.gz"
    tar -czf "$BACKUP_FILE" --absolute-names \
        /etc/pve /etc/network /var/lib/pve-cluster /root && \
    echo -e "\\nBackup mÃ­nimo guardado en: $BACKUP_FILE" || \
    echo -e "\\nError durante el backup mÃ­nimo."
    read -p "Pulsa ENTER para continuar..."
}

# Lanzar menÃº principal
while true; do main_menu; done
""")

from pathlib import Path

backup_script_path = Path("/mnt/data/proxmox_host_backup_menu.sh")
backup_script_path.write_text(menu_script)
backup_script_path.chmod(0o755)
backup_script_path


================================================
FILE: scripts/test/vm/create_vm.sh
================================================
[Binary file]


================================================
FILE: scripts/test/vm/disk_selector.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# Disk Selector Module - ProxMenux
# ==========================================================
# Reutiliza la lÃ³gica original de selecciÃ³n de discos
# virtuales y fÃ­sicos con integraciÃ³n de traducciones
# ==========================================================


BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

function select_disk_type() {
  DISK_TYPE=$(whiptail --backtitle "ProxMenux" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  [[ -z "$DISK_TYPE" ]] && return 1

  if [[ "$DISK_TYPE" == "virtual" ]]; then
    select_virtual_disk
  else
    select_passthrough_disk
  fi
}

# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
}
# ==========================================================


================================================
FILE: scripts/test/vm/guest_agent_config.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# Guest Agent Configurator - ProxMenux
# ==========================================================
# AÃ±ade soporte al QEMU Guest Agent y dispositivos Ãºtiles.
# Se adapta segÃºn el sistema operativo.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache



function configure_guest_agent() {
  if [[ -z "$VMID" ]]; then
    msg_error "$(translate "No VMID defined. Cannot apply guest agent config.")"
    return 1
  fi

  msg_info "$(translate "Adding QEMU Guest Agent support...")"

  # Habilitar el agente en la VM
  qm set "$VMID" -agent enabled=1 >/dev/null 2>&1

  # AÃ±adir canal de comunicaciÃ³n virtio
  qm set "$VMID" -chardev socket,id=qga0,path=/var/run/qemu-server/$VMID.qga,server=on,wait=off >/dev/null 2>&1
  qm set "$VMID" -device virtio-serial-pci -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 >/dev/null 2>&1

  msg_ok "$(translate "Guest Agent configuration applied")"

  if [[ "$OS_TYPE" == "windows" ]]; then
    echo -e "${YW}$(translate "Reminder: You must install the QEMU Guest Agent inside the Windows VM")${NC}"
    echo -e "${YW}$(translate "Tip: Also mount the VirtIO ISO for drivers and guest agent installer")${NC}"
    echo -e "${TAB}- https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/"
  elif [[ "$OS_TYPE" == "linux" || "$OS_TYPE" == "lite" ]]; then
    echo -e "${YW}$(translate "Tip: You can install the QEMU Guest Agent inside the VM with:")${NC}"
    echo -e "${TAB}apt install qemu-guest-agent -y && systemctl enable --now qemu-guest-agent"
  fi
}




================================================
FILE: scripts/test/vm/select_linux_iso.sh
================================================
#!/usr/bin/env bash

# ==============================================================
# ProxMenux - Linux ISO Selector (No download yet)
# ==============================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache



function select_linux_iso() {

ISO_DIR="/var/lib/vz/template/iso"
mkdir -p "$ISO_DIR"


DISTROS=(
  "Ubuntu 22.04 LTS Desktop|Desktop|ProxMenux|https://releases.ubuntu.com/22.04/ubuntu-22.04.4-desktop-amd64.iso"
  "Ubuntu 20.04 LTS Desktop|Desktop|ProxMenux|https://releases.ubuntu.com/20.04/ubuntu-20.04.6-desktop-amd64.iso"
  "Ubuntu 22.04 LTS Server (CLI)|CLI|ProxMenux|https://releases.ubuntu.com/22.04/ubuntu-22.04.4-live-server-amd64.iso"
  "Ubuntu 20.04 LTS Server (CLI)|CLI|ProxMenux|https://releases.ubuntu.com/20.04/ubuntu-20.04.6-live-server-amd64.iso"
  "Debian 12 Gnome (Desktop)|Desktop|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.5.0-amd64-DVD-1.iso"
  "Debian 11 Gnome (Desktop)|Desktop|ProxMenux|https://cdimage.debian.org/debian-cd/11.9.0/amd64/iso-dvd/debian-11.9.0-amd64-DVD-1.iso"
  "Debian 12 Netinst (CLI)|CLI|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-12.5.0-amd64-netinst.iso"
  "Debian 11 Netinst (CLI)|CLI|ProxMenux|https://cdimage.debian.org/debian-cd/11.9.0/amd64/iso-cd/debian-11.9.0-amd64-netinst.iso"
  "Fedora Workstation 39|Desktop|ProxMenux|https://download.fedoraproject.org/pub/fedora/linux/releases/39/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-39-1.5.iso"
  "Fedora Workstation 38|Desktop|ProxMenux|https://download.fedoraproject.org/pub/fedora/linux/releases/38/Workstation/x86_64/iso/Fedora-Workstation-Live-x86_64-38-1.6.iso"
  "Rocky Linux 9.3 Gnome|Desktop|ProxMenux|https://download.rockylinux.org/pub/rocky/9.3/isos/x86_64/Rocky-9.3-x86_64-boot.iso"
  "Rocky Linux 8.9 Gnome|Desktop|ProxMenux|https://download.rockylinux.org/pub/rocky/8.9/isos/x86_64/Rocky-8.9-x86_64-boot.iso"
  "Linux Mint 21.3 Cinnamon|Desktop|ProxMenux|https://mirrors.edge.kernel.org/linuxmint/stable/21.3/linuxmint-21.3-cinnamon-64bit.iso"
  "Linux Mint 21.2 Cinnamon|Desktop|ProxMenux|https://mirrors.edge.kernel.org/linuxmint/stable/21.2/linuxmint-21.2-cinnamon-64bit.iso"
  "openSUSE Leap 15.5|Desktop|ProxMenux|https://download.opensuse.org/distribution/leap/15.5/iso/openSUSE-Leap-15.5-DVD-x86_64.iso"
  "openSUSE Leap 15.4|Desktop|ProxMenux|https://download.opensuse.org/distribution/leap/15.4/iso/openSUSE-Leap-15.4-DVD-x86_64.iso"
  "Alpine Linux 3.19|CLI|ProxMenux|https://dl-cdn.alpinelinux.org/alpine/v3.19/releases/x86_64/alpine-standard-3.19.1-x86_64.iso"
  "Kali Linux 2024.1|Desktop|ProxMenux|https://cdimage.kali.org/kali-2024.1/kali-linux-2024.1-installer-amd64.iso"
  "Manjaro 23.1 GNOME|Desktop|ProxMenux|https://download.manjaro.org/gnome/23.1/manjaro-gnome-23.1-231017-linux65.iso"
  "Arch Linux   (automatizado)|Cloud-ini|Helper Scripts|https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/archlinux-vm.sh"
  "Debian 12    (automatizado)|Cloud-ini|Helper Scripts|https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/debian-vm.sh"
  "Ubuntu 22.04 (automatizado)|Cloud-ini|Helper Scripts|https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2204-vm.sh"
  "Ubuntu 24.04 (automatizado)|Cloud-ini|Helper Scripts|https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2404-vm.sh"
  "Ubuntu 24.10 (automatizado)|Cloud-ini|Helper Scripts|https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2410-vm.sh"
)

MENU_OPTIONS=()
INDEX=0
for entry in "${DISTROS[@]}"; do
  IFS='|' read -r NAME TYPE SOURCE URL <<< "$entry"
  LINE=$(printf "%-35s â”‚ %-10s â”‚ %s" "$NAME" "$TYPE" "$SOURCE")
  MENU_OPTIONS+=("$INDEX" "$LINE")
  URLS[$INDEX]="$entry"
  ((INDEX++))
done

HEADER="%-41s â”‚ %-10s â”‚ %s"
HEADER_TEXT=$(printf "$HEADER" "     VersiÃ³n" "Tipo" "Fuente")

CHOICE=$(whiptail --title "ProxMenux - Linux ISO" \
  --menu "$(translate "Select the Linux distribution to install"):\n\n$HEADER_TEXT" 20 80 10 \
  "${MENU_OPTIONS[@]}" \
  3>&1 1>&2 2>&3)

[[ $? -ne 0 ]] && echo "Cancelled" && exit 1

SELECTED="${URLS[$CHOICE]}"
IFS='|' read -r ISO_NAME ISO_TYPE SOURCE ISO_URL <<< "$SELECTED"
ISO_FILE=$(basename "$ISO_URL")
ISO_PATH="$ISO_DIR/$ISO_FILE"

# Exportar para que los use el script principal
export ISO_NAME
export ISO_TYPE
export ISO_URL
export ISO_FILE
export ISO_PATH


}


================================================
FILE: scripts/test/vm/select_nas_iso.sh
================================================
#!/usr/bin/env bash

# ==============================================================
# ProxMenux - NAS ISO Selector
# ==============================================================

# Configuracion Base
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ISO_DIR="/var/lib/vz/template/iso"
mkdir -p "$ISO_DIR"

function select_nas_iso() {

  NAS_OPTIONS=(
    "1" "$(translate "Synology DSM VM")"
    "2" "$(translate "TrueNAS SCALE VM 24.04.2.5") (Dragonfish)"
    "3" "$(translate "TrueNAS CORE VM (FreeBSD based)")"
    "4" "$(translate "OpenMediaVault VM (Debian based)")"
    "5" "$(translate "Rockstor VM (openSUSE based)")"
  )

  NAS_TYPE=$(whiptail --title "ProxMenux - NAS Systems" --menu "$(translate "Select the NAS system to install")" 20 70 6 \
    "${NAS_OPTIONS[@]}" 3>&1 1>&2 2>&3)

  [[ $? -ne 0 ]] && echo "Cancelled." && exit 1

  case "$NAS_TYPE" in
    1)
      bash <(curl -s "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/scripts/vm/synology.sh")
      exit 0
      ;;
    2)
      ISO_NAME="TrueNAS SCALE 24.04.2.5 (Dragonfish)"
      ISO_URL="https://download.truenas.com/TrueNAS-SCALE-Dragonfish/24.04.2.5/TrueNAS-SCALE-24.04.2.5.iso"
      ISO_FILE="TrueNAS-SCALE-24.04.2.5.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      ;;
    3)
      LATEST_ISO=$(wget -qO- https://download.freenas.org/latest/x64/ | grep -oP 'href="\K[^"]+\.iso' | head -n1)
      ISO_NAME="TrueNAS CORE (Latest)"
      ISO_URL="https://download.freenas.org/latest/x64/$LATEST_ISO"
      ISO_FILE=$(basename "$LATEST_ISO")
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      ;;
    4)
      ISO_NAME="OpenMediaVault"
      ISO_URL="https://downloads.sourceforge.net/project/openmediavault/7.2.0/openmediavault_7.2.0-amd64.iso"
      ISO_FILE="openmediavault_7.2.0-amd64.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      ;;
    5)
      ISO_NAME="Rockstor"
      ISO_URL="https://rockstor.com/downloads/installer/leap/15.6/x86_64/Rockstor-Leap15.6-generic.x86_64-5.0.15-0.install.iso"
      ISO_FILE="Rockstor-Leap15.6-generic.x86_64-5.0.15-0.install.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      ;;
  esac

  export ISO_NAME
  export ISO_URL
  export ISO_FILE
  export ISO_PATH
}



================================================
FILE: scripts/test/vm/select_windows_iso.sh
================================================
#!/usr/bin/env bash

# ==============================================================
# ProxMenux - Windows ISO Selector
# ==============================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

ISO_DIR="/var/lib/vz/template/iso"
mkdir -p "$ISO_DIR"




function select_windows_iso() {
  local CHOICE=$(whiptail --title "ProxMenux - Windows ISO" --menu "$(translate "Select how to provide the Windows ISO")" 15 60 2 \
    "1" "$(translate "Use existing ISO from storage")" \
    "2" "$(translate "Download ISO using UUP Dump")" 3>&1 1>&2 2>&3)

  [[ $? -ne 0 ]] && msg_error "$(translate "Operation cancelled.")" && exit 1

  case "$CHOICE" in
    1)
      select_existing_iso
      ;;
    2)
      if [[ -f ./uupdump_creator.sh ]]; then
        source ./uupdump_creator.sh
        run_uupdump_creator || exit 1
        detect_latest_iso_created
      else
        msg_error "$(translate "UUP Dump script not found.")"
        exit 1
      fi
      ;;
  esac
}

function select_existing_iso() {
  ISO_LIST=()
  while read -r line; do
    FILENAME=$(basename "$line")
    SIZE=$(du -h "$line" | cut -f1)
    ISO_LIST+=("$FILENAME" "$SIZE")
  done < <(find "$ISO_DIR" -type f -iname "*.iso" ! -iname "virtio*" | sort)

  if [[ ${#ISO_LIST[@]} -eq 0 ]]; then
    msg_error "$(translate "No ISO images found in $ISO_DIR.")"
    exit 1
  fi

  ISO_FILE=$(whiptail --title "ProxMenux - Windows ISO" --menu "$(translate "Choose a Windows ISO to use:")" 20 70 10 "${ISO_LIST[@]}" 3>&1 1>&2 2>&3)

  if [[ -z "$ISO_FILE" ]]; then
    msg_error "$(translate "No ISO selected.")"
    exit 1
  fi

  ISO_PATH="$ISO_DIR/$ISO_FILE"
  ISO_NAME="$ISO_FILE"

  export ISO_PATH ISO_FILE ISO_NAME
}




function detect_latest_iso_created() {
  ISO_FILE=$(find "$ISO_DIR" -maxdepth 1 -type f -iname "*.iso" ! -iname "virtio*" -printf "%T@ %p\n" | sort -n | awk '{print $2}' | tail -n 1)

  if [[ -z "$ISO_FILE" ]]; then
    msg_error "$(translate "No ISO file detected after UUP Dump process.")"
    exit 1
  fi

  ISO_NAME=$(basename "$ISO_FILE")
  ISO_PATH="$ISO_FILE"

  export ISO_PATH ISO_FILE ISO_NAME
}




================================================
FILE: scripts/test/vm/synology4.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Synology DSM VM Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 13/03/2025
# ==========================================================
# Description:
# This script automates the creation and configuration of a Synology DSM 
# (DiskStation Manager) virtual machine (VM) in Proxmox VE. It simplifies the
# setup process by allowing both default and advanced configuration options.
#
# The script automates the complete VM creation process, including loader 
# download, disk configuration, and VM boot setup.
#
# **Credits**
# This script is an original idea but incorporates ideas and elements from 
# a similar script by user **tim104979** from the ProxmoxVE branch:
# (https://raw.githubusercontent.com/tim104979/ProxmoxVE/refs/heads/main/vm/synology-vm.sh)
#
# Copyright (c) Proxmox VE Helper-Scripts Community
# License: MIT | https://github.com/community-scripts/ProxmoxVE/raw/main/LICENSE
#
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

GEN_MAC="02"
for i in {1..5}; do
  BYTE=$(printf "%02X" $((RANDOM % 256)))
  GEN_MAC="${GEN_MAC}:${BYTE}"
done

NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
NAME="Synology VM"
IMAGES_DIR="/var/lib/vz/template/iso"
ERROR_FLAG=false





function exit_script() {
  clear
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
}


# Define the header_info function at the beginning of the script

function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}              Synology VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}
# ==========================================================






# ==========================================================
# start Script
# ==========================================================
function start_script() {
  if (whiptail --backtitle "ProxMenuX" --title "SETTINGS" --yesno "$(translate  "Use Default Settings?")" --no-button Advanced 10 58); then
    header_info
    echo -e "${DEF}Using Default Settings${CL}"
    default_settings
  else
    header_info
    echo -e "${CUS}Using Advanced Settings${CL}"
    advanced_settings
  fi
}
# ==========================================================




# ==========================================================
# Default Settings
# ==========================================================
function default_settings() {
  VMID="$NEXTID"
  FORMAT=""
  MACHINE=" -machine q35"
  BIOS_TYPE=" -bios ovmf"
  DISK_CACHE=""
  HN="Synology-DSM"
  CPU_TYPE=" -cpu host"
  CORE_COUNT="2"
  RAM_SIZE="4096"
  BRG="vmbr0"
  MAC="$GEN_MAC"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  START_VM="no"
  
  echo -e " ${TAB}${DGN}Using Virtual Machine ID: ${BGN}${VMID}${CL}"
  echo -e " ${TAB}${DGN}Using Machine Type: ${BGN}q35${CL}"
  echo -e " ${TAB}${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
  echo -e " ${TAB}${DGN}Using Hostname: ${BGN}${HN}${CL}"
  echo -e " ${TAB}${DGN}Using CPU Model: ${BGN}Host${CL}"
  echo -e " ${TAB}${DGN}Allocated Cores: ${BGN}${CORE_COUNT}${CL}"
  echo -e " ${TAB}${DGN}Allocated RAM: ${BGN}${RAM_SIZE}${CL}"
  echo -e " ${TAB}${DGN}Using Bridge: ${BGN}${BRG}${CL}"
  echo -e " ${TAB}${DGN}Using MAC Address: ${BGN}${MAC}${CL}"
  echo -e " ${TAB}${DGN}Using VLAN: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Using Interface MTU Size: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Configuring Serial Port: ${BGN}${SERIAL_PORT}${CL}"
  echo -e " ${TAB}${DGN}Start VM when completed: ${BGN}${START_VM}${CL}"
  echo -e
  echo -e "${DEF}Creating a $NAME using the above default settings${CL}"
 
  sleep 1
  select_disk_type
}
# ==========================================================





# ==========================================================
# advanced Settings
# ==========================================================
function advanced_settings() {
  # VM ID Selection
  while true; do
    if VMID=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 $NEXTID --title "VIRTUAL MACHINE ID" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
      if [ -z "$VMID" ]; then
        VMID="$NEXTID"
      fi
      if pct status "$VMID" &>/dev/null || qm status "$VMID" &>/dev/null; then
        echo -e "${CROSS}${RD} ID $VMID is already in use${CL}"
        sleep 1
        continue
      fi
      echo -e "${DGN}Virtual Machine ID: ${BGN}$VMID${CL}"
      break
    else
      exit_script
    fi
  done

  # Machine Type Selection
  if MACH=$(whiptail --backtitle "ProxMenuX" --title "$(translate "MACHINE TYPE")" --radiolist --cancel-button Exit-Script "Choose Type" 10 58 2 \
    "q35" "Machine q35" ON \
    "i440fx" "Machine i440fx" OFF \
    3>&1 1>&2 2>&3); then
    if [ $MACH = q35 ]; then
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=""
      MACHINE=" -machine q35"
    else
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=",efitype=4m"
      MACHINE=""
    fi
  else
    exit_script
  fi

    # BIOS Type Selection 
  if BIOS=$(whiptail --backtitle "ProxMenuX" --title "$(translate "BIOS TYPE")" --radiolist --cancel-button Exit-Script "Choose BIOS Type" 10 58 2 \
    "ovmf" "UEFI (OVMF)" ON \
    "seabios" "SeaBIOS (Legacy)" OFF \
    3>&1 1>&2 2>&3); then
    if [ "$BIOS" = "seabios" ]; then
        echo -e "${DGN}Using BIOS Type: ${BGN}SeaBIOS${CL}"
        BIOS_TYPE=" -bios seabios"
    else
        echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
        BIOS_TYPE=" -bios ovmf"
    fi
  else
    exit_script
   fi

  # Hostname Selection
  if VM_NAME=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Hostname")" 8 58 Synology-DSM --title "HOSTNAME" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VM_NAME ]; then
      HN="Synology-DSM"
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    else
      HN=$(echo ${VM_NAME,,} | tr -d ' ')
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    fi
  else
    exit_script
  fi

  # CPU Type Selection 
  if CPU_TYPE1=$(whiptail --backtitle "ProxMenuX" --title "$(translate "CPU MODEL")" --radiolist "Choose" --cancel-button Exit-Script 10 58 2 \
    "1" "Host" ON \
    "0" "KVM64" OFF \
    3>&1 1>&2 2>&3); then
    if [ $CPU_TYPE1 = "1" ]; then
      echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
      CPU_TYPE=" -cpu host"
    else
      echo -e "${DGN}Using CPU Model: ${BGN}KVM64${CL}"
      CPU_TYPE=""
    fi
  else
    exit_script
  fi

  # Core Count Selection
  if CORE_COUNT=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate CPU Cores")" 8 58 2 --title "CORE COUNT" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $CORE_COUNT ]; then
      CORE_COUNT="2"
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    else
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    fi
  else
    exit_script
  fi

  # RAM Size Selection
  if RAM_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate RAM in MiB")" 8 58 4096 --title "RAM" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $RAM_SIZE ]; then
      RAM_SIZE="4096"
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    else
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    fi
  else
    exit_script
  fi

  # Bridge Selection
  if BRG=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Bridge")" 8 58 vmbr0 --title "BRIDGE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $BRG ]; then
      BRG="vmbr0"
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    else
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    fi
  else
    exit_script
  fi

  # MAC Address Selection
  if MAC1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a MAC Address")" 8 58 $GEN_MAC --title "MAC ADDRESS" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MAC1 ]; then
      MAC="$GEN_MAC"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC${CL}"
    else
      MAC="$MAC1"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC1${CL}"
    fi
  else
    exit_script
  fi

  # VLAN Selection
  if VLAN1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Vlan(leave blank for default)")" 8 58 --title "VLAN" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VLAN1 ]; then
      VLAN1="Default"
      VLAN=""
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    else
      VLAN=",tag=$VLAN1"
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    fi
  else
    exit_script
  fi

  # MTU Selection
  if MTU1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Interface MTU Size (leave blank for default)")" 8 58 --title "MTU SIZE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MTU1 ]; then
      MTU1="Default"
      MTU=""
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    else
      MTU=",mtu=$MTU1"
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    fi
  else
    exit_script
  fi



  # Confirmation
  if (whiptail --backtitle "ProxMenuX" --title "$(translate "ADVANCED SETTINGS COMPLETE")" --yesno "Ready to create a $NAME?" --no-button Do-Over 10 58); then
    echo -e
    echo -e "${CUS}Creating a $NAME using the above advanced settings${CL}"
    sleep 1
    select_disk_type
  else
   header_info
   sleep 1
   echo -e "${CUS}Using Advanced Settings${CL}"
   advanced_settings
  fi
}
# ==========================================================





# ==========================================================
# Select Disk
# ==========================================================
function select_disk_type() {

  DISK_TYPE=$(whiptail --backtitle "ProxMenuX" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  EXIT_STATUS=$?

  if [[ $EXIT_STATUS -ne 0 ]]; then
      clear
      header_info
      msg_error "Operation cancelled by user. Returning to start scrip..."
      sleep 2
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
  fi

  if [[ "$DISK_TYPE" == "virtual" ]]; then
      select_virtual_disk
  else
      select_passthrough_disk
  fi
}

# ==========================================================





# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


  select_loader
}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
  select_loader
}
# ==========================================================






# ==========================================================
# Select Loader
# ==========================================================
function select_loader() {
  # Ensure the images directory exists
  if [ ! -d "$IMAGES_DIR" ]; then
    msg_info "Creating images directory"
    mkdir -p "$IMAGES_DIR"
    chmod 755 "$IMAGES_DIR"
    msg_ok "Images directory created: $IMAGES_DIR"
  fi

  # Create the loader selection menu
  LOADER_OPTION=$(whiptail --backtitle "ProxMenuX" --title "SELECT LOADER" --menu "$(translate "Choose a loader for Synology DSM:")" 15 70 4 \
    "1" "AuxXxilium Arc Loader" \
    "2" "RedPill Loader (RROrg - RR)" \
    "3" "TinyCore RedPill Loader (PeterSuh-Q3 M-shell)" \
    "4" "Custom Loader Image (from $IMAGES_DIR)" \
    3>&1 1>&2 2>&3)

  if [ -z "$LOADER_OPTION" ]; then
    exit_script
  fi

  case $LOADER_OPTION in
    1)
      LOADER_TYPE="arc"
      LOADER_NAME="AuxXxilium Arc"
      LOADER_URL="https://github.com/AuxXxilium/arc/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    2)
      LOADER_TYPE="redpill"
      LOADER_NAME="RedPill RR"
      LOADER_URL="https://github.com/RROrg/rr/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    3)
      LOADER_TYPE="tinycore"
      LOADER_NAME="TinyCore RedPill M-shell"
      LOADER_URL="https://github.com/PeterSuh-Q3/tinycore-redpill/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    4)
      LOADER_TYPE="custom"
      LOADER_NAME="Custom Image"
      LOADER_URL="https://xpenology.com/forum/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      select_custom_image
      ;;
  esac
}

function select_custom_image() {
  # Check if there are any images in the directory
  IMAGES=$(find "$IMAGES_DIR" -type f -name "*.img" -o -name "*.iso" -o -name "*.qcow2" -o -name "*.vmdk" | sort)
  
  if [ -z "$IMAGES" ]; then
    whiptail --title "$(translate "No Images Found")" --msgbox "No compatible images found in $IMAGES_DIR\n\nSupported formats: .img, .iso, .qcow2, .vmdk\n\nPlease add some images and try again." 15 70
    select_loader
  fi
  
  # Create an array of image options for whiptail
  IMAGE_OPTIONS=()

  while read -r img; do
    filename=$(basename "$img")
    filesize=$(du -h "$img" | cut -f1)
    IMAGE_OPTIONS+=("$img" "$filesize")
  done <<< "$IMAGES"
  
  # Let the user select an image
  LOADER_FILE=$(whiptail --backtitle "ProxMenuX" --title "SELECT CUSTOM IMAGE" --menu "$(translate "Choose a custom image:")" 20 70 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
  
  if [ -z "$LOADER_FILE" ]; then
    msg_error "No custom image selected"
    exit_script
  fi
  
  echo -e "${DGN}${TAB}Using Custom Image: ${BGN}$(basename "$LOADER_FILE")${CL}"
  FILE=$(basename "$LOADER_FILE")
}
# ==========================================================







# ==========================================================
# Download Loader
# ==========================================================
function download_loader() {

  echo -e "${DGN}${TAB}Retrieving the URL for the ${BGN}$LOADER_NAME loader${CL}"

  if [[ "$LOADER_TYPE" == "arc" || "$LOADER_TYPE" == "redpill" ]] && ! command -v unzip &> /dev/null; then
    msg_info "Installing unzip..."
    apt-get update -qq && apt-get install -y unzip -qq >/dev/null 2>&1
    if ! command -v unzip &> /dev/null; then
      msg_error "Failed to install unzip"
      sleep 2
      return 1
    fi
    msg_ok "Installed unzip successfully."
  fi
  
  case $LOADER_TYPE in
    arc)
      curl -s https://api.github.com/repos/AuxXxilium/arc/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/arc.img.zip"
      
      if [ -f "$IMAGES_DIR/arc.img.zip" ]; then
        cd "$IMAGES_DIR"
        unzip -q arc.img.zip
        rm arc.img.zip
        FILE="arc.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null
      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
      fi
      ;;
      
    redpill)
      curl -s https://api.github.com/repos/RROrg/rr/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/rr.img.zip"

      if [ -f "$IMAGES_DIR/rr.img.zip" ]; then
          cd "$IMAGES_DIR"
          msg_info "Unzipping $LOADER_NAME loader. Please wait..."
          unzip -qo rr.img.zip
          msg_ok "Unzipped $LOADER_NAME loader successfully."
          rm -f rr.img.zip
          FILE="rr.img"
          LOADER_FILE="$IMAGES_DIR/$FILE"
          cd - > /dev/null
      fi

      ;;
      
    tinycore)
      curl -s https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest \
      | grep "browser_download_url.*tinycore-redpill.v.*img.gz" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/tinycore.img.gz"
      
      if [ -f "$IMAGES_DIR/tinycore.img.gz" ]; then
        cd "$IMAGES_DIR"

        msg_info "Unzipping $LOADER_NAME loader. Please wait..."
        gunzip -f tinycore.img.gz 2> /dev/null
        msg_ok "Unzipped $LOADER_NAME loader successfully."
        FILE="tinycore.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null

      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
        
      fi
      ;;
  esac
  
  msg_ok "Downloaded ${CL}${BL}${FILE}${CL} to ${IMAGES_DIR}"
}
# =======================================================





# ==========================================================
# Select UEFI Storage 
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location for EFI disk."

  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}

  else
    kill $SPINNER_PID > /dev/null
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "EFI Disk Storage" --radiolist \
        "$(translate "Choose the storage volume for the EFI disk (4MB):\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 

    done

  fi
  
  echo "$STORAGE"
}
# ==========================================================





# ==========================================================
# Select Storage Loader 
# ==========================================================
function select_storage_volume() {
  local vmid=$1
  local purpose=$2
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location."
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "Storage Pools" --radiolist \
        "$(translate "Choose the storage volume for $purpose:\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit
    done
  fi
  
  echo "$STORAGE"
}






# ==========================================================
# Create VM
# ==========================================================
function create_vm() {

  # Create the VM
  qm create $VMID -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} -cores $CORE_COUNT -memory $RAM_SIZE \
    -name $HN -tags proxmenux -net0 virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU -onboot 1 -ostype l26 -scsihw virtio-scsi-pci \
    -serial0 socket
  msg_ok "Create a $NAME"


 
# Check if UEFI (OVMF) is being used ===================
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then

    msg_info "Configuring EFI disk"
    EFI_STORAGE=$(select_efi_storage $VMID)
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    
    # Determine storage type and extension
    STORAGE_TYPE=$(pvesm status -storage $EFI_STORAGE | awk 'NR>1 {print $2}')
    case $STORAGE_TYPE in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac
    
    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    EFI_DISK_ID="efidisk0"

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:4,efitype=4m,format=raw,pre-enrolled-keys=0" >/dev/null 2>&1; then
            msg_ok "EFI disk created (raw) and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
        else
            msg_error "Failed to configure EFI disk"
            ERROR_FLAG=true
        fi
    else
 
        EFI_DISK_NAME="vm-${VMID}-disk-efivars"
        EFI_DISK_EXT=""
        EFI_DISK_REF=""

        if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME" 4M >/dev/null 2>&1; then
            if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:${EFI_DISK_NAME},pre-enrolled-keys=0" >/dev/null 2>&1; then
                msg_ok "EFI disk created and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
            else
                msg_error "Failed to configure EFI disk"
                ERROR_FLAG=true
            fi
        else
            msg_error "Failed to create EFI disk"
            ERROR_FLAG=true
        fi
    fi


  fi
# ==========================================================


# Select storage volume for loader =======================

    LOADER_STORAGE=$(select_storage_volume $VMID "loader disk")
      

    #Run the command in the background and capture its PID
    qm importdisk $VMID ${LOADER_FILE} $LOADER_STORAGE > /tmp/import_log_$VMID.txt 2>&1 &
    import_pid=$!

    # Show a simple progress indicator
    echo -n "Importing loader disk: "
    while kill -0 $import_pid 2>/dev/null; do
        echo -n "."
        sleep 2.5
    done

    wait $import_pid
    rm -f /tmp/import_log_$VMID.txt

    IMPORTED_DISK=$(qm config $VMID | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)

    # If the disk was not imported correctly, show an error message but continue
    if [ -z "$IMPORTED_DISK" ]; then
          msg_error "Loader import failed. No disk detected."
          ERROR_FLAG=true
      else
          msg_ok "Loader imported successfully to ${CL}${BL}$LOADER_STORAGE${GN}${CL}"
    fi




    STORAGE_TYPE=$(pvesm status -storage "$LOADER_STORAGE" | awk 'NR>1 {print $2}')

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
        # Recuperar el disco importado como unused
        IMPORTED_DISK=$(qm config $VMID | grep -oP 'unused\d+:\K.*')
        if [[ -n "$IMPORTED_DISK" ]]; then
            if qm set "$VMID" -ide0 "$IMPORTED_DISK" >/dev/null 2>&1; then
                msg_ok "Configured loader disk as ide0"
                # Eliminar entrada unused
                UNUSED_ID=$(qm config $VMID | grep -oP '(unused\d+):' | cut -d: -f1)
                qm set "$VMID" -delete "$UNUSED_ID" >/dev/null 2>&1
            else
                msg_error "Failed to assign loader disk to ide0"
                ERROR_FLAG=true
            fi
        else
            msg_error "Loader import failed. No disk detected."
            ERROR_FLAG=true
        fi
    else
        # Para LVM/ZFS, usar el nombre fijo como hasta ahora
        DISK_NAME="vm-${VMID}-disk-0"
        if qm set "$VMID" -ide0 "$LOADER_STORAGE:${DISK_NAME}" >/dev/null 2>&1; then
            msg_ok "Configured loader disk as ide0"
        else
            msg_error "Failed to assign loader disk"
            ERROR_FLAG=true
        fi
    fi


    result=$(qm set "$VMID" -boot order=ide0 2>&1)
    if [[ $? -eq 0 ]]; then
          msg_ok "Loader configured as boot device."
      else
          ERROR_FLAG=true
    fi

# ==========================================================

if [ "$DISK_TYPE" = "virtual" ]; then
    if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "No virtual disks configured."
        exit_script
    fi

    DISK_INFO=""
    CONSOLE_DISK_INFO=""

    for i in "${!VIRTUAL_DISKS[@]}"; do
        IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
        
        STORAGE_TYPE=$(pvesm status -storage $STORAGE | awk 'NR>1 {print $2}')
        case $STORAGE_TYPE in
            nfs | dir)
                DISK_EXT=".raw"
                DISK_REF="$VMID/"
                ;;
            *)
                DISK_EXT=""
                DISK_REF=""
                ;;
        esac
        

        DISK_NUM=$((i+1))
        DISK_NAME="vm-${VMID}-disk-${DISK_NUM}${DISK_EXT}"

        
        # Create virtual disk
		STORAGE_TYPE=$(pvesm status -storage "$STORAGE" | awk 'NR>1 {print $2}')
		SATA_ID="sata$i"
		DISK_NUM=$((i+1))

		if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
			# MÃ©todo alternativo para BTRFS o similares â†’ usa format=raw directamente
			msg_info "Creating virtual disk (format=raw) for $STORAGE_TYPE..."
			if ! qm set "$VMID" -$SATA_ID "$STORAGE:$SIZE,format=raw" >/dev/null 2>&1; then
				msg_error "Failed to assign disk $DISK_NUM ($SATA_ID) on $STORAGE"
				ERROR_FLAG=true
				continue
			fi
		else
			# MÃ©todo estÃ¡ndar para LVM/ZFS
			msg_info "Allocating virtual disk for $STORAGE_TYPE..."
			if ! pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME" "$SIZE"G >/dev/null 2>&1; then
				msg_error "Failed to allocate virtual disk $DISK_NUM"
				ERROR_FLAG=true
				continue
			fi
			if ! qm set "$VMID" -$SATA_ID "$STORAGE:${DISK_REF}$DISK_NAME" >/dev/null 2>&1; then
				msg_error "Failed to configure virtual disk as $SATA_ID"
				ERROR_FLAG=true
				continue
			fi
		fi

		msg_ok "Configured virtual disk as $SATA_ID, ${SIZE}GB on ${CL}${BL}$STORAGE${CL} ${GN}"

        
        # Add information to the description
        DISK_INFO="${DISK_INFO}<p>Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE}</p>"
        CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} ($SATA_ID)\n"
    done
    

    
    # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"
    
    msg_info "Setting VM description"
    if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
        msg_error "Failed to set VM description"
        exit_script
    fi
    msg_ok "Configured VM description"


else


      # Configure multiple passthrough disks
      DISK_INFO=""
      CONSOLE_DISK_INFO=""

      for i in "${!PASSTHROUGH_DISKS[@]}"; do
          DISK="${PASSTHROUGH_DISKS[$i]}"
          DISK_MODEL=$(lsblk -ndo MODEL "$DISK" | xargs)
          DISK_SIZE=$(lsblk -ndo SIZE "$DISK" | xargs)
          DISK_ID="sata$i"
          

          result=$(qm set $VMID -${DISK_ID} ${DISK} 2>&1)
          if [[ $? -eq 0 ]]; then
              msg_ok "Configured disk ${CL}${BL}($DISK_MODEL $DISK_SIZE)${CL}${GN} as $DISK_ID"
          fi
          # Add information to the description
          DISK_INFO="${DISK_INFO}<p>Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE)</p>"
          CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE) (${DISK_ID})\n"
      done


      # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"


      result=$(qm set $VMID -description "$HTML_DESC" 2>&1)
      if [[ $? -eq 0 ]]; then
         msg_ok "Configured VM description"
      fi
      

fi
  
  
if [ "$ERROR_FLAG" = true ]; then
   msg_error "VM created with errors. Check configuration." 
else
msg_success "$(translate "Completed Successfully!")"

echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
echo -e "${TAB}1. $(translate "Start the VM")"
echo -e "${TAB}2. $(translate "Open the VM console and wait for the loader to boot")"
echo -e "${TAB}3. $(translate "In the loader interface, follow the instructions to select your Synology model")"
echo -e "${TAB}4. $(translate "Complete the DSM installation wizard")"
echo -e "${TAB}5. $(translate "Find your device using https://finds.synology.com")"
echo -e

msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

fi
  
}

# ==========================================================



# ==========================================================
# Main execution
# ==========================================================
header_info
#echo -e "\n Loading..."
sleep 1

# Start script
if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
  start_script
else
  clear
  exit
fi

# Create VM
create_vm

# ==========================================================


================================================
FILE: scripts/test/vm/synology5.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Synology DSM VM Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 13/03/2025
# ==========================================================
# Description:
# This script automates the creation and configuration of a Synology DSM 
# (DiskStation Manager) virtual machine (VM) in Proxmox VE. It simplifies the
# setup process by allowing both default and advanced configuration options.
#
# The script automates the complete VM creation process, including loader 
# download, disk configuration, and VM boot setup.
#
# **Credits**
# This script is an original idea but incorporates ideas and elements from 
# a similar script by user **tim104979** from the ProxmoxVE branch:
# (https://raw.githubusercontent.com/tim104979/ProxmoxVE/refs/heads/main/vm/synology-vm.sh)
#
# Copyright (c) Proxmox VE Helper-Scripts Community
# License: MIT | https://github.com/community-scripts/ProxmoxVE/raw/main/LICENSE
#
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

GEN_MAC="02"
for i in {1..5}; do
  BYTE=$(printf "%02X" $((RANDOM % 256)))
  GEN_MAC="${GEN_MAC}:${BYTE}"
done

NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
NAME="Synology VM"
IMAGES_DIR="/var/lib/vz/template/iso"
ERROR_FLAG=false





function exit_script() {
  clear
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
}


# Define the header_info function at the beginning of the script

function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}              Synology VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}
# ==========================================================






# ==========================================================
# start Script
# ==========================================================
function start_script() {
  if (whiptail --backtitle "ProxMenuX" --title "SETTINGS" --yesno "$(translate  "Use Default Settings?")" --no-button Advanced 10 58); then
    header_info
    echo -e "${DEF}Using Default Settings${CL}"
    default_settings
  else
    header_info
    echo -e "${CUS}Using Advanced Settings${CL}"
    advanced_settings
  fi
}
# ==========================================================




# ==========================================================
# Default Settings
# ==========================================================
function default_settings() {
  VMID="$NEXTID"
  FORMAT=""
  MACHINE=" -machine q35"
  BIOS_TYPE=" -bios ovmf"
  DISK_CACHE=""
  HN="Synology-DSM"
  CPU_TYPE=" -cpu host"
  CORE_COUNT="2"
  RAM_SIZE="4096"
  BRG="vmbr0"
  MAC="$GEN_MAC"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  START_VM="no"
  
  echo -e " ${TAB}${DGN}Using Virtual Machine ID: ${BGN}${VMID}${CL}"
  echo -e " ${TAB}${DGN}Using Machine Type: ${BGN}q35${CL}"
  echo -e " ${TAB}${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
  echo -e " ${TAB}${DGN}Using Hostname: ${BGN}${HN}${CL}"
  echo -e " ${TAB}${DGN}Using CPU Model: ${BGN}Host${CL}"
  echo -e " ${TAB}${DGN}Allocated Cores: ${BGN}${CORE_COUNT}${CL}"
  echo -e " ${TAB}${DGN}Allocated RAM: ${BGN}${RAM_SIZE}${CL}"
  echo -e " ${TAB}${DGN}Using Bridge: ${BGN}${BRG}${CL}"
  echo -e " ${TAB}${DGN}Using MAC Address: ${BGN}${MAC}${CL}"
  echo -e " ${TAB}${DGN}Using VLAN: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Using Interface MTU Size: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Configuring Serial Port: ${BGN}${SERIAL_PORT}${CL}"
  echo -e " ${TAB}${DGN}Start VM when completed: ${BGN}${START_VM}${CL}"
  echo -e
  echo -e "${DEF}Creating a $NAME using the above default settings${CL}"
 
  sleep 1
  select_disk_type
}
# ==========================================================





# ==========================================================
# advanced Settings
# ==========================================================
function advanced_settings() {
  # VM ID Selection
  while true; do
    if VMID=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 $NEXTID --title "VIRTUAL MACHINE ID" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
      if [ -z "$VMID" ]; then
        VMID="$NEXTID"
      fi
      if pct status "$VMID" &>/dev/null || qm status "$VMID" &>/dev/null; then
        echo -e "${CROSS}${RD} ID $VMID is already in use${CL}"
        sleep 1
        continue
      fi
      echo -e "${DGN}Virtual Machine ID: ${BGN}$VMID${CL}"
      break
    else
      exit_script
    fi
  done

  # Machine Type Selection
  if MACH=$(whiptail --backtitle "ProxMenuX" --title "$(translate "MACHINE TYPE")" --radiolist --cancel-button Exit-Script "Choose Type" 10 58 2 \
    "q35" "Machine q35" ON \
    "i440fx" "Machine i440fx" OFF \
    3>&1 1>&2 2>&3); then
    if [ $MACH = q35 ]; then
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=""
      MACHINE=" -machine q35"
    else
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=",efitype=4m"
      MACHINE=""
    fi
  else
    exit_script
  fi

    # BIOS Type Selection 
  if BIOS=$(whiptail --backtitle "ProxMenuX" --title "$(translate "BIOS TYPE")" --radiolist --cancel-button Exit-Script "Choose BIOS Type" 10 58 2 \
    "ovmf" "UEFI (OVMF)" ON \
    "seabios" "SeaBIOS (Legacy)" OFF \
    3>&1 1>&2 2>&3); then
    if [ "$BIOS" = "seabios" ]; then
        echo -e "${DGN}Using BIOS Type: ${BGN}SeaBIOS${CL}"
        BIOS_TYPE=" -bios seabios"
    else
        echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
        BIOS_TYPE=" -bios ovmf"
    fi
  else
    exit_script
   fi

  # Hostname Selection
  if VM_NAME=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Hostname")" 8 58 Synology-DSM --title "HOSTNAME" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VM_NAME ]; then
      HN="Synology-DSM"
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    else
      HN=$(echo ${VM_NAME,,} | tr -d ' ')
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    fi
  else
    exit_script
  fi

  # CPU Type Selection 
  if CPU_TYPE1=$(whiptail --backtitle "ProxMenuX" --title "$(translate "CPU MODEL")" --radiolist "Choose" --cancel-button Exit-Script 10 58 2 \
    "1" "Host" ON \
    "0" "KVM64" OFF \
    3>&1 1>&2 2>&3); then
    if [ $CPU_TYPE1 = "1" ]; then
      echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
      CPU_TYPE=" -cpu host"
    else
      echo -e "${DGN}Using CPU Model: ${BGN}KVM64${CL}"
      CPU_TYPE=""
    fi
  else
    exit_script
  fi

  # Core Count Selection
  if CORE_COUNT=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate CPU Cores")" 8 58 2 --title "CORE COUNT" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $CORE_COUNT ]; then
      CORE_COUNT="2"
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    else
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    fi
  else
    exit_script
  fi

  # RAM Size Selection
  if RAM_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate RAM in MiB")" 8 58 4096 --title "RAM" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $RAM_SIZE ]; then
      RAM_SIZE="4096"
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    else
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    fi
  else
    exit_script
  fi

  # Bridge Selection
  if BRG=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Bridge")" 8 58 vmbr0 --title "BRIDGE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $BRG ]; then
      BRG="vmbr0"
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    else
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    fi
  else
    exit_script
  fi

  # MAC Address Selection
  if MAC1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a MAC Address")" 8 58 $GEN_MAC --title "MAC ADDRESS" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MAC1 ]; then
      MAC="$GEN_MAC"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC${CL}"
    else
      MAC="$MAC1"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC1${CL}"
    fi
  else
    exit_script
  fi

  # VLAN Selection
  if VLAN1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Vlan(leave blank for default)")" 8 58 --title "VLAN" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VLAN1 ]; then
      VLAN1="Default"
      VLAN=""
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    else
      VLAN=",tag=$VLAN1"
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    fi
  else
    exit_script
  fi

  # MTU Selection
  if MTU1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Interface MTU Size (leave blank for default)")" 8 58 --title "MTU SIZE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MTU1 ]; then
      MTU1="Default"
      MTU=""
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    else
      MTU=",mtu=$MTU1"
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    fi
  else
    exit_script
  fi



  # Confirmation
  if (whiptail --backtitle "ProxMenuX" --title "$(translate "ADVANCED SETTINGS COMPLETE")" --yesno "Ready to create a $NAME?" --no-button Do-Over 10 58); then
    echo -e
    echo -e "${CUS}Creating a $NAME using the above advanced settings${CL}"
    sleep 1
    select_disk_type
  else
   header_info
   sleep 1
   echo -e "${CUS}Using Advanced Settings${CL}"
   advanced_settings
  fi
}
# ==========================================================





# ==========================================================
# Select Disk
# ==========================================================
function select_disk_type() {

  DISK_TYPE=$(whiptail --backtitle "ProxMenuX" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  EXIT_STATUS=$?

  if [[ $EXIT_STATUS -ne 0 ]]; then
      clear
      header_info
      msg_error "Operation cancelled by user. Returning to start scrip..."
      sleep 2
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
  fi

  if [[ "$DISK_TYPE" == "virtual" ]]; then
      select_virtual_disk
  else
      select_passthrough_disk
  fi
}

# ==========================================================





# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


  select_loader
}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
  select_loader
}
# ==========================================================






# ==========================================================
# Select Loader
# ==========================================================
function select_loader() {
  # Ensure the images directory exists
  if [ ! -d "$IMAGES_DIR" ]; then
    msg_info "Creating images directory"
    mkdir -p "$IMAGES_DIR"
    chmod 755 "$IMAGES_DIR"
    msg_ok "Images directory created: $IMAGES_DIR"
  fi

  # Create the loader selection menu
  LOADER_OPTION=$(whiptail --backtitle "ProxMenuX" --title "SELECT LOADER" --menu "$(translate "Choose a loader for Synology DSM:")" 15 70 4 \
    "1" "AuxXxilium Arc Loader" \
    "2" "RedPill Loader (RROrg - RR)" \
    "3" "TinyCore RedPill Loader (PeterSuh-Q3 M-shell)" \
    "4" "Custom Loader Image (from $IMAGES_DIR)" \
    3>&1 1>&2 2>&3)

  if [ -z "$LOADER_OPTION" ]; then
    exit_script
  fi

  case $LOADER_OPTION in
    1)
      LOADER_TYPE="arc"
      LOADER_NAME="AuxXxilium Arc"
      LOADER_URL="https://github.com/AuxXxilium/arc/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    2)
      LOADER_TYPE="redpill"
      LOADER_NAME="RedPill RR"
      LOADER_URL="https://github.com/RROrg/rr/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    3)
      LOADER_TYPE="tinycore"
      LOADER_NAME="TinyCore RedPill M-shell"
      LOADER_URL="https://github.com/PeterSuh-Q3/tinycore-redpill/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    4)
      LOADER_TYPE="custom"
      LOADER_NAME="Custom Image"
      LOADER_URL="https://xpenology.com/forum/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      select_custom_image
      ;;
  esac
}

function select_custom_image() {
  # Check if there are any images in the directory
  IMAGES=$(find "$IMAGES_DIR" -type f -name "*.img" -o -name "*.iso" -o -name "*.qcow2" -o -name "*.vmdk" | sort)
  
  if [ -z "$IMAGES" ]; then
    whiptail --title "$(translate "No Images Found")" --msgbox "No compatible images found in $IMAGES_DIR\n\nSupported formats: .img, .iso, .qcow2, .vmdk\n\nPlease add some images and try again." 15 70
    select_loader
  fi
  
  # Create an array of image options for whiptail
  IMAGE_OPTIONS=()

  while read -r img; do
    filename=$(basename "$img")
    filesize=$(du -h "$img" | cut -f1)
    IMAGE_OPTIONS+=("$img" "$filesize")
  done <<< "$IMAGES"
  
  # Let the user select an image
  LOADER_FILE=$(whiptail --backtitle "ProxMenuX" --title "SELECT CUSTOM IMAGE" --menu "$(translate "Choose a custom image:")" 20 70 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
  
  if [ -z "$LOADER_FILE" ]; then
    msg_error "No custom image selected"
    exit_script
  fi
  
  echo -e "${DGN}${TAB}Using Custom Image: ${BGN}$(basename "$LOADER_FILE")${CL}"
  FILE=$(basename "$LOADER_FILE")
}
# ==========================================================







# ==========================================================
# Download Loader
# ==========================================================
function download_loader() {

  echo -e "${DGN}${TAB}Retrieving the URL for the ${BGN}$LOADER_NAME loader${CL}"

  if [[ "$LOADER_TYPE" == "arc" || "$LOADER_TYPE" == "redpill" ]] && ! command -v unzip &> /dev/null; then
    msg_info "Installing unzip..."
    apt-get update -qq && apt-get install -y unzip -qq >/dev/null 2>&1
    if ! command -v unzip &> /dev/null; then
      msg_error "Failed to install unzip"
      sleep 2
      return 1
    fi
    msg_ok "Installed unzip successfully."
  fi
  
  case $LOADER_TYPE in
    arc)
      curl -s https://api.github.com/repos/AuxXxilium/arc/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/arc.img.zip"
      
      if [ -f "$IMAGES_DIR/arc.img.zip" ]; then
        cd "$IMAGES_DIR"
        unzip -q arc.img.zip
        rm arc.img.zip
        FILE="arc.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null
      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
      fi
      ;;
      
    redpill)
      curl -s https://api.github.com/repos/RROrg/rr/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/rr.img.zip"

      if [ -f "$IMAGES_DIR/rr.img.zip" ]; then
          cd "$IMAGES_DIR"
          msg_info "Unzipping $LOADER_NAME loader. Please wait..."
          unzip -qo rr.img.zip
          msg_ok "Unzipped $LOADER_NAME loader successfully."
          rm -f rr.img.zip
          FILE="rr.img"
          LOADER_FILE="$IMAGES_DIR/$FILE"
          cd - > /dev/null
      fi

      ;;
      
    tinycore)
      curl -s https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest \
      | grep "browser_download_url.*tinycore-redpill.v.*img.gz" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/tinycore.img.gz"
      
      if [ -f "$IMAGES_DIR/tinycore.img.gz" ]; then
        cd "$IMAGES_DIR"

        msg_info "Unzipping $LOADER_NAME loader. Please wait..."
        gunzip -f tinycore.img.gz 2> /dev/null
        msg_ok "Unzipped $LOADER_NAME loader successfully."
        FILE="tinycore.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null

      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
        
      fi
      ;;
  esac
  
  msg_ok "Downloaded ${CL}${BL}${FILE}${CL} to ${IMAGES_DIR}"
}
# =======================================================





# ==========================================================
# Select UEFI Storage 
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location for EFI disk."

  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}

  else
    kill $SPINNER_PID > /dev/null
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "EFI Disk Storage" --radiolist \
        "$(translate "Choose the storage volume for the EFI disk (4MB):\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 

    done

  fi
  
  echo "$STORAGE"
}
# ==========================================================





# ==========================================================
# Select Storage Loader 
# ==========================================================
function select_storage_volume() {
  local vmid=$1
  local purpose=$2
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location."
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "Storage Pools" --radiolist \
        "$(translate "Choose the storage volume for $purpose:\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit
    done
  fi
  
  echo "$STORAGE"
}






# ==========================================================
# Create VM
# ==========================================================
function create_vm() {

  # Create the VM
  qm create $VMID -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} -cores $CORE_COUNT -memory $RAM_SIZE \
    -name $HN -tags proxmenux -net0 virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU -onboot 1 -ostype l26 -scsihw virtio-scsi-pci \
    -serial0 socket
  msg_ok "Create a $NAME"


 
# Check if UEFI (OVMF) is being used ===================
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then

    msg_info "Configuring EFI disk"
    EFI_STORAGE=$(select_efi_storage $VMID)
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    
    # Determine storage type and extension
    STORAGE_TYPE=$(pvesm status -storage $EFI_STORAGE | awk 'NR>1 {print $2}')
    case $STORAGE_TYPE in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac
    
    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    EFI_DISK_ID="efidisk0"

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:4,efitype=4m,format=raw,pre-enrolled-keys=0" >/dev/null 2>&1; then
            msg_ok "EFI disk created (raw) and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
        else
            msg_error "Failed to configure EFI disk"
            ERROR_FLAG=true
        fi
    else
 
        EFI_DISK_NAME="vm-${VMID}-disk-efivars"
        EFI_DISK_EXT=""
        EFI_DISK_REF=""

        if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME" 4M >/dev/null 2>&1; then
            if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:${EFI_DISK_NAME},pre-enrolled-keys=0" >/dev/null 2>&1; then
                msg_ok "EFI disk created and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
            else
                msg_error "Failed to configure EFI disk"
                ERROR_FLAG=true
            fi
        else
            msg_error "Failed to create EFI disk"
            ERROR_FLAG=true
        fi
    fi


  fi
# ==========================================================


# Select storage volume for loader =======================

    LOADER_STORAGE=$(select_storage_volume $VMID "loader disk")
      

    #Run the command in the background and capture its PID
    qm importdisk $VMID ${LOADER_FILE} $LOADER_STORAGE > /tmp/import_log_$VMID.txt 2>&1 &
    import_pid=$!

    # Show a simple progress indicator
    echo -n "Importing loader disk: "
    while kill -0 $import_pid 2>/dev/null; do
        echo -n "."
        sleep 2.5
    done

    wait $import_pid
    rm -f /tmp/import_log_$VMID.txt

    IMPORTED_DISK=$(qm config $VMID | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)

    # If the disk was not imported correctly, show an error message but continue
    if [ -z "$IMPORTED_DISK" ]; then
          msg_error "Loader import failed. No disk detected."
          ERROR_FLAG=true
      else
          msg_ok "Loader imported successfully to ${CL}${BL}$LOADER_STORAGE${GN}${CL}"
    fi




 
    STORAGE_TYPE=$(pvesm status -storage "$LOADER_STORAGE" | awk 'NR>1 {print $2}')

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        UNUSED_LINE=$(qm config "$VMID" | grep -E '^unused[0-9]+:')
        IMPORTED_ID=$(echo "$UNUSED_LINE" | cut -d: -f1)
        IMPORTED_REF=$(echo "$UNUSED_LINE" | cut -d: -f2- | xargs)

        if [[ -n "$IMPORTED_REF" && -n "$IMPORTED_ID" ]]; then
            if qm set "$VMID" -ide0 "$IMPORTED_REF" >/dev/null 2>&1; then
                msg_ok "Configured loader disk as ide0"
                qm set "$VMID" -delete "$IMPORTED_ID" >/dev/null 2>&1
            else
                msg_error "Failed to assign loader disk to ide0"
                ERROR_FLAG=true
            fi
        else
            msg_error "Loader import failed. No disk detected in config."
            ERROR_FLAG=true
        fi
    else

        DISK_NAME="vm-${VMID}-disk-0"
        if qm set "$VMID" -ide0 "$LOADER_STORAGE:${DISK_NAME}" >/dev/null 2>&1; then
            msg_ok "Configured loader disk as ide0"
        else
            msg_error "Failed to assign loader disk"
            ERROR_FLAG=true
        fi
    fi




    result=$(qm set "$VMID" -boot order=ide0 2>&1)
    if [[ $? -eq 0 ]]; then
          msg_ok "Loader configured as boot device."
      else
          ERROR_FLAG=true
    fi

# ==========================================================

if [ "$DISK_TYPE" = "virtual" ]; then
    if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "No virtual disks configured."
        exit_script
    fi

    DISK_INFO=""
    CONSOLE_DISK_INFO=""

    for i in "${!VIRTUAL_DISKS[@]}"; do
        IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
        
        STORAGE_TYPE=$(pvesm status -storage $STORAGE | awk 'NR>1 {print $2}')
        case $STORAGE_TYPE in
            nfs | dir)
                DISK_EXT=".raw"
                DISK_REF="$VMID/"
                ;;
            *)
                DISK_EXT=""
                DISK_REF=""
                ;;
        esac
        

        DISK_NUM=$((i+1))
        DISK_NAME="vm-${VMID}-disk-${DISK_NUM}${DISK_EXT}"
        SATA_ID="sata$i"
        
        # Create virtual disk
        if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
        
          msg_info "Creating virtual disk (format=raw) for $STORAGE_TYPE..."
          if ! qm set "$VMID" -$SATA_ID "$STORAGE:$SIZE,format=raw" >/dev/null 2>&1; then
            msg_error "Failed to assign disk $DISK_NUM ($SATA_ID) on $STORAGE"
            ERROR_FLAG=true
            continue
          fi
        else

          msg_info "Allocating virtual disk for $STORAGE_TYPE..."
          if ! pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME" "$SIZE"G >/dev/null 2>&1; then
            msg_error "Failed to allocate virtual disk $DISK_NUM"
            ERROR_FLAG=true
            continue
          fi
          if ! qm set "$VMID" -$SATA_ID "$STORAGE:${DISK_REF}$DISK_NAME" >/dev/null 2>&1; then
            msg_error "Failed to configure virtual disk as $SATA_ID"
            ERROR_FLAG=true
            continue
          fi
        fi

        msg_ok "Configured virtual disk as $SATA_ID, ${SIZE}GB on ${CL}${BL}$STORAGE${CL} ${GN}"

        
        # Add information to the description
        DISK_INFO="${DISK_INFO}<p>Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE}</p>"
        CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} ($SATA_ID)\n"
    done
    

    
    # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"
    
    msg_info "Setting VM description"
    if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
        msg_error "Failed to set VM description"
        exit_script
    fi
    msg_ok "Configured VM description"


else


      # Configure multiple passthrough disks
      DISK_INFO=""
      CONSOLE_DISK_INFO=""

      for i in "${!PASSTHROUGH_DISKS[@]}"; do
          DISK="${PASSTHROUGH_DISKS[$i]}"
          DISK_MODEL=$(lsblk -ndo MODEL "$DISK" | xargs)
          DISK_SIZE=$(lsblk -ndo SIZE "$DISK" | xargs)
          DISK_ID="sata$i"
          

          result=$(qm set $VMID -${DISK_ID} ${DISK} 2>&1)
          if [[ $? -eq 0 ]]; then
              msg_ok "Configured disk ${CL}${BL}($DISK_MODEL $DISK_SIZE)${CL}${GN} as $DISK_ID"
          fi
          # Add information to the description
          DISK_INFO="${DISK_INFO}<p>Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE)</p>"
          CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE) (${DISK_ID})\n"
      done


      # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"


      result=$(qm set $VMID -description "$HTML_DESC" 2>&1)
      if [[ $? -eq 0 ]]; then
         msg_ok "Configured VM description"
      fi
      

fi
  
  
if [ "$ERROR_FLAG" = true ]; then
   msg_error "VM created with errors. Check configuration." 
else
msg_success "$(translate "Completed Successfully!")"

echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
echo -e "${TAB}1. $(translate "Start the VM")"
echo -e "${TAB}2. $(translate "Open the VM console and wait for the loader to boot")"
echo -e "${TAB}3. $(translate "In the loader interface, follow the instructions to select your Synology model")"
echo -e "${TAB}4. $(translate "Complete the DSM installation wizard")"
echo -e "${TAB}5. $(translate "Find your device using https://finds.synology.com")"
echo -e

msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

fi
  
}

# ==========================================================



# ==========================================================
# Main execution
# ==========================================================
header_info
#echo -e "\n Loading..."
sleep 1

# Start script
if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
  start_script
else
  clear
  exit
fi

# Create VM
create_vm

# ==========================================================


================================================
FILE: scripts/test/vm/uupdump_creator.sh
================================================
#!/usr/bin/env bash

# ==============================================================
# ProxMenux - Windows ISO Creator from UUP Dump
# ==============================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

function run_uupdump_creator() {

clear
show_proxmenux_logo

# ConfiguraciÃ³n de carpetas
TMP_DIR="/root/uup-temp"
OUT_DIR="/var/lib/vz/template/iso"
CONVERTER="/root/uup-converter"

mkdir -p "$TMP_DIR" "$OUT_DIR"
cd "$TMP_DIR" || exit 1

# Solicitar URL UUP Dump al usuario
UUP_URL=$(whiptail --inputbox "$(translate "Paste the UUP Dump URL here")" 10 90 3>&1 1>&2 2>&3)
[[ $? -ne 0 ]] && msg_error "$(translate "Cancelled by user.")" && exit 1

# Validar que la URL tenga los parÃ¡metros necesarios
if [[ ! "$UUP_URL" =~ id=.+\&pack=.+\&edition=.+ ]]; then
  msg_error "$(translate "The URL does not contain the required parameters (id, pack, edition).")"
  exit 1
fi

# Extraer parÃ¡metros de la URL
BUILD_ID=$(echo "$UUP_URL" | grep -oP 'id=\K[^&]+')
LANG=$(echo "$UUP_URL" | grep -oP 'pack=\K[^&]+')
EDITION=$(echo "$UUP_URL" | grep -oP 'edition=\K[^&]+')
ARCH="amd64"

echo -e "\n${BGN}=============== UUP Dump Creator ===============${CL}"
echo -e "    ${BGN}ğŸ†” ID:${CL} ${DGN}$BUILD_ID${CL}"
echo -e "    ${BGN}ğŸŒ Language:${CL} ${DGN}$LANG${CL}"
echo -e "    ${BGN}ğŸ’¿ Edition:${CL} ${DGN}$EDITION${CL}"
echo -e "    ${BGN}ğŸ–¥ï¸ Architecture:${CL} ${DGN}$ARCH${CL}"
echo -e "${BGN}===============================================${CL}\n"

# Descargar el conversor si no existe
if [[ ! -f "$CONVERTER/convert.sh" ]]; then
  echo "ğŸ“¦ $(translate "Downloading UUP converter...")"
  mkdir -p "$CONVERTER"
  cd "$CONVERTER" || exit 1
  wget -q https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz -O converter.tar.gz
  tar -xzf converter.tar.gz --strip-components=1
  chmod +x convert.sh
  cd "$TMP_DIR" || exit 1
fi

# Crear script de descarga uup_download_linux.sh
cat > uup_download_linux.sh <<EOF
#!/bin/bash
mkdir -p files
echo "https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz" > files/converter_multi

for prog in aria2c cabextract wimlib-imagex chntpw; do
  which \$prog &>/dev/null || { echo "\$prog not found."; exit 1; }
done
which genisoimage &>/dev/null || which mkisofs &>/dev/null || { echo "genisoimage/mkisofs not found."; exit 1; }

destDir="UUPs"
tempScript="aria2_script.\$RANDOM.txt"

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j2 --allow-overwrite=true --auto-file-renaming=false -d"files" -i"files/converter_multi" || exit 1

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -o"\$tempScript" --allow-overwrite=true --auto-file-renaming=false \
  "https://uupdump.net/get.php?id=$BUILD_ID&pack=$LANG&edition=$EDITION&aria2=2" || exit 1

grep '#UUPDUMP_ERROR:' "\$tempScript" && { echo "âŒ Error generating UUP download list."; exit 1; }

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j5 -c -R -d"\$destDir" -i"\$tempScript" || exit 1
EOF

chmod +x uup_download_linux.sh

# Ejecutar la descarga de archivos UUP
./uup_download_linux.sh

# Buscar carpeta UUPs descargada
UUP_FOLDER=$(find "$TMP_DIR" -type d -name "UUPs" | head -n1)
[[ -z "$UUP_FOLDER" ]] && msg_error "$(translate "No UUP folder found.")" && exit 1

# Iniciar conversiÃ³n a ISO
echo -e "\n${GN}=======================================${CL}"
echo -e "    ğŸ’¿ ${GN}Starting ISO conversion...${CL}"
echo -e "${GN}=======================================${CL}\n"

"$CONVERTER/convert.sh" wim "$UUP_FOLDER" 1

# Buscar la ISO generada
ISO_FILE=$(find "$TMP_DIR" "$CONVERTER" "$UUP_FOLDER" -maxdepth 1 -iname "*.iso" | head -n1)
if [[ -f "$ISO_FILE" ]]; then
  mv "$ISO_FILE" "$OUT_DIR/"
  msg_ok "$(translate "ISO created successfully:") $OUT_DIR/$(basename "$ISO_FILE")"

  # Limpiar temporales
  msg_ok "$(translate "Cleaning temporary files...")"
  rm -rf "$TMP_DIR" "$CONVERTER"

  export LANGUAGE=C
  export LANG=C
  export LC_ALL=C
  load_language
  initialize_cache

  msg_success "$(translate "Press Enter to return to menu...")"
  read -r
else
  msg_warn "$(translate "No ISO was generated.")"

  export LANGUAGE=C
  export LANG=C
  export LC_ALL=C
  load_language
  initialize_cache

  msg_success "$(translate "Press Enter to return to menu...")"
  read -r
fi

}


================================================
FILE: scripts/test/vm/vm_configurator.sh
================================================
#!/usr/bin/env bash

# ================================================
# VM Configuration Module - ProxMenux
# ================================================



BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

load_language
initialize_cache



function generate_mac() {
  local GEN_MAC="02"
  for i in {1..5}; do
    BYTE=$(printf "%02X" $((RANDOM % 256)))
    GEN_MAC="${GEN_MAC}:${BYTE}"
  done
  echo "$GEN_MAC"
}

function load_default_vm_config() {
  local os_type="$1"

  VMID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
  MAC=$(generate_mac)

  case "$os_type" in
    "nas")
      HN="synology-nas"
      CORE_COUNT="2"
      RAM_SIZE="8192"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
    "windows")
      HN="windows-vm"
      CORE_COUNT="4"
      RAM_SIZE="8192"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
    "linux")
      HN="linux-vm"
      CORE_COUNT="2"
      RAM_SIZE="4096"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
    "lite")
      HN="lite-vm"
      CORE_COUNT="1"
      RAM_SIZE="2048"
      MACHINE=""
      BIOS_TYPE=" -bios seabios"
      START_VM="no"
      ;;
    *)
      HN="vm-proxmenux"
      CORE_COUNT="2"
      RAM_SIZE="2048"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
  esac

  CPU_TYPE=" -cpu host"
  BRG="vmbr0"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  FORMAT=""
  DISK_CACHE=""
}

function apply_default_vm_config() {
  echo -e "${DEF}$(translate "Applying default VM configuration")${CL}"
  echo -e "${DGN}$(translate "Virtual Machine ID")${CL}: ${BGN}$VMID${CL}"
  echo -e "${DGN}$(translate "Hostname")${CL}: ${BGN}$HN${CL}"
  echo -e "${DGN}$(translate "CPU Cores")${CL}: ${BGN}$CORE_COUNT${CL}"
  echo -e "${DGN}$(translate "RAM Size")${CL}: ${BGN}$RAM_SIZE MiB${CL}"
  echo -e "${DGN}$(translate "Machine Type")${CL}: ${BGN}${MACHINE/ -machine /}${CL}"
  echo -e "${DGN}$(translate "BIOS Type")${CL}: ${BGN}${BIOS_TYPE/ -bios /}${CL}"
  echo -e "${DGN}$(translate "CPU Model")${CL}: ${BGN}${CPU_TYPE/ -cpu /}${CL}"
  echo -e "${DGN}$(translate "Network Bridge")${CL}: ${BGN}$BRG${CL}"
  echo -e "${DGN}$(translate "MAC Address")${CL}: ${BGN}$MAC${CL}"
  echo -e "${DGN}$(translate "Start VM after creation")${CL}: ${BGN}$START_VM${CL}"
  echo -e
}



function configure_vm_advanced() {
  # VMID
  while true; do
    VMID=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 "$VMID" --title "VM ID" 3>&1 1>&2 2>&3) || return
    if [ -z "$VMID" ]; then continue; fi
    if qm status "$VMID" &>/dev/null || pct status "$VMID" &>/dev/null; then
      msg_error "$(translate "ID already in use. Please choose another.")"
    else
      break
    fi
  done

  # Hostname
  HN=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set Hostname")" 8 58 "$HN" --title "Hostname" 3>&1 1>&2 2>&3) || return
  [[ -z "$HN" ]] && HN="vm-proxmenux"

  # Machine Type
  MACHINE_TYPE=$(whiptail --backtitle "ProxMenux" --title "$(translate "MACHINE TYPE")" --radiolist \
    "$(translate "Select machine type")" 10 60 2 \
    "q35"     "QEMU q35" ON \
    "i440fx"  "Legacy i440fx" OFF 3>&1 1>&2 2>&3) || return

  if [ "$MACHINE_TYPE" = "q35" ]; then
    MACHINE=" -machine q35"
    FORMAT=""
  else
    MACHINE=""
    FORMAT=",efitype=4m"
  fi

  # BIOS
  BIOS=$(whiptail --backtitle "ProxMenux" --title "$(translate "BIOS TYPE")" --radiolist \
    "$(translate "Choose BIOS type")" 10 60 2 \
    "ovmf"    "UEFI (OVMF)" ON \
    "seabios" "Legacy BIOS (SeaBIOS)" OFF 3>&1 1>&2 2>&3) || return

  BIOS_TYPE=" -bios $BIOS"

  # CPU Type
  CPU_CHOICE=$(whiptail --backtitle "ProxMenux" --title "$(translate "CPU MODEL")" --radiolist \
    "$(translate "Select CPU model")" 10 60 2 \
    "host"  "Host (recommended)" ON \
    "kvm64" "Generic KVM64" OFF 3>&1 1>&2 2>&3) || return

  if [ "$CPU_CHOICE" = "host" ]; then
    CPU_TYPE=" -cpu host"
  else
    CPU_TYPE=" -cpu kvm64"
  fi

  # Core Count
  CORE_COUNT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Number of CPU cores")" 8 58 "$CORE_COUNT" --title "CPU Cores" 3>&1 1>&2 2>&3) || return

  # RAM
  RAM_SIZE=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Amount of RAM in MiB")" 8 58 "$RAM_SIZE" --title "RAM" 3>&1 1>&2 2>&3) || return

  # Bridge
  BRG=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set network bridge")" 8 58 "$BRG" --title "Network Bridge" 3>&1 1>&2 2>&3) || return

  # MAC
  MAC_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set MAC Address (leave empty for random)")" 8 58 "$MAC" --title "MAC Address" 3>&1 1>&2 2>&3) || return
  if [[ -z "$MAC_INPUT" ]]; then
    MAC=$(generate_mac)
  else
    MAC="$MAC_INPUT"
  fi

  # VLAN
  VLAN_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set VLAN Tag (leave empty for none)")" 8 58 --title "VLAN" 3>&1 1>&2 2>&3) || return
  VLAN=""
  [[ -n "$VLAN_INPUT" ]] && VLAN=",tag=$VLAN_INPUT"

  # MTU
  MTU_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set MTU size (leave empty for default)")" 8 58 --title "MTU" 3>&1 1>&2 2>&3) || return
  MTU=""
  [[ -n "$MTU_INPUT" ]] && MTU=",mtu=$MTU_INPUT"

  # Start VM
  if (whiptail --backtitle "ProxMenux" --title "$(translate "START VM")" --yesno "$(translate "Start VM when finished?")" 10 60); then
    START_VM="yes"
  else
    START_VM="no"
  fi

  msg_ok "$(translate "Advanced configuration completed.")"
}



================================================
FILE: scripts/test/vm/vm_creator.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# VM Creator Module - ProxMenux
# ==========================================================
# Este mÃ³dulo recibe las variables globales y crea la VM
# con su configuraciÃ³n, discos y descripciÃ³n.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# FunciÃ³n para montar ISOs
# ==========================================================
function mount_iso_to_vm() {
  local vmid="$1"
  local iso_path="$2"
  local device="$3"

  if [[ -f "$iso_path" ]]; then
    local iso_basename
    iso_basename=$(basename "$iso_path")
    qm set "$vmid" -$device "local:iso/$iso_basename,media=cdrom" >/dev/null 2>&1
    msg_ok "$(translate "Mounted ISO on device") $device â†’ $iso_basename"
  else
    msg_warn "$(translate "ISO not found to mount on device") $device"
  fi
}




# ==========================================================
# Select Interface Type
# ==========================================================
function select_interface_type() {
  INTERFACE_TYPE=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Disk Interface")" --radiolist \
    "$(translate "Select the bus type for the disks:")" 15 70 4 \
    "scsi"    "$(translate "SCSI   (recommended for Linux and Windows)")" ON \
    "sata"    "$(translate "SATA   (standard - high compatibility)")" OFF \
    "virtio"  "$(translate "VirtIO (advanced - high performance)")" OFF \
    "ide"     "IDE    (legacy)" OFF \
    3>&1 1>&2 2>&3) || exit 1

  case "$INTERFACE_TYPE" in
    "scsi"|"sata")
      DISCARD_OPTS=",discard=on,ssd=on"
      ;;
    "virtio")
      DISCARD_OPTS=",discard=on"
      ;;
    "ide")
      DISCARD_OPTS=""
      ;;
  esac

  msg_ok "$(translate "Disk interface selected:") $INTERFACE_TYPE"
}


# ==========================================================
# FunciÃ³n principal para crear la VM
# ==========================================================
function create_vm() {
  local BOOT_ORDER=""
  local DISK_INFO=""
  local DISK_INDEX=0
  local ISO_DIR="/var/lib/vz/template/iso"


  # Descargar ISO si es necesario
  if [[ -n "$ISO_PATH" && -n "$ISO_URL" && ! -f "$ISO_PATH" ]]; then
    wget --no-verbose --show-progress -O "$ISO_PATH" "$ISO_URL"
    if [[ -f "$ISO_PATH" ]]; then
      msg_ok "$(translate "ISO image downloaded")"
    else
      msg_error "$(translate "Failed to download ISO image")"
      return
    fi
  fi


  # Crear la VM base primero (mÃ­nima)
  qm create "$VMID" -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} \
    -cores "$CORE_COUNT" -memory "$RAM_SIZE" -name "$HN" -tags proxmenux \
    -net0 "virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU" -ostype l26 \
    -scsihw virtio-scsi-pci -serial0 "$SERIAL_PORT"
  msg_ok "$(translate "Base VM created with ID") $VMID"


  # Crear disco EFI si corresponde
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then
    msg_info "$(translate "Configuring EFI disk")"
    EFI_STORAGE=$(select_efi_storage "$VMID")
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"

    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    case "$STORAGE_TYPE" in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac

    if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME$EFI_DISK_EXT" 4M >/dev/null 2>&1; then
      if qm set "$VMID" -efidisk0 "$EFI_STORAGE:${EFI_DISK_REF}$EFI_DISK_NAME$EFI_DISK_EXT,pre-enrolled-keys=0" >/dev/null 2>&1; then
        msg_ok "$(translate "EFI disk created and configured on") $EFI_STORAGE"
      else
        msg_error "$(translate "Failed to configure EFI disk")"
      fi
    else
      msg_error "$(translate "Failed to create EFI disk")"
    fi
  fi




# ==========================================================
# Crear discos virtuales o fÃ­sicos con interfaz seleccionada
# ==========================================================

# Primero seleccionar la interfaz
select_interface_type

  if [[ "$DISK_TYPE" == "virtual" && ${#VIRTUAL_DISKS[@]} -gt 0 ]]; then
    for i in "${!VIRTUAL_DISKS[@]}"; do
      DISK_INDEX=$((i+1))
      IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
      DISK_NAME="vm-${VMID}-disk-${DISK_INDEX}"
      SLOT_NAME="${INTERFACE_TYPE}${i}"

      STORAGE_TYPE=$(pvesm status -storage "$STORAGE" | awk 'NR>1 {print $2}')
      case "$STORAGE_TYPE" in
        dir|nfs)
          DISK_EXT=".raw"
          DISK_REF="$VMID/"
          ;;
        *)
          DISK_EXT=""
          DISK_REF=""
          ;;
      esac

      if pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME$DISK_EXT" "$SIZE"G >/dev/null 2>&1; then
        qm set "$VMID" -$SLOT_NAME "$STORAGE:${DISK_REF}${DISK_NAME}${DISK_EXT}${DISCARD_OPTS}" >/dev/null
        msg_ok "$(translate "Virtual disk") $DISK_INDEX ${SIZE}GB - $STORAGE ($SLOT_NAME)"
        DISK_INFO+="<p>Virtual Disk $DISK_INDEX: ${SIZE}GB ($STORAGE / $SLOT_NAME)</p>"
        [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
      else
        msg_error "$(translate "Failed to create disk") $DISK_INDEX"
      fi
    done
  fi

  if [[ "$DISK_TYPE" == "passthrough" && ${#PASSTHROUGH_DISKS[@]} -gt 0 ]]; then
    for i in "${!PASSTHROUGH_DISKS[@]}"; do
      SLOT_NAME="${INTERFACE_TYPE}${i}"
      DISK="${PASSTHROUGH_DISKS[$i]}"
      MODEL=$(lsblk -ndo MODEL "$DISK")
      SIZE=$(lsblk -ndo SIZE "$DISK")
      qm set "$VMID" -$SLOT_NAME "$DISK${DISCARD_OPTS}" >/dev/null 2>&1
      msg_ok "$(translate "Passthrough disk assigned") ($DISK â†’ $SLOT_NAME)"
      DISK_INFO+="<p>Passthrough Disk $((i+1)): $DISK ($MODEL $SIZE)</p>"
      [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
    done
  fi




  # Ahora montamos las ISOs
  if [[ -f "$ISO_PATH" ]]; then
    mount_iso_to_vm "$VMID" "$ISO_PATH" "ide2"
  fi

  # Para Windows, preguntar y montar ISO VirtIO
  if [[ "$OS_TYPE" == "windows" ]]; then
    local VIRTIO_DIR="/var/lib/vz/template/iso"
    local VIRTIO_SELECTED=""
    local VIRTIO_DOWNLOAD_URL="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso"

    while true; do
      VIRTIO_OPTION=$(whiptail --title "ProxMenux - VirtIO Drivers" --menu "$(translate "Select how to provide VirtIO drivers")" 15 70 2 \
        "1" "$(translate "Download latest VirtIO ISO automatically")" \
        "2" "$(translate "Use existing VirtIO ISO from storage")" 3>&1 1>&2 2>&3)

      [[ $? -ne 0 ]] && msg_warn "$(translate "VirtIO ISO selection cancelled.")" && break

      case "$VIRTIO_OPTION" in
        1)

          if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
            if whiptail --title "ProxMenux" --yesno "$(translate "A VirtIO ISO already exists. Do you want to overwrite it?")" 10 60; then
              wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
              if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
                msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
              else
                msg_error "$(translate "Failed to download VirtIO driver ISO.")"
              fi
            fi
          else
            wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
            if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
              msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
            else
              msg_error "$(translate "Failed to download VirtIO driver ISO.")"
            fi
          fi

          VIRTIO_SELECTED="$VIRTIO_DIR/virtio-win.iso"
          ;;
        2)

          VIRTIO_LIST=()
          while read -r line; do
            FILENAME=$(basename "$line")
            SIZE=$(du -h "$line" | cut -f1)
            VIRTIO_LIST+=("$FILENAME" "$SIZE")
          done < <(find "$VIRTIO_DIR" -type f -iname "virtio*.iso" | sort)

          if [[ ${#VIRTIO_LIST[@]} -eq 0 ]]; then
            msg_warn "$(translate "No VirtIO ISO found. Please download one.")"
            continue  # Volver a preguntar
          fi

          VIRTIO_FILE=$(whiptail --title "ProxMenux - VirtIO ISOs" --menu "$(translate "Select a VirtIO ISO to use:")" 20 70 10 "${VIRTIO_LIST[@]}" 3>&1 1>&2 2>&3)

          if [[ -n "$VIRTIO_FILE" ]]; then
            VIRTIO_SELECTED="$VIRTIO_DIR/$VIRTIO_FILE"
          else
            msg_warn "$(translate "No VirtIO ISO selected. Please choose again.")"
            continue
          fi
          ;;
      esac

      if [[ -n "$VIRTIO_SELECTED" && -f "$VIRTIO_SELECTED" ]]; then
        mount_iso_to_vm "$VMID" "$VIRTIO_SELECTED" "ide3"
      else
        msg_warn "$(translate "VirtIO ISO not found after selection.")"
      fi

      break
    done
  fi


  # Configurar el orden de arranque (primer disco, luego CD)
  local BOOT_FINAL="$BOOT_ORDER"
  [[ -f "$ISO_PATH" ]] && BOOT_FINAL="$BOOT_ORDER;ide2"
  qm set "$VMID" -boot order="$BOOT_FINAL" >/dev/null
  msg_ok "$(translate "Boot order set to") $BOOT_FINAL"

  # Crear descripciÃ³n
  local DESC="<div align='center'><h1>$HN</h1><p>Created with ProxMenux</p>$DISK_INFO</div>"
  qm set "$VMID" -description "$DESC" >/dev/null
  msg_ok "$(translate "VM description configured")"

  # Arrancar la VM si corresponde
  if [[ "$START_VM" == "yes" ]]; then
    qm start "$VMID"
    msg_ok "$(translate "VM started")"
  fi

  msg_success "$(translate "VM creation completed")"
}


# ==========================================================
# FunciÃ³n select_efi_storage (no cambia)
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()
  while read -r line; do
    TAG=$(echo "$line" | awk '{print $1}')
    TYPE=$(echo "$line" | awk '{printf "%-10s", $2}')
    FREE=$(echo "$line" | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf("%9sB", $6)}')
    STORAGE_MENU+=("$TAG" "Type: $TYPE Free: $FREE" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  if [ ${#STORAGE_MENU[@]} -eq 0 ]; then
    msg_error "$(translate "Unable to detect a valid storage location for EFI disk.")"
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    STORAGE=$(whiptail --backtitle "ProxMenux" --title "$(translate "EFI Disk Storage")" --radiolist \
      "$(translate "Choose the storage volume for the EFI disk (4MB):")" 16 70 6 \
      "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 1
  fi

  echo "$STORAGE"
}



================================================
FILE: scripts/utilities/proxmox-upgrade-pve8-to-pve9-manual-guide.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - Manual Proxmox VE 8 to 9 Upgrade Guide
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 13/08/2025
# ==========================================================

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

show_command() {
    local step="$1"
    local description="$2"
    local command="$3"
    local note="$4"
    local command_extra="$5"
    
    echo -e "${BGN}${step}.${CL} ${BL}${description}${CL}"
    echo ""
    echo -e "${TAB}${command}"
    echo -e
    [[ -n "$note" ]] && echo -e "${TAB}${DARK_GRAY}${note}${CL}"
    [[ -n "$command_extra" ]] && echo -e "${TAB}${YW}${command_extra}${CL}"
    echo ""
}

show_proxmox_upgrade_manual_guide() {
    clear
    show_proxmenux_logo
    msg_title "$(translate "Proxmox VE 8 to 9 Manual Upgrade Guide")"
        
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e "${TAB}${BGN}$(translate "Source:")${CL} ${BL}https://pve.proxmox.com/wiki/Upgrade_from_8_to_9${CL}"
    echo -e
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "IMPORTANT PREREQUISITES:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}â€¢ $(translate "System must be updated to latest PVE 8.4+ before starting")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Use SSH or terminal access (SSH recommended)")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Use tmux or screen to avoid interruptions")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Have valid backups of all VMs and containers")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "At least 5GB free space on root filesystem")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Do not run the upgrade from the Web UI virtual console (it will disconnect)")${CL}"
    echo -e 
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    

    show_command "1" \
        "$(translate "Update system to latest PVE 8.4+ (if not done already):")\n\n" \
        "apt update && apt dist-upgrade -y" \
        "$(translate "Or use ProxMenux update function")" \
        "\n\n"
        

    show_command "2" \
        "$(translate "Verify PVE version (must be 8.4.1 or newer):")\n\n" \
        "pveversion" \
        "" \
        "\n"


    show_command "2.1" \
        "${YW}$(translate "If this node runs hyper-converged Ceph: ensure Ceph is 19.x (Squid) BEFORE upgrading PVE.")${CL}\n\n" \
        "ceph --version" \
        "$(translate "If not 19.x, upgrade Ceph (Reefâ†’Squid) first per the official guide:") ${BL}https://pve.proxmox.com/wiki/Ceph_Squid${CL}" \
        "\n"



    show_command "3" \
        "$(translate "Run upgrade checklist script:")\n\n" \
        "pve8to9 --full" \
        "${YW}$(translate "If it warns about 'systemd-boot' meta-package, remove it:")${CL} apt remove systemd-boot" \
        "\n"
    

    show_command "4" \
        "$(translate "Start terminal multiplexer (recommended):")\n\n" \
        "tmux new-session -s upgrade    ${DARK_GRAY}$(translate "# Recommended: avoids disconnection during upgrade")${CL}\n\n    screen -S upgrade              ${DARK_GRAY}$(translate "# Alternative if you prefer screen")${CL}" \
        "" \
        "\n"
    

    show_command "5" \
        "$(translate "Update Debian repositories to Trixie:")\n\n" \
        "sed -i 's/bookworm/trixie/g' /etc/apt/sources.list" \
        "" \
        "\n"
    

    show_command "6" \
        "${YW}$(translate "Update PVE enterprise repository (Only if using enterprise):")${CL}\n\n" \
        "${CUS}sed -i 's/bookworm/trixie/g' /etc/apt/sources.list.d/pve-enterprise.list${CL}" \
        "$(translate "Skip this step if using no-subscription repository")" \
        "\n\n"
    

    show_command "7" \
        "${YW}$(translate "Add new PVE 9 enterprise repository (deb822 format) (Only if using enterprise):")${CL}\n\n" \
        "${CUS}cat > /etc/apt/sources.list.d/pve-enterprise.sources << EOF
Types: deb
URIs: https://enterprise.proxmox.com/debian/pve
Suites: trixie
Components: pve-enterprise
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF${CL}" \
        "$(translate "Only if using enterprise subscription")" \
        "\n\n"
    

    show_command "8" \
        "$(translate "OR add new PVE 9 no-subscription repository:")\n\n" \
        "cat > /etc/apt/sources.list.d/proxmox.sources << EOF
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: trixie
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF" \
        "$(translate "Only if using no-subscription repository")" \
        "\n\n"


    show_command "8.1" \
        "$(translate "Refresh APT index and verify repositories:")\n\n" \
        "apt update && apt policy | sed -n '1,120p'" \
        "$(translate "Ensure there are no errors and that proxmox-ve candidate shows 9.x")" \
        "\n"


    show_command "9" \
        "${YW}$(translate "Update Ceph repository (Only if using Ceph):")${CL}\n\n" \
        "${CUS}cat > /etc/apt/sources.list.d/ceph.sources << EOF
Types: deb
URIs: http://download.proxmox.com/debian/ceph-squid
Suites: trixie
Components: no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF${CL}" \
        "$(translate "Use enterprise URL if you have subscription.")" \
        "\n\n"
    

    show_command "10" \
        "$(translate "Remove old repository files:")\n\n" \
        "rm -f /etc/apt/sources.list.d/pve-enterprise.list /etc/apt/sources.list.d/ceph.list" \
        "$(translate "Also comment any remaining 'bookworm' entries in *.list if present.")" \
        "\n"
    

    show_command "11" \
        "$(translate "Update package index:")\n\n" \
        "apt update" \
        "" \
        "\n"
    

    show_command "12" \
        "$(translate "Disable kernel audit messages (optional but recommended):")\n\n" \
        "systemctl disable --now systemd-journald-audit.socket" \
        "" \
        "\n"
    

    show_command "13" \
        "$(translate "Start the main system upgrade:")\n\n" \
        "apt dist-upgrade" \
        "$(translate "This will take time. Answer prompts carefully - see notes below.")\n" \
        "\n"
    

    echo -e "${TAB}${BOLD}$(translate "UPGRADE PROMPTS - RECOMMENDED ANSWERS:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}/etc/issue:${CL} ${YW}$(translate "Keep current version (N)")${CL}"
    echo -e "${TAB}${BGN}/etc/lvm/lvm.conf:${CL} ${YW}$(translate "Install maintainer's version (Y)")${CL}"
    echo -e "${TAB}${BGN}/etc/ssh/sshd_config:${CL} ${YW}$(translate "Install maintainer's version (Y)")${CL}"
    echo -e "${TAB}${BGN}/etc/default/grub:${CL} ${YW}$(translate "Keep current version (N) if modified")${CL}"
    echo -e "${TAB}${BGN}/etc/chrony/chrony.conf:${CL} ${YW}$(translate "Install maintainer's version (Y)")${CL}"
    echo -e "${TAB}${BGN}$(translate "Service restarts:")${CL} ${YW}$(translate "Use default (Yes)")${CL}"
    echo -e "${TAB}${BGN}apt-listchanges:${CL} ${YW}$(translate "Press 'q' to exit")${CL}"
    echo -e 
    echo -e 
    echo -e 


    show_command "13.1" \
        "${YW}$(translate "If booting in EFI mode with root on LVM: install GRUB for EFI")${CL}\n\n" \
        "[ -d /sys/firmware/efi ] && apt install grub-efi-amd64" \
        "$(translate "Per official known issues; ensures proper boot after upgrade")" \
        "\n"


    show_command "14" \
        "$(translate "Run checklist again to verify upgrade:")\n\n" \
        "pve8to9 --full" \
        "$(translate "Should show fewer or no issues")" \
        "\n"
    

    show_command "15" \
        "$(translate "Reboot the system:")\n\n" \
        "reboot" \
        "" \
        "\n"
    

    show_command "16" \
        "$(translate "After reboot, verify PVE version:")\n\n" \
        "pveversion" \
        "$(translate "Should show pve-manager/9.x.x")" \
        "\n"
    

    show_command "17" \
        "$(translate "Optional: Modernize repository sources:")\n\n" \
        "apt modernize-sources" \
        "$(translate "Converts to deb822; keeps .list backups as .bak")" \
        "\n"
    
    echo -e "${TAB}${BL}------------------------------------------------------------------------${CL}"
    echo -e 
    echo -e 
    echo -e "${TAB}${BOLD}$(translate "CLUSTER UPGRADE NOTES:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}â€¢ $(translate "Upgrade one node at a time")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Migrate VMs away from node being upgraded")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "Wait for each node to complete before starting next")${CL}"
    echo -e "${TAB}${BGN}â€¢ $(translate "HA groups will be migrated to HA rules automatically")${CL}"
    echo -e 
    echo -e 
    
    echo -e
    echo -e "${TAB}${BOLD}$(translate "TROUBLESHOOTING:")${CL}"
    echo -e
    echo -e "${TAB}${BGN}$(translate "If GUI does not load:")${CL} ${YW}Check with 'systemctl status pveproxy' and restart with 'systemctl restart pveproxy'${CL}"
    echo -e "${TAB}${BGN}$(translate "If ZFS errors occur:")${CL} ${YW}Ensure the 'zfsutils-linux' package is up to date${CL}"
    echo -e "${TAB}${BGN}$(translate "If network does not work:")${CL} ${YW}Check /etc/network/interfaces and ensure 'ifupdown2' is installed${CL}"
    echo -e "${TAB}${BGN}$(translate "If upgrade fails:")${CL} ${YW}apt -f install${CL}"
    echo -e "${TAB}${BGN}$(translate "If repositories error:")${CL} ${YW}Check /etc/apt/sources.list*${CL}"
    echo -e "${TAB}${BGN}$(translate "If 'proxmox-ve' removal warning:")${CL} ${YW}Fix repository configuration (ensure PVE 9 repo active)${CL}"
    echo -e "${TAB}${BGN}$(translate "Emergency recovery:")${CL} ${YW}Boot from rescue system${CL}"
    echo -e
    echo -e

    
    echo -e 
    msg_success "$(translate "Press Enter to return to menu...")"
    echo -e 
    read -r
    clear
    exit 0
    #bash "$LOCAL_SCRIPTS/utilities/upgrade_pve8_to_pve9.sh"

}


# Main execution
show_proxmox_upgrade_manual_guide



================================================
FILE: scripts/utilities/proxmox_update.sh
================================================
#!/bin/bash

# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 04/07/2025
# ==========================================================
# Description:
# This script safely updates your Proxmox VE system and underlying Debian packages
# through an interactive and automated process.
#
# Main features:
# - Repairs and optimizes APT repositories (Proxmox & Debian)
# - Removes duplicate or conflicting sources
# - Switches to the recommended 'no-subscription' Proxmox repository
# - Updates all Proxmox and Debian system packages
# - Installs essential packages if missing (e.g., zfsutils, chrony)
# - Checks for LVM and storage issues and repairs headers if needed
# - Removes conflicting time sync packages automatically
# - Performs a system cleanup after updating (autoremove, autoclean)
# - Provides a summary and prompts for reboot if necessary
#
# The goal of this script is to simplify and secure the update process for Proxmox,
# reduce manual intervention, and prevent common repository and package errors.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

export SCRIPT_TITLE="Proxmox system update"

# ==========================================================

NECESSARY_REBOOT=1

apt_upgrade() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

    if [[ -z "$pve_version" ]]; then
        msg_error "Unable to detect Proxmox version."
        return 1
    fi

    if [[ "$pve_version" -ge 9 ]]; then
        show_proxmenux_logo
        msg_title "$(translate "$SCRIPT_TITLE")"
        bash "$LOCAL_SCRIPTS/global/update-pve9_2.sh"

    else
        show_proxmenux_logo
        msg_title "$(translate "Proxmox system update")"
        bash "$LOCAL_SCRIPTS/global/update-pve8.sh"

    fi


}



check_reboot() {
    NECESSARY_REBOOT=0

    if [ -f /var/run/reboot-required ]; then
        NECESSARY_REBOOT=1
    fi
    if grep -q "linux-image" "$log_file" 2>/dev/null; then
        NECESSARY_REBOOT=1
    fi

    if [[ "$NECESSARY_REBOOT" -eq 1 ]]; then
        if whiptail --title "$(translate "Reboot Required")" \
                    --yesno "$(translate "Some changes require a reboot to take effect. Do you want to restart now?")" 10 60; then

            msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
            apt-get -y autoremove >/dev/null 2>&1
            apt-get -y autoclean >/dev/null 2>&1
            msg_ok "$(translate "Cleanup finished")"
            echo -e
            msg_success "$(translate "Press Enter to continue...")"
            read -r

            msg_warn "$(translate "Rebooting the system...")"
            reboot
        else
            msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
            apt-get -y autoremove >/dev/null 2>&1
            apt-get -y autoclean >/dev/null 2>&1
            msg_ok "$(translate "Cleanup finished")"
            echo -e
            msg_info2 "$(translate "You can reboot later manually.")"
            echo -e
            msg_success "$(translate "Press Enter to continue...")"
            read -r
            return 0
        fi
    else
        msg_info "$(translate "Removing no longer required packages and purging old cached updates...")"
        apt-get -y autoremove >/dev/null 2>&1
        apt-get -y autoclean >/dev/null 2>&1
        msg_ok "$(translate "Cleanup finished")"
        echo -e
        msg_ok "$(translate "All changes applied. No reboot required.")"
        echo -e
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
    fi
}



apt_upgrade
check_reboot

    








================================================
FILE: scripts/utilities/pve8to9_check.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenuX - Upgrade PVE 8 â†’ 9 (Simplified, per official guide)
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 14/08/2025
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"


if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache


# ==========================================================

LOG="/var/log/pve8-a-pve9-$(date +%Y%m%d-%H%M%S).log"
: > "$LOG"

disable_translation_post_upgrade() {
  translate() { echo "$1"; }
}
disable_translation_post_upgrade

if [[ "$pve_version" -ge 9 ]]; then
  disable_translation_post_upgrade
fi



run_pve8to9_check2() {
  local tmp
  tmp="$(mktemp)"
  echo -e
  set -o pipefail
  pve8to9 --full 2>&1 | tee -a "$LOG" | tee "$tmp"
  local rc=${PIPESTATUS[0]}

  local fails warns
  fails=$(grep -c 'FAIL:' "$tmp" || true)
  warns=$(grep -c 'WARN:' "$tmp" || true)


    if (( fails > 0 )); then
      echo -e
      echo -e "${BFR}${RD}[ERROR] $(translate "Pre-check found") $fails $(translate "blocking issue(s).")\n$(translate "Please resolve the problem(s) as described above, then re-run the upgrade script.")${CL}"
      echo -e
      
      local repair_commands=()
      local repair_descriptions=()
      
      # Error 1: systemd-boot meta-package
      if grep -q 'systemd-boot meta-package installed' "$tmp"; then
        repair_commands+=("apt install systemd-boot-efi systemd-boot-tools -y && apt remove systemd-boot -y")
        repair_descriptions+=("$(translate "Fix systemd-boot meta-package conflict")")
        echo -e "${YW}$(translate "Fix systemd-boot:") ${CL}apt install systemd-boot-efi systemd-boot-tools -y && apt remove systemd-boot -y"
      fi
      
      
      # Error 2: Ceph version incompatible
      if grep -q -E '(ceph.*version|ceph.*incompatible)' "$tmp"; then
        repair_commands+=("ceph versions && pveceph upgrade")
        repair_descriptions+=("$(translate "Upgrade Ceph to compatible version")")
        echo -e "${YW}$(translate "Fix Ceph version:") ${CL}ceph versions && pveceph upgrade"
      fi
      
      # Error 3: Repository configuration issues
      if grep -q -E '(repository.*issue|repo.*problem|sources.*error)' "$tmp"; then
        repair_commands+=("cleanup_duplicate_repos && configure_repositories")
        repair_descriptions+=("$(translate "Fix repository configuration")")
        echo -e "${YW}$(translate "Fix repositories:") ${CL}cleanup_duplicate_repos && configure_repositories"
      fi
      
      # Error 4: Package conflicts
      if grep -q -E '(package.*conflict|dependency.*problem)' "$tmp"; then
        repair_commands+=("apt update && apt autoremove -y && apt autoclean")
        repair_descriptions+=("$(translate "Resolve package conflicts")")
        echo -e "${YW}$(translate "Fix package conflicts:") ${CL}apt update && apt autoremove -y && apt autoclean"
      fi
      
      # Error 5: Disk space issues
      if grep -q -E '(disk.*space|storage.*full|no.*space)' "$tmp"; then
        repair_commands+=("apt clean && apt autoremove -y && journalctl --vacuum-time=7d")
        repair_descriptions+=("$(translate "Free up disk space")")
        echo -e "${YW}$(translate "Fix disk space:") ${CL}apt clean && apt autoremove -y && journalctl --vacuum-time=7d"
      fi
      
      # Error 6: Network/DNS issues
      if grep -q -E '(network.*error|dns.*problem|connection.*failed)' "$tmp"; then
        repair_commands+=("systemctl restart networking && systemctl restart systemd-resolved")
        repair_descriptions+=("$(translate "Fix network connectivity")")
        echo -e "${YW}$(translate "Fix network:") ${CL}systemctl restart networking && systemctl restart systemd-resolved"
      fi
      
      echo -e
      

      if [[ ${#repair_commands[@]} -gt 0 ]]; then
        echo -e "${BFR}${CY}$(translate "Repair Options:")${CL}"
        echo -e "${TAB}${GN}1.${CL} $(translate "Try automatic repair of detected issues")"
        echo -e "${TAB}${GN}2.${CL} $(translate "Show manual repair commands")"
        echo -e
        echo -n "$(translate "Select option [1-2] (default: 2): ")"
        read -r repair_choice
        
        case "$repair_choice" in
          1)
            echo -e
            msg_info2 "$(translate "Attempting automatic repair...")"
            local repair_success=0
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${YW}$(translate "Executing:") ${repair_descriptions[$i]}${CL}"
              if eval "${repair_commands[$i]}"; then
                msg_ok "${repair_descriptions[$i]} - $(translate "Success")"
              else
                msg_error "${repair_descriptions[$i]} - $(translate "Failed")"
                repair_success=1
              fi
            done
            
            if [[ $repair_success -eq 0 ]]; then
              echo -e
              msg_info2 "$(translate "Re-running pre-check after repairs...")"
              sleep 2
              run_pve8to9_check
              return $?
            else
              echo -e
              msg_error "$(translate "Some repairs failed. Please fix manually and re-run the script.")"
            fi
            ;;
            2)
            echo -e
            echo -e "$(translate "${BFR}${CY}Manual Repair Commands:${CL}")"
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${BL}# ${repair_descriptions[$i]}${CL}"
              echo -e
              echo -e "${TAB}${repair_commands[$i]}"
              echo -e
            done
            echo -e
            msg_info2 "$(translate "Once finished, re-run the script 'PVE 8 to 9 check' to verify that all issues.")"
            echo -e
            msg_success "$(translate "Press Enter to exit the script after reading instructions...")"
            read -r
            rm -f "$tmp"
            exit 1
            ;;
        esac
      fi
      
      msg_success "$(translate "Press Enter to continue")"
      read -r
    fi
    
    echo -e
    msg_ok "$(translate "Checklist post-upgrade finished. Warnings:") $warns"
    echo -e
    msg_success "$(translate "Press Enter to continue")"
    read -r
    rm -f "$tmp"
    return $rc

}

show_proxmenux_logo
msg_title "$(translate "Run PVE 8 to 9 check")"
run_pve8to9_check2





================================================
FILE: scripts/utilities/system_utils.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenux - A menu-driven script for Proxmox VE management
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.1
# Last Updated: 30/07/2025
# ==========================================================
# Description:
# This script provides an interactive system utilities installer with a 
# comprehensive dialog-based interface for Proxmox VE and Linux systems.
# It simplifies the installation and management of essential command-line 
# tools and utilities commonly used in server environments.
#
# The script offers both individual utility selection and predefined groups
# for different use cases, ensuring administrators can quickly set up their
# preferred toolset without manual package management.
#
# Supported utility categories:
# - Basic utilities: grc, htop, tree, curl, wget
# - Development tools: git, vim, nano, dos2unix
# - Compression tools: zip, unzip, rsync, cabextract
# - Network tools: iperf3, nmap, tcpdump, nethogs, iptraf-ng, sshpass
# - Analysis tools: jq, ncdu, iotop, btop, iftop
# - System tools: mlocate, net-tools, ipset, msr-tools
# - Virtualization tools: libguestfs-tools, wimtools, genisoimage, chntpw
# - Download tools: axel, aria2
#
# The script automatically handles package name differences across distributions
# and provides detailed feedback on installation success, warnings, and failures.
# It includes built-in troubleshooting for common PATH and command availability
# issues that may occur after package installation.
#

# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

OS_CODENAME="$(grep "VERSION_CODENAME=" /etc/os-release | cut -d"=" -f 2 | xargs )"

# ==========================================================
install_system_utils() {
    command_exists() {
        command -v "$1" >/dev/null 2>&1
    }


ensure_repositories_() {
    local sources_file="/etc/apt/sources.list"
    local need_update=false


    if [[ ! -f "$sources_file" ]]; then
        msg_warn "$(translate "sources.list not found, creating default Debian repository...")"
        cat > "$sources_file" << EOF
# Default Debian ${OS_CODENAME} repository
deb http://deb.debian.org/debian ${OS_CODENAME} main contrib non-free non-free-firmware
EOF
        need_update=true
    else

        if ! grep -q "deb.*${OS_CODENAME}.*main" "$sources_file"; then
            echo "deb http://deb.debian.org/debian ${OS_CODENAME} main contrib non-free non-free-firmware" >> "$sources_file"
            need_update=true
        fi
    fi


    if [[ "$need_update" == true ]] || ! apt list --installed >/dev/null 2>&1; then
        msg_info "$(translate "Updating APT package lists...")"
        apt-get update -o Acquire::AllowInsecureRepositories=true >/dev/null 2>&1
    fi

    return 0
}







ensure_repositories() {
  local pve_version need_update=false
  pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

  if [[ -z "$pve_version" ]]; then
    msg_error "Unable to detect Proxmox version."
    return 1
  fi

  if (( pve_version >= 9 )); then
    # ===== PVE 9 (Debian 13 - trixie) =====
    # proxmox.sources (no-subscription) â”€ create if missing
    if [[ ! -f /etc/apt/sources.list.d/proxmox.sources ]]; then
      cat > /etc/apt/sources.list.d/proxmox.sources <<'EOF'
Enabled: true
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: trixie
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
      need_update=true
    fi

    # debian.sources â”€ create if missing
    if [[ ! -f /etc/apt/sources.list.d/debian.sources ]]; then
      cat > /etc/apt/sources.list.d/debian.sources <<'EOF'
Types: deb
URIs: http://deb.debian.org/debian/
Suites: trixie trixie-updates
Components: main contrib non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg

Types: deb
URIs: http://security.debian.org/debian-security/
Suites: trixie-security
Components: main contrib non-free-firmware
Signed-By: /usr/share/keyrings/debian-archive-keyring.gpg
EOF
      need_update=true
    fi

  # apt-get update only if needed or lists are empty
  if [[ "$need_update" == true ]] || [[ ! -d /var/lib/apt/lists || -z "$(ls -A /var/lib/apt/lists 2>/dev/null)" ]]; then
    msg_info "$(translate "Updating APT package lists...")"
    apt-get update >/dev/null 2>&1 || apt-get update
  fi


  else
    # ===== PVE 8 (Debian 12 - bookworm) =====
    local sources_file="/etc/apt/sources.list"

    # Debian base (create or append minimal lines if missing)
    if ! grep -qE 'deb .* bookworm .* main' "$sources_file" 2>/dev/null; then
      {
        echo "deb http://deb.debian.org/debian bookworm main contrib non-free non-free-firmware"
        echo "deb http://deb.debian.org/debian bookworm-updates main contrib non-free non-free-firmware"
        echo "deb http://security.debian.org/debian-security bookworm-security main contrib non-free non-free-firmware"
      } >> "$sources_file"
      need_update=true
    fi

    # Proxmox no-subscription list (classic) if missing
    if [[ ! -f /etc/apt/sources.list.d/pve-no-subscription.list ]]; then
      echo "deb http://download.proxmox.com/debian/pve bookworm pve-no-subscription" \
        > /etc/apt/sources.list.d/pve-no-subscription.list
      need_update=true
    fi
  fi

  # apt-get update only if needed or lists are empty
  if [[ "$need_update" == true ]] || [[ ! -d /var/lib/apt/lists || -z "$(ls -A /var/lib/apt/lists 2>/dev/null)" ]]; then
    msg_info "$(translate "Updating APT package lists...")"
    apt-get update >/dev/null 2>&1 || apt-get update
  fi

  return 0
}







    install_single_package() {
        local package="$1"
        local command_name="${2:-$package}"
        local description="$3"
        
        msg_info "$(translate "Installing") $package ($description)..."
        local install_success=false
        
        if apt install -y "$package" >/dev/null 2>&1; then
            install_success=true
        fi
        cleanup
        
        if [ "$install_success" = true ]; then
            hash -r 2>/dev/null
            sleep 1
            if command_exists "$command_name"; then
                msg_ok "$package $(translate "installed correctly and available")"
                return 0
            else
                msg_warn "$package $(translate "installed but command not immediately available")"
                msg_info2 "$(translate "May need to restart terminal")"
                return 2
            fi
        else
            msg_error "$(translate "Error installing") $package"
            return 1
        fi
    }

    show_main_utilities_menu() {
        local choice
        choice=$(dialog --clear --backtitle "ProxMenux" \
            --title "$(translate "Utilities Installation Menu")" \
            --menu "$(translate "Select an option"):" 20 70 12 \
            "1" "$(translate "Custom selection")" \
            "2" "$(translate "Install ALL utilities")" \
            "3" "$(translate "Install basic utilities") (grc, htop, tree, curl, wget)" \
            "4" "$(translate "Install development tools") (git, vim, nano)" \
            "5" "$(translate "Install compression tools") (zip, unzip, rsync)" \
            "6" "$(translate "Install terminal multiplexers") (screen, tmux)" \
            "7" "$(translate "Install analysis tools") (jq, ncdu, iotop)" \
            "8" "$(translate "Install network tools") (nethogs, nmap, tcpdump, lsof)" \
            "9" "$(translate "Verify installations")" \
            "0" "$(translate "Return to main menu")" 2>&1 >/dev/tty)
        
        echo "$choice"
    }

    show_custom_selection() {
        local utilities=(
            "axel" "$(translate "Download accelerator")" "OFF"
            "dos2unix" "$(translate "Convert DOS/Unix text files")" "OFF"
            "grc" "$(translate "Generic log/command colorizer")" "OFF"
            "htop" "$(translate "Interactive process viewer")" "OFF"
            "btop" "$(translate "Modern resource monitor")" "OFF"
            "iftop" "$(translate "Real-time network usage")" "OFF"
            "iotop" "$(translate "Monitor disk I/O usage")" "OFF"
            #"iperf3" "$(translate "Network performance testing")" "OFF"
            "intel-gpu-tools" "$(translate "tools for the Intel graphics driver")" "OFF"
            "s-tui" "$(translate "Stress-Terminal UI")" "OFF"
            "ipset" "$(translate "Manage IP sets")" "OFF"
            "iptraf-ng" "$(translate "Network monitoring tool")" "OFF"
            "plocate" "$(translate "Locate files quickly")" "OFF"
            "msr-tools" "$(translate "Access CPU MSRs")" "OFF"
            "net-tools" "$(translate "Legacy networking tools")" "OFF"
            "sshpass" "$(translate "Non-interactive SSH login")" "OFF"
            "tmux" "$(translate "Terminal multiplexer")" "OFF"
            "unzip" "$(translate "Extract ZIP files")" "OFF"
            "zip" "$(translate "Create ZIP files")" "OFF"
            "libguestfs-tools" "$(translate "VM disk utilities")" "OFF"
            "aria2" "$(translate "Multi-source downloader")" "OFF"
            "cabextract" "$(translate "Extract CAB files")" "OFF"
            "wimtools" "$(translate "Manage WIM images")" "OFF"
            "genisoimage" "$(translate "Create ISO images")" "OFF"
            "chntpw" "$(translate "Edit Windows registry/passwords")" "OFF"
        )
        
        local selected
        selected=$(dialog --clear --backtitle "ProxMenux" \
            --title "$(translate "Select utilities to install")" \
            --checklist "$(translate "Use SPACE to select/deselect, ENTER to confirm")" \
            25 80 20 "${utilities[@]}" 2>&1 >/dev/tty)
        
        echo "$selected"
    }

    install_utility_group() {
        local group_name="$1"
        shift
        local utilities=("$@")
        
        clear
        show_proxmenux_logo
        msg_title "$(translate "Installing group"): $group_name"
        
  
        if ! ensure_repositories; then
            msg_error "$(translate "Failed to configure repositories. Installation aborted.")"
            return 1
        fi
        
        local failed=0
        local success=0
        local warning=0
        
        declare -A package_to_command=(
            ["plocate"]="locate"
            ["msr-tools"]="rdmsr"
            ["net-tools"]="netstat"
            ["libguestfs-tools"]="virt-filesystems"
            ["aria2"]="aria2c"
            ["wimtools"]="wimlib-imagex"
        )
        
        for util_info in "${utilities[@]}"; do
            IFS=':' read -r package command description <<< "$util_info"
            local verify_command="${package_to_command[$package]:-$command}"
            install_single_package "$package" "$verify_command" "$description"
            local install_result=$?
            
            case $install_result in
                0) success=$((success + 1)) ;;
                1) failed=$((failed + 1)) ;;
                2) warning=$((warning + 1)) ;;
            esac
            sleep 2
        done
        
        echo
        msg_info2 "$(translate "Installation summary") - $group_name:"
        msg_ok "$(translate "Successful"): $success"
        [ $warning -gt 0 ] && msg_warn "$(translate "With warnings"): $warning"
        [ $failed -gt 0 ] && msg_error "$(translate "Failed"): $failed"
        
        dialog --clear --backtitle "ProxMenux" \
            --title "$(translate "Installation Complete")" \
            --msgbox "$(translate "Group"): $group_name\n$(translate "Successful"): $success\n$(translate "With warnings"): $warning\n$(translate "Failed"): $failed" 10 50
    }

    install_selected_utilities() {
        local selected="$1"
        
        if [ -z "$selected" ]; then
            dialog --clear --backtitle "ProxMenux" \
                --title "$(translate "No Selection")" \
                --msgbox "$(translate "No utilities were selected")" 8 40
            return
        fi
        
        clear
        show_proxmenux_logo
        msg_title "$(translate "Installing selected utilities")"
        

        if ! ensure_repositories; then
            msg_error "$(translate "Failed to configure repositories. Installation aborted.")"
            return 1
        fi
        
        local failed=0
        local success=0
        local warning=0
        local selected_array
        IFS=' ' read -ra selected_array <<< "$selected"
        
        declare -A package_to_command=(
            ["mlocate"]="locate"
            ["msr-tools"]="rdmsr"
            ["net-tools"]="netstat"
            ["libguestfs-tools"]="virt-filesystems"
            ["aria2"]="aria2c"
            ["wimtools"]="wimlib-imagex"
        )
        
        for util in "${selected_array[@]}"; do
            util=$(echo "$util" | tr -d '"')
            local verify_command="${package_to_command[$util]:-$util}"
            install_single_package "$util" "$verify_command" "$util"
            local install_result=$?
            
            case $install_result in
                0) success=$((success + 1)) ;;
                1) failed=$((failed + 1)) ;;
                2) warning=$((warning + 1)) ;;
            esac
            sleep 2
        done
        
        if [ -f ~/.bashrc ]; then
            source ~/.bashrc >/dev/null 2>&1
        fi
        
        hash -r 2>/dev/null
        echo
        msg_info2 "$(translate "Installation summary"):"
        msg_ok "$(translate "Successful"): $success"
        [ $warning -gt 0 ] && msg_warn "$(translate "With warnings"): $warning"
        [ $failed -gt 0 ] && msg_error "$(translate "Failed"): $failed"
        
        dialog --clear --backtitle "ProxMenux" \
            --title "$(translate "Installation Complete")" \
            --msgbox "$(translate "Selected utilities installation completed")\n$(translate "Successful"): $success\n$(translate "With warnings"): $warning\n$(translate "Failed"): $failed" 12 60
    }

    verify_installations() {
        clear
        show_proxmenux_logo
        msg_info "$(translate "Verifying all utilities status")..."
        
        local utilities=(
            "axel:Download accelerator"
            "dialog:Console GUI dialogs"
            "dos2unix:Convert DOS/Unix text files"
            "grc:Generic log/command colorizer"
            "htop:Interactive process viewer"
            "btop:Modern resource monitor"
            "iftop:Real-time network usage"
            "iotop:Monitor disk I/O usage"
            #"iperf3:Network performance testing"
            "intel-gpu-tools:tools for the Intel graphics driver"
            "s-tui:Stress-Terminal UI"
            "ipset:Manage IP sets"
            "iptraf-ng:Network monitoring tool"
            "plocate:Locate files quickly"
            "rdmsr:Access CPU MSRs"
            "netstat:Legacy networking tools"
            "sshpass:Non-interactive SSH login"
            "tmux:Terminal multiplexer"
            "unzip:Extract ZIP files"
            "zip:Create ZIP files"
            "virt-filesystems:VM disk utilities"
            "aria2c:Multi-source downloader"
            "cabextract:Extract CAB files"
            "wimlib-imagex:Manage WIM images"
            "genisoimage:Create ISO images"
            "chntpw:Edit Windows registry/passwords"
        )
        
        local available=0
        local missing=0
        local status_text=""
        
        for util in "${utilities[@]}"; do
            IFS=':' read -r cmd desc <<< "$util"
            if command_exists "$cmd"; then
                status_text+="\nâœ“ $cmd - $desc"
                available=$((available + 1))
            else
                status_text+="\nâœ— $cmd - $desc"
                missing=$((missing + 1))
            fi
        done
        
        cleanup
        
        local summary="$(translate "Total"): $((available + missing))\n$(translate "Available"): $available\n$(translate "Missing"): $missing"
        
        dialog --clear --backtitle "ProxMenux" \
            --title "$(translate "Utilities Verification")" \
            --msgbox "$summary$status_text" 25 80
    }

    # Main menu loop
    while true; do
        choice=$(show_main_utilities_menu)
        case $choice in
            1)
                selected=$(show_custom_selection)
                install_selected_utilities "$selected"
                ;;
            2)
                all_utils=(
                    "axel:axel:Download accelerator"
                    "dos2unix:dos2unix:Convert DOS/Unix text files"
                    "grc:grc:Generic log/command colorizer"
                    "htop:htop:Interactive process viewer"
                    "btop:btop:Modern resource monitor"
                    "iftop:iftop:Real-time network usage"
                    "iotop:iotop:Monitor disk I/O usage"
                    #"iperf3:iperf3:Network performance testing"
                    "intel-gpu-tools:tools for the Intel graphics driver"
                    "s-tui:Stress-Terminal UI"
                    "ipset:ipset:Manage IP sets"
                    "iptraf-ng:iptraf-ng:Network monitoring tool"
                    "plocate:locate:Locate files quickly"
                    "msr-tools:rdmsr:Access CPU MSRs"
                    "net-tools:netstat:Legacy networking tools"
                    "sshpass:sshpass:Non-interactive SSH login"
                    "tmux:tmux:Terminal multiplexer"
                    "unzip:unzip:Extract ZIP files"
                    "zip:zip:Create ZIP files"
                    "libguestfs-tools:virt-filesystems:VM disk utilities"
                    "aria2:aria2c:Multi-source downloader"
                    "cabextract:cabextract:Extract CAB files"
                    "wimtools:wimlib-imagex:Manage WIM images"
                    "genisoimage:genisoimage:Create ISO images"
                    "chntpw:chntpw:Edit Windows registry/passwords"
                )
                install_utility_group "$(translate "ALL Utilities")" "${all_utils[@]}"
                ;;
            3)
                basic_utils=(
                    "grc:grc:Generic Colouriser"
                    "htop:htop:Process monitor"
                    "tree:tree:Directory structure"
                    "curl:curl:Data transfer"
                    "wget:wget:Web downloader"
                )
                install_utility_group "$(translate "Basic Utilities")" "${basic_utils[@]}"
                ;;
            4)
                dev_utils=(
                    "git:git:Version control"
                    "vim:vim:Advanced editor"
                    "nano:nano:Simple editor"
                )
                install_utility_group "$(translate "Development Tools")" "${dev_utils[@]}"
                ;;
            5)
                compress_utils=(
                    "zip:zip:ZIP compressor"
                    "unzip:unzip:ZIP extractor"
                    "rsync:rsync:File synchronizer"
                )
                install_utility_group "$(translate "Compression Tools")" "${compress_utils[@]}"
                ;;
            6)
                multiplex_utils=(
                    "screen:screen:Terminal multiplexer"
                    "tmux:tmux:Advanced multiplexer"
                )
                install_utility_group "$(translate "Terminal Multiplexers")" "${multiplex_utils[@]}"
                ;;
            7)
                analysis_utils=(
                    "jq:jq:JSON processor"
                    "ncdu:ncdu:Disk analyzer"
                    "iotop:iotop:I/O monitor"
                )
                install_utility_group "$(translate "Analysis Tools")" "${analysis_utils[@]}"
                ;;
            8)
                network_utils=(
                    "nethogs:nethogs:Network monitor"
                    "nmap:nmap:Network scanner"
                    "tcpdump:tcpdump:Packet analyzer"
                    "lsof:lsof:Open files"
                )
                install_utility_group "$(translate "Network Tools")" "${network_utils[@]}"
                ;;
            9)
                verify_installations
                ;;
            0|"")
                break
                ;;
            *)
                dialog --clear --backtitle "ProxMenux" \
                    --title "$(translate "Invalid Option")" \
                    --msgbox "$(translate "Please select a valid option")" 8 40
                ;;
        esac
    done
    
    clear
}

install_system_utils



================================================
FILE: scripts/utilities/upgrade_pve8_to_pve9.sh
================================================
#!/bin/bash
# ==========================================================
# ProxMenuX - Upgrade PVE 8 â†’ 9 (Simplified, per official guide)
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 14/08/2025
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"


if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================

LOG="/var/log/pve8-a-pve9-$(date +%Y%m%d-%H%M%S).log"
: > "$LOG"


REPO_MODE="no-subscription"   
DISABLE_AUDIT="1"
ASSUME_YES="0"                
CEPH_ENFORCE="auto"          


for arg in "$@"; do
  case "$arg" in
    --enterprise) REPO_MODE="enterprise" ;;
    --no-subscription) REPO_MODE="no-subscription" ;;
    --skip-audit-disable) DISABLE_AUDIT="0" ;;
    --assume-yes|-y) ASSUME_YES="1" ;;
    --ignore-ceph-check) CEPH_ENFORCE="skip" ;;
    --warn-ceph-check) CEPH_ENFORCE="warn" ;;
    *) ;;
  esac
done

# ==========================================================


run_manual_guide() {
    local SCRIPT_FILE="$LOCAL_SCRIPTS/utilities/proxmox-upgrade-pve8-to-pve9-manual-guide.sh"
    if [[ ! -f "$SCRIPT_FILE" ]]; then
        msg_error "$(translate "Manual guide script not found")"
        return 1
    fi
    bash "$SCRIPT_FILE"
}

run_pve8to9_check() {
    local SCRIPT_FILE="$LOCAL_SCRIPTS/utilities/pve8to9_check.sh"
    if [[ ! -f "$SCRIPT_FILE" ]]; then
        msg_error "$(translate "Check script not found")"
        return 1
    fi
    bash "$SCRIPT_FILE"
}

ask_run_mode() {

    if [[ "${ASSUME_YES:-0}" == "1" ]]; then
        msg_ok "$(translate "Run mode: Unattended")"
        export DEBIAN_FRONTEND=noninteractive
        export APT_LISTCHANGES_FRONTEND=none
        exit 0
    fi


    while true; do
        if command -v dialog >/dev/null 2>&1; then
            local title text choice status
            title="$(translate "Select run mode")"; [[ -z "$title" ]] && title="Select run mode"
            text="$(translate "Choose how to perform the upgrade:")"; [[ -z "$text" ]] && text="Choose how to perform the upgrade:"
            title=${title//$'\r'/}; title=${title//$'\n'/' '}
            text=${text//$'\r'/};  text=${text//$'\n'/' '}

            choice=$(
                dialog --backtitle "ProxMenux" \
                       --title "$title" \
                       --menu "$text" 20 70 8 \
                       1 "$(translate "Automatic/Unattended")" \
                       2 "$(translate "Interactive (guided, prompts visible)")" \
                       3 "$(translate "Run PVE 8 to 9") check" \
                       4 "$(translate "Manual upgrade guide step by step")" \
                       3>&1 1>&2 2>&3
            ); status=$?


            if [[ $status -ne 0 ]]; then
                exit 0
            fi

            case "$choice" in
                1)
                    ASSUME_YES="1"
                    show_proxmenux_logo || true
                    msg_title "$(translate "Upgrade assistant: Proxmox VE 8 â†’ 9 (Trixie)")"
                    msg_info2 "$(translate "Run mode selected: Automatic")"
                    export DEBIAN_FRONTEND=noninteractive
                    export APT_LISTCHANGES_FRONTEND=none
                    break   
                    ;;
                3)
                    run_pve8to9_check
                    continue  
                    ;;
                4)
                    run_manual_guide
                    continue  
                    ;;
                *)
                    show_proxmenux_logo || true
                    msg_title "$(translate "Upgrade assistant: Proxmox VE 8 â†’ 9 (Trixie)")"
                    msg_info2 "$(translate "Run mode selected: Interactive")"
                    break   
                    ;;
            esac

        elif command -v whiptail >/dev/null 2>&1; then
            local choice
            if ! choice=$(
                whiptail --title "$(translate "Select run mode")" \
                         --menu "$(translate "Choose how to perform the upgrade:")" 20 70 8 \
                         "1" "$(translate "Automatic/Unattended")" \
                         "2" "$(translate "Interactive (guided, prompts visible)")" \
                         "3" "$(translate "Run PVE 8 to 9") check" \
                         "4" "$(translate "Manual upgrade guide step by step")" \
                         3>&1 1>&2 2>&3
            ); then
                exit 0
            fi

            case "$choice" in
                1)
                    ASSUME_YES="1"
                    show_proxmenux_logo || true
                    msg_title "$(translate "Upgrade assistant: Proxmox VE 8 â†’ 9 (Trixie)")"
                    msg_info2 "$(translate "Run mode selected: Automatic/Unattended")"
                    export DEBIAN_FRONTEND=noninteractive
                    export APT_LISTCHANGES_FRONTEND=none
                    break
                    ;;
                3)
                    run_pve8to9_check
                    continue
                    ;;
                4)
                    run_manual_guide
                    continue
                    ;;
                *)
                    show_proxmenux_logo || true
                    msg_title "$(translate "Upgrade assistant: Proxmox VE 8 â†’ 9 (Trixie)")"
                    msg_info2 "$(translate "Run mode selected: Interactive")"
                    break
                    ;;
            esac
        fi
    done

}




# ==========================================================


confirm() {
  local prompt="$1"
  if [[ "$ASSUME_YES" == "1" ]]; then
    return 0
  fi
  if command -v whiptail >/dev/null 2>&1; then
    whiptail --title "$(translate "Confirmation")" --yesno "$prompt" 14 80
  else
    echo -n "$(translate "$prompt") [y/N]: "
    read -r ans
    [[ "$ans" =~ ^[Yy]$ ]]
  fi
}

ask_choice_auto_or_manual() {
  if [[ "$ASSUME_YES" == "1" ]]; then
    echo "auto"; return 0
  fi
  if command -v whiptail >/dev/null 2>&1; then
    if whiptail --title "$(translate "Cluster upgrade mode")" --yesno "$(translate "Pending upgrades detected on a clustered node.\n\nTo proceed safely, update this node to the latest Proxmox VE 8.x before switching to Trixie/PVE 9.\n\nSelect Yes for AUTOMATIC upgrade (recommended), or No for MANUAL instructions.")" 16 78; then
      echo "auto"
    else
      echo "manual"
    fi
  else
    echo -n "$(translate "Pending upgrades detected on a clustered node. Perform AUTOMATIC upgrade now? (y = automatic, n = manual): ")"
    read -r ans
    [[ "$ans" =~ ^[Yy]$ ]] && echo "auto" || echo "manual"
  fi
}



run_step() {

  local pre="$1"; local ok="$2"; local cmd="$3"
  echo -ne "${TAB}${YW}$(translate "$pre")${CL}"
  if bash -lc "set -o pipefail; $cmd 2>&1 | tee -a \"$LOG\""; then
    echo -e "${BFR}${TAB}${CM}${GN}$(translate "$ok")${CL}"
    return 0
  else
    echo -e "${BFR}${TAB}${RD}[ERROR] $(translate "Failed. See log:") $LOG${CL}"
    exit 1
  fi
}

run_step_interactive() {

  local pre="$1"; local ok="$2"; shift 2
  echo -ne "${TAB}${YW}$(translate "$pre")${CL}"
  if "$@"; then
    echo -e "${BFR}${TAB}${CM}${GN}$(translate "$ok")${CL}"
    return 0
  else
    echo -e "${BFR}${TAB}${RD}[ERROR] $(translate "Failed. See log:") $LOG${CL}"
    exit 1
  fi
}

append_step() {

  local pre="$1"; local ok="$2"; local cmd="$3"
  echo -ne "${TAB}${YW}$(translate "$pre")${CL}"
  if bash -lc "set -o pipefail; $cmd 2>&1 | tee -a \"$LOG\""; then
    echo -e "${BFR}${TAB}${CM}${GN}$(translate "$ok")${CL}"
  else
    echo -e "${BFR}${TAB}${CM}${GN}$(translate "$ok")${CL}"
  fi
}

file_contains() {
  local file="$1"
  local pattern="$2"
  grep -qE "$pattern" "$file" 2>/dev/null
}

is_cluster_node() {
  if command -v pvecm >/dev/null 2>&1 && pvecm status >> "$LOG" 2>&1; then
    return 0
  fi
  return 1
}

is_hyperconverged_ceph_node() {
  if command -v pveceph >/dev/null 2>&1; then
    if pveceph status >> "$LOG" 2>&1; then
      return 0
    fi
  fi
  if systemctl list-units --type=service --all 2>/dev/null | grep -Eq 'ceph-(mon|osd|mgr)@'; then
    return 0
  fi
  if ls /var/lib/ceph/osd/ceph-* >/dev/null 2>&1; then
    return 0
  fi
  if [[ -f /etc/pve/ceph.conf ]]; then
    return 0
  fi
  return 1
}


# ==========================================================


create_pve_repo_enterprise_if_missing() {
  local f="/etc/apt/sources.list.d/pve-enterprise.sources"
  [[ -f "$f" ]] && return 0
  cat > "$f" << 'EOF'
Types: deb
URIs: https://enterprise.proxmox.com/debian/pve
Suites: trixie
Components: pve-enterprise
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
  chmod 644 "$f"
}

create_pve_repo_nosub_if_missing() {
  local f="/etc/apt/sources.list.d/proxmox.sources"
  [[ -f "$f" ]] && return 0
  cat > "$f" << 'EOF'
Types: deb
URIs: http://download.proxmox.com/debian/pve
Suites: trixie
Components: pve-no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
  chmod 644 "$f"
}

create_ceph_repo_enterprise_if_missing() {
  local f="/etc/apt/sources.list.d/ceph.sources"
  [[ -f "$f" ]] && return 0
  cat > "$f" << 'EOF'
Types: deb
URIs: https://enterprise.proxmox.com/debian/ceph-squid
Suites: trixie
Components: enterprise
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
  chmod 644 "$f"
}

create_ceph_repo_nosub_if_missing() {
  local f="/etc/apt/sources.list.d/ceph.sources"
  [[ -f "$f" ]] && return 0
  cat > "$f" << 'EOF'
Types: deb
URIs: http://download.proxmox.com/debian/ceph-squid
Suites: trixie
Components: no-subscription
Signed-By: /usr/share/keyrings/proxmox-archive-keyring.gpg
EOF
  chmod 644 "$f"
}

disable_enterprise_repo_if_present() {
  local s="/etc/apt/sources.list.d/pve-enterprise.sources"
  local l="/etc/apt/sources.list.d/pve-enterprise.list"
  if [[ -f "$s" ]]; then
    if grep -qi '^Enabled:' "$s"; then
      sed -i 's/^Enabled:.*/Enabled: false/i' "$s"
    else
      echo "Enabled: false" >> "$s"
    fi
  fi
  if [[ -f "$l" ]]; then
    sed -i 's/^[[:space:]]*deb/# deb/' "$l"
  fi
}

comment_legacy_pve8_lists() {
  for f in /etc/apt/sources.list.d/pve-public-repo.list /etc/apt/sources.list.d/pve-install-repo.list; do
    [[ -f "$f" ]] || continue
    sed -i 's/^[[:space:]]*deb/# deb/' "$f" || true
  done
}

comment_legacy_ceph_list() {
  local f="/etc/apt/sources.list.d/ceph.list"
  [[ -f "$f" ]] || return 0
  sed -i 's/^[[:space:]]*deb/# deb/' "$f" || true
}

apt_update_with_repo_fallback() {

  local output status
  output="$(apt-get update >/dev/null 2>&1 | tee -a "$LOG")"; status=${PIPESTATUS[0]}
  if [[ $status -eq 0 ]]; then
    msg_ok2 "$(translate "APT indexes updated for Trixie")"
    return 0
  fi
  if [[ "$REPO_MODE" == "enterprise" ]] && { echo "$output" | grep -qE '401[[:space:]]+Unauthorized' || echo "$output" | grep -qi 'enterprise\.proxmox\.com'; }; then
    if [[ "$ASSUME_YES" == "1" ]] || confirm "$(translate "Enterprise repository returned 401 Unauthorized (no valid subscription). Switch to the no-subscription repository and retry?")"; then

      disable_enterprise_repo_if_present
      create_pve_repo_nosub_if_missing
      if [[ -f /etc/apt/sources.list.d/ceph.sources ]]; then
        create_ceph_repo_nosub_if_missing
      fi
      REPO_MODE="no-subscription"
      msg_ok2 "$(translate "Repositories switched to no-subscription")"

      if apt-get update >> "$LOG" >/dev/null 2>&1; then
        msg_ok2 "$(translate "APT indexes updated for Trixie (no-subscription)")"
        return 0
      else
        echo -e "${BFR}${TAB}${RD}[ERROR] $(translate "APT index update failed after switching to no-subscription. See log:") $LOG${CL}"
        exit 1
      fi
    else
      echo -e "${BFR}${TAB}${RD}[ERROR] $(translate "Enterprise repository unauthorized and fallback declined by user") $LOG${CL}"
      exit 1
    fi
  fi
  echo -e "${BFR}${TAB}${RD}[ERROR] $(translate "APT index update failed. See log:") $LOG${CL}"
  exit 1
}

# ==========================================================

proxmox_repo_candidate_ok() {
  local cand
  cand="$(apt-cache policy proxmox-ve 2>/dev/null | awk -F': ' '/Candidate:/{print $2}')"
  [[ -n "$cand" && "$cand" != "(none)" && "$cand" =~ ^9 ]]
}


simulate_would_remove_proxmox_ve() {
  apt-get -s dist-upgrade >/dev/null 2>&1 | grep -Eq 'Remv[[:space:]]+proxmox-ve|The following packages will be REMOVED:.*proxmox-ve'
}


guard_against_proxmox_ve_removal() {
  msg_info "$(translate "Validating Proxmox 9 repositories (checking 'proxmox-ve' candidate)...")"
  if proxmox_repo_candidate_ok; then
    msg_ok "$(translate "Proxmox repository OK (candidate is 9.x)")"
  else
    if [[ "$REPO_MODE" == "enterprise" ]]; then
      msg_warn "$(translate "Proxmox enterprise repo might be missing or inaccessible. Trying to switch to no-subscription...")"
      disable_enterprise_repo_if_present
      create_pve_repo_nosub_if_missing
      REPO_MODE="no-subscription"
      apt_update_with_repo_fallback
      if proxmox_repo_candidate_ok; then
        msg_ok "$(translate "Proxmox repository fixed (no-subscription, candidate is 9.x)")"
      else
        msg_error "$(translate "Could not find a valid 'proxmox-ve' 9.x candidate after switching to no-subscription. Please verify your repository configuration and network, then retry.")"
        exit 1
      fi
    else
      msg_error "$(translate "Invalid 'proxmox-ve' candidate (not 9.x or none). Please verify your repository configuration and network, then retry.")"
      exit 1
    fi
  fi
  msg_info "$(translate "Running pre-upgrade simulation to verify 'proxmox-ve' will remain installed...")"
  if simulate_would_remove_proxmox_ve; then
    msg_error "$(translate "Pre-upgrade check FAILED: the simulation shows that 'proxmox-ve' would be REMOVED.\n    This indicates a repository or dependency issue and upgrading now could break your Proxmox installation.")"
    echo "---- $(translate "Recommended diagnostic commands") ----"
    echo "apt-cache policy proxmox-ve"
    echo "apt policy | sed -n '1,120p'"
    echo "cat /etc/apt/sources.list"
    echo "ls -l /etc/apt/sources.list.d/*.list /etc/apt/sources.list.d/*.sources"
    exit 1
  else
    msg_ok "$(translate "Pre-upgrade simulation passed: 'proxmox-ve' will be kept or upgraded safely.")"
  fi

}


# ==========================================================


check_not_web_terminal() {
    [[ "${PVE_ALLOW_WEBTERM:-0}" = "1" ]] && return 0

    [[ -n "${SSH_CONNECTION:-}" ]] && return 0

    local pid ppid comm args i
    pid=$$

    show_web_terminal_block_msg() {
    local title msg_line1 msg_line2 msg

    title="$(translate "Unsupported Terminal")"
    msg_line1="$(translate "This script cannot be executed from the Proxmox web terminal.")"
    msg_line2="$(translate "Please use an SSH session (Linux, macOS, Windows/PuTTY) or a physical console to perform the upgrade.")"

    msg="${msg_line1}"$'\n\n'"${msg_line2}"

    whiptail --title "$title" --msgbox "$msg" 12 72
}

    for i in {1..12}; do
        ppid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d ' ')
        [[ -z "$ppid" || "$ppid" -le 1 ]] && break

        comm=$(ps -o comm= -p "$ppid" 2>/dev/null || true)
        args=$(ps -o args= -p "$ppid" 2>/dev/null || true)

        if echo "$comm $args" | grep -Eqi 'termproxy|vncshell'; then
            show_web_terminal_block_msg
            msg_warn "$(translate "Upgrade canceled by user")"
            exit 1
        fi

        pid="$ppid"
    done
}

ask_run_mode

check_not_web_terminal



export NCURSES_NO_UTF8_ACS=1

show_upgrade_confirm() {

  local title
  title="$(translate "Upgrade to Proxmox VE 9")"

  local intro req l1 l2 l3 l4 cont
  intro="$(translate "This will upgrade this node to Proxmox VE 9 on Debian Trixie.")"
  req="$(translate "REQUIREMENTS:")"
  l1="$(translate "Valid backups for all VMs/CTs")"
  l2="$(translate "Run from console, or SSH inside tmux/screen")"
  l3="$(translate "Migrate away any guests that must keep running")"
  l4=""  
  cont="$(translate "Continue?")"


  local bullet="â€¢"
  if ! locale charmap 2>/dev/null | grep -qi 'utf-8'; then
    bullet="-"
  fi

  local msg
  msg="${intro}"$'\n\n'"${req}"$'\n'
  msg+="${bullet} ${l1}"$'\n'
  msg+="${bullet} ${l2}"$'\n'
  msg+="${bullet} ${l3}"

  [[ -n "$l4" ]] && msg+=$'\n'"${bullet} ${l4}"
  msg+=$'\n\n'"${cont}"

  local cols width height
  cols=$(tput cols 2>/dev/null || echo 80)
  width=$(( cols < 78 ? (cols>40?cols-2:40) : 78 ))
  height=18

  if whiptail --title "$title" --yesno "$msg" "$height" "$width"; then
    return 0
  else
    msg_warn "$(translate "Upgrade canceled by user")"
    exit 0
  fi
}

show_upgrade_confirm




# ---------------------------
# Step 1
# ---------------------------


apt_upgrade() {
    local pve_version
    pve_version=$(pveversion 2>/dev/null | grep -oP 'pve-manager/\K[0-9]+' | head -1)

    if [[ -z "$pve_version" ]]; then
        msg_error "Unable to detect Proxmox version."
        return 1
    fi

    if [[ "$pve_version" -ge 9 ]]; then
        msg_info2 "$(translate "Proxmox 9 system update allready")"
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        exit 1

    else
        bash "$LOCAL_SCRIPTS/global/update-pve8.sh"
        hash -r

    fi
}

apt_upgrade

# ---------------------------

regenerate_pve_cache() {
  msg_info "$(translate "Regenerating PVE package cache...")"
  
  mkdir -p /var/lib/pve-manager
  chmod 755 /var/lib/pve-manager
  
  systemctl restart pve-manager 2>/dev/null || true
  
  sleep 2
  
  timeout 10 pvesh get /nodes/localhost/apt/update 2>/dev/null || true
  
  msg_ok "$(translate "PVE cache regenerated")"
}

regenerate_pve_cache

# ---------------------------

run_pve8to9_check() {
  local tmp
  tmp="$(mktemp)"
  echo -e
  set -o pipefail
  pve8to9 --full 2>&1 | tee -a "$LOG" | tee "$tmp"
  local rc=${PIPESTATUS[0]}

  local fails warns
  fails=$(grep -c 'FAIL:' "$tmp" || true)
  warns=$(grep -c 'WARN:' "$tmp" || true)


    if (( fails > 0 )); then
      echo -e
      echo -e "${BFR}${RD}[ERROR] $(translate "Pre-check found") $fails $(translate "blocking issue(s).")\n$(translate "Please resolve the problem(s) as described above, then re-run the upgrade script.")${CL}"
      echo -e
      

      local repair_commands=()
      local repair_descriptions=()
      
      # Error 1: systemd-boot meta-package
      if grep -q 'systemd-boot meta-package installed' "$tmp"; then
        repair_commands+=("apt remove -y systemd-boot")
        repair_descriptions+=("$(translate "Remove obsolete systemd-boot meta-package")")
        echo -e "${YW}$(translate "Fix systemd-boot:") ${CL}apt remove -y systemd-boot"
      fi
      # Error 2: Kernel version mismatch
      if grep -q -E 'FAIL:.*(kernel.*mismatch|kernel.*version.*mismatch)' "$tmp"; then
        repair_commands+=("update-grub")
        repair_descriptions+=("$(translate "Update kernel to compatible version")")
        echo -e "${YW}$(translate "Fix kernel version:") ${CL}update-grub"
      fi
      
      # Error 3: Ceph version incompatible
      if grep -q -E '(ceph.*version|ceph.*incompatible)' "$tmp"; then
        repair_commands+=("ceph versions && pveceph upgrade")
        repair_descriptions+=("$(translate "Upgrade Ceph to compatible version")")
        echo -e "${YW}$(translate "Fix Ceph version:") ${CL}ceph versions && pveceph upgrade"
      fi
      
      # Error 4: Repository configuration issues
      if grep -q -E '(repository.*issue|repo.*problem|sources.*error)' "$tmp"; then
        repair_commands+=("cleanup_duplicate_repos && configure_repositories")
        repair_descriptions+=("$(translate "Fix repository configuration")")
        echo -e "${YW}$(translate "Fix repositories:") ${CL}cleanup_duplicate_repos && configure_repositories"
      fi
      
      # Error 5: Package conflicts
      if grep -q -E '(package.*conflict|dependency.*problem)' "$tmp"; then
        repair_commands+=("apt update && apt autoremove -y && apt autoclean")
        repair_descriptions+=("$(translate "Resolve package conflicts")")
        echo -e "${YW}$(translate "Fix package conflicts:") ${CL}apt update && apt autoremove -y && apt autoclean"
      fi
      
      # Error 6: Disk space issues
      if grep -q -E 'FAIL:.*(disk space|no space left|storage.*full)' "$tmp"; then
        repair_commands+=("apt clean && apt autoremove -y && journalctl --vacuum-time=7d")
        repair_descriptions+=("$(translate "Free up disk space")")
        echo -e "${YW}$(translate "Fix disk space:") ${CL}apt clean && apt autoremove -y && journalctl --vacuum-time=7d"
      fi
      
      
      echo -e
      

      if [[ ${#repair_commands[@]} -gt 0 ]]; then
        echo -e "${BFR}${CY}$(translate "Repair Options:")${CL}"
        echo -e "${TAB}${GN}1.${CL} $(translate "Try automatic repair of detected issues")"
        echo -e "${TAB}${GN}2.${CL} $(translate "Show manual repair commands")"
        echo -e "${TAB}${GN}3.${CL} $(translate "Exit and repair manually")"
        echo -e
        echo -n "$(translate "Select option [1-3] (default: 3): ")"
        read -r repair_choice
        
        case "$repair_choice" in
          1)
            echo -e
            msg_info2 "$(translate "Attempting automatic repair...")"
            local repair_success=0
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${YW}$(translate "Executing:") ${repair_descriptions[$i]}${CL}"
              if eval "${repair_commands[$i]}"; then
                msg_ok "${repair_descriptions[$i]} - $(translate "Success")"
              else
                msg_error "${repair_descriptions[$i]} - $(translate "Failed")"
                repair_success=1
              fi
            done
            
            if [[ $repair_success -eq 0 ]]; then
              echo -e
              msg_info2 "$(translate "Re-running pre-check after repairs...")"
              sleep 2
              run_pve8to9_check
              return $?
            else
              echo -e
              msg_error "$(translate "Some repairs failed. Please fix manually and re-run the script.")"
            fi
            ;;
          2)
            echo -e
            echo -e "$(translate "${BFR}${CY}Manual Repair Commands:${CL}")"
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${BL}# ${repair_descriptions[$i]}${CL}"
              echo -e
              echo -e "${TAB}${repair_commands[$i]}"
              echo -e
            done
            echo -e
            msg_info2 "$(translate "Once finished, re-run 'PVE 8 to 9 check' to verify that all issues are resolved \n    before executing the PVE 8 â†’ PVE 9 upgrade.")"
            echo -e
            msg_success "$(translate "Press Enter to exit the script after reading instructions...")"
            read -r
            rm -f "$tmp"
            exit 1
            ;;
          *)
            echo -e
            msg_info2 "$(translate "Exiting for manual repair...")"
            ;;
        esac
      fi
      
      msg_success "$(translate "Press Enter to exit and repair")"
      read -r
      rm -f "$tmp"
      exit 1
    fi
    
    echo -e
    msg_ok "$(translate "Checklist pre-check finished. Warnings:") $warns"
    rm -f "$tmp"
    return $rc

}

run_pve8to9_check





# ---------------------------
# Step 2
# ---------------------------

run_step \
  "" \
  "Connectivity to Proxmox repository OK" \
  "ping -c1 -W2 download.proxmox.com >/dev/null"


msg_info "$(translate "Checking free space in /var/cache/apt/archives...")"
FREE_MB=$(df /var/cache/apt/archives | awk 'NR==2 {print int($4/1024)}')
if [[ "${FREE_MB:-0}" -lt 1024 ]]; then
  msg_error "$(translate "Insufficient space:") ${FREE_MB}MB $(translate "(need â‰¥ 1024MB)")"
  exit 1
else
  msg_ok "$(translate "Free space OK:") ${FREE_MB}MB"
fi


if [[ "$DISABLE_AUDIT" == "1" ]]; then
  append_step \
    "" \
    "Audit socket disabled or not required" \
    "systemctl disable --now systemd-journald-audit.socket >/dev/null 2>&1 || true"
fi




# ---------------------------
# Step 3
# ---------------------------

if command -v ceph >/dev/null 2>&1; then
  if [[ "$CEPH_ENFORCE" == "skip" ]]; then
    msg_ok2 "$(translate "Ceph check skipped by user flag (--ignore-ceph-check)")"
  else
    if is_hyperconverged_ceph_node; then
      msg_info "$(translate "Ceph detected as hyper-converged on this node. Checking version (require 19.x Squid)...")"
      CEPH_V=$(ceph --version 2>/dev/null | head -1 || true)
      if echo "$CEPH_V" | grep -Eq 'ceph.*(version 19|squid)'; then
        msg_ok "$(translate "Ceph version OK:") $CEPH_V"
      else
        if [[ "$CEPH_ENFORCE" == "warn" ]]; then
          msg_warn "$(translate "Ceph is not 19.x (Squid). Proceeding due to --warn-ceph-check. Detected:") ${CEPH_V:-N/A}"
        else
          msg_error "$(translate "Ceph is not 19.x (Squid). Upgrade Ceph first. Detected:") ${CEPH_V:-N/A}"
          exit 1
        fi
      fi
    else
      CEPH_V=$(ceph --version 2>/dev/null | head -1 || true)
      echo -e "${BFR}${TAB}${CM}${GN}${CEPH_V:-N/A}${CL}"
    fi
  fi
fi




# ---------------------------
# Step 4
# ---------------------------

OS_FILE="/etc/apt/sources.list"
if [[ -f "$OS_FILE" ]]; then
  msg_info "$(translate "Updating Debian Bookworm â†’ Trixie in sources.list...")"
  if sed -i 's/bookworm/trixie/g' "$OS_FILE"; then
    msg_ok "$(translate "sources.list updated to Trixie")"
  else
    msg_ok "$(translate "sources.list update skipped (no change)")"
  fi
else
  msg_ok "$(translate "No main sources.list present (skipped)")"
fi

PVE_ENT_LIST="/etc/apt/sources.list.d/pve-enterprise.list"
msg_info "$(translate "Updating pve-enterprise.list (if present) to Trixie...")"
if [[ -f "$PVE_ENT_LIST" ]]; then
  if sed -i 's/bookworm/trixie/g' "$PVE_ENT_LIST"; then
    msg_ok "$(translate "pve-enterprise.list updated to Trixie")"
  else
    msg_ok "$(translate "pve-enterprise.list update skipped (no change)")"
  fi
else
  msg_ok "$(translate "No pve-enterprise.list present (skipped)")"
fi


msg_info "$(translate "Commenting any residual Bookworm lines in *.list...")"
for f in /etc/apt/sources.list.d/*.list; do
  [[ -f "$f" ]] || continue
  sed -i '/bookworm/s/^/# /' "$f" || true
done
sed -i '/bookworm/s/^/# /' "$OS_FILE" 2>/dev/null || true
msg_ok "$(translate "Residual Bookworm entries commented where applicable")"




# ---------------------------
# Step 5
# ---------------------------

if [[ "$REPO_MODE" == "enterprise" ]]; then
  msg_info "$(translate "Ensuring pve-enterprise.sources (PVE 9, deb822) is present...")"
  create_pve_repo_enterprise_if_missing
  msg_ok "$(translate "Enterprise repository present")"
else
  msg_info "$(translate "Ensuring proxmox.sources (PVE 9, no-subscription, deb822) is present...")"
  create_pve_repo_nosub_if_missing
  msg_ok "$(translate "No-subscription repository present")"
fi


msg_info "$(translate "Commenting legacy PVE 8 repository .list files (if any)...")"
comment_legacy_pve8_lists
msg_ok "$(translate "Legacy PVE 8 .list files commented or not present")"




# ---------------------------
# Step 6
# ---------------------------

if command -v ceph >/dev/null 2>&1; then
  if [[ "$REPO_MODE" == "enterprise" ]]; then
    msg_info "$(translate "Ensuring ceph.sources (enterprise, Trixie) is present...")"
    create_ceph_repo_enterprise_if_missing
    msg_ok "$(translate "Ceph enterprise repository present")"
  else
    msg_info "$(translate "Ensuring ceph.sources (no-subscription, Trixie) is present...")"
    create_ceph_repo_nosub_if_missing
    msg_ok "$(translate "Ceph no-subscription repository present")"
  fi

  msg_info "$(translate "Commenting legacy ceph.list (if present)...")"
  comment_legacy_ceph_list
  msg_ok "$(translate "Legacy ceph.list commented or not present")"
fi




# ---------------------------
# Step 7
# ---------------------------

apt_update_with_repo_fallback

run_step \
  "" \
  "Repository verification completed (see log)" \
  "apt policy >/dev/null 2>&1"





# ---------------------------
# Step 8
# ---------------------------

guard_against_proxmox_ve_removal

disable_translation_post_upgrade() {
  translate() { echo "$1"; }
}
disable_translation_post_upgrade



# ==========================================================


# ---------------------------
# Step 9
# ---------------------------

if [[ "$ASSUME_YES" == "1" ]]; then
  run_step \
    "" \
    "System upgraded to Trixie/PVE 9" \
    "DEBIAN_FRONTEND=noninteractive APT_LISTCHANGES_FRONTEND=none apt-get -y -o Dpkg::Options::='--force-confdef' -o Dpkg::Options::='--force-confold' dist-upgrade"
else
  run_step_interactive \
    "" \
    "System upgraded to Trixie/PVE 9" \
    bash -lc "apt-get dist-upgrade"
fi



# ==========================================================




# ---------------------------
# Step 10
# ---------------------------
if [[ -d /sys/firmware/efi ]]; then
  if [[ "$ASSUME_YES" == "1" ]]; then
    append_step \
      "Installing grub-efi-amd64" \
      "grub-efi-amd64 installed or already present" \
      "apt-get install -y grub-efi-amd64 >/dev/null 2>&1"
  else
    run_step \
      "Installing grub-efi-amd64" \
      "grub-efi-amd64 installed or already present" \
      "apt-get install grub-efi-amd64 >/dev/null 2>&1"
  fi
fi





run_pve8to9_check2() {
  local tmp
  tmp="$(mktemp)"
  echo -e
  set -o pipefail
  pve8to9 --full 2>&1 | tee -a "$LOG" | tee "$tmp"
  local rc=${PIPESTATUS[0]}

  local fails warns
  fails=$(grep -c 'FAIL:' "$tmp" || true)
  warns=$(grep -c 'WARN:' "$tmp" || true)


    if (( fails > 0 )); then
      echo -e
      echo -e "${BFR}${RD}[ERROR] $(translate "Pre-check found") $fails $(translate "blocking issue(s).")\n$(translate "Please resolve the problem(s) as described above, then re-run the upgrade script.")${CL}"
      echo -e
      

      local repair_commands=()
      local repair_descriptions=()
      
      # Error 1: systemd-boot meta-package
      if grep -q 'systemd-boot meta-package installed' "$tmp"; then
        repair_commands+=("apt remove -y systemd-boot")
        repair_descriptions+=("$(translate "Remove obsolete systemd-boot meta-package")")
        echo -e "${YW}$(translate "Fix systemd-boot:") ${CL}apt remove -y systemd-boot"
      fi
      # Error 2: Kernel version mismatch
      if grep -q -E 'FAIL:.*(kernel.*mismatch|kernel.*version.*mismatch)' "$tmp"; then
        repair_commands+=("update-grub")
        repair_descriptions+=("$(translate "Update kernel to compatible version")")
        echo -e "${YW}$(translate "Fix kernel version:") ${CL}update-grub"
      fi
      
      # Error 3: Ceph version incompatible
      if grep -q -E '(ceph.*version|ceph.*incompatible)' "$tmp"; then
        repair_commands+=("ceph versions && pveceph upgrade")
        repair_descriptions+=("$(translate "Upgrade Ceph to compatible version")")
        echo -e "${YW}$(translate "Fix Ceph version:") ${CL}ceph versions && pveceph upgrade"
      fi
      
      # Error 4: Repository configuration issues
      if grep -q -E '(repository.*issue|repo.*problem|sources.*error)' "$tmp"; then
        repair_commands+=("cleanup_duplicate_repos && configure_repositories")
        repair_descriptions+=("$(translate "Fix repository configuration")")
        echo -e "${YW}$(translate "Fix repositories:") ${CL}cleanup_duplicate_repos && configure_repositories"
      fi
      
      # Error 5: Package conflicts
      if grep -q -E '(package.*conflict|dependency.*problem)' "$tmp"; then
        repair_commands+=("apt update && apt autoremove -y && apt autoclean")
        repair_descriptions+=("$(translate "Resolve package conflicts")")
        echo -e "${YW}$(translate "Fix package conflicts:") ${CL}apt update && apt autoremove -y && apt autoclean"
      fi
      
      # Error 6: Disk space issues
      if grep -q -E 'FAIL:.*(disk space|no space left|storage.*full)' "$tmp"; then
        repair_commands+=("apt clean && apt autoremove -y && journalctl --vacuum-time=7d")
        repair_descriptions+=("$(translate "Free up disk space")")
        echo -e "${YW}$(translate "Fix disk space:") ${CL}apt clean && apt autoremove -y && journalctl --vacuum-time=7d"
      fi
      
      echo -e
      

      if [[ ${#repair_commands[@]} -gt 0 ]]; then
        echo -e "${BFR}${CY}$(translate "Repair Options:")${CL}"
        echo -e "${TAB}${GN}1.${CL} $(translate "Try automatic repair of detected issues")"
        echo -e "${TAB}${GN}2.${CL} $(translate "Show manual repair commands")"
        echo -e
        echo -n "$(translate "Select option [1-2] (default: 2): ")"
        read -r repair_choice
        
        case "$repair_choice" in
          1)
            echo -e
            msg_info2 "$(translate "Attempting automatic repair...")"
            local repair_success=0
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${YW}$(translate "Executing:") ${repair_descriptions[$i]}${CL}"
              if eval "${repair_commands[$i]}"; then
                msg_ok "${repair_descriptions[$i]} - $(translate "Success")"
              else
                msg_error "${repair_descriptions[$i]} - $(translate "Failed")"
                repair_success=1
              fi
            done
            
            if [[ $repair_success -eq 0 ]]; then
              echo -e
              msg_info2 "$(translate "Re-running pre-check after repairs...")"
              sleep 2
              run_pve8to9_check
              return $?
            else
              echo -e
              msg_error "$(translate "Some repairs failed. Please fix manually and re-run the script.")"
            fi
            ;;
          2)
            echo -e
            echo -e "$(translate "${BFR}${CY}Manual Repair Commands:${CL}")"
            for i in "${!repair_commands[@]}"; do
              echo -e "${TAB}${BL}# ${repair_descriptions[$i]}${CL}"
              echo -e
              echo -e "${TAB}${repair_commands[$i]}"
              echo -e
            done
            echo -e
            msg_info2 "$(translate "Once finished, re-run the script 'PVE 8 to 9 check' to verify that all issues are resolved \n   before rebooting.")"
            echo -e
            msg_success "$(translate "Press Enter to exit the script after reading instructions...")"
            read -r
            rm -f "$tmp"
            exit 1
            ;;
        esac
      fi
      
      msg_success "$(translate "Press Enter to continue")"
      read -r
    fi
    
    echo -e
    msg_ok "$(translate "Checklist post-upgrade finished. Warnings:") $warns"
    rm -f "$tmp"
    return $rc

}

run_pve8to9_check2


# ---------------------------


echo
echo
echo
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "      UPGRADE TO PVE 9 COMPLETED (reboot required)            "
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo
echo
echo

msg_success "Press Enter to continue..."
read -r

whiptail --title "Reboot Required" \
  --yesno "It is RECOMMENDED to reboot now to load the new kernel and services.\n\nReboot now?" \
  12 70

if [ $? -eq 0 ]; then
  echo -e
  msg_warn "Rebooting the system..."
  echo -e
  reboot
else
  msg_info2 "You can reboot later manually."
  echo -e
  msg_success "Press Enter to exit"
  read -r
fi

exit 0



================================================
FILE: scripts/utilities/uup_dump_iso_creator.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenux - UUP Dump ISO Creator Custom
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 30/06/2025
# ==========================================================
# Description:
# This script is part of the ProxMenux tools for Proxmox VE.
# It allows downloading and converting official Windows ISO images 
# from UUP Dump using a shared link (with ID, pack, and edition).
#
# Key features:
# - Automatically installs and verifies required dependencies (aria2c, cabextract, wimlib-imagexâ€¦)
# - Downloads the selected Windows edition from UUP Dump using aria2
# - Converts the downloaded files into a bootable ISO
# - Stores the resulting ISO in the default template path (/var/lib/vz/template/iso)
# - Provides a graphical prompt via whiptail for user-friendly usage
#
# This tool simplifies the creation of official Windows ISOs
# for use in virtual machines within Proxmox VE.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
detect_iso_dir() {
    for store in $(pvesm status -content iso | awk 'NR>1 {print $1}'); do
        for ext in iso img; do
            volid=$(pvesm list "$store" --content iso | awk -v ext="$ext" 'NR>1 && $2 ~ ext {print $1; exit}')
            if [[ -n "$volid" ]]; then
                path=$(pvesm path "$volid" 2>/dev/null)
                dir=$(dirname "$path")
                [[ -d "$dir" ]] && echo "$dir" && return 0
            fi
        done
    done
    
    if [[ -d /var/lib/vz/template/iso ]]; then
        echo "/var/lib/vz/template/iso"
        return 0
    fi
    
    return 1
}


function get_destination_path() {
    local default_path="$1"
    local user_path=""
    
    while true; do

######################################

        user_path=$(dialog  --backtitle "ProxMenux" --inputbox "$(translate "Enter destination path for ISO file")" 10 80 "$default_path" 3>&1 1>&2 2>&3)
        
######################################

        if [[ $? -ne 0 ]]; then
            return 1
        fi
        

        if [[ -z "$user_path" ]]; then
            user_path="$default_path"
        fi
        

        if [[ ! -d "$user_path" ]]; then
            if mkdir -p "$user_path" 2>/dev/null; then
                #msg_ok "$(translate "Directory created successfully:") $user_path"
                echo "$user_path"
                return 0
            else
                dialog --backtitle "ProxMenux" --msgbox "$(translate "Error: Cannot create directory") '$user_path'. $(translate "Please check permissions and try again.")" 8 60

                continue
            fi
        else

            if [[ -w "$user_path" ]]; then
                echo "$user_path"
                return 0
            else
                dialog --backtitle "ProxMenux" --msgbox "$(translate "Error: No write permissions in directory") '$user_path'. $(translate "Please choose another path.")" 8 60

                continue
            fi
        fi
    done
}

function run_uupdump_creator() {
    local DEPS=(curl aria2 cabextract wimtools genisoimage chntpw)
    local CMDS=(curl aria2c cabextract wimlib-imagex genisoimage chntpw)
    local MISSING=()
    local FAILED=()


    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            MISSING+=("${DEPS[$i]}")
        fi
    done

    if [[ ${#MISSING[@]} -gt 0 ]]; then
        clear
        show_proxmenux_logo
        echo -e
        msg_info "$(translate "Installing dependencies: ${MISSING[*]}")"
        apt-get update -qq >/dev/null 2>&1
        msg_ok "$(translate "All dependencies installed and verified.")"
        if ! apt-get install -y "${MISSING[@]}" >/dev/null 2>&1; then
            msg_error "$(translate "Failed to install: ${MISSING[*]}")"
            exit 1
        fi
    fi


    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            FAILED+=("${CMDS[$i]}")
        fi
    done

    #if [[ ${#FAILED[@]} -eq 0 ]]; then
    #    msg_ok "$(translate "All dependencies installed and verified.")"
    #else
    #    msg_error "$(translate "Missing commands after installation: ${FAILED[*]}")"
    #    exit 1
    #fi


    ISO_DIR=$(detect_iso_dir)
    if [[ -z "$ISO_DIR" ]]; then
        msg_error "$(translate "Could not determine a valid ISO storage directory.")"
        exit 1
    fi
    mkdir -p "$ISO_DIR"

######################################

    DEFAULT_TMP="/root/uup-temp"
    USER_INPUT=$(dialog --backtitle "ProxMenux" --inputbox "Enter temporary folder path (default: $DEFAULT_TMP):" 10 60 "$DEFAULT_TMP" 3>&1 1>&2 2>&3)
    
######################################


    if [[ $? -ne 0 ]]; then
        return
    fi


    if [[ $? -ne 0 || -z "$USER_INPUT" ]]; then
        USER_INPUT="$DEFAULT_TMP"
    fi


    if [[ "$USER_INPUT" == "$DEFAULT_TMP" ]]; then
        TMP_DIR="$USER_INPUT"
        CLEAN_ALL=true
    else
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        RANDOM_ID=$(head /dev/urandom | tr -dc a-z0-9 | head -c 4)
        TMP_DIR="${USER_INPUT%/}/uup-session-${TIMESTAMP}-${RANDOM_ID}"
        CLEAN_ALL=false
    fi

    mkdir -p "$TMP_DIR" || {
        msg_error "$(translate "Failed to create temporary directory:") $TMP_DIR"
        exit 1
    }


    OUT_DIR=$(get_destination_path "$ISO_DIR")
    if [[ $? -ne 0 ]]; then
        return 1
    fi


######################################

    UUP_URL=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Paste the UUP Dump URL here")" 10 90 3>&1 1>&2 2>&3)

######################################


    if [[ $? -ne 0 ]]; then
        return
    fi

    
    if [[ $? -ne 0 || -z "$UUP_URL" ]]; then
        msg_warn "$(translate "Cancelled by user or empty URL.")"
        return 1  
    fi


    if [[ ! "$UUP_URL" =~ id=.+\&pack=.+\&edition=.+ ]]; then
        msg_error "$(translate "The URL does not contain the required parameters (id, pack, edition).")"
        sleep 2
        return
    fi


    BUILD_ID=$(echo "$UUP_URL" | grep -oP 'id=\K[^&]+')
    LANG=$(echo "$UUP_URL" | grep -oP 'pack=\K[^&]+')
    EDITION=$(echo "$UUP_URL" | grep -oP 'edition=\K[^&]+')
    ARCH="amd64"
    clear
    show_proxmenux_logo
    echo -e
    echo -e "\n${BGN}=============== UUP Dump Creator ===============${CL}"
    echo -e "    ${BGN}ğŸ†” ID:${CL} ${DGN}$BUILD_ID${CL}"
    echo -e "    ${BGN}ğŸŒ Language:${CL} ${DGN}$LANG${CL}"
    echo -e "    ${BGN}ğŸ’¿ Edition:${CL} ${DGN}$EDITION${CL}"
    echo -e "    ${BGN}ğŸ–¥ï¸ Architecture:${CL} ${DGN}$ARCH${CL}"
    echo -e "    ${BGN}ğŸ“ Destination:${CL} ${DGN}$OUT_DIR${CL}"
    echo -e "${BGN}===============================================${CL}\n"


    CONVERTER="$TMP_DIR/converter"
    if [[ ! -f "$CONVERTER/convert.sh" ]]; then
        echo "ğŸ“¦ $(translate "Downloading UUP converter...")"
        mkdir -p "$CONVERTER"
        cd "$CONVERTER" || exit 1
        wget -q https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz -O converter.tar.gz
        tar -xzf converter.tar.gz --strip-components=1
        chmod +x convert.sh
        cd "$TMP_DIR" || exit 1
    fi


    cat > uup_download_linux.sh <<EOF
#!/bin/bash
mkdir -p files
echo "https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz" > files/converter_multi

for prog in aria2c cabextract wimlib-imagex chntpw; do
  which \$prog &>/dev/null || { echo "\$prog not found."; exit 1; }
done

which genisoimage &>/dev/null || which mkisofs &>/dev/null || { echo "genisoimage/mkisofs not found."; exit 1; }

destDir="UUPs"
tempScript="aria2_script.\$RANDOM.txt"

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \\
  -x16 -s16 -j2 --allow-overwrite=true --auto-file-renaming=false -d"files" -i"files/converter_multi" || exit 1

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \\
  -o"\$tempScript" --allow-overwrite=true --auto-file-renaming=false \\
  "https://uupdump.net/get.php?id=$BUILD_ID&pack=$LANG&edition=$EDITION&aria2=2" || exit 1

grep '#UUPDUMP_ERROR:' "\$tempScript" && { echo "âŒ Error generating UUP download list."; exit 1; }

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \\
  -x16 -s16 -j5 -c -R -d"\$destDir" -i"\$tempScript" || exit 1
EOF

    chmod +x uup_download_linux.sh


    ./uup_download_linux.sh


    UUP_FOLDER=$(find "$TMP_DIR" -type d -name "UUPs" | head -n1)
    [[ -z "$UUP_FOLDER" ]] && msg_error "$(translate "No UUP folder found.")" && exit 1

    echo -e "\n${GN}=======================================${CL}"
    echo -e "    ğŸ’¿ ${GN}Starting ISO conversion...${CL}"
    echo -e "${GN}=======================================${CL}\n"


    "$CONVERTER/convert.sh" wim "$UUP_FOLDER" 1


    ISO_FILE=$(find "$TMP_DIR" "$CONVERTER" "$UUP_FOLDER" -maxdepth 1 -iname "*.iso" | head -n1)

    if [[ -f "$ISO_FILE" ]]; then
        mv "$ISO_FILE" "$OUT_DIR/"
        msg_ok "$(translate "ISO created successfully:") $OUT_DIR/$(basename "$ISO_FILE")"
        msg_ok "$(translate "Cleaning temporary files...")"
        
        if [[ "$CLEAN_ALL" == true ]]; then
            rm -rf "$TMP_DIR" "$CONVERTER"
        else
            [[ -d "$TMP_DIR" ]] && rm -rf "$TMP_DIR"
            [[ -d "$CONVERTER" ]] && rm -rf "$CONVERTER"
        fi

        export OS_TYPE="windows"
        export LANGUAGE=C
        export LANG=C
        export LC_ALL=C
        load_language
        initialize_cache
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
    else
        msg_warn "$(translate "No ISO was generated.")"
        rm -rf "$TMP_DIR" "$CONVERTER"
        export LANGUAGE=C
        export LANG=C
        export LC_ALL=C
        load_language
        initialize_cache
        msg_success "$(translate "Press Enter to return to menu...")"
        read -r
        return 1
    fi
}

run_uupdump_creator


================================================
FILE: scripts/vm/create_vm.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================



LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
VM_REPO="$LOCAL_SCRIPTS/vm"
ISO_REPO="$LOCAL_SCRIPTS/vm"
MENU_REPO="$LOCAL_SCRIPTS/menus"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"


source "$VM_REPO/vm_configurator.sh"
source "$VM_REPO/disk_selector.sh"
source "$VM_REPO/vm_creator.sh"



if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache



function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}             ProxMenux VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}

# ==========================================================
# MAIN EXECUTION
# ==========================================================

header_info
echo -e "\n Loading..."
sleep 1




function start_vm_configuration() {

  if (whiptail --title "ProxMenux" --yesno "$(translate "Use Default Settings?")" --no-button "$(translate "Advanced")" 10 60); then
    header_info
    load_default_vm_config "$OS_TYPE"

    if [[ -z "$HN" ]]; then
      HN=$(whiptail --inputbox "$(translate "Enter a name for the new virtual machine:")" 10 60 --title "VM Hostname" 3>&1 1>&2 2>&3)
      [[ -z "$HN" ]] && HN="custom-vm"
    fi

    apply_default_vm_config
  else
    header_info
    echo -e "${CUS}$(translate "Using advanced configuration")${CL}"
    configure_vm_advanced "$OS_TYPE"
  fi
}



while true; do
  OS_TYPE=$(dialog --backtitle "ProxMenux" \
    --title "$(translate "Select System Type")" \
    --menu "\n$(translate "Choose the type of virtual system to install:")" 18 70 10 \
    1 "$(translate "Create") VM System NAS" \
    2 "$(translate "Create") VM System Windows" \
    3 "$(translate "Create") VM System Linux" \
    4 "$(translate "Create") VM System macOS (OSX-PROXMOX)" \
    5 "$(translate "Create") VM System Others (based Linux)" \
    6 "$(translate "Return to Main Menu")" \
    3>&1 1>&2 2>&3)


  [[ $? -ne 0 || "$OS_TYPE" == "5" ]] && exec bash "$MENU_REPO/main_menu.sh"

  case "$OS_TYPE" in
    1)
      source "$ISO_REPO/select_nas_iso.sh" && select_nas_iso || continue
      ;;
    2)
      source "$ISO_REPO/select_windows_iso.sh" && select_windows_iso || continue
      ;;
    3)
      source "$ISO_REPO/select_linux_iso.sh" && select_linux_iso || continue
      ;;
    4)
      whiptail --title "OSX-PROXMOX" --yesno "$(translate "This is an external script that creates a macOS VM in Proxmox VE in just a few steps, whether you are using AMD or Intel hardware.")\n\n$(translate "The script clones the osx-proxmox.com repository and once the setup is complete, the server will automatically reboot.")\n\n$(translate "Make sure there are no critical services running as they will be interrupted. Ensure your server can be safely rebooted.")\n\n$(translate  "Visit https://osx-proxmox.com for more information.")\n\n$(translate "Do you want to run the script now?")" 20 70
      if [[ $? -eq 0 ]]; then
        bash -c "$(curl -fsSL https://install.osx-proxmox.com)"
      fi
      continue
      ;;
    5)
      source "$ISO_REPO/select_linux_iso.sh" && select_linux_other_scripts || continue
      ;;
  esac


  if ! confirm_vm_creation; then
    continue  
  fi


  start_vm_configuration || continue


  select_disk_type
  if [[ -z "$DISK_TYPE" ]]; then
    msg_error "$(translate "Disk type selection failed or cancelled")"
    continue  
  fi

  create_vm
  break
done





function start_vm_configuration() {

  if (whiptail --title "ProxMenux" --yesno "$(translate "Use Default Settings?")" --no-button "$(translate "Advanced")" 10 60); then
    header_info
    load_default_vm_config "$OS_TYPE"

    if [[ -z "$HN" ]]; then
      HN=$(whiptail --inputbox "$(translate "Enter a name for the new virtual machine:")" 10 60 --title "VM Hostname" 3>&1 1>&2 2>&3)
      [[ -z "$HN" ]] && HN="custom-vm"
    fi

    apply_default_vm_config
  else
    header_info
    echo -e "${CUS}$(translate "Using advanced configuration")${CL}"
    configure_vm_advanced "$OS_TYPE"
  fi
}



================================================
FILE: scripts/vm/disk_selector.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================


BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

function select_disk_type() {
  DISK_TYPE=$(whiptail --backtitle "ProxMenux" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  [[ -z "$DISK_TYPE" ]] && return 1

  if [[ "$DISK_TYPE" == "virtual" ]]; then
    select_virtual_disk
  else
    select_passthrough_disk
  fi
}

# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      


  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."


    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

 
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    

    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi


    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi


    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")



    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done


  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
}
# ==========================================================


================================================
FILE: scripts/vm/guest_agent_config.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# Guest Agent Configurator - ProxMenux
# ==========================================================
# AÃ±ade soporte al QEMU Guest Agent y dispositivos Ãºtiles.
# Se adapta segÃºn el sistema operativo.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache



function configure_guest_agent() {
  if [[ -z "$VMID" ]]; then
    msg_error "$(translate "No VMID defined. Cannot apply guest agent config.")"
    return 1
  fi

  msg_info "$(translate "Adding QEMU Guest Agent support...")"

  # Habilitar el agente en la VM
  qm set "$VMID" -agent enabled=1 >/dev/null 2>&1

  # AÃ±adir canal de comunicaciÃ³n virtio
  qm set "$VMID" -chardev socket,id=qga0,path=/var/run/qemu-server/$VMID.qga,server=on,wait=off >/dev/null 2>&1
  qm set "$VMID" -device virtio-serial-pci -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 >/dev/null 2>&1

  msg_ok "$(translate "Guest Agent configuration applied")"

  if [[ "$OS_TYPE" == "windows" ]]; then
    echo -e "${YW}$(translate "Reminder: You must install the QEMU Guest Agent inside the Windows VM")${NC}"
    echo -e "${YW}$(translate "Tip: Also mount the VirtIO ISO for drivers and guest agent installer")${NC}"
    echo -e "${TAB}- https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/"
  elif [[ "$OS_TYPE" == "linux" || "$OS_TYPE" == "lite" ]]; then
    echo -e "${YW}$(translate "Tip: You can install the QEMU Guest Agent inside the VM with:")${NC}"
    echo -e "${TAB}apt install qemu-guest-agent -y && systemctl enable --now qemu-guest-agent"
  fi
}




================================================
FILE: scripts/vm/select_linux_iso.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================


LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
ISO_DIR="/var/lib/vz/template/iso"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"
load_language
initialize_cache

# ==============================================================
# FUNCIONES PRINCIPALES
# ==============================================================

function select_linux_iso() {

	local EXIT_FLAG="no"
	local header
	if [[ "$LANGUAGE" == "es" ]]; then
	  header=$(printf "%-43sâ”‚ %s" "       DescripciÃ³n" "Fuente")
	else
	  header=$(printf "%-42sâ”‚ %s" "       $(translate "Description")" "$(translate "Source")")
	fi


  while [[ "$EXIT_FLAG" != "yes" ]]; do

    if [[ "$LANGUAGE" == "es" ]]; then

                CHOICE=$(dialog --clear \
                  --backtitle "ProxMenux" \
                  --title "Opciones de instalaciÃ³n de Linux" \
                  --menu "\nSeleccione el tipo de instalaciÃ³n de Linux:\n\n$header" \
                  18 72 10 \
                  1 "$(printf '%-35sâ”‚ %s' 'Instalar con metodo tradicional' 'Desde ISO oficial')" \
                  2 "$(printf '%-35sâ”‚ %s' 'Instalar con script Cloud-Init' 'Helper Scripts')" \
                  3 "$(printf '%-35sâ”‚ %s' 'Instalar con ISO personal' 'Almacenamiento local')" \
                  4 "Volver al menÃº principal" \
                  3>&1 1>&2 2>&3)
                        else
 
                local desc1 desc2 desc3 back
                desc1="$(translate "Install with traditional method")"
                desc2="$(translate "Install with Cloud-Init script")"
                desc3="$(translate "Install with personal ISO")"
                back="$(translate "Return to main menu")"
                          CHOICE=$(dialog --clear \
        --backtitle "ProxMenux" \
        --title "$(translate "Linux Installation Options")" \
        --menu "\n$(translate "Select the type of Linux installation:")\n\n$header" \
        18 70 10 \
        1 "$(printf '%-35sâ”‚ %s' "$desc1" "From official ISO")" \
        2 "$(printf '%-35sâ”‚ %s' "$desc2" "Helper Scripts")" \
        3 "$(printf '%-35sâ”‚ %s' "$desc3" "Local Storage")" \
        4 "$back" \
        3>&1 1>&2 2>&3)
    fi

    if [[ $? -ne 0 || "$CHOICE" == "4" ]]; then
      unset ISO_NAME ISO_TYPE ISO_URL ISO_FILE ISO_PATH HN
      return 1
    fi

    case "$CHOICE" in
      1) select_linux_iso_official && EXIT_FLAG="yes" ;;
      2) select_linux_cloudinit ;;
      3) select_linux_custom_iso && EXIT_FLAG="yes" ;;
    esac
  done
}




function select_linux_iso_official() {
  DISTROS=(
    "Ubuntu 25.04|Desktop|ProxMenux|https://releases.ubuntu.com/25.04/ubuntu-25.04-desktop-amd64.iso"
    "Ubuntu 24.04|Desktop|ProxMenux|https://releases.ubuntu.com/24.04/ubuntu-24.04.2-desktop-amd64.iso"
    "Ubuntu 22.04|Desktop|ProxMenux|https://releases.ubuntu.com/22.04/ubuntu-22.04.5-desktop-amd64.iso"
    "Ubuntu 20.04|Desktop|ProxMenux|https://releases.ubuntu.com/20.04/ubuntu-20.04.6-desktop-amd64.iso"
    "Ubuntu 25.04 Server|CLI|ProxMenux|https://releases.ubuntu.com/25.04/ubuntu-25.04-live-server-amd64.iso"
    "Ubuntu 24.04 Server|CLI|ProxMenux|https://releases.ubuntu.com/24.04/ubuntu-24.04.2-live-server-amd64.iso"
    "Ubuntu 22.04 Server|CLI|ProxMenux|https://releases.ubuntu.com/22.04/ubuntu-22.04.5-live-server-amd64.iso"
    "Ubuntu 20.04 Server|CLI|ProxMenux|https://releases.ubuntu.com/20.04/ubuntu-20.04.6-live-server-amd64.iso"
    "Debian 13|Desktop|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-13.0.0-amd64-DVD-1.iso"
    "Debian 12|Desktop|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-12.10.0-amd64-DVD-1.iso"
    "Debian 11|Desktop|ProxMenux|https://cdimage.debian.org/cdimage/archive/11.11.0/amd64/iso-dvd/debian-11.11.0-amd64-DVD-1.iso"
    "Debian 13 Netinst|CLI|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-13.0.0-amd64-netinst.iso"
    "Debian 12 Netinst|CLI|ProxMenux|https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/debian-12.10.0-amd64-netinst.iso"
    "Debian 11 Netinst|CLI|ProxMenux|https://cdimage.debian.org/cdimage/archive/11.11.0/amd64/iso-cd/debian-11.11.0-amd64-netinst.iso"
    "Fedora Workstation 42|Desktop|ProxMenux|https://download.fedoraproject.org/pub/fedora/linux/releases/42/Workstation/x86_64/iso/Fedora-Workstation-Live-42-1.1.x86_64.iso"
    "Arch Linux|CLI|ProxMenux|https://geo.mirror.pkgbuild.com/iso/2025.07.01/archlinux-2025.07.01-x86_64.iso"
    "Rocky Linux 9.5|Desktop|ProxMenux|https://download.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9.5-x86_64-dvd.iso"
    "Linux Mint 22.1|Desktop|ProxMenux|https://mirrors.edge.kernel.org/linuxmint/stable/22.1/linuxmint-22.1-cinnamon-64bit.iso"
    "openSUSE Leap 15.6|Desktop|ProxMenux|https://download.opensuse.org/distribution/leap/15.6/iso/openSUSE-Leap-15.6-DVD-x86_64-Media.iso"
    "Alpine Linux 3.21|Desktop|ProxMenux|https://dl-cdn.alpinelinux.org/alpine/v3.21/releases/x86_64/alpine-virt-3.21.3-x86_64.iso"
    "Kali Linux 2025.1|Desktop|ProxMenux|https://cdimage.kali.org/kali-2025.1c/kali-linux-2025.1c-installer-amd64.iso"
    "Manjaro 25.0|Desktop|ProxMenux|https://download.manjaro.org/gnome/25.0.0/manjaro-gnome-25.0.0-250414-linux612.iso"
  )

  MENU_OPTIONS=()
  INDEX=0
  for entry in "${DISTROS[@]}"; do
    IFS='|' read -r NAME TYPE SOURCE URL <<< "$entry"
    LINE=$(printf "%-30s â”‚ %-10s â”‚ %s" "$NAME" "$TYPE" "$SOURCE")
    MENU_OPTIONS+=("$INDEX" "$LINE")
    URLS[$INDEX]="$entry"
    ((INDEX++))
  done

  HEADER="%-42s â”‚ %-10s â”‚ %s"
  HEADER_TEXT=$(printf "$HEADER" "            Distribution" "Type" "Script Install")

  CHOICE=$(dialog --backtitle "ProxMenux" \
    --title "$(translate "Official Linux Distributions")" \
    --menu "$(translate "Select the Linux distribution to install:")\n\n$HEADER_TEXT" 20 80 12 \
    "${MENU_OPTIONS[@]}" \
    3>&1 1>&2 2>&3)

  [[ $? -ne 0 ]] && return 1

  SELECTED="${URLS[$CHOICE]}"
  IFS='|' read -r ISO_NAME ISO_TYPE SOURCE ISO_URL <<< "$SELECTED"
  ISO_FILE=$(basename "$ISO_URL")
  ISO_PATH="$ISO_DIR/$ISO_FILE"

  HN=$(echo "$ISO_NAME" | \
    sed 's/ (.*)//' | \
    tr -cs '[:alnum:]' '-' | \
    sed 's/^-*//' | \
    sed 's/-*$//' | \
    cut -c1-63)
              
  export ISO_NAME ISO_TYPE ISO_URL ISO_FILE ISO_PATH HN
  export OS_TYPE="3"
  return 0
}


function select_linux_cloudinit() {
  local CLOUDINIT_OPTIONS=(
    "1" "Arch Linux   (Cloud-Init automated)   â”‚ Helper Scripts"
    "2" "Debian 13    (Cloud-Init automated)   â”‚ Helper Scripts"
    "3" "Debian 12    (Cloud-Init automated)   â”‚ Helper Scripts"
    "4" "Ubuntu 22.04 (Cloud-Init automated)   â”‚ Helper Scripts"
    "5" "Ubuntu 24.04 (Cloud-Init automated)   â”‚ Helper Scripts"
    "6" "Ubuntu 24.10 (Cloud-Init automated)   â”‚ Helper Scripts"
    "7" "Ubuntu 25.04 (Cloud-Init automated)   â”‚ Helper Scripts"
    "8" "$(translate "Return to Main Menu")"
  )

  local script_selection
  script_selection=$(dialog --backtitle "ProxMenux" --title "$(translate "Cloud-Init Automated Installers")" \
    --menu "\n$(translate "Select a pre-configured Linux VM script to execute:")" 20 78 10 \
    "${CLOUDINIT_OPTIONS[@]}" 3>&1 1>&2 2>&3)

  [[ $? -ne 0 ]] && return

  case "$script_selection" in
    1)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/archlinux-vm.sh")
      ;;
    2)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/debian-13-vm.sh")
      ;;
    3)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/debian-vm.sh")
      ;;
    4)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2204-vm.sh")
      ;;
    5)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2404-vm.sh")
      ;;
    6)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2410-vm.sh")
      ;;
    7)
      bash <(curl -s "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/ubuntu2504-vm.sh")
      echo -e
      echo -e "after installation, checkout:\nhttps://github.com/community-scripts/ProxmoxVE/discussions/272"
      echo -e
      ;;  
    8)
      return
      ;;
  esac

  msg_success "$(translate "Press Enter to return to menu...")"
  read -r

  whiptail --title "Proxmox VE Helper-Scripts" \
           --msgbox "$(translate "Visit the website to discover more scripts, stay updated with the latest updates, and support the project:\n\nhttps://community-scripts.github.io/ProxmoxVE")" 15 70

  exec bash "$LOCAL_SCRIPTS/vm/create_vm.sh"
}


function select_linux_custom_iso() {
  ISO_LIST=()
  while read -r line; do
    FILENAME=$(basename "$line")
    SIZE=$(du -h "$line" | cut -f1)
    ISO_LIST+=("$FILENAME" "$SIZE")
  done < <(find "$ISO_DIR" -type f -iname "*.iso" | sort)

  if [[ ${#ISO_LIST[@]} -eq 0 ]]; then
    header_info
    msg_error "$(translate "No ISO images found in") $ISO_DIR."
    sleep 2
    return 1
  fi

  ISO_FILE=$(dialog --backtitle "ProxMenux" --title "$(translate "Available ISO Images")" \
    --menu "$(translate "Select a custom ISO to use:")" 20 70 10 \
    "${ISO_LIST[@]}" 3>&1 1>&2 2>&3)

  if [[ -z "$ISO_FILE" ]]; then
    header_info
    msg_warn "$(translate "No ISO selected.")"
    return 1
  fi

  ISO_PATH="$ISO_DIR/$ISO_FILE"
  ISO_NAME="$ISO_FILE"             

  export ISO_PATH ISO_FILE ISO_NAME
  export OS_TYPE="3"
  return 0
}



function select_linux_other_scripts() {
local OTHER_OPTIONS=(
  "1" "Home Assistant OS VM (HAOS)       â”‚ Helper Scripts"
  "2" "Docker VM (Debian + SSH + Docker) â”‚ Helper Scripts"
  "3" "Nextcloud                         â”‚ Helper Scripts"
  "4" "$(translate "Return to Main Menu")"
)

local choice
choice=$(dialog --backtitle "ProxMenux" \
  --title "$(translate "Other Prebuilt Linux VMs")" \
  --menu "\n$(translate "Select one of the ready-to-run Linux VMs:")" 18 70 10 \
  "${OTHER_OPTIONS[@]}" 3>&1 1>&2 2>&3)

if [[ $? -ne 0 || "$choice" == "4" ]]; then
  return 1
fi

case "$choice" in
  1)
    bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/haos-vm.sh)"
    ;;
  2)
    bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/docker-vm.sh)"
    echo -e
    echo -e "${TAB}$(translate "Default Login Credentials:")"
    echo -e "${TAB}Username: root"
    echo -e "${TAB}Password: docker"
    echo -e
    ;;
  3)
    bash -c "$(curl -fsSL https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/nextcloud-vm.sh)"
    echo -e
    echo -e "${TAB}$(translate "You can use the following credentials to login to the Nextcloud vm:")"
    echo -e "${TAB}Username: admin"
    echo -e "${TAB}$(translate "This VM requires extra installation steps, see install guide at:\nhttps://github.com/community-scripts/ProxmoxVE/discussions/144")"
    echo -e
    ;;
esac

msg_success "$(translate "Press Enter to return to menu...")"
read -r

whiptail --title "Proxmox VE Helper-Scripts" \
  --msgbox "$(translate "Visit the website to discover more scripts, stay updated with the latest updates, and support the project:\n\nhttps://community-scripts.github.io/ProxmoxVE")" 15 70

return 1

}









================================================
FILE: scripts/vm/select_nas_iso.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================


BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"
load_language
initialize_cache

ISO_DIR="/var/lib/vz/template/iso"
mkdir -p "$ISO_DIR"

function select_nas_iso() {

  local NAS_OPTIONS=(
    "1" "Synology DSM   VM          (Loader Linux-based)"
    "2" "TrueNAS SCALE  VM          (Fangtooth)"
    "3" "TrueNAS CORE   VM          (FreeBSD based)"
    "4" "OpenMediaVault VM          (Debian based)"
    "5" "XigmaNAS       VM          (FreeBSD based)"
    "6" "Rockstor       VM          (openSUSE based)"
    "7" "ZimaOS         VM          (Proxmox-zimaos)"
    "8" "Umbrel OS      VM          (Helper Scripts)"
    "9" "$(translate "Return to Main Menu")"
  )

  local NAS_TYPE
  NAS_TYPE=$(dialog --backtitle "ProxMenux" \
    --title "$(translate "NAS Systems")" \
    --menu "\n$(translate "Select the NAS system to install:")" 20 70 10 \
    "${NAS_OPTIONS[@]}" 3>&1 1>&2 2>&3)


  [[ $? -ne 0 ]] && return 1

  case "$NAS_TYPE" in
    1)
      bash "$LOCAL_SCRIPTS/vm/synology.sh"
      msg_success "$(translate "Press Enter to return to menu...")"
      read -r
      return 1
      ;;
    2)
      ISO_NAME="TrueNAS SCALE 25 (Fangtooth)"
      ISO_URL="https://download.truenas.com/TrueNAS-SCALE-Fangtooth/25.04.0/TrueNAS-SCALE-25.04.0.iso"
      ISO_FILE="TrueNAS-SCALE-25.04.0.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      HN="TrueNAS-Scale"
      ;;
    3)
      ISO_NAME="TrueNAS CORE 13.3"
      ISO_URL="https://download.freenas.org/13.3/STABLE/latest/x64/TrueNAS-13.3-U1.2.iso"
      ISO_FILE="TrueNAS-13.3-U1.2.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      HN="TrueNAS-Core"
      ;;
    4)
      ISO_NAME="OpenMediaVault 7.4.17"
      ISO_URL="https://sourceforge.net/projects/openmediavault/files/iso/7.4.17/openmediavault_7.4.17-amd64.iso/download"
      ISO_FILE="openmediavault_7.4.17-amd64.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      HN="OpenMediaVault"
      ;;
    5)
      ISO_NAME="XigmaNAS-14.3.0.5"
      ISO_URL="https://sourceforge.net/projects/xigmanas/files/XigmaNAS-14.3.0.5/14.3.0.5.10566/XigmaNAS-x64-LiveCD-14.3.0.5.10566.iso/download"
      ISO_FILE="XigmaNAS-x64-LiveCD-14.3.0.5.10566.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      HN="XigmaNAS"
      ;;
    6)
      ISO_NAME="Rockstor"
      ISO_URL="https://rockstor.com/downloads/installer/leap/15.6/x86_64/Rockstor-Leap15.6-generic.x86_64-5.0.15-0.install.iso"
      ISO_FILE="Rockstor-Leap15.6-generic.x86_64-5.0.15-0.install.iso"
      ISO_PATH="$ISO_DIR/$ISO_FILE"
      HN="Rockstor"
      ;;
    7)
      bash "$LOCAL_SCRIPTS/vm/zimaos.sh"
      msg_success "$(translate "Press Enter to return to menu...")"
      read -r
      return 1
      ;;
    8)
      HN="Umbrel OS"
      bash -c "$(wget -qLO - https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/vm/umbrel-os-vm.sh)"
      echo -e
      echo -e "${TAB}$(translate "Default Login Credentials:")"
      echo -e "${TAB}Username: umbrel"
      echo -e "${TAB}Password: umbrel"
      echo -e "${TAB}$(translate "After logging in, run: ip a to obtain the IP address.\nThen, enter that IP address in your web browser like this:\n  http://IP_ADDRESS\n\nThis will open the Umbral OS dashboard.")"
      echo -e
      msg_success "$(translate "Press Enter to return to menu...")"
      read -r
      
      whiptail --title "Proxmox VE - Umbrel OS" \
        --msgbox "$(translate "Umbrel OS installer script by Helper Scripts\n\nVisit the GitHub repo to learn more, contribute, or support the project:\n\nhttps://community-scripts.github.io/ProxmoxVE/scripts?id=umbrel-os-vm")" 15 70

      return 1
      ;;

    9)
      return 1
      ;;
  esac

  export ISO_NAME ISO_URL ISO_FILE ISO_PATH HN
  return 0
}



================================================
FILE: scripts/vm/select_windows_iso.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
UUP_REPO="$LOCAL_SCRIPTS/vm"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"
ISO_DIR="/var/lib/vz/template/iso"

[[ -f "$UTILS_FILE" ]] && source "$UTILS_FILE"
load_language
initialize_cache
mkdir -p "$ISO_DIR"

function select_windows_iso() {
  local EXIT_FLAG="no"
  local header
  if [[ "$LANGUAGE" == "es" ]]; then
    header=$(printf "%-41sâ”‚ %s" "      DescripciÃ³n" "Fuente")
  else
    header=$(printf "%-43sâ”‚ %s" "        $(translate "Description")" "$(translate "Source")")
  fi

  while [[ "$EXIT_FLAG" != "yes" ]]; do
    if [[ "$LANGUAGE" == "es" ]]; then
      CHOICE=$(dialog --clear \
        --backtitle "ProxMenux" \
        --title "Opciones de instalaciÃ³n de Windows" \
        --menu "\nSeleccione el tipo de instalaciÃ³n de Windows:\n\n$header" \
        18 70 10 \
        1 "$(printf '%-34sâ”‚ %s' 'Instalar con ISO UUP Dump' 'UUP Dump ISO creator')" \
        2 "$(printf '%-34sâ”‚ %s' 'Instalar con ISO personal' 'Almacenamiento local')" \
        3 "Volver al menÃº principal" \
        3>&1 1>&2 2>&3)
    else
      local desc1 desc2 back
      desc1="$(translate "Install with ISO from UUP Dump")"
      desc2="$(translate "Install with personal ISO")"
      back="$(translate "Return to main menu")"
      CHOICE=$(dialog --clear \
        --backtitle "ProxMenux" \
        --title "$(translate "Windows Installation Options")" \
        --menu "\n$(translate "Select the type of Windows installation:")\n\n$header" \
        18 70 10 \
        1 "$(printf '%-35sâ”‚ %s' "$desc1" "UUP Dump creator")" \
        2 "$(printf '%-35sâ”‚ %s' "$desc2" "Local Storage")" \
        3 "$back" \
        3>&1 1>&2 2>&3)
    fi

    if [[ $? -ne 0 || "$CHOICE" == "3" ]]; then
      unset ISO_NAME ISO_TYPE ISO_URL ISO_FILE ISO_PATH HN
      return 1
    fi

    case "$CHOICE" in
      1)
        if source "$UUP_REPO/uupdump_creator.sh"; then
          run_uupdump_creator || return 1
          detect_latest_iso_created || return 1
          EXIT_FLAG="yes"
        else
          msg_error "$(translate "UUP Dump script not found.")"
          return 1
        fi
        ;;
      2)
        select_existing_iso || return 1
        EXIT_FLAG="yes"
        ;;
    esac
  done
}


function select_existing_iso() {
  ISO_LIST=()
  while read -r line; do
    FILENAME=$(basename "$line")
    SIZE=$(du -h "$line" | cut -f1)
    ISO_LIST+=("$FILENAME" "$SIZE")
  done < <(find "$ISO_DIR" -type f -iname "*.iso" ! -iname "virtio*" | sort)

  if [[ ${#ISO_LIST[@]} -eq 0 ]]; then
    header_info
    msg_error "$(translate "No ISO images found in") $ISO_DIR."
    sleep 2
    return 1
  fi

  ISO_FILE=$(dialog --backtitle "ProxMenux" --title "$(translate "Available ISO Images")" \
    --menu "$(translate "Choose a Windows ISO to use:")" 20 70 10 \
    "${ISO_LIST[@]}" 3>&1 1>&2 2>&3)

  [[ -z "$ISO_FILE" ]] && msg_warn "$(translate "No ISO selected.")" && return 1

  ISO_PATH="$ISO_DIR/$ISO_FILE"
  ISO_NAME="$ISO_FILE"

  export ISO_PATH ISO_FILE ISO_NAME
  export OS_TYPE="2"
  
  return 0
}

function detect_latest_iso_created() {
  ISO_FILE=$(find "$ISO_DIR" -maxdepth 1 -type f -iname "*.iso" ! -iname "virtio*" -printf "%T@ %p\n" | sort -n | awk '{print $2}' | tail -n 1)

  if [[ -z "$ISO_FILE" ]]; then
    msg_error "$(translate "No ISO file detected after UUP Dump process.")"
    sleep 2
    return 1
  fi

  ISO_NAME=$(basename "$ISO_FILE")
  ISO_PATH="$ISO_FILE"

  export ISO_PATH ISO_FILE ISO_NAME
  export OS_TYPE="2"

  return 0
}



================================================
FILE: scripts/vm/synology.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Synology DSM VM Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 13/03/2025
# ==========================================================
# Description:
# This script automates the creation and configuration of a Synology DSM 
# (DiskStation Manager) virtual machine (VM) in Proxmox VE. It simplifies the
# setup process by allowing both default and advanced configuration options.
#
# The script automates the complete VM creation process, including loader 
# download, disk configuration, and VM boot setup.
#
# **Credits**
# This script is an original idea but incorporates ideas and elements from 
# a similar script by user **tim104979** from the ProxmoxVE branch:
# (https://raw.githubusercontent.com/tim104979/ProxmoxVE/refs/heads/main/vm/synology-vm.sh)
#
# Copyright (c) Proxmox VE Helper-Scripts Community
# License: MIT | https://github.com/community-scripts/ProxmoxVE/raw/main/LICENSE
#
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

GEN_MAC="02"
for i in {1..5}; do
  BYTE=$(printf "%02X" $((RANDOM % 256)))
  GEN_MAC="${GEN_MAC}:${BYTE}"
done

NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
NAME="Synology VM"
IMAGES_DIR="/var/lib/vz/template/iso"
ERROR_FLAG=false





function exit_script() {
  clear
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
}


# Define the header_info function at the beginning of the script

function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}              Synology VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}
# ==========================================================






# ==========================================================
# start Script
# ==========================================================
function start_script() {
  if (whiptail --backtitle "ProxMenuX" --title "SETTINGS" --yesno "$(translate  "Use Default Settings?")" --no-button Advanced 10 58); then
    header_info
    echo -e "${DEF}Using Default Settings${CL}"
    default_settings
  else
    header_info
    echo -e "${CUS}Using Advanced Settings${CL}"
    advanced_settings
  fi
}
# ==========================================================




# ==========================================================
# Default Settings
# ==========================================================
function default_settings() {
  VMID="$NEXTID"
  FORMAT=""
  MACHINE=" -machine q35"
  BIOS_TYPE=" -bios ovmf"
  DISK_CACHE=""
  HN="Synology-DSM"
  CPU_TYPE=" -cpu host"
  CORE_COUNT="2"
  RAM_SIZE="4096"
  BRG="vmbr0"
  MAC="$GEN_MAC"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  START_VM="no"
  
  echo -e " ${TAB}${DGN}Using Virtual Machine ID: ${BGN}${VMID}${CL}"
  echo -e " ${TAB}${DGN}Using Machine Type: ${BGN}q35${CL}"
  echo -e " ${TAB}${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
  echo -e " ${TAB}${DGN}Using Hostname: ${BGN}${HN}${CL}"
  echo -e " ${TAB}${DGN}Using CPU Model: ${BGN}Host${CL}"
  echo -e " ${TAB}${DGN}Allocated Cores: ${BGN}${CORE_COUNT}${CL}"
  echo -e " ${TAB}${DGN}Allocated RAM: ${BGN}${RAM_SIZE}${CL}"
  echo -e " ${TAB}${DGN}Using Bridge: ${BGN}${BRG}${CL}"
  echo -e " ${TAB}${DGN}Using MAC Address: ${BGN}${MAC}${CL}"
  echo -e " ${TAB}${DGN}Using VLAN: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Using Interface MTU Size: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Configuring Serial Port: ${BGN}${SERIAL_PORT}${CL}"
  echo -e " ${TAB}${DGN}Start VM when completed: ${BGN}${START_VM}${CL}"
  echo -e
  echo -e "${DEF}Creating a $NAME using the above default settings${CL}"
 
  sleep 1
  select_disk_type
}
# ==========================================================





# ==========================================================
# advanced Settings
# ==========================================================
function advanced_settings() {
  # VM ID Selection
  while true; do
    if VMID=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 $NEXTID --title "VIRTUAL MACHINE ID" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
      if [ -z "$VMID" ]; then
        VMID="$NEXTID"
      fi
      if pct status "$VMID" &>/dev/null || qm status "$VMID" &>/dev/null; then
        echo -e "${CROSS}${RD} ID $VMID is already in use${CL}"
        sleep 1
        continue
      fi
      echo -e "${DGN}Virtual Machine ID: ${BGN}$VMID${CL}"
      break
    else
      exit_script
    fi
  done

  # Machine Type Selection
  if MACH=$(whiptail --backtitle "ProxMenuX" --title "$(translate "MACHINE TYPE")" --radiolist --cancel-button Exit-Script "Choose Type" 10 58 2 \
    "q35" "Machine q35" ON \
    "i440fx" "Machine i440fx" OFF \
    3>&1 1>&2 2>&3); then
    if [ $MACH = q35 ]; then
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=""
      MACHINE=" -machine q35"
    else
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=",efitype=4m"
      MACHINE=""
    fi
  else
    exit_script
  fi

    # BIOS Type Selection 
  if BIOS=$(whiptail --backtitle "ProxMenuX" --title "$(translate "BIOS TYPE")" --radiolist --cancel-button Exit-Script "Choose BIOS Type" 10 58 2 \
    "ovmf" "UEFI (OVMF)" ON \
    "seabios" "SeaBIOS (Legacy)" OFF \
    3>&1 1>&2 2>&3); then
    if [ "$BIOS" = "seabios" ]; then
        echo -e "${DGN}Using BIOS Type: ${BGN}SeaBIOS${CL}"
        BIOS_TYPE=" -bios seabios"
    else
        echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
        BIOS_TYPE=" -bios ovmf"
    fi
  else
    exit_script
   fi

  # Hostname Selection
  if VM_NAME=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Hostname")" 8 58 Synology-DSM --title "HOSTNAME" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VM_NAME ]; then
      HN="Synology-DSM"
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    else
      HN=$(echo ${VM_NAME,,} | tr -d ' ')
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    fi
  else
    exit_script
  fi

  # CPU Type Selection 
  if CPU_TYPE1=$(whiptail --backtitle "ProxMenuX" --title "$(translate "CPU MODEL")" --radiolist "Choose" --cancel-button Exit-Script 10 58 2 \
    "1" "Host" ON \
    "0" "KVM64" OFF \
    3>&1 1>&2 2>&3); then
    if [ $CPU_TYPE1 = "1" ]; then
      echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
      CPU_TYPE=" -cpu host"
    else
      echo -e "${DGN}Using CPU Model: ${BGN}KVM64${CL}"
      CPU_TYPE=""
    fi
  else
    exit_script
  fi

  # Core Count Selection
  if CORE_COUNT=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate CPU Cores")" 8 58 2 --title "CORE COUNT" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $CORE_COUNT ]; then
      CORE_COUNT="2"
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    else
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    fi
  else
    exit_script
  fi

  # RAM Size Selection
  if RAM_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate RAM in MiB")" 8 58 4096 --title "RAM" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $RAM_SIZE ]; then
      RAM_SIZE="4096"
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    else
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    fi
  else
    exit_script
  fi

  # Bridge Selection
  if BRG=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Bridge")" 8 58 vmbr0 --title "BRIDGE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $BRG ]; then
      BRG="vmbr0"
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    else
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    fi
  else
    exit_script
  fi

  # MAC Address Selection
  if MAC1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a MAC Address")" 8 58 $GEN_MAC --title "MAC ADDRESS" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MAC1 ]; then
      MAC="$GEN_MAC"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC${CL}"
    else
      MAC="$MAC1"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC1${CL}"
    fi
  else
    exit_script
  fi

  # VLAN Selection
  if VLAN1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Vlan(leave blank for default)")" 8 58 --title "VLAN" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VLAN1 ]; then
      VLAN1="Default"
      VLAN=""
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    else
      VLAN=",tag=$VLAN1"
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    fi
  else
    exit_script
  fi

  # MTU Selection
  if MTU1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Interface MTU Size (leave blank for default)")" 8 58 --title "MTU SIZE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MTU1 ]; then
      MTU1="Default"
      MTU=""
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    else
      MTU=",mtu=$MTU1"
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    fi
  else
    exit_script
  fi



  # Confirmation
  if (whiptail --backtitle "ProxMenuX" --title "$(translate "ADVANCED SETTINGS COMPLETE")" --yesno "Ready to create a $NAME?" --no-button Do-Over 10 58); then
    echo -e
    echo -e "${CUS}Creating a $NAME using the above advanced settings${CL}"
    sleep 1
    select_disk_type
  else
   header_info
   sleep 1
   echo -e "${CUS}Using Advanced Settings${CL}"
   advanced_settings
  fi
}
# ==========================================================





# ==========================================================
# Select Disk
# ==========================================================
function select_disk_type() {

  DISK_TYPE=$(whiptail --backtitle "ProxMenuX" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  EXIT_STATUS=$?

  if [[ $EXIT_STATUS -ne 0 ]]; then
      clear
      header_info
      msg_error "Operation cancelled by user. Returning to start scrip..."
      sleep 2
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
  fi

  if [[ "$DISK_TYPE" == "virtual" ]]; then
      select_virtual_disk
  else
      select_passthrough_disk
  fi
}

# ==========================================================





# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


  select_loader
}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
  select_loader
}
# ==========================================================






# ==========================================================
# Select Loader
# ==========================================================
function select_loader() {
  # Ensure the images directory exists
  if [ ! -d "$IMAGES_DIR" ]; then
    msg_info "Creating images directory"
    mkdir -p "$IMAGES_DIR"
    chmod 755 "$IMAGES_DIR"
    msg_ok "Images directory created: $IMAGES_DIR"
  fi

  # Create the loader selection menu
  LOADER_OPTION=$(whiptail --backtitle "ProxMenuX" --title "SELECT LOADER" --menu "$(translate "Choose a loader for Synology DSM:")" 15 70 4 \
    "1" "AuxXxilium Arc Loader" \
    "2" "RedPill Loader (RROrg - RR)" \
    "3" "TinyCore RedPill Loader (PeterSuh-Q3 M-shell)" \
    "4" "Custom Loader Image (from $IMAGES_DIR)" \
    3>&1 1>&2 2>&3)

  if [ -z "$LOADER_OPTION" ]; then
    exit_script
  fi

  case $LOADER_OPTION in
    1)
      LOADER_TYPE="arc"
      LOADER_NAME="AuxXxilium Arc"
      LOADER_URL="https://github.com/AuxXxilium/arc/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    2)
      LOADER_TYPE="redpill"
      LOADER_NAME="RedPill RR"
      LOADER_URL="https://github.com/RROrg/rr/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    3)
      LOADER_TYPE="tinycore"
      LOADER_NAME="TinyCore RedPill M-shell"
      LOADER_URL="https://github.com/PeterSuh-Q3/tinycore-redpill/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    4)
      LOADER_TYPE="custom"
      LOADER_NAME="Custom Image"
      LOADER_URL="https://xpenology.com/forum/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      select_custom_image
      ;;
  esac
}

function select_custom_image() {
  # Check if there are any images in the directory
  IMAGES=$(find "$IMAGES_DIR" -type f -name "*.img" -o -name "*.iso" -o -name "*.qcow2" -o -name "*.vmdk" | sort)
  
  if [ -z "$IMAGES" ]; then
    whiptail --title "$(translate "No Images Found")" --msgbox "No compatible images found in $IMAGES_DIR\n\nSupported formats: .img, .iso, .qcow2, .vmdk\n\nPlease add some images and try again." 15 70
    select_loader
  fi
  
  # Create an array of image options for whiptail
  IMAGE_OPTIONS=()

  while read -r img; do
    filename=$(basename "$img")
    filesize=$(du -h "$img" | cut -f1)
    IMAGE_OPTIONS+=("$img" "$filesize")
  done <<< "$IMAGES"
  
  # Let the user select an image
  LOADER_FILE=$(whiptail --backtitle "ProxMenuX" --title "SELECT CUSTOM IMAGE" --menu "$(translate "Choose a custom image:")" 20 70 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
  
  if [ -z "$LOADER_FILE" ]; then
    msg_error "No custom image selected"
    exit_script
  fi
  
  echo -e "${DGN}${TAB}Using Custom Image: ${BGN}$(basename "$LOADER_FILE")${CL}"
  FILE=$(basename "$LOADER_FILE")
}
# ==========================================================







# ==========================================================
# Download Loader
# ==========================================================
function download_loader() {

  echo -e "${DGN}${TAB}Retrieving the URL for the ${BGN}$LOADER_NAME loader${CL}"

  if [[ "$LOADER_TYPE" == "arc" || "$LOADER_TYPE" == "redpill" ]] && ! command -v unzip &> /dev/null; then
    msg_info "Installing unzip..."
    apt-get update -qq && apt-get install -y unzip -qq >/dev/null 2>&1
    if ! command -v unzip &> /dev/null; then
      msg_error "Failed to install unzip"
      sleep 2
      return 1
    fi
    msg_ok "Installed unzip successfully."
  fi
  
  case $LOADER_TYPE in
    arc)
      curl -s https://api.github.com/repos/AuxXxilium/arc/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/arc.img.zip"
      
      if [ -f "$IMAGES_DIR/arc.img.zip" ]; then
        cd "$IMAGES_DIR"
        unzip -q arc.img.zip
        rm arc.img.zip
        FILE="arc.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null
      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
      fi
      ;;
      
    redpill)
      curl -s https://api.github.com/repos/RROrg/rr/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/rr.img.zip"

      if [ -f "$IMAGES_DIR/rr.img.zip" ]; then
          cd "$IMAGES_DIR"
          msg_info "Unzipping $LOADER_NAME loader. Please wait..."
          unzip -qo rr.img.zip
          msg_ok "Unzipped $LOADER_NAME loader successfully."
          rm -f rr.img.zip
          FILE="rr.img"
          LOADER_FILE="$IMAGES_DIR/$FILE"
          cd - > /dev/null
      fi

      ;;
      
    tinycore)
      curl -s https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest \
      | grep "browser_download_url.*tinycore-redpill.v.*img.gz" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/tinycore.img.gz"
      
      if [ -f "$IMAGES_DIR/tinycore.img.gz" ]; then
        cd "$IMAGES_DIR"

        msg_info "Unzipping $LOADER_NAME loader. Please wait..."
        gunzip -f tinycore.img.gz 2> /dev/null
        msg_ok "Unzipped $LOADER_NAME loader successfully."
        FILE="tinycore.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null

      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
        
      fi
      ;;
  esac
  
  msg_ok "Downloaded ${CL}${BL}${FILE}${CL} to ${IMAGES_DIR}"
}
# =======================================================





# ==========================================================
# Select UEFI Storage 
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location for EFI disk."

  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}

  else
    kill $SPINNER_PID > /dev/null
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "EFI Disk Storage" --radiolist \
        "$(translate "Choose the storage volume for the EFI disk (4MB):\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 

    done

  fi
  
  echo "$STORAGE"
}
# ==========================================================





# ==========================================================
# Select Storage Loader 
# ==========================================================
function select_storage_volume() {
  local vmid=$1
  local purpose=$2
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location."
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "Storage Pools" --radiolist \
        "$(translate "Choose the storage volume for $purpose:\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit
    done
  fi
  
  echo "$STORAGE"
}






# ==========================================================
# Create VM
# ==========================================================
function create_vm() {

  # Create the VM
  qm create $VMID -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} -cores $CORE_COUNT -memory $RAM_SIZE \
    -name $HN -tags proxmenux -net0 virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU -onboot 1 -ostype l26 -scsihw virtio-scsi-pci \
    -serial0 socket
  msg_ok "Create a $NAME"


 
# Check if UEFI (OVMF) is being used ===================
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then

    msg_info "Configuring EFI disk"
    EFI_STORAGE=$(select_efi_storage $VMID)
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    
    # Determine storage type and extension
    STORAGE_TYPE=$(pvesm status -storage $EFI_STORAGE | awk 'NR>1 {print $2}')
    case $STORAGE_TYPE in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac
    
    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    EFI_DISK_ID="efidisk0"

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:4,efitype=4m,format=raw,pre-enrolled-keys=0" >/dev/null 2>&1; then
            msg_ok "EFI disk created (raw) and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
        else
            msg_error "Failed to configure EFI disk"
            ERROR_FLAG=true
        fi
    else
 
        EFI_DISK_NAME="vm-${VMID}-disk-efivars"
        EFI_DISK_EXT=""
        EFI_DISK_REF=""

        if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME" 4M >/dev/null 2>&1; then
            if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:${EFI_DISK_NAME},pre-enrolled-keys=0" >/dev/null 2>&1; then
                msg_ok "EFI disk created and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
            else
                msg_error "Failed to configure EFI disk"
                ERROR_FLAG=true
            fi
        else
            msg_error "Failed to create EFI disk"
            ERROR_FLAG=true
        fi
    fi


  fi
# ==========================================================


# Select storage volume for loader =======================

    LOADER_STORAGE=$(select_storage_volume $VMID "loader disk")
      

    #Run the command in the background and capture its PID
    qm importdisk $VMID ${LOADER_FILE} $LOADER_STORAGE > /tmp/import_log_$VMID.txt 2>&1 &
    import_pid=$!

    # Show a simple progress indicator
    echo -n "Importing loader disk: "
    while kill -0 $import_pid 2>/dev/null; do
        echo -n "."
        sleep 2.5
    done

    wait $import_pid
    rm -f /tmp/import_log_$VMID.txt

    IMPORTED_DISK=$(qm config $VMID | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)

    # If the disk was not imported correctly, show an error message but continue
    if [ -z "$IMPORTED_DISK" ]; then
          msg_error "Loader import failed. No disk detected."
          ERROR_FLAG=true
      else
          msg_ok "Loader imported successfully to ${CL}${BL}$LOADER_STORAGE${GN}${CL}"
    fi




 
    STORAGE_TYPE=$(pvesm status -storage "$LOADER_STORAGE" | awk 'NR>1 {print $2}')

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        UNUSED_LINE=$(qm config "$VMID" | grep -E '^unused[0-9]+:')
        IMPORTED_ID=$(echo "$UNUSED_LINE" | cut -d: -f1)
        IMPORTED_REF=$(echo "$UNUSED_LINE" | cut -d: -f2- | xargs)

        if [[ -n "$IMPORTED_REF" && -n "$IMPORTED_ID" ]]; then
            if qm set "$VMID" -ide0 "$IMPORTED_REF" >/dev/null 2>&1; then
                msg_ok "Configured loader disk as ide0"
                qm set "$VMID" -delete "$IMPORTED_ID" >/dev/null 2>&1
            else
                msg_error "Failed to assign loader disk to ide0"
                ERROR_FLAG=true
            fi
        else
            msg_error "Loader import failed. No disk detected in config."
            ERROR_FLAG=true
        fi
    else

        DISK_NAME="vm-${VMID}-disk-0"
        if qm set "$VMID" -ide0 "$LOADER_STORAGE:${DISK_NAME}" >/dev/null 2>&1; then
            msg_ok "Configured loader disk as ide0"
        else
            msg_error "Failed to assign loader disk"
            ERROR_FLAG=true
        fi
    fi




    result=$(qm set "$VMID" -boot order=ide0 2>&1)
    if [[ $? -eq 0 ]]; then
          msg_ok "Loader configured as boot device."
      else
          ERROR_FLAG=true
    fi

# ==========================================================

if [ "$DISK_TYPE" = "virtual" ]; then
    if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "No virtual disks configured."
        exit_script
    fi

    DISK_INFO=""
    CONSOLE_DISK_INFO=""

    for i in "${!VIRTUAL_DISKS[@]}"; do
        IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
        
        STORAGE_TYPE=$(pvesm status -storage $STORAGE | awk 'NR>1 {print $2}')
        case $STORAGE_TYPE in
            nfs | dir)
                DISK_EXT=".raw"
                DISK_REF="$VMID/"
                ;;
            *)
                DISK_EXT=""
                DISK_REF=""
                ;;
        esac
        

        DISK_NUM=$((i+1))
        DISK_NAME="vm-${VMID}-disk-${DISK_NUM}${DISK_EXT}"
        SATA_ID="sata$i"
        
        # Create virtual disk
        if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
        
          msg_info "Creating virtual disk (format=raw) for $STORAGE_TYPE..."
          if ! qm set "$VMID" -$SATA_ID "$STORAGE:$SIZE,format=raw" >/dev/null 2>&1; then
            msg_error "Failed to assign disk $DISK_NUM ($SATA_ID) on $STORAGE"
            ERROR_FLAG=true
            continue
          fi
        else

          msg_info "Allocating virtual disk for $STORAGE_TYPE..."
          if ! pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME" "$SIZE"G >/dev/null 2>&1; then
            msg_error "Failed to allocate virtual disk $DISK_NUM"
            ERROR_FLAG=true
            continue
          fi
          if ! qm set "$VMID" -$SATA_ID "$STORAGE:${DISK_REF}$DISK_NAME" >/dev/null 2>&1; then
            msg_error "Failed to configure virtual disk as $SATA_ID"
            ERROR_FLAG=true
            continue
          fi
        fi

        msg_ok "Configured virtual disk as $SATA_ID, ${SIZE}GB on ${CL}${BL}$STORAGE${CL} ${GN}"

        
        # Add information to the description
        DISK_INFO="${DISK_INFO}<p>Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE}</p>"
        CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} ($SATA_ID)\n"
    done
    

    
    # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"
    
    msg_info "Setting VM description"
    if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
        msg_error "Failed to set VM description"
        exit_script
    fi
    msg_ok "Configured VM description"


else


      # Configure multiple passthrough disks
      DISK_INFO=""
      CONSOLE_DISK_INFO=""

      for i in "${!PASSTHROUGH_DISKS[@]}"; do
          DISK="${PASSTHROUGH_DISKS[$i]}"
          DISK_MODEL=$(lsblk -ndo MODEL "$DISK" | xargs)
          DISK_SIZE=$(lsblk -ndo SIZE "$DISK" | xargs)
          DISK_ID="sata$i"
          

          result=$(qm set $VMID -${DISK_ID} ${DISK} 2>&1)
          if [[ $? -eq 0 ]]; then
              msg_ok "Configured disk ${CL}${BL}($DISK_MODEL $DISK_SIZE)${CL}${GN} as $DISK_ID"
          fi
          # Add information to the description
          DISK_INFO="${DISK_INFO}<p>Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE)</p>"
          CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE) (${DISK_ID})\n"
      done


      # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"


      result=$(qm set $VMID -description "$HTML_DESC" 2>&1)
      if [[ $? -eq 0 ]]; then
         msg_ok "Configured VM description"
      fi
      

fi
  
  
if [ "$ERROR_FLAG" = true ]; then
   msg_error "VM created with errors. Check configuration." 
else
msg_success "$(translate "Completed Successfully!")"

echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
echo -e "${TAB}1. $(translate "Start the VM")"
echo -e "${TAB}2. $(translate "Open the VM console and wait for the loader to boot")"
echo -e "${TAB}3. $(translate "In the loader interface, follow the instructions to select your Synology model")"
echo -e "${TAB}4. $(translate "Complete the DSM installation wizard")"
echo -e "${TAB}5. $(translate "Find your device using https://finds.synology.com")"
echo -e

#msg_success "$(translate "Press Enter to return to the main menu...")"
#read -r

fi
  
}

# ==========================================================



# ==========================================================
# Main execution
# ==========================================================
header_info
#echo -e "\n Loading..."
sleep 1

# Start script
if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
  start_script
else
  clear
  exit
fi

# Create VM
create_vm

# ==========================================================


================================================
FILE: scripts/vm/synology_.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Synology DSM VM Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 13/03/2025
# ==========================================================
# Description:
# This script automates the creation and configuration of a Synology DSM 
# (DiskStation Manager) virtual machine (VM) in Proxmox VE. It simplifies the
# setup process by allowing both default and advanced configuration options.
#
# The script automates the complete VM creation process, including loader 
# download, disk configuration, and VM boot setup.
#
# **Credits**
# This script is an original idea but incorporates ideas and elements from 
# a similar script by user **tim104979** from the ProxmoxVE branch:
# (https://raw.githubusercontent.com/tim104979/ProxmoxVE/refs/heads/main/vm/synology-vm.sh)
#
# Copyright (c) Proxmox VE Helper-Scripts Community
# License: MIT | https://github.com/community-scripts/ProxmoxVE/raw/main/LICENSE
#
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

GEN_MAC="02"
for i in {1..5}; do
  BYTE=$(printf "%02X" $((RANDOM % 256)))
  GEN_MAC="${GEN_MAC}:${BYTE}"
done

NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
NAME="Synology VM"
IMAGES_DIR="/var/lib/vz/template/iso"
ERROR_FLAG=false





function exit_script() {
  clear
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
}


# Define the header_info function at the beginning of the script

function header_info() {
  clear
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}              Synology VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}
# ==========================================================






# ==========================================================
# start Script
# ==========================================================
function start_script() {
  if (whiptail --backtitle "ProxMenuX" --title "SETTINGS" --yesno "$(translate  "Use Default Settings?")" --no-button Advanced 10 58); then
    header_info
    echo -e "${DEF}Using Default Settings${CL}"
    default_settings
  else
    header_info
    echo -e "${CUS}Using Advanced Settings${CL}"
    advanced_settings
  fi
}
# ==========================================================




# ==========================================================
# Default Settings
# ==========================================================
function default_settings() {
  VMID="$NEXTID"
  FORMAT=""
  MACHINE=" -machine q35"
  BIOS_TYPE=" -bios ovmf"
  DISK_CACHE=""
  HN="Synology-DSM"
  CPU_TYPE=" -cpu host"
  CORE_COUNT="2"
  RAM_SIZE="4096"
  BRG="vmbr0"
  MAC="$GEN_MAC"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  START_VM="no"
  
  echo -e "${DGN}Using Virtual Machine ID: ${BGN}${VMID}${CL}"
  echo -e "${DGN}Using Machine Type: ${BGN}q35${CL}"
  echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
  echo -e "${DGN}Using Hostname: ${BGN}${HN}${CL}"
  echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
  echo -e "${DGN}Allocated Cores: ${BGN}${CORE_COUNT}${CL}"
  echo -e "${DGN}Allocated RAM: ${BGN}${RAM_SIZE}${CL}"
  echo -e "${DGN}Using Bridge: ${BGN}${BRG}${CL}"
  echo -e "${DGN}Using MAC Address: ${BGN}${MAC}${CL}"
  echo -e "${DGN}Using VLAN: ${BGN}Default${CL}"
  echo -e "${DGN}Using Interface MTU Size: ${BGN}Default${CL}"
  echo -e "${DGN}Configuring Serial Port: ${BGN}${SERIAL_PORT}${CL}"
  echo -e "${DGN}Start VM when completed: ${BGN}${START_VM}${CL}"
  echo -e
  echo -e "${DEF}Creating a $NAME using the above default settings${CL}"
 
  sleep 1
  select_disk_type
}
# ==========================================================





# ==========================================================
# advanced Settings
# ==========================================================
function advanced_settings() {
  # VM ID Selection
  while true; do
    if VMID=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 $NEXTID --title "VIRTUAL MACHINE ID" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
      if [ -z "$VMID" ]; then
        VMID="$NEXTID"
      fi
      if pct status "$VMID" &>/dev/null || qm status "$VMID" &>/dev/null; then
        echo -e "${CROSS}${RD} ID $VMID is already in use${CL}"
        sleep 1
        continue
      fi
      echo -e "${DGN}Virtual Machine ID: ${BGN}$VMID${CL}"
      break
    else
      exit_script
    fi
  done

  # Machine Type Selection
  if MACH=$(whiptail --backtitle "ProxMenuX" --title "$(translate "MACHINE TYPE")" --radiolist --cancel-button Exit-Script "Choose Type" 10 58 2 \
    "q35" "Machine q35" ON \
    "i440fx" "Machine i440fx" OFF \
    3>&1 1>&2 2>&3); then
    if [ $MACH = q35 ]; then
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=""
      MACHINE=" -machine q35"
    else
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=",efitype=4m"
      MACHINE=""
    fi
  else
    exit_script
  fi

    # BIOS Type Selection 
  if BIOS=$(whiptail --backtitle "ProxMenuX" --title "$(translate "BIOS TYPE")" --radiolist --cancel-button Exit-Script "Choose BIOS Type" 10 58 2 \
    "ovmf" "UEFI (OVMF)" ON \
    "seabios" "SeaBIOS (Legacy)" OFF \
    3>&1 1>&2 2>&3); then
    if [ "$BIOS" = "seabios" ]; then
        echo -e "${DGN}Using BIOS Type: ${BGN}SeaBIOS${CL}"
        BIOS_TYPE=" -bios seabios"
    else
        echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
        BIOS_TYPE=" -bios ovmf"
    fi
  else
    exit_script
   fi

  # Hostname Selection
  if VM_NAME=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Hostname")" 8 58 Synology-DSM --title "HOSTNAME" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VM_NAME ]; then
      HN="Synology-DSM"
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    else
      HN=$(echo ${VM_NAME,,} | tr -d ' ')
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    fi
  else
    exit_script
  fi

  # CPU Type Selection 
  if CPU_TYPE1=$(whiptail --backtitle "ProxMenuX" --title "$(translate "CPU MODEL")" --radiolist "Choose" --cancel-button Exit-Script 10 58 2 \
    "1" "Host" ON \
    "0" "KVM64" OFF \
    3>&1 1>&2 2>&3); then
    if [ $CPU_TYPE1 = "1" ]; then
      echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
      CPU_TYPE=" -cpu host"
    else
      echo -e "${DGN}Using CPU Model: ${BGN}KVM64${CL}"
      CPU_TYPE=""
    fi
  else
    exit_script
  fi

  # Core Count Selection
  if CORE_COUNT=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate CPU Cores")" 8 58 2 --title "CORE COUNT" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $CORE_COUNT ]; then
      CORE_COUNT="2"
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    else
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    fi
  else
    exit_script
  fi

  # RAM Size Selection
  if RAM_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate RAM in MiB")" 8 58 4096 --title "RAM" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $RAM_SIZE ]; then
      RAM_SIZE="4096"
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    else
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    fi
  else
    exit_script
  fi

  # Bridge Selection
  if BRG=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Bridge")" 8 58 vmbr0 --title "BRIDGE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $BRG ]; then
      BRG="vmbr0"
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    else
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    fi
  else
    exit_script
  fi

  # MAC Address Selection
  if MAC1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a MAC Address")" 8 58 $GEN_MAC --title "MAC ADDRESS" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MAC1 ]; then
      MAC="$GEN_MAC"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC${CL}"
    else
      MAC="$MAC1"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC1${CL}"
    fi
  else
    exit_script
  fi

  # VLAN Selection
  if VLAN1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Vlan(leave blank for default)")" 8 58 --title "VLAN" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VLAN1 ]; then
      VLAN1="Default"
      VLAN=""
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    else
      VLAN=",tag=$VLAN1"
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    fi
  else
    exit_script
  fi

  # MTU Selection
  if MTU1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Interface MTU Size (leave blank for default)")" 8 58 --title "MTU SIZE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MTU1 ]; then
      MTU1="Default"
      MTU=""
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    else
      MTU=",mtu=$MTU1"
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    fi
  else
    exit_script
  fi



  # Confirmation
  if (whiptail --backtitle "ProxMenuX" --title "$(translate "ADVANCED SETTINGS COMPLETE")" --yesno "Ready to create a $NAME?" --no-button Do-Over 10 58); then
    echo -e
    echo -e "${CUS}Creating a $NAME using the above advanced settings${CL}"
    sleep 1
    select_disk_type
  else
   header_info
   sleep 1
   echo -e "${CUS}Using Advanced Settings${CL}"
   advanced_settings
  fi
}
# ==========================================================





# ==========================================================
# Select Disk
# ==========================================================
function select_disk_type() {

  DISK_TYPE=$(whiptail --backtitle "ProxMenuX" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  EXIT_STATUS=$?

  if [[ $EXIT_STATUS -ne 0 ]]; then
      clear
      header_info
      msg_error "Operation cancelled by user. Returning to start scrip..."
      sleep 2
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
  fi

  if [[ "$DISK_TYPE" == "virtual" ]]; then
      select_virtual_disk
  else
      select_passthrough_disk
  fi
}

# ==========================================================





# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 32 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="32"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


  select_loader
}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
  select_loader
}
# ==========================================================






# ==========================================================
# Select Loader
# ==========================================================
function select_loader() {
  # Ensure the images directory exists
  if [ ! -d "$IMAGES_DIR" ]; then
    msg_info "Creating images directory"
    mkdir -p "$IMAGES_DIR"
    chmod 755 "$IMAGES_DIR"
    msg_ok "Images directory created: $IMAGES_DIR"
  fi

  # Create the loader selection menu
  LOADER_OPTION=$(whiptail --backtitle "ProxMenuX" --title "SELECT LOADER" --menu "$(translate "Choose a loader for Synology DSM:")" 15 70 4 \
    "1" "AuxXxilium Arc Loader" \
    "2" "RedPill Loader (RROrg - RR)" \
    "3" "TinyCore RedPill Loader (PeterSuh-Q3 M-shell)" \
    "4" "Custom Loader Image (from $IMAGES_DIR)" \
    3>&1 1>&2 2>&3)

  if [ -z "$LOADER_OPTION" ]; then
    exit_script
  fi

  case $LOADER_OPTION in
    1)
      LOADER_TYPE="arc"
      LOADER_NAME="AuxXxilium Arc"
      LOADER_URL="https://github.com/AuxXxilium/arc/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    2)
      LOADER_TYPE="redpill"
      LOADER_NAME="RedPill RR"
      LOADER_URL="https://github.com/RROrg/rr/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    3)
      LOADER_TYPE="tinycore"
      LOADER_NAME="TinyCore RedPill M-shell"
      LOADER_URL="https://github.com/PeterSuh-Q3/tinycore-redpill/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    4)
      LOADER_TYPE="custom"
      LOADER_NAME="Custom Image"
      LOADER_URL="https://xpenology.com/forum/"
      echo -e "${DGN}${TAB}Selected Loader: ${BGN}$LOADER_NAME${CL}"
      select_custom_image
      ;;
  esac
}

function select_custom_image() {
  # Check if there are any images in the directory
  IMAGES=$(find "$IMAGES_DIR" -type f -name "*.img" -o -name "*.iso" -o -name "*.qcow2" -o -name "*.vmdk" | sort)
  
  if [ -z "$IMAGES" ]; then
    whiptail --title "$(translate "No Images Found")" --msgbox "No compatible images found in $IMAGES_DIR\n\nSupported formats: .img, .iso, .qcow2, .vmdk\n\nPlease add some images and try again." 15 70
    select_loader
  fi
  
  # Create an array of image options for whiptail
  IMAGE_OPTIONS=()

  while read -r img; do
    filename=$(basename "$img")
    filesize=$(du -h "$img" | cut -f1)
    IMAGE_OPTIONS+=("$img" "$filesize")
  done <<< "$IMAGES"
  
  # Let the user select an image
  LOADER_FILE=$(whiptail --backtitle "ProxMenuX" --title "SELECT CUSTOM IMAGE" --menu "$(translate "Choose a custom image:")" 20 70 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
  
  if [ -z "$LOADER_FILE" ]; then
    msg_error "No custom image selected"
    exit_script
  fi
  
  echo -e "${DGN}${TAB}Using Custom Image: ${BGN}$(basename "$LOADER_FILE")${CL}"
  FILE=$(basename "$LOADER_FILE")
}
# ==========================================================







# ==========================================================
# Download Loader
# ==========================================================
function download_loader() {

  echo -e "${DGN}${TAB}Retrieving the URL for the ${BGN}$LOADER_NAME loader${CL}"

  if [[ "$LOADER_TYPE" == "arc" || "$LOADER_TYPE" == "redpill" ]] && ! command -v unzip &> /dev/null; then
    msg_info "Installing unzip..."
    apt-get update -qq && apt-get install -y unzip -qq >/dev/null 2>&1
    if ! command -v unzip &> /dev/null; then
      msg_error "Failed to install unzip"
      sleep 2
      return 1
    fi
    msg_ok "Installed unzip successfully."
  fi
  
  case $LOADER_TYPE in
    arc)
      curl -s https://api.github.com/repos/AuxXxilium/arc/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/arc.img.zip"
      
      if [ -f "$IMAGES_DIR/arc.img.zip" ]; then
        cd "$IMAGES_DIR"
        unzip -q arc.img.zip
        rm arc.img.zip
        FILE="arc.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null
      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
      fi
      ;;
      
    redpill)
      curl -s https://api.github.com/repos/RROrg/rr/releases/latest \
      | grep "browser_download_url.*\.img\.zip" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/rr.img.zip"

      if [ -f "$IMAGES_DIR/rr.img.zip" ]; then
          cd "$IMAGES_DIR"
          msg_info "Unzipping $LOADER_NAME loader. Please wait..."
          unzip -qo rr.img.zip
          msg_ok "Unzipped $LOADER_NAME loader successfully."
          rm -f rr.img.zip
          FILE="rr.img"
          LOADER_FILE="$IMAGES_DIR/$FILE"
          cd - > /dev/null
      fi

      ;;
      
    tinycore)
      curl -s https://api.github.com/repos/PeterSuh-Q3/tinycore-redpill/releases/latest \
      | grep "browser_download_url.*tinycore-redpill.v.*img.gz" \
      | cut -d '"' -f 4 \
      | xargs wget -q --show-progress -O "$IMAGES_DIR/tinycore.img.gz"
      
      if [ -f "$IMAGES_DIR/tinycore.img.gz" ]; then
        cd "$IMAGES_DIR"

        msg_info "Unzipping $LOADER_NAME loader. Please wait..."
        gunzip -f tinycore.img.gz 2> /dev/null
        msg_ok "Unzipped $LOADER_NAME loader successfully."
        FILE="tinycore.img"
        LOADER_FILE="$IMAGES_DIR/$FILE"
        cd - > /dev/null

      else
        msg_error "Failed to download $LOADER_NAME loader"
        sleep 1
        select_loader
        
      fi
      ;;
  esac
  
  msg_ok "Downloaded ${CL}${BL}${FILE}${CL} to ${IMAGES_DIR}"
}
# =======================================================





# ==========================================================
# Select UEFI Storage 
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location for EFI disk."

  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}

  else
    kill $SPINNER_PID > /dev/null
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "EFI Disk Storage" --radiolist \
        "$(translate "Choose the storage volume for the EFI disk (4MB):\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 

    done

  fi
  
  echo "$STORAGE"
}
# ==========================================================





# ==========================================================
# Select Storage Loader 
# ==========================================================
function select_storage_volume() {
  local vmid=$1
  local purpose=$2
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location."
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "Storage Pools" --radiolist \
        "$(translate "Choose the storage volume for $purpose:\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit
    done
  fi
  
  echo "$STORAGE"
}






# ==========================================================
# Create VM
# ==========================================================
function create_vm() {

  # Create the VM
  qm create $VMID -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} -cores $CORE_COUNT -memory $RAM_SIZE \
    -name $HN -tags proxmenux -net0 virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU -onboot 1 -ostype l26 -scsihw virtio-scsi-pci \
    -serial0 socket
  msg_ok "Create a $NAME"


 
# Check if UEFI (OVMF) is being used ===================
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then

    msg_info "Configuring EFI disk"
    EFI_STORAGE=$(select_efi_storage $VMID)
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    
    # Determine storage type and extension
    STORAGE_TYPE=$(pvesm status -storage $EFI_STORAGE | awk 'NR>1 {print $2}')
    case $STORAGE_TYPE in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac
    
    if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME$EFI_DISK_EXT" 4M >/dev/null 2>&1; then
        if qm set "$VMID" -efidisk0 "$EFI_STORAGE:${EFI_DISK_REF}$EFI_DISK_NAME$EFI_DISK_EXT,pre-enrolled-keys=0" >/dev/null 2>&1; then
            msg_ok "EFI disk created and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
        else
            msg_error "Failed to configure EFI disk"
            ERROR_FLAG=true
        fi
    else
        msg_error "Failed to create EFI disk"
        ERROR_FLAG=true
    fi

  fi
# ==========================================================


# Select storage volume for loader =======================

    LOADER_STORAGE=$(select_storage_volume $VMID "loader disk")
      

    #Run the command in the background and capture its PID
    qm importdisk $VMID ${LOADER_FILE} $LOADER_STORAGE > /tmp/import_log_$VMID.txt 2>&1 &
    import_pid=$!

    # Show a simple progress indicator
    echo -n "Importing loader disk: "
    while kill -0 $import_pid 2>/dev/null; do
        echo -n "."
        sleep 2.5
    done

    wait $import_pid
    rm -f /tmp/import_log_$VMID.txt

    IMPORTED_DISK=$(qm config $VMID | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)

    # If the disk was not imported correctly, show an error message but continue
    if [ -z "$IMPORTED_DISK" ]; then
          msg_error "Loader import failed. No disk detected."
          ERROR_FLAG=true
      else
          msg_ok "Loader imported successfully to ${CL}${BL}$LOADER_STORAGE${GN}${CL}"
    fi

    # Configure the loader disk as scsi0
    DISK_NAME="vm-${VMID}-disk-0"

    result=$(qm set "$VMID" -ide0 "${LOADER_STORAGE}:${DISK_NAME}" 2>&1 > /dev/null)
    if [[ $? -eq 0 ]]; then
          msg_ok "Configured loader disk as ide0"
      else
          ERROR_FLAG=true
    fi
    result=$(qm set "$VMID" -boot order=ide0 2>&1)
    if [[ $? -eq 0 ]]; then
          msg_ok "Loader configured as boot device."
      else
          ERROR_FLAG=true
    fi

# ==========================================================

if [ "$DISK_TYPE" = "virtual" ]; then
    if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "No virtual disks configured."
        exit_script
    fi

    DISK_INFO=""
    CONSOLE_DISK_INFO=""

    for i in "${!VIRTUAL_DISKS[@]}"; do
        IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
        
        STORAGE_TYPE=$(pvesm status -storage $STORAGE | awk 'NR>1 {print $2}')
        case $STORAGE_TYPE in
            nfs | dir)
                DISK_EXT=".raw"
                DISK_REF="$VMID/"
                ;;
            *)
                DISK_EXT=""
                DISK_REF=""
                ;;
        esac
        

        DISK_NUM=$((i+1))
        DISK_NAME="vm-${VMID}-disk-${DISK_NUM}${DISK_EXT}"

        
        # Create virtual disk
        msg_info "Creating virtual disk..."
        if ! pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME" "$SIZE"G >/dev/null 2>&1; then
            msg_error "Failed to allocate virtual disk $DISK_NUM"

        fi
        
        # Configure disk in the VM (sata0, sata1, etc.)
        SATA_ID="sata$i"
        if ! qm set "$VMID" -$SATA_ID "$STORAGE:${DISK_REF}$DISK_NAME" >/dev/null 2>&1; then
            msg_error "Failed to configure virtual disk as $SATA_ID"

        fi
        msg_ok "Configured virtual disk as $SATA_ID, ${SIZE}GB on ${CL}${BL}$STORAGE${CL} ${GN}"
        
        # Add information to the description
        DISK_INFO="${DISK_INFO}<p>Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE}</p>"
        CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} ($SATA_ID)\n"
    done
    

    
    # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"
    
    msg_info "Setting VM description"
    if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
        msg_error "Failed to set VM description"
        exit_script
    fi
    msg_ok "Configured VM description"


else


      # Configure multiple passthrough disks
      DISK_INFO=""
      CONSOLE_DISK_INFO=""

      for i in "${!PASSTHROUGH_DISKS[@]}"; do
          DISK="${PASSTHROUGH_DISKS[$i]}"
          DISK_MODEL=$(lsblk -ndo MODEL "$DISK" | xargs)
          DISK_SIZE=$(lsblk -ndo SIZE "$DISK" | xargs)
          DISK_ID="sata$i"
          

          result=$(qm set $VMID -${DISK_ID} ${DISK} 2>&1)
          if [[ $? -eq 0 ]]; then
              msg_ok "Configured disk ${CL}${BL}($DISK_MODEL $DISK_SIZE)${CL}${GN} as $DISK_ID"
          fi
          # Add information to the description
          DISK_INFO="${DISK_INFO}<p>Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE)</p>"
          CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Passthrough Disk $((i+1)): $DISK ($DISK_MODEL $DISK_SIZE) (${DISK_ID})\n"
      done


      # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>Synology DSM VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>Loader: $LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/synology.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Loader-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"


      result=$(qm set $VMID -description "$HTML_DESC" 2>&1)
      if [[ $? -eq 0 ]]; then
         msg_ok "Configured VM description"
      fi
      

fi
  
  
if [ "$ERROR_FLAG" = true ]; then
   msg_error "VM created with errors. Check configuration." 
else
msg_success "$(translate "Completed Successfully!")"

echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
echo -e "${TAB}1. $(translate "Start the VM")"
echo -e "${TAB}2. $(translate "Open the VM console and wait for the loader to boot")"
echo -e "${TAB}3. $(translate "In the loader interface, follow the instructions to select your Synology model")"
echo -e "${TAB}4. $(translate "Complete the DSM installation wizard")"
echo -e "${TAB}5. $(translate "Find your device using https://finds.synology.com")"
echo -e

msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

fi
  
}

# ==========================================================



# ==========================================================
# Main execution
# ==========================================================
header_info
#echo -e "\n Loading..."
sleep 1

# Start script
if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
  start_script
else
  clear
  exit
fi

# Create VM
create_vm

# ==========================================================


================================================
FILE: scripts/vm/uupdump_creator.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenux - UUP Dump ISO Creator
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the ProxMenux tools for Proxmox VE.
# It allows downloading and converting official Windows ISO images 
# from UUP Dump using a shared link (with ID, pack, and edition).
#
# Key features:
# - Automatically installs and verifies required dependencies (aria2c, cabextract, wimlib-imagexâ€¦)
# - Downloads the selected Windows edition from UUP Dump using aria2
# - Converts the downloaded files into a bootable ISO
# - Stores the resulting ISO in the default template path (/var/lib/vz/template/iso)
# - Provides a graphical prompt via whiptail for user-friendly usage
#
# This tool simplifies the creation of official Windows ISOs
# for use in virtual machines within Proxmox VE.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================


detect_iso_dir() {
  for store in $(pvesm status -content iso | awk 'NR>1 {print $1}'); do
    for ext in iso img; do
      volid=$(pvesm list "$store" --content iso | awk -v ext="$ext" 'NR>1 && $2 ~ ext {print $1; exit}')
      if [[ -n "$volid" ]]; then
        path=$(pvesm path "$volid" 2>/dev/null)
        dir=$(dirname "$path")
        [[ -d "$dir" ]] && echo "$dir" && return 0
      fi
    done
  done

  if [[ -d /var/lib/vz/template/iso ]]; then
    echo "/var/lib/vz/template/iso"
    return 0
  fi

  return 1
}


function run_uupdump_creator() {


    local DEPS=(curl aria2 cabextract wimtools genisoimage chntpw)
    local CMDS=(curl aria2c cabextract wimlib-imagex genisoimage chntpw)
    local MISSING=()
    local FAILED=()

    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            MISSING+=("${DEPS[$i]}")
        fi
    done

    if [[ ${#MISSING[@]} -gt 0 ]]; then
        show_proxmenux_logo
        msg_info "$(translate "Installing dependencies: ${MISSING[*]}")"
        apt-get update -qq >/dev/null 2>&1
        if ! apt-get install -y "${MISSING[@]}" >/dev/null 2>&1; then
            msg_error "$(translate "Failed to install: ${MISSING[*]}")"
            sleep 2
            exit 1
        fi
        msg_ok "$(translate "All dependencies installed and verified.")"
    fi

    for i in "${!CMDS[@]}"; do
        if ! command -v "${CMDS[$i]}" &>/dev/null; then
            FAILED+=("${CMDS[$i]}")
        fi
    done

    if [[ ${#FAILED[@]} -gt 0 ]]; then
        show_proxmenux_logo
        msg_error "$(translate "Missing commands after installation:") ${FAILED[*]}"
        sleep 2
        exit 1
    fi



ISO_DIR=$(detect_iso_dir)
if [[ -z "$ISO_DIR" ]]; then
  show_proxmenux_logo
  msg_error "$(translate "Could not determine a valid ISO storage directory.")"
  sleep 2
  exit 1
fi


mkdir -p "$ISO_DIR"



DEFAULT_BASE="/root/uup-temp"
BASE_INPUT=$(dialog --clear --inputbox "$(translate "Enter base folder for temporary files and converter (default:") $DEFAULT_BASE):" 10 60 "$DEFAULT_BASE" 3>&1 1>&2 2>&3)

if [[ $? -ne 0 || -z "$BASE_INPUT" ]]; then
  BASE_INPUT="$DEFAULT_BASE"
fi


BASE_CLEAN="$(echo "$BASE_INPUT" | sed 's:[[:space:]]*$::' | sed 's:/*$::')"


if [[ ! -d "$BASE_CLEAN" ]]; then
  if ! mkdir -p "$BASE_CLEAN"; then
    show_proxmenux_logo
    msg_error "$(translate "The selected base folder does not exist and could not be created:") $BASE_CLEAN"
    sleep 2
    exit 1
  fi
fi
if [[ ! -w "$BASE_CLEAN" ]]; then
  show_proxmenux_logo
  msg_error "$(translate "No write permissions on:") $BASE_CLEAN"
  sleep 2
  exit 1
fi


TMP_DIR="$BASE_CLEAN/uup-temp"
OUT_DIR="$ISO_DIR"
CONVERTER="$BASE_CLEAN/uup-converter"

if ! mkdir -p "$TMP_DIR"; then
  show_proxmenux_logo
  msg_error "$(translate "Could not create temporary directory:") $TMP_DIR"
  sleep 2
  exit 1
fi

if ! mkdir -p "$CONVERTER"; then
  show_proxmenux_logo
  msg_error "$(translate "Could not create converter directory:") $CONVERTER"
  sleep 2
  exit 1
fi

cd "$TMP_DIR" || { msg_error "$(translate "Failed to access:") $TMP_DIR"; exit 1; }



UUP_URL=$(whiptail --inputbox "$(translate "Paste the UUP Dump URL here")" 10 90 3>&1 1>&2 2>&3)
if [[ $? -ne 0 || -z "$UUP_URL" ]]; then
  return 1  
fi

if [[ ! "$UUP_URL" =~ id=.+\&pack=.+\&edition=.+ ]]; then
  show_proxmenux_logo
  msg_error "$(translate "The URL does not contain the required parameters (id, pack, edition).")"
  sleep 2
  return 1 
fi


BUILD_ID=$(echo "$UUP_URL" | grep -oP 'id=\K[^&]+')
LANG=$(echo "$UUP_URL" | grep -oP 'pack=\K[^&]+')
EDITION=$(echo "$UUP_URL" | grep -oP 'edition=\K[^&]+')
ARCH="amd64"

show_proxmenux_logo
echo -e
echo -e "\n${BGN}=============== UUP Dump Creator ===============${CL}"
echo -e "    ${BGN}ğŸ†” ID:${CL} ${DGN}$BUILD_ID${CL}"
echo -e "    ${BGN}ğŸŒ Language:${CL} ${DGN}$LANG${CL}"
echo -e "    ${BGN}ğŸ’¿ Edition:${CL} ${DGN}$EDITION${CL}"
echo -e "    ${BGN}ğŸ–¥ï¸ Architecture:${CL} ${DGN}$ARCH${CL}"
echo -e "${BGN}===============================================${CL}\n"


if [[ ! -f "$CONVERTER/convert.sh" ]]; then
  echo "ğŸ“¦ $(translate "Downloading UUP converter...")"
  mkdir -p "$CONVERTER"
  cd "$CONVERTER" || exit 1
  wget -q https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz -O converter.tar.gz
  tar -xzf converter.tar.gz --strip-components=1
  chmod +x convert.sh
  cd "$TMP_DIR" || exit 1
fi


cat > uup_download_linux.sh <<EOF
#!/bin/bash
mkdir -p files
echo "https://git.uupdump.net/uup-dump/converter/archive/refs/heads/master.tar.gz" > files/converter_multi

for prog in aria2c cabextract wimlib-imagex chntpw; do
  which \$prog &>/dev/null || { echo "\$prog not found."; exit 1; }
done
which genisoimage &>/dev/null || which mkisofs &>/dev/null || { echo "genisoimage/mkisofs not found."; exit 1; }

destDir="UUPs"
tempScript="aria2_script.\$RANDOM.txt"

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j2 --allow-overwrite=true --auto-file-renaming=false -d"files" -i"files/converter_multi" || exit 1

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -o"\$tempScript" --allow-overwrite=true --auto-file-renaming=false \
  "https://uupdump.net/get.php?id=$BUILD_ID&pack=$LANG&edition=$EDITION&aria2=2" || exit 1

grep '#UUPDUMP_ERROR:' "\$tempScript" && { echo "âŒ Error generating UUP download list."; exit 1; }

aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" \
  -x16 -s16 -j5 -c -R -d"\$destDir" -i"\$tempScript" || exit 1
EOF

chmod +x uup_download_linux.sh



# ==========================
./uup_download_linux.sh
# ==========================



UUP_FOLDER=$(find "$TMP_DIR" -type d -name "UUPs" | head -n1)
[[ -z "$UUP_FOLDER" ]] && msg_error "$(translate "No UUP folder found.")" && exit 1


echo -e "\n${GN}=======================================${CL}"
echo -e "    ğŸ’¿ ${GN}Starting ISO conversion...${CL}"
echo -e "${GN}=======================================${CL}\n"

"$CONVERTER/convert.sh" wim "$UUP_FOLDER" 1


ISO_FILE=$(find "$TMP_DIR" "$CONVERTER" "$UUP_FOLDER" -maxdepth 1 -iname "*.iso" | head -n1)
if [[ -f "$ISO_FILE" ]]; then
  mv "$ISO_FILE" "$OUT_DIR/"
  msg_ok "$(translate "ISO created successfully:") $OUT_DIR/$(basename "$ISO_FILE")"


  msg_ok "$(translate "Cleaning temporary files...")"
if [[ "$CLEAN_ALL" == true ]]; then
  rm -rf "$TMP_DIR" "$CONVERTER"
else
  [[ -d "$TMP_DIR" ]] && rm -rf "$TMP_DIR"
  [[ -d "$CONVERTER" ]] && rm -rf "$CONVERTER"
fi
    
  export OS_TYPE="windows"
  export LANG=en_US.UTF-8
  export LC_ALL=en_US.UTF-8
  export LANGUAGE=en_US:en

  load_language
  initialize_cache

  msg_success "$(translate "Press Enter to return to menu...")"
  read -r

else
  msg_warn "$(translate "No ISO was generated.")"
  rm -rf "$TMP_DIR" "$CONVERTER"
  export LANG=en_US.UTF-8
  export LC_ALL=en_US.UTF-8
  export LANGUAGE=en_US:en

  load_language
  initialize_cache
  msg_success "$(translate "Press Enter to return to menu...")"
  read -r
  return 1
fi

}



================================================
FILE: scripts/vm/vm_configurator.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================



BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

load_language
initialize_cache


function confirm_vm_creation() {
  clear
  local CONFIRM_TITLE="${HN:-$(translate "New Virtual Machine")}"
  local CONFIRM_MSG="$(translate "This will create a new VM") $CONFIRM_TITLE. $(translate "Proceed?")"

  if ! whiptail --backtitle "ProxMenux" --title "$CONFIRM_TITLE" --yesno "$CONFIRM_MSG" 10 60; then
    header_info
    msg_warn "$(translate "VM creation cancelled by user.")"
    sleep 1
    return 1
  fi
  return 0
}


function generate_mac() {
  local GEN_MAC="02"
  for i in {1..5}; do
    BYTE=$(printf "%02X" $((RANDOM % 256)))
    GEN_MAC="${GEN_MAC}:${BYTE}"
  done
  echo "$GEN_MAC"
}

function load_default_vm_config() {
  local os_type="$1"

  VMID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
  MAC=$(generate_mac)

  case "$os_type" in
    "1")

      CORE_COUNT="2"
      RAM_SIZE="8192"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
    "2")

      CORE_COUNT="4"
      RAM_SIZE="8192"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
    "3")

      CORE_COUNT="2"
      RAM_SIZE="4096"
      MACHINE=" -machine q35"
      BIOS_TYPE=" -bios ovmf"
      START_VM="no"
      ;;
  esac

  if [[ "$os_type" == "1" && "$HN" == "OpenMediaVault" ]]; then
  BIOS_TYPE=" -bios seabios"
  fi


  [[ -z "$CORE_COUNT" ]] && CORE_COUNT="2"
  [[ -z "$RAM_SIZE" ]] && RAM_SIZE="4096"

  CPU_TYPE=" -cpu host"
  BRG="vmbr0"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  FORMAT=""
  DISK_CACHE=""
  
}

function apply_default_vm_config() {
  echo -e "${DEF}$(translate "Applying default VM configuration")${CL}"
  echo -e " ${TAB}${DGN}$(translate "Virtual Machine ID")${CL}: ${BGN}$VMID${CL}"
  echo -e " ${TAB}${DGN}$(translate "Hostname")${CL}: ${BGN}$HN${CL}"
  echo -e " ${TAB}${DGN}$(translate "CPU Cores")${CL}: ${BGN}$CORE_COUNT${CL}"
  echo -e " ${TAB}${DGN}$(translate "RAM Size")${CL}: ${BGN}$RAM_SIZE MiB${CL}"
  echo -e " ${TAB}${DGN}$(translate "Machine Type")${CL}: ${BGN}${MACHINE/ -machine /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "BIOS Type")${CL}: ${BGN}${BIOS_TYPE/ -bios /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "CPU Model")${CL}: ${BGN}${CPU_TYPE/ -cpu /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "Network Bridge")${CL}: ${BGN}$BRG${CL}"
  echo -e " ${TAB}${DGN}$(translate "MAC Address")${CL}: ${BGN}$MAC${CL}"
  echo -e " ${TAB}${DGN}$(translate "Start VM after creation")${CL}: ${BGN}$START_VM${CL}"
  echo -e
  echo -e "${DEF}$(translate "Creating VM with the above configuration")${CL}"
}



function configure_vm_advanced() {
  header_info


  NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
  [[ -z "$MAC" ]] && MAC=$(generate_mac)

  # VMID
  while true; do
    VMID=$(whiptail --backtitle "ProxMenux" \
      --inputbox "$(translate "Set Virtual Machine ID")" 8 60 "$NEXTID" \
      --title "VM ID" --cancel-button Exit 3>&1 1>&2 2>&3) || return 1

    if [[ -z "$VMID" ]]; then
      VMID="$NEXTID"
    fi

    if qm status "$VMID" &>/dev/null || pct status "$VMID" &>/dev/null; then
      msg_error "$(translate "ID already in use. Please choose another.")"
      sleep 1
    else
      break
    fi
  done

  # Hostname
  HN=$(whiptail --backtitle "ProxMenux" \
    --inputbox "$(translate "Set Hostname")" 8 60 "$HN" \
    --title "Hostname" 3>&1 1>&2 2>&3) || return 1
  [[ -z "$HN" ]] && HN="vm-proxmenux"

  # Machine Type
  MACHINE_TYPE=$(whiptail --backtitle "ProxMenux" --title "$(translate "Machine Type")" \
    --radiolist "$(translate "Select machine type")" 10 60 2 \
    "q35"     "QEMU q35" ON \
    "i440fx"  "Legacy i440fx" OFF 3>&1 1>&2 2>&3) || return 1
  [[ "$MACHINE_TYPE" == "q35" ]] && MACHINE=" -machine q35" && FORMAT="" || MACHINE="" && FORMAT=",efitype=4m"

  # BIOS
  if [[ "$HN" == "OpenMediaVault" ]]; then
    BIOS_TYPE=" -bios seabios"
  else
    BIOS=$(whiptail --backtitle "ProxMenux" --title "$(translate "BIOS Type")" \
      --radiolist "$(translate "Choose BIOS type")" 10 60 2 \
      "ovmf"    "UEFI (OVMF)" ON \
      "seabios" "Legacy BIOS (SeaBIOS)" OFF 3>&1 1>&2 2>&3) || return 1
    BIOS_TYPE=" -bios $BIOS"
  fi

  # CPU Type
#  CPU_CHOICE=$(whiptail --backtitle "ProxMenux" --title "$(translate "CPU Model")" \
#    --radiolist "$(translate "Select CPU model")" 10 60 2 \
#    "host"  "Host (recommended)" ON \
#    "kvm64" "Generic KVM64" OFF 3>&1 1>&2 2>&3) || return 1
#  [[ "$CPU_CHOICE" == "host" ]] && CPU_TYPE=" -cpu host" || CPU_TYPE=" -cpu kvm64"

  CPU_CHOICE=$(whiptail --backtitle "ProxMenux" --title "$(translate "CPU Model")" \
  --radiolist "$(translate "Select CPU model")" 17 70 11 \
  "host"          "Host (recommended)" ON \
  "kvm64"         "Generic KVM64" OFF \
  "kvm32"         "Generic KVM32" OFF \
  "qemu64"        "QEMU 64-bit CPU" OFF \
  "qemu32"        "QEMU 32-bit CPU" OFF \
  "max"           "Expose all QEMU CPU features" OFF \
  "x86-64-v2"     "Nehalem-class (x86-64-v2)" OFF \
  "x86-64-v2-AES" "Same as v2 but with AES" OFF \
  "x86-64-v3"     "Haswell-class (x86-64-v3)" OFF \
  "x86-64-v4"     "Skylake-class (x86-64-v4)" OFF 3>&1 1>&2 2>&3) || return 1

  CPU_TYPE=" -cpu $CPU_CHOICE"

  # Core Count
  CORE_COUNT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Number of CPU cores (default: 2)")" \
    8 60 "${CORE_COUNT:-2}" --title "CPU Cores" 3>&1 1>&2 2>&3) || return 1
  [[ -z "$CORE_COUNT" ]] && CORE_COUNT="2"

  # RAM
  RAM_SIZE=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Amount of RAM in MiB (default: 4096)")" \
    8 60 "${RAM_SIZE:-4096}" --title "RAM" 3>&1 1>&2 2>&3) || return 1
  [[ -z "$RAM_SIZE" ]] && RAM_SIZE="4096"

  # Bridge
  BRG=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set network bridge (default: vmbr0)")" \
    8 60 "${BRG:-vmbr0}" --title "Bridge" 3>&1 1>&2 2>&3) || return 1

  # MAC
  MAC_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set MAC Address (leave empty for automatic)")" \
    8 60 "$MAC" --title "MAC Address" 3>&1 1>&2 2>&3) || return 1
  [[ -z "$MAC_INPUT" ]] && MAC=$(generate_mac) || MAC="$MAC_INPUT"

  # VLAN
  VLAN_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set VLAN (leave empty for none)")" \
    8 60 "" --title "VLAN" 3>&1 1>&2 2>&3) || return 1
  VLAN=""
  [[ -n "$VLAN_INPUT" ]] && VLAN=",tag=$VLAN_INPUT"

  # MTU
  MTU_INPUT=$(whiptail --backtitle "ProxMenux" --inputbox "$(translate "Set MTU (leave empty for default)")" \
    8 60 "" --title "MTU" 3>&1 1>&2 2>&3) || return 1
  MTU=""
  [[ -n "$MTU_INPUT" ]] && MTU=",mtu=$MTU_INPUT"

  # Serial Port
  if (whiptail --backtitle "ProxMenux" --title "Serial Port" \
    --yesno "$(translate "Do you want to enable the serial port") (socket)?" 10 60); then
    SERIAL_PORT="socket"
  else
    SERIAL_PORT=""
  fi

  # Start VM
  if (whiptail --backtitle "ProxMenux" --title "$(translate "Start VM")" \
    --yesno "$(translate "Start VM after creation?")" 10 60); then
    START_VM="yes"
  else
    START_VM="no"
  fi

  echo -e "${CUS}$(translate "Using advanced configuration")${CL}"
  echo -e " ${TAB}${DGN}$(translate "Virtual Machine ID")${CL}: ${BGN}$VMID${CL}"
  echo -e " ${TAB}${DGN}$(translate "Hostname")${CL}: ${BGN}$HN${CL}"
  echo -e " ${TAB}${DGN}$(translate "CPU Cores")${CL}: ${BGN}$CORE_COUNT${CL}"
  echo -e " ${TAB}${DGN}$(translate "RAM Size")${CL}: ${BGN}$RAM_SIZE MiB${CL}"
  echo -e " ${TAB}${DGN}$(translate "Machine Type")${CL}: ${BGN}${MACHINE/ -machine /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "BIOS Type")${CL}: ${BGN}${BIOS_TYPE/ -bios /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "CPU Model")${CL}: ${BGN}${CPU_TYPE/ -cpu /}${CL}"
  echo -e " ${TAB}${DGN}$(translate "Network Bridge")${CL}: ${BGN}$BRG${CL}"
  echo -e " ${TAB}${DGN}$(translate "MAC Address")${CL}: ${BGN}$MAC${CL}"
  echo -e " ${TAB}${DGN}$(translate "VLAN")${CL}: ${BGN}${VLAN:-None}${CL}"
  echo -e " ${TAB}${DGN}$(translate "Interface MTU")${CL}: ${BGN}${MTU:-Default}${CL}"
  echo -e " ${TAB}${DGN}$(translate "Start VM")${CL}: ${BGN}$START_VM${CL}"
  echo -e
  echo -e "${CUS}$(translate "Creating VM with the above configuration")${CL}"
  sleep 1



  return 0
}



================================================
FILE: scripts/vm/vm_creator.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================

LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# Mont ISOs
# ==========================================================
function mount_iso_to_vm() {
  local vmid="$1"
  local iso_path="$2"
  local device="$3"

  if [[ -f "$iso_path" ]]; then
    local iso_basename
    iso_basename=$(basename "$iso_path")
    qm set "$vmid" -$device "local:iso/$iso_basename,media=cdrom" >/dev/null 2>&1
    msg_ok "$(translate "Mounted ISO on device") $device â†’ $iso_basename"
  else
    msg_warn "$(translate "ISO not found to mount on device") $device"
  fi
}




# ==========================================================
# Select Interface Type
# ==========================================================
function select_interface_type() {
  INTERFACE_TYPE=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Disk Interface")" --radiolist \
    "$(translate "Select the bus type for the disks:")" 15 70 4 \
    "scsi"    "$(translate "SCSI   (recommended for Linux and Windows)")" ON \
    "sata"    "$(translate "SATA   (standard - high compatibility)")" OFF \
    "virtio"  "$(translate "VirtIO (advanced - high performance)")" OFF \
    "ide"     "IDE    (legacy)" OFF \
    3>&1 1>&2 2>&3) || exit 1

  case "$INTERFACE_TYPE" in
    "scsi"|"sata")
      DISCARD_OPTS=",discard=on,ssd=on"
      ;;
    "virtio")
      DISCARD_OPTS=",discard=on"
      ;;
    "ide")
      DISCARD_OPTS=""
      ;;
  esac

  msg_ok "$(translate "Disk interface selected:") $INTERFACE_TYPE"
}


# ==========================================================
# EFI/TPM
# ==========================================================
function select_storage_target() {
  local PURPOSE="$1"
  local vmid="$2"
  local STORAGE=""
  local STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo "$line" | awk '{print $1}')
    TYPE=$(echo "$line" | awk '{printf "%-10s", $2}')
    FREE=$(echo "$line" | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf("%9sB", $6)}')
    STORAGE_MENU+=("$TAG" "$(translate "Type:") $TYPE $(translate "Free:") $FREE" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  if [[ ${#STORAGE_MENU[@]} -eq 0 ]]; then
    msg_error "$(translate "Unable to detect a valid storage location for $PURPOSE disk.")"
    exit 1
  elif [[ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]]; then
    STORAGE="${STORAGE_MENU[0]}"
  else
    kill $SPINNER_PID > /dev/null
    STORAGE=$(whiptail --backtitle "ProxMenux" --title "$(translate "$PURPOSE Disk Storage")" --radiolist \
      "$(translate "Choose the storage volume for the $PURPOSE disk (4MB):\n\nUse Spacebar to select.")" 16 70 6 \
      "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 1
  fi

  echo "$STORAGE"
}




# ==========================================================
# Guest Agent Configurator 
# ==========================================================
function configure_guest_agent() {
  if [[ -z "$VMID" ]]; then
    msg_error "$(translate "No VMID defined. Cannot apply guest agent config.")"
    return 1
  fi

  msg_info "$(translate "Adding QEMU Guest Agent support...")"

  # Habilitar el agente en la VM
  qm set "$VMID" -agent enabled=1 >/dev/null 2>&1

  # AÃ±adir canal de comunicaciÃ³n virtio
  qm set "$VMID" -chardev socket,id=qga0,path=/var/run/qemu-server/$VMID.qga,server=on,wait=off >/dev/null 2>&1
  qm set "$VMID" -device virtio-serial-pci -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 >/dev/null 2>&1

  msg_ok "$(translate "Guest Agent configuration applied")"

}




# ==========================================================
# Create VM
# ==========================================================
function create_vm() {
  local BOOT_ORDER=""
  local DISK_INFO=""
  local DISK_INDEX=0
  local ISO_DIR="/var/lib/vz/template/iso"



  if [[ -n "$ISO_PATH" && -n "$ISO_URL" && ! -f "$ISO_PATH" ]]; then
  
    if [[ "$ISO_URL" == *"sourceforge.net"* ]]; then
   
      wget --content-disposition --show-progress -O "$ISO_PATH" "$ISO_URL"
    else
  
      wget --no-verbose --show-progress -O "$ISO_PATH" "$ISO_URL"
    fi

  
    if [[ -f "$ISO_PATH" ]]; then
      msg_ok "$(translate "ISO image downloaded")"
    else
      msg_error "$(translate "Failed to download ISO image")"
      return
    fi
  fi

  if [[ "$OS_TYPE" == "2" ]]; then
	  GUEST_OS_TYPE="win10"
    else
	  GUEST_OS_TYPE="l26"
  fi



 # qm create "$VMID" -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} \
 #   -cores "$CORE_COUNT" -memory "$RAM_SIZE" -name "$HN" -tags proxmenux \
 #   -net0 "virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU" -ostype "$GUEST_OS_TYPE" \
 #   -scsihw virtio-scsi-pci \
 #   $( [[ -n "$SERIAL_PORT" ]] && echo "-serial0 $SERIAL_PORT" ) >/dev/null 2>&1


qm create "$VMID" \
  -agent 1${MACHINE:+ $MACHINE} \
  -localtime 1${BIOS_TYPE:+ $BIOS_TYPE}${CPU_TYPE:+ $CPU_TYPE} \
  -cores "$CORE_COUNT" \
  -memory "$RAM_SIZE" \
  -name "$HN" \
  -tags proxmenux \
  -net0 "virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU" \
  -ostype "$GUEST_OS_TYPE" \
  -scsihw virtio-scsi-pci \
  $( [[ -n "$SERIAL_PORT" ]] && echo "-serial0 $SERIAL_PORT" ) \
  >/dev/null 2>&1

if [[ "$OS_TYPE" == "2" ]]; then
  qm set "$VMID" -tablet 1 >/dev/null 2>&1
fi

  msg_ok "$(translate "Base VM created with ID") $VMID"




if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then
  msg_info "$(translate "Configuring EFI disk")"
  EFI_STORAGE=$(select_storage_target "EFI" "$VMID")
  STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
  EFI_DISK_ID="efidisk0"
  EFI_KEYS="0"

  [[ "$OS_TYPE" == "2" ]] && EFI_KEYS="1"

  if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
 
    if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:4,efitype=4m,format=raw,pre-enrolled-keys=$EFI_KEYS" >/dev/null 2>&1; then
      msg_ok "$(translate "EFI disk created and configured on") $EFI_STORAGE"
    else
      msg_error "$(translate "Failed to configure EFI disk")"
    fi
  else

    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME" 4M >/dev/null 2>&1; then
      if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:$EFI_DISK_NAME,pre-enrolled-keys=$EFI_KEYS" >/dev/null 2>&1; then
        msg_ok "$(translate "EFI disk created and configured on") $EFI_STORAGE"
      else
        msg_error "$(translate "Failed to configure EFI disk")"
      fi
    else
      msg_error "$(translate "Failed to create EFI disk")"
    fi
  fi
fi






if [[ "$OS_TYPE" == "2" ]]; then
  msg_info "$(translate "Configuring TPM device")"
  TPM_STORAGE=$(select_storage_target "TPM" "$VMID")
  STORAGE_TYPE=$(pvesm status -storage "$TPM_STORAGE" | awk 'NR>1 {print $2}')
  TPM_ID="tpmstate0"

  if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

    if qm set "$VMID" -$TPM_ID "$TPM_STORAGE:4,version=v2.0,format=raw" >/dev/null 2>&1; then
      msg_ok "$(translate "TPM device added to VM")"
    else
      msg_error "$(translate "Failed to configure TPM device in VM")"
    fi
  else

    TPM_NAME="vm-${VMID}-tpmstate"
    if pvesm alloc "$TPM_STORAGE" "$VMID" "$TPM_NAME" 4M >/dev/null 2>&1; then
      if qm set "$VMID" -$TPM_ID "$TPM_STORAGE:$TPM_NAME,size=4M,version=v2.0" >/dev/null 2>&1; then
        msg_ok "$(translate "TPM device added to VM")"
      else
        msg_error "$(translate "Failed to configure TPM device in VM")"
      fi
    else
      msg_error "$(translate "Failed to create TPM state disk")"
    fi
  fi
fi







# ==========================================================
# Create Diks
# ==========================================================


select_interface_type

  if [[ "$DISK_TYPE" == "virtual" && ${#VIRTUAL_DISKS[@]} -gt 0 ]]; then
    for i in "${!VIRTUAL_DISKS[@]}"; do
      DISK_INDEX=$((i+1))
      IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
      DISK_NAME="vm-${VMID}-disk-${DISK_INDEX}"
      SLOT_NAME="${INTERFACE_TYPE}${i}"

      STORAGE_TYPE=$(pvesm status -storage "$STORAGE" | awk 'NR>1 {print $2}')
      case "$STORAGE_TYPE" in
        dir|nfs|btrfs)
          DISK_EXT=".raw"
          DISK_REF="$VMID/"
          ;;
        *)
          DISK_EXT=""
          DISK_REF=""
          ;;
      esac

      if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
 
            if qm set "$VMID" -$SLOT_NAME "$STORAGE:${SIZE},format=raw${DISCARD_OPTS}" >/dev/null 2>&1; then
              msg_ok "$(translate "Virtual disk") $DISK_INDEX ${SIZE}GB - $STORAGE ($SLOT_NAME)"
              DISK_INFO+="<p>Virtual Disk $DISK_INDEX: ${SIZE}GB ($STORAGE / $SLOT_NAME)</p>"
              [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
            else
              msg_error "$(translate "Failed to assign virtual disk") $DISK_INDEX"
            fi
          else

            #DISK_NAME="vm-${VMID}-disk-${DISK_INDEX}"

            if pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME$DISK_EXT" "$SIZE"G >/dev/null 2>&1; then
              qm set "$VMID" -$SLOT_NAME "$STORAGE:${DISK_REF}${DISK_NAME}${DISK_EXT}${DISCARD_OPTS}" >/dev/null
              msg_ok "$(translate "Virtual disk") $DISK_INDEX ${SIZE}GB - $STORAGE ($SLOT_NAME)"
              DISK_INFO+="<p>Virtual Disk $DISK_INDEX: ${SIZE}GB ($STORAGE / $SLOT_NAME)</p>"
              [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
            else
              msg_error "$(translate "Failed to create disk") $DISK_INDEX"
            fi
          fi
    done
  fi



  if [[ "$DISK_TYPE" == "passthrough" && ${#PASSTHROUGH_DISKS[@]} -gt 0 ]]; then
    for i in "${!PASSTHROUGH_DISKS[@]}"; do
      SLOT_NAME="${INTERFACE_TYPE}${i}"
      DISK="${PASSTHROUGH_DISKS[$i]}"
      MODEL=$(lsblk -ndo MODEL "$DISK")
      SIZE=$(lsblk -ndo SIZE "$DISK")
      qm set "$VMID" -$SLOT_NAME "$DISK${DISCARD_OPTS}" >/dev/null 2>&1
      msg_ok "$(translate "Passthrough disk assigned") ($DISK â†’ $SLOT_NAME)"
      DISK_INFO+="<p>Passthrough Disk $((i+1)): $DISK ($MODEL $SIZE)</p>"
      [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
    done
  fi





  if [[ -f "$ISO_PATH" ]]; then
    mount_iso_to_vm "$VMID" "$ISO_PATH" "ide2"
  fi

  
  if [[ "$OS_TYPE" == "2" ]]; then
    local VIRTIO_DIR="/var/lib/vz/template/iso"
    local VIRTIO_SELECTED=""
    local VIRTIO_DOWNLOAD_URL="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso"

    while true; do
      VIRTIO_OPTION=$(whiptail --title "ProxMenux - VirtIO Drivers" --menu "$(translate "Select how to provide VirtIO drivers")" 15 70 2 \
        "1" "$(translate "Download latest VirtIO ISO automatically")" \
        "2" "$(translate "Use existing VirtIO ISO from storage")" 3>&1 1>&2 2>&3)

      [[ $? -ne 0 ]] && msg_warn "$(translate "VirtIO ISO selection cancelled.")" && break

      case "$VIRTIO_OPTION" in
        1)

          if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
            if whiptail --title "ProxMenux" --yesno "$(translate "A VirtIO ISO already exists. Do you want to overwrite it?")" 10 60; then
              wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
              if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
                msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
              else
                msg_error "$(translate "Failed to download VirtIO driver ISO.")"
              fi
            fi
          else
            wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
            if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
              msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
            else
              msg_error "$(translate "Failed to download VirtIO driver ISO.")"
            fi
          fi

          VIRTIO_SELECTED="$VIRTIO_DIR/virtio-win.iso"
          ;;
        2)

          VIRTIO_LIST=()
          while read -r line; do
            FILENAME=$(basename "$line")
            SIZE=$(du -h "$line" | cut -f1)
            VIRTIO_LIST+=("$FILENAME" "$SIZE")
          done < <(find "$VIRTIO_DIR" -type f -iname "virtio*.iso" | sort)

          if [[ ${#VIRTIO_LIST[@]} -eq 0 ]]; then
            msg_warn "$(translate "No VirtIO ISO found. Please download one.")"
            continue  
          fi

          VIRTIO_FILE=$(whiptail --title "ProxMenux - VirtIO ISOs" --menu "$(translate "Select a VirtIO ISO to use:")" 20 70 10 "${VIRTIO_LIST[@]}" 3>&1 1>&2 2>&3)

          if [[ -n "$VIRTIO_FILE" ]]; then
            VIRTIO_SELECTED="$VIRTIO_DIR/$VIRTIO_FILE"
          else
            msg_warn "$(translate "No VirtIO ISO selected. Please choose again.")"
            continue
          fi
          ;;
      esac

      if [[ -n "$VIRTIO_SELECTED" && -f "$VIRTIO_SELECTED" ]]; then
        mount_iso_to_vm "$VMID" "$VIRTIO_SELECTED" "ide3"
      else
        msg_warn "$(translate "VirtIO ISO not found after selection.")"
      fi

      break
    done
  fi


  local BOOT_FINAL="$BOOT_ORDER"
  [[ -f "$ISO_PATH" ]] && BOOT_FINAL="$BOOT_ORDER;ide2"
  qm set "$VMID" -boot order="$BOOT_FINAL" >/dev/null
  msg_ok "$(translate "Boot order set to") $BOOT_FINAL"




  HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>$HN VM</h1>
<p style='margin: 0;'>Created with ProxMenux</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://github.com/MacRimi/ProxMenux/blob/main/scripts/vm/create_vm.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"

msg_info "$(translate "Setting VM description")"
if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
    msg_error "$(translate "Failed to set VM description")"
else
    msg_ok "$(translate "VM description configured")"
fi


  if [[ "$START_VM" == "yes" ]]; then
    qm start "$VMID"
    msg_ok "$(translate "VM started")"
  fi
  configure_guest_agent
  msg_success "$(translate "VM creation completed")"

if [[ "$OS_TYPE" == "2" ]]; then
  echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
  echo -e "${TAB}1. $(translate "Start the VM to begin Windows installation from the mounted ISO.")"
  echo -e "${TAB}2. $(translate "When asked to select a disk, click Load Driver and load the VirtIO drivers.")"
  echo -e "${TAB}   $(translate "Required if using a VirtIO or SCSI disk.")"
  echo -e "${TAB}3. $(translate "Also install the VirtIO network driver during setup to enable network access.")"
  echo -e "${TAB}4. $(translate "Continue the Windows installation as usual.")"
  echo -e "${TAB}5. $(translate "Once installed, open the VirtIO ISO and run the installer to complete driver setup.")"
  echo -e "${TAB}6. $(translate "Reboot the VM to complete the driver installation.")"
  echo -e
elif [[ "$OS_TYPE" == "3" ]]; then
  echo -e "${TAB}${GN}$(translate "Recommended: Install the QEMU Guest Agent in the VM")${CL}"
  echo -e "${TAB}$(translate "Run the following inside the VM:")"
  echo -e "${TAB}${CY}apt install qemu-guest-agent -y && systemctl enable --now qemu-guest-agent${CL}"
  echo -e
fi


msg_success "$(translate "Press Enter to return to the main menu...")"
read -r
bash "$LOCAL_SCRIPTS/menus/create_vm_menu.sh"
exit 0

}



================================================
FILE: scripts/vm/vm_creator_.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - Virtual Machine Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 07/05/2025
# ==========================================================
# Description:
# This script is part of the central ProxMenux VM creation module. It allows users
# to create virtual machines (VMs) in Proxmox VE using either default or advanced
# configurations, streamlining the deployment of Linux, Windows, and other systems.
#
# Key features:
# - Supports both virtual disk creation and physical disk passthrough.
# - Automates CPU, RAM, BIOS, network and storage configuration.
# - Provides a user-friendly menu to select OS type, ISO image and disk interface.
# - Automatically generates a detailed and styled HTML description for each VM.
#
# All operations are designed to simplify and accelerate VM creation in a 
# consistent and maintainable way, using ProxMenux standards.
# ==========================================================

BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
  source "$UTILS_FILE"
fi

load_language
initialize_cache

# ==========================================================
# Mont ISOs
# ==========================================================
function mount_iso_to_vm() {
  local vmid="$1"
  local iso_path="$2"
  local device="$3"

  if [[ -f "$iso_path" ]]; then
    local iso_basename
    iso_basename=$(basename "$iso_path")
    qm set "$vmid" -$device "local:iso/$iso_basename,media=cdrom" >/dev/null 2>&1
    msg_ok "$(translate "Mounted ISO on device") $device â†’ $iso_basename"
  else
    msg_warn "$(translate "ISO not found to mount on device") $device"
  fi
}




# ==========================================================
# Select Interface Type
# ==========================================================
function select_interface_type() {
  INTERFACE_TYPE=$(whiptail --backtitle "ProxMenux" --title "$(translate "Select Disk Interface")" --radiolist \
    "$(translate "Select the bus type for the disks:")" 15 70 4 \
    "scsi"    "$(translate "SCSI   (recommended for Linux and Windows)")" ON \
    "sata"    "$(translate "SATA   (standard - high compatibility)")" OFF \
    "virtio"  "$(translate "VirtIO (advanced - high performance)")" OFF \
    "ide"     "IDE    (legacy)" OFF \
    3>&1 1>&2 2>&3) || exit 1

  case "$INTERFACE_TYPE" in
    "scsi"|"sata")
      DISCARD_OPTS=",discard=on,ssd=on"
      ;;
    "virtio")
      DISCARD_OPTS=",discard=on"
      ;;
    "ide")
      DISCARD_OPTS=""
      ;;
  esac

  msg_ok "$(translate "Disk interface selected:") $INTERFACE_TYPE"
}


# ==========================================================
# EFI/TPM
# ==========================================================
function select_storage_target() {
  local PURPOSE="$1"
  local vmid="$2"
  local STORAGE=""
  local STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo "$line" | awk '{print $1}')
    TYPE=$(echo "$line" | awk '{printf "%-10s", $2}')
    FREE=$(echo "$line" | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf("%9sB", $6)}')
    STORAGE_MENU+=("$TAG" "$(translate "Type:") $TYPE $(translate "Free:") $FREE" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  if [[ ${#STORAGE_MENU[@]} -eq 0 ]]; then
    msg_error "$(translate "Unable to detect a valid storage location for $PURPOSE disk.")"
    exit 1
  elif [[ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]]; then
    STORAGE="${STORAGE_MENU[0]}"
  else
    kill $SPINNER_PID > /dev/null
    STORAGE=$(whiptail --backtitle "ProxMenux" --title "$(translate "$PURPOSE Disk Storage")" --radiolist \
      "$(translate "Choose the storage volume for the $PURPOSE disk (4MB):\n\nUse Spacebar to select.")" 16 70 6 \
      "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 1
  fi

  echo "$STORAGE"
}




# ==========================================================
# Guest Agent Configurator 
# ==========================================================
function configure_guest_agent() {
  if [[ -z "$VMID" ]]; then
    msg_error "$(translate "No VMID defined. Cannot apply guest agent config.")"
    return 1
  fi

  msg_info "$(translate "Adding QEMU Guest Agent support...")"

  # Habilitar el agente en la VM
  qm set "$VMID" -agent enabled=1 >/dev/null 2>&1

  # AÃ±adir canal de comunicaciÃ³n virtio
  qm set "$VMID" -chardev socket,id=qga0,path=/var/run/qemu-server/$VMID.qga,server=on,wait=off >/dev/null 2>&1
  qm set "$VMID" -device virtio-serial-pci -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0 >/dev/null 2>&1

  msg_ok "$(translate "Guest Agent configuration applied")"

}




# ==========================================================
# Create VM
# ==========================================================
function create_vm() {
  local BOOT_ORDER=""
  local DISK_INFO=""
  local DISK_INDEX=0
  local ISO_DIR="/var/lib/vz/template/iso"



  if [[ -n "$ISO_PATH" && -n "$ISO_URL" && ! -f "$ISO_PATH" ]]; then
  
    if [[ "$ISO_URL" == *"sourceforge.net"* ]]; then
   
      wget --content-disposition --show-progress -O "$ISO_PATH" "$ISO_URL"
    else
  
      wget --no-verbose --show-progress -O "$ISO_PATH" "$ISO_URL"
    fi

  
    if [[ -f "$ISO_PATH" ]]; then
      msg_ok "$(translate "ISO image downloaded")"
    else
      msg_error "$(translate "Failed to download ISO image")"
      return
    fi
  fi

  if [[ "$OS_TYPE" == "2" ]]; then
	  GUEST_OS_TYPE="win10"
    else
	  GUEST_OS_TYPE="l26"
  fi



  qm create "$VMID" -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} \
    -cores "$CORE_COUNT" -memory "$RAM_SIZE" -name "$HN" -tags proxmenux \
    -net0 "virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU" -ostype "$GUEST_OS_TYPE" \
    -scsihw virtio-scsi-pci \
    $( [[ -n "$SERIAL_PORT" ]] && echo "-serial0 $SERIAL_PORT" ) >/dev/null 2>&1

  msg_ok "$(translate "Base VM created with ID") $VMID"



  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then
    msg_info "$(translate "Configuring EFI disk")"
    EFI_STORAGE=$(select_storage_target "EFI" "$VMID")
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"

    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    case "$STORAGE_TYPE" in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac

    EFI_KEYS="0"
    [[ "$OS_TYPE" == "2" ]] && EFI_KEYS="1"

    if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME$EFI_DISK_EXT" 4M >/dev/null 2>&1; then
      if qm set "$VMID" -efidisk0 "$EFI_STORAGE:${EFI_DISK_REF}$EFI_DISK_NAME$EFI_DISK_EXT,pre-enrolled-keys=$EFI_KEYS" >/dev/null 2>&1; then
        msg_ok "$(translate "EFI disk created and configured on") $EFI_STORAGE"
      else
        msg_error "$(translate "Failed to configure EFI disk")"
      fi
    else
      msg_error "$(translate "Failed to create EFI disk")"
    fi
  fi






  if [[ "$OS_TYPE" == "2" ]]; then
    msg_info "$(translate "Configuring TPM device")"
    TPM_STORAGE=$(select_storage_target "TPM" "$VMID")
    TPM_NAME="vm-${VMID}-tpmstate"

    STORAGE_TYPE=$(pvesm status -storage "$TPM_STORAGE" | awk 'NR>1 {print $2}')
    case "$STORAGE_TYPE" in
      nfs | dir)
        TPM_EXT=".raw"
        TPM_REF="$VMID/"
        ;;
      *)
        TPM_EXT=""
        TPM_REF=""
        ;;
    esac

    TPM_FULL_NAME="${TPM_NAME}${TPM_EXT}"

    if pvesm alloc "$TPM_STORAGE" "$VMID" "$TPM_FULL_NAME" 4M >/dev/null 2>&1; then
      TPM_PATH="$TPM_STORAGE:${TPM_REF}${TPM_FULL_NAME},size=4M,version=v2.0"
      if qm set "$VMID" -tpmstate0 "$TPM_PATH" >/dev/null 2>&1; then
        msg_ok "$(translate "TPM device added to VM")"
      else
        msg_error "$(translate "Failed to configure TPM device in VM") â†’ $TPM_PATH"
      fi
    else
      msg_error "$(translate "Failed to create TPM state disk")"
    fi
  fi








# ==========================================================
# Create Diks
# ==========================================================


select_interface_type

  if [[ "$DISK_TYPE" == "virtual" && ${#VIRTUAL_DISKS[@]} -gt 0 ]]; then
    for i in "${!VIRTUAL_DISKS[@]}"; do
      DISK_INDEX=$((i+1))
      IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
      DISK_NAME="vm-${VMID}-disk-${DISK_INDEX}"
      SLOT_NAME="${INTERFACE_TYPE}${i}"

      STORAGE_TYPE=$(pvesm status -storage "$STORAGE" | awk 'NR>1 {print $2}')
      case "$STORAGE_TYPE" in
        dir|nfs)
          DISK_EXT=".raw"
          DISK_REF="$VMID/"
          ;;
        *)
          DISK_EXT=""
          DISK_REF=""
          ;;
      esac

      if pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME$DISK_EXT" "$SIZE"G >/dev/null 2>&1; then
        qm set "$VMID" -$SLOT_NAME "$STORAGE:${DISK_REF}${DISK_NAME}${DISK_EXT}${DISCARD_OPTS}" >/dev/null
        msg_ok "$(translate "Virtual disk") $DISK_INDEX ${SIZE}GB - $STORAGE ($SLOT_NAME)"
        DISK_INFO+="<p>Virtual Disk $DISK_INDEX: ${SIZE}GB ($STORAGE / $SLOT_NAME)</p>"
        [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
      else
        msg_error "$(translate "Failed to create disk") $DISK_INDEX"
      fi
    done
  fi

  if [[ "$DISK_TYPE" == "passthrough" && ${#PASSTHROUGH_DISKS[@]} -gt 0 ]]; then
    for i in "${!PASSTHROUGH_DISKS[@]}"; do
      SLOT_NAME="${INTERFACE_TYPE}${i}"
      DISK="${PASSTHROUGH_DISKS[$i]}"
      MODEL=$(lsblk -ndo MODEL "$DISK")
      SIZE=$(lsblk -ndo SIZE "$DISK")
      qm set "$VMID" -$SLOT_NAME "$DISK${DISCARD_OPTS}" >/dev/null 2>&1
      msg_ok "$(translate "Passthrough disk assigned") ($DISK â†’ $SLOT_NAME)"
      DISK_INFO+="<p>Passthrough Disk $((i+1)): $DISK ($MODEL $SIZE)</p>"
      [[ -z "$BOOT_ORDER" ]] && BOOT_ORDER="$SLOT_NAME"
    done
  fi





  if [[ -f "$ISO_PATH" ]]; then
    mount_iso_to_vm "$VMID" "$ISO_PATH" "ide2"
  fi

  
  if [[ "$OS_TYPE" == "2" ]]; then
    local VIRTIO_DIR="/var/lib/vz/template/iso"
    local VIRTIO_SELECTED=""
    local VIRTIO_DOWNLOAD_URL="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso"

    while true; do
      VIRTIO_OPTION=$(whiptail --title "ProxMenux - VirtIO Drivers" --menu "$(translate "Select how to provide VirtIO drivers")" 15 70 2 \
        "1" "$(translate "Download latest VirtIO ISO automatically")" \
        "2" "$(translate "Use existing VirtIO ISO from storage")" 3>&1 1>&2 2>&3)

      [[ $? -ne 0 ]] && msg_warn "$(translate "VirtIO ISO selection cancelled.")" && break

      case "$VIRTIO_OPTION" in
        1)

          if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
            if whiptail --title "ProxMenux" --yesno "$(translate "A VirtIO ISO already exists. Do you want to overwrite it?")" 10 60; then
              wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
              if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
                msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
              else
                msg_error "$(translate "Failed to download VirtIO driver ISO.")"
              fi
            fi
          else
            wget -q --show-progress -O "$VIRTIO_DIR/virtio-win.iso" "$VIRTIO_DOWNLOAD_URL"
            if [[ -f "$VIRTIO_DIR/virtio-win.iso" ]]; then
              msg_ok "$(translate "VirtIO driver ISO downloaded successfully.")"
            else
              msg_error "$(translate "Failed to download VirtIO driver ISO.")"
            fi
          fi

          VIRTIO_SELECTED="$VIRTIO_DIR/virtio-win.iso"
          ;;
        2)

          VIRTIO_LIST=()
          while read -r line; do
            FILENAME=$(basename "$line")
            SIZE=$(du -h "$line" | cut -f1)
            VIRTIO_LIST+=("$FILENAME" "$SIZE")
          done < <(find "$VIRTIO_DIR" -type f -iname "virtio*.iso" | sort)

          if [[ ${#VIRTIO_LIST[@]} -eq 0 ]]; then
            msg_warn "$(translate "No VirtIO ISO found. Please download one.")"
            continue  
          fi

          VIRTIO_FILE=$(whiptail --title "ProxMenux - VirtIO ISOs" --menu "$(translate "Select a VirtIO ISO to use:")" 20 70 10 "${VIRTIO_LIST[@]}" 3>&1 1>&2 2>&3)

          if [[ -n "$VIRTIO_FILE" ]]; then
            VIRTIO_SELECTED="$VIRTIO_DIR/$VIRTIO_FILE"
          else
            msg_warn "$(translate "No VirtIO ISO selected. Please choose again.")"
            continue
          fi
          ;;
      esac

      if [[ -n "$VIRTIO_SELECTED" && -f "$VIRTIO_SELECTED" ]]; then
        mount_iso_to_vm "$VMID" "$VIRTIO_SELECTED" "ide3"
      else
        msg_warn "$(translate "VirtIO ISO not found after selection.")"
      fi

      break
    done
  fi


  local BOOT_FINAL="$BOOT_ORDER"
  [[ -f "$ISO_PATH" ]] && BOOT_FINAL="$BOOT_ORDER;ide2"
  qm set "$VMID" -boot order="$BOOT_FINAL" >/dev/null
  msg_ok "$(translate "Boot order set to") $BOOT_FINAL"




  HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>$HN VM</h1>
<p style='margin: 0;'>Created with ProxMenux</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/docs/create-vm/synology' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://github.com/MacRimi/ProxMenux/blob/main/scripts/vm/create_vm.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"

msg_info "$(translate "Setting VM description")"
if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
    msg_error "$(translate "Failed to set VM description")"
else
    msg_ok "$(translate "VM description configured")"
fi


  if [[ "$START_VM" == "yes" ]]; then
    qm start "$VMID"
    msg_ok "$(translate "VM started")"
  fi
  configure_guest_agent
  msg_success "$(translate "VM creation completed")"

if [[ "$OS_TYPE" == "2" ]]; then
  echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
  echo -e "${TAB}1. $(translate "Start the VM to begin Windows installation from the mounted ISO.")"
  echo -e "${TAB}2. $(translate "When asked to select a disk, click Load Driver and load the VirtIO drivers.")"
  echo -e "${TAB}   $(translate "Required if using a VirtIO or SCSI disk.")"
  echo -e "${TAB}3. $(translate "Also install the VirtIO network driver during setup to enable network access.")"
  echo -e "${TAB}4. $(translate "Continue the Windows installation as usual.")"
  echo -e "${TAB}5. $(translate "Once installed, open the VirtIO ISO and run the installer to complete driver setup.")"
  echo -e "${TAB}6. $(translate "Reboot the VM to complete the driver installation.")"
  echo -e
elif [[ "$OS_TYPE" == "3" ]]; then
  echo -e "${TAB}${GN}$(translate "Recommended: Install the QEMU Guest Agent in the VM")${CL}"
  echo -e "${TAB}$(translate "Run the following inside the VM:")"
  echo -e "${TAB}${CY}apt install qemu-guest-agent -y && systemctl enable --now qemu-guest-agent${CL}"
  echo -e
fi


msg_success "$(translate "Press Enter to return to the main menu...")"
read -r

}



================================================
FILE: scripts/vm/zimaos.sh
================================================
#!/usr/bin/env bash

# ==========================================================
# ProxMenuX - ZimaOS VM Creator Script
# ==========================================================
# Author      : MacRimi
# Copyright   : (c) 2024 MacRimi
# License     : (CC BY-NC 4.0) (https://github.com/MacRimi/ProxMenux/blob/main/LICENSE)
# Version     : 1.0
# Last Updated: 21/08/2025
# ==========================================================
# Description:
# This script automates the creation and configuration of a ZimaOS 
# Virtual machine (VM) in Proxmox VE. It simplifies the
# setup process by allowing both default and advanced configuration options.
#
# The script automates the complete VM creation process, including loader 
# download, disk configuration, and VM boot setup.
#
#
# ==========================================================


# Configuration ============================================
LOCAL_SCRIPTS="/usr/local/share/proxmenux/scripts"
BASE_DIR="/usr/local/share/proxmenux"
UTILS_FILE="$BASE_DIR/utils.sh"
VENV_PATH="/opt/googletrans-env"

if [[ -f "$UTILS_FILE" ]]; then
    source "$UTILS_FILE"
fi
load_language
initialize_cache
# ==========================================================

GEN_MAC="02"
for i in {1..5}; do
  BYTE=$(printf "%02X" $((RANDOM % 256)))
  GEN_MAC="${GEN_MAC}:${BYTE}"
done

NEXTID=$(pvesh get /cluster/nextid 2>/dev/null || echo "100")
NAME="ZimaOS VM"
IMAGES_DIR="/var/lib/vz/template/iso"
ERROR_FLAG=false





function exit_script() {
  clear
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
}


# Define the header_info function at the beginning of the script

function header_info() {
  show_proxmenux_logo
  echo -e "${BL}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•‘${YWB}                ZimaOS VM Creator              ${BL}â•‘${CL}"
  echo -e "${BL}â•‘                                               â•‘${CL}"
  echo -e "${BL}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${CL}"
  echo -e
}
# ==========================================================






# ==========================================================
# start Script
# ==========================================================
function start_script() {
  if (whiptail --backtitle "ProxMenuX" --title "SETTINGS" --yesno "$(translate  "Use Default Settings?")" --no-button Advanced 10 58); then
    header_info
    echo -e "${DEF}Using Default Settings${CL}"
    default_settings
  else
    header_info
    echo -e "${CUS}Using Advanced Settings${CL}"
    advanced_settings
  fi
}
# ==========================================================




# ==========================================================
# Default Settings
# ==========================================================
function default_settings() {
  VMID="$NEXTID"
  FORMAT=""
  MACHINE=" -machine q35"
  BIOS_TYPE=" -bios ovmf"
  DISK_CACHE=""
  HN="ZimaOS"
  CPU_TYPE=" -cpu host"
  CORE_COUNT="2"
  RAM_SIZE="4096"
  BRG="vmbr0"
  MAC="$GEN_MAC"
  VLAN=""
  MTU=""
  SERIAL_PORT="socket"
  START_VM="no"
  INTERFACE_TYPE="scsi"
  DISCARD_OPTS=",discard=on,ssd=on"
  
  echo -e " ${TAB}${DGN}Using Virtual Machine ID: ${BGN}${VMID}${CL}"
  echo -e " ${TAB}${DGN}Using Machine Type: ${BGN}q35${CL}"
  echo -e " ${TAB}${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
  echo -e " ${TAB}${DGN}Using Hostname: ${BGN}${HN}${CL}"
  echo -e " ${TAB}${DGN}Using CPU Model: ${BGN}Host${CL}"
  echo -e " ${TAB}${DGN}Allocated Cores: ${BGN}${CORE_COUNT}${CL}"
  echo -e " ${TAB}${DGN}Allocated RAM: ${BGN}${RAM_SIZE}${CL}"
  echo -e " ${TAB}${DGN}Using Bridge: ${BGN}${BRG}${CL}"
  echo -e " ${TAB}${DGN}Using MAC Address: ${BGN}${MAC}${CL}"
  echo -e " ${TAB}${DGN}Using VLAN: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Using Interface MTU Size: ${BGN}Default${CL}"
  echo -e " ${TAB}${DGN}Configuring Serial Port: ${BGN}${SERIAL_PORT}${CL}"
  echo -e " ${TAB}${DGN}Start VM when completed: ${BGN}${START_VM}${CL}"
  echo -e " ${TAB}${DGN}Disk Interface Type: ${BGN}${INTERFACE_TYPE}${CL}"
  echo -e
  echo -e "${DEF}Creating a $NAME using the above default settings${CL}"
 
  sleep 1
  select_disk_type
}
# ==========================================================





# ==========================================================
# advanced Settings
# ==========================================================
function advanced_settings() {
  # VM ID Selection
  while true; do
    if VMID=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Virtual Machine ID")" 8 58 $NEXTID --title "VIRTUAL MACHINE ID" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
      if [ -z "$VMID" ]; then
        VMID="$NEXTID"
      fi
      if pct status "$VMID" &>/dev/null || qm status "$VMID" &>/dev/null; then
        echo -e "${CROSS}${RD} ID $VMID is already in use${CL}"
        sleep 1
        continue
      fi
      echo -e "${DGN}Virtual Machine ID: ${BGN}$VMID${CL}"
      break
    else
      exit_script
    fi
  done

  # Machine Type Selection
  if MACH=$(whiptail --backtitle "ProxMenuX" --title "$(translate "MACHINE TYPE")" --radiolist --cancel-button Exit-Script "Choose Type" 10 58 2 \
    "q35" "Machine q35" ON \
    "i440fx" "Machine i440fx" OFF \
    3>&1 1>&2 2>&3); then
    if [ $MACH = q35 ]; then
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=""
      MACHINE=" -machine q35"
    else
      echo -e "${DGN}Using Machine Type: ${BGN}$MACH${CL}"
      FORMAT=",efitype=4m"
      MACHINE=""
    fi
  else
    exit_script
  fi

    # BIOS Type Selection 
  if BIOS=$(whiptail --backtitle "ProxMenuX" --title "$(translate "BIOS TYPE")" --radiolist --cancel-button Exit-Script "Choose BIOS Type" 10 58 2 \
    "ovmf" "UEFI (OVMF)" ON \
    "seabios" "SeaBIOS (Legacy)" OFF \
    3>&1 1>&2 2>&3); then
    if [ "$BIOS" = "seabios" ]; then
        echo -e "${DGN}Using BIOS Type: ${BGN}SeaBIOS${CL}"
        BIOS_TYPE=" -bios seabios"
    else
        echo -e "${DGN}Using BIOS Type: ${BGN}OVMF (UEFI)${CL}"
        BIOS_TYPE=" -bios ovmf"
    fi
  else
    exit_script
   fi

  # Hostname Selection
  if VM_NAME=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Hostname")" 8 58 ZimaOS --title "HOSTNAME" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VM_NAME ]; then
      HN="ZimaOS"
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    else
      HN=$(echo ${VM_NAME,,} | tr -d ' ')
      echo -e "${DGN}Using Hostname: ${BGN}$HN${CL}"
    fi
  else
    exit_script
  fi

  # CPU Type Selection 
  if CPU_TYPE1=$(whiptail --backtitle "ProxMenuX" --title "$(translate "CPU MODEL")" --radiolist "Choose" --cancel-button Exit-Script 10 58 2 \
    "1" "Host" ON \
    "0" "KVM64" OFF \
    3>&1 1>&2 2>&3); then
    if [ $CPU_TYPE1 = "1" ]; then
      echo -e "${DGN}Using CPU Model: ${BGN}Host${CL}"
      CPU_TYPE=" -cpu host"
    else
      echo -e "${DGN}Using CPU Model: ${BGN}KVM64${CL}"
      CPU_TYPE=""
    fi
  else
    exit_script
  fi

  # Core Count Selection
  if CORE_COUNT=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate CPU Cores")" 8 58 2 --title "CORE COUNT" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $CORE_COUNT ]; then
      CORE_COUNT="2"
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    else
      echo -e "${DGN}Allocated Cores: ${BGN}$CORE_COUNT${CL}"
    fi
  else
    exit_script
  fi

  # RAM Size Selection
  if RAM_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Allocate RAM in MiB")" 8 58 4096 --title "RAM" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $RAM_SIZE ]; then
      RAM_SIZE="4096"
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    else
      echo -e "${DGN}Allocated RAM: ${BGN}$RAM_SIZE${CL}"
    fi
  else
    exit_script
  fi

  # Bridge Selection
  if BRG=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Bridge")" 8 58 vmbr0 --title "BRIDGE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $BRG ]; then
      BRG="vmbr0"
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    else
      echo -e "${DGN}Using Bridge: ${BGN}$BRG${CL}"
    fi
  else
    exit_script
  fi

  # MAC Address Selection
  if MAC1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a MAC Address")" 8 58 $GEN_MAC --title "MAC ADDRESS" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MAC1 ]; then
      MAC="$GEN_MAC"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC${CL}"
    else
      MAC="$MAC1"
      echo -e "${DGN}Using MAC Address: ${BGN}$MAC1${CL}"
    fi
  else
    exit_script
  fi

  # VLAN Selection
  if VLAN1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set a Vlan(leave blank for default)")" 8 58 --title "VLAN" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $VLAN1 ]; then
      VLAN1="Default"
      VLAN=""
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    else
      VLAN=",tag=$VLAN1"
      echo -e "${DGN}Using Vlan: ${BGN}$VLAN1${CL}"
    fi
  else
    exit_script
  fi

  # MTU Selection
  if MTU1=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "Set Interface MTU Size (leave blank for default)")" 8 58 --title "MTU SIZE" --cancel-button Exit-Script 3>&1 1>&2 2>&3); then
    if [ -z $MTU1 ]; then
      MTU1="Default"
      MTU=""
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    else
      MTU=",mtu=$MTU1"
      echo -e "${DGN}Using Interface MTU Size: ${BGN}$MTU1${CL}"
    fi
  else
    exit_script
  fi




  # Select Interface Type
  INTERFACE_TYPE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Disk Interface")" --radiolist \
    "$(translate "Select the bus type for the disks:")" 15 70 4 \
    "scsi"    "$(translate "SCSI   (recommended for Linux)")" ON \
    "sata"    "$(translate "SATA   (standard - high compatibility)")" OFF \
    3>&1 1>&2 2>&3) || exit 1

  case "$INTERFACE_TYPE" in
    "scsi"|"sata")
      DISCARD_OPTS=",discard=on,ssd=on"
      ;;
  esac

  msg_ok "$(translate "Disk interface selected:") $INTERFACE_TYPE"


  # Confirmation
  if (whiptail --backtitle "ProxMenuX" --title "$(translate "ADVANCED SETTINGS COMPLETE")" --yesno "Ready to create a $NAME?" --no-button Do-Over 10 58); then
    echo -e
    echo -e "${CUS}Creating a $NAME using the above advanced settings${CL}"
    sleep 1
    select_disk_type
  else
   header_info
   sleep 1
   echo -e "${CUS}Using Advanced Settings${CL}"
   advanced_settings
  fi
}
# ==========================================================





# ==========================================================
# Select Disk
# ==========================================================
function select_disk_type() {

  DISK_TYPE=$(whiptail --backtitle "ProxMenuX" --title "DISK TYPE" --menu "$(translate "Choose disk type:")" 12 58 2 \
    "virtual" "$(translate "Create virtual disk")" \
    "passthrough" "$(translate "Use physical disk passthrough")" \
    --ok-button "Select" --cancel-button "Cancel" 3>&1 1>&2 2>&3)

  EXIT_STATUS=$?

  if [[ $EXIT_STATUS -ne 0 ]]; then
      clear
      header_info
      msg_error "Operation cancelled by user. Returning to start script..."
      sleep 2
      if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
        start_script
      else
        clear
        exit
      fi
  fi

  if [[ "$DISK_TYPE" == "virtual" ]]; then
      select_virtual_disk
  else
      select_passthrough_disk
  fi
}

# ==========================================================





# ==========================================================
# Select Virtual Disks
# ==========================================================
function select_virtual_disk() {

  VIRTUAL_DISKS=()      

  # Loop to add multiple disks
  local add_more_disks=true
  while $add_more_disks; do

  msg_info "Detecting available storage volumes..."

    # Get list of available storage
    STORAGE_MENU=()
    while read -r line; do
      TAG=$(echo $line | awk '{print $1}')
      TYPE=$(echo $line | awk '{print $2}')
      FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
      ITEM=$(printf "%-15s %-10s %-15s" "$TAG" "$TYPE" "$FREE")
      STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
    done < <(pvesm status -content images | awk 'NR>1')

    # Check that storage is available
    VALID=$(pvesm status -content images | awk 'NR>1')
    if [ -z "$VALID" ]; then
      msg_error "Unable to detect a valid storage location."
      sleep 2
      select_disk_type
    fi

    
    # Select storage
    if [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
      STORAGE=${STORAGE_MENU[0]}
      msg_ok "Using ${CL}${BL}$STORAGE${CL} ${GN}for Storage Location."
    else

      kill $SPINNER_PID > /dev/null
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "$(translate "Select Storage Volume")" --radiolist \
        "$(translate  "Choose the storage volume for the virtual disk:\n")" 20 78 10 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3)
      
      if [ $? -ne 0 ] || [ -z "$STORAGE" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
          msg_error "No storage selected. At least one disk is required."
          select_disk_type
        else
          add_more_disks=false
          continue
        fi
      fi
      

    fi

    # Request disk size
    DISK_SIZE=$(whiptail --backtitle "ProxMenuX" --inputbox "$(translate "System Disk Size (GB)")" 8 58 64 --title "VIRTUAL DISK" --cancel-button Cancel 3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ]; then
      if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
        msg_error "Disk size not specified. At least one disk is required."
        sleep 2
        select_disk_type
        
      else
        add_more_disks=false
        continue
      fi
    fi
    
    if [ -z "$DISK_SIZE" ]; then
      DISK_SIZE="64"
    fi

    # Store the configuration in the disk list
    VIRTUAL_DISKS+=("${STORAGE}:${DISK_SIZE}")


    # Ask if you want to create another disk
    if ! whiptail --backtitle "ProxMenuX" --title "$(translate "Add Another Disk")" \
      --yesno "$(translate "Do you want to add another virtual disk?")" 8 58; then
      add_more_disks=false
    fi
  done

  # Show summary of the created disks
  if [ ${#VIRTUAL_DISKS[@]} -gt 0 ]; then

    msg_ok "Virtual Disks Created:"
    for i in "${!VIRTUAL_DISKS[@]}"; do
      echo -e "${TAB}${BL}- Disk $((i+1)): ${VIRTUAL_DISKS[$i]}GB${CL}"
    done
  fi


  export VIRTUAL_DISKS


  select_loader
}

# ==========================================================






# ==========================================================
# Select Physical Disks
# ==========================================================
function select_passthrough_disk() {

  msg_info "$(translate "Detecting available disks...")"

  FREE_DISKS=()

  USED_DISKS=$(lsblk -n -o PKNAME,TYPE | grep 'lvm' | awk '{print "/dev/" $1}')
  MOUNTED_DISKS=$(lsblk -ln -o NAME,MOUNTPOINT | awk '$2!="" {print "/dev/" $1}')

  ZFS_DISKS=""
  ZFS_RAW=$(zpool list -v -H 2>/dev/null | awk '{print $1}' | grep -v '^NAME$' | grep -v '^-' | grep -v '^mirror')

  for entry in $ZFS_RAW; do
      path=""
      if [[ "$entry" == wwn-* || "$entry" == ata-* ]]; then
          if [ -e "/dev/disk/by-id/$entry" ]; then
              path=$(readlink -f "/dev/disk/by-id/$entry")
          fi
      elif [[ "$entry" == /dev/* ]]; then
          path="$entry"
      fi

      if [ -n "$path" ]; then
          base_disk=$(lsblk -no PKNAME "$path" 2>/dev/null)
          if [ -n "$base_disk" ]; then
              ZFS_DISKS+="/dev/$base_disk"$'\n'
          fi
      fi
  done

  ZFS_DISKS=$(echo "$ZFS_DISKS" | sort -u)
  LVM_DEVICES=$(pvs --noheadings -o pv_name 2> >(grep -v 'File descriptor .* leaked') | xargs -n1 readlink -f | sort -u)

  RAID_ACTIVE=$(grep -Po 'md\d+\s*:\s*active\s+raid[0-9]+' /proc/mdstat | awk '{print $1}' | sort -u)

  while read -r DISK; do
      [[ "$DISK" =~ /dev/zd ]] && continue

      INFO=($(lsblk -dn -o MODEL,SIZE "$DISK"))
      MODEL="${INFO[@]::${#INFO[@]}-1}"
      SIZE="${INFO[-1]}"
      LABEL=""
      SHOW_DISK=true

      IS_MOUNTED=false
      IS_RAID=false
      IS_ZFS=false
      IS_LVM=false

      while read -r part fstype; do
          [[ "$fstype" == "zfs_member" ]] && IS_ZFS=true
          [[ "$fstype" == "linux_raid_member" ]] && IS_RAID=true
          [[ "$fstype" == "LVM2_member" ]] && IS_LVM=true
          if grep -q "/dev/$part" <<< "$MOUNTED_DISKS"; then
              IS_MOUNTED=true
          fi
      done < <(lsblk -ln -o NAME,FSTYPE "$DISK" | tail -n +2)

      REAL_PATH=$(readlink -f "$DISK")
      if echo "$LVM_DEVICES" | grep -qFx "$REAL_PATH"; then
          IS_MOUNTED=true
      fi

      USED_BY=""
      REAL_PATH=$(readlink -f "$DISK")
      CONFIG_DATA=$(cat /etc/pve/qemu-server/*.conf /etc/pve/lxc/*.conf 2>/dev/null)

      if grep -Fq "$REAL_PATH" <<< "$CONFIG_DATA"; then
          USED_BY="âš  $(translate "In use")"
      else
          for SYMLINK in /dev/disk/by-id/*; do
              if [[ "$(readlink -f "$SYMLINK")" == "$REAL_PATH" ]]; then
                  if grep -Fq "$SYMLINK" <<< "$CONFIG_DATA"; then
                      USED_BY="âš  $(translate "In use")"
                      break
                  fi
              fi
          done
      fi

      if $IS_RAID && grep -q "$DISK" <<< "$(cat /proc/mdstat)" && grep -q "active raid" /proc/mdstat; then
          SHOW_DISK=false
      fi

      if $IS_ZFS || $IS_MOUNTED || [[ "$ZFS_DISKS" == *"$DISK"* ]]; then
          SHOW_DISK=false
      fi

      if $SHOW_DISK; then
        [[ -n "$USED_BY" ]] && LABEL+=" [$USED_BY]"
        [[ "$IS_RAID" == true ]] && LABEL+=" âš  RAID"
        [[ "$IS_LVM" == true ]] && LABEL+=" âš  LVM"
        [[ "$IS_ZFS" == true ]] && LABEL+=" âš  ZFS"
          DESCRIPTION=$(printf "%-30s %10s%s" "$MODEL" "$SIZE" "$LABEL")
          FREE_DISKS+=("$DISK" "$DESCRIPTION" "OFF")
      fi
  done < <(lsblk -dn -e 7,11 -o PATH)


  if [ "${#FREE_DISKS[@]}" -eq 0 ]; then
    cleanup
    whiptail --title "Error" --msgbox "$(translate "No disks available for this VM.")" 8 40
    select_disk_type
    return
  fi

  MAX_WIDTH=$(printf "%s\n" "${FREE_DISKS[@]}" | awk '{print length}' | sort -nr | head -n1)
  TOTAL_WIDTH=$((MAX_WIDTH + 20)) 
  [ $TOTAL_WIDTH -lt 50 ] && TOTAL_WIDTH=50
  cleanup
  SELECTED_DISKS=$(whiptail --title "Select Disks" --checklist \
    "$(translate "Select the disks you want to use (use spacebar to select):")" 20 $TOTAL_WIDTH 10 \
    "${FREE_DISKS[@]}" 3>&1 1>&2 2>&3)

  if [ -z "$SELECTED_DISKS" ]; then
    msg_error "Disk not specified. At least one disk is required."
    sleep 2
    select_disk_type
    return
  fi


  msg_ok "Disk passthrough selected:"
  PASSTHROUGH_DISKS=()
  for DISK in $(echo "$SELECTED_DISKS" | tr -d '"'); do
    DISK_INFO=$(lsblk -ndo MODEL,SIZE "$DISK" | xargs)
    echo -e "${TAB}${CL}${BL}- $DISK $DISK_INFO${GN}${CL}"
    PASSTHROUGH_DISKS+=("$DISK")
  done

  
  select_loader
}
# ==========================================================






# ==========================================================
# Select Loader
# ==========================================================
function select_loader() {
  # Ensure the images directory exists
  if [ ! -d "$IMAGES_DIR" ]; then
    msg_info "Creating images directory"
    mkdir -p "$IMAGES_DIR"
    chmod 755 "$IMAGES_DIR"
    msg_ok "Images directory created: $IMAGES_DIR"
  fi

  # Create the loader selection menu for ZimaOS
  LOADER_OPTION=$(whiptail --backtitle "ProxMenuX" --title "SELECT ZIMAOS IMAGE" --menu "$(translate "Choose ZimaOS image option:")" 15 70 4 \
    "1" "Download Latest ZimaOS Release" \
    "2" "Use Existing ZimaOS Image" \
    3>&1 1>&2 2>&3)

  if [ -z "$LOADER_OPTION" ]; then
    exit_script
  fi

  case $LOADER_OPTION in
    1)
      LOADER_TYPE="latest"
      LOADER_NAME="ZimaOS Latest"
      LOADER_URL="https://github.com/IceWhaleTech/ZimaOS/"
      echo -e "${DGN}${TAB}Selected: ${BGN}$LOADER_NAME${CL}"
      download_loader
      ;;
    2)
      LOADER_TYPE="existing"
      LOADER_NAME="ZimaOS"
      LOADER_URL="https://github.com/IceWhaleTech/ZimaOS/"
      echo -e "${DGN}${TAB}Selected: ${BGN}$LOADER_NAME${CL}"
      select_custom_image
      ;;
  esac
}


function select_custom_image() {
  # Check if there are any images in the directory
  IMAGES=$(find "$IMAGES_DIR" -type f -name "*.img" -o -name "*.iso" -o -name "*.qcow2" -o -name "*.vmdk" | sort)
  
  if [ -z "$IMAGES" ]; then
    whiptail --title "$(translate "No Images Found")" --msgbox "No compatible images found in $IMAGES_DIR\n\nSupported formats: .img, .iso, .qcow2, .vmdk\n\nPlease add some images and try again." 15 70
    select_loader
  fi
  
  # Create an array of image options for whiptail
  IMAGE_OPTIONS=()

  while read -r img; do
    filename=$(basename "$img")
    filesize=$(du -h "$img" | cut -f1)
    IMAGE_OPTIONS+=("$img" "$filesize")
  done <<< "$IMAGES"
  
  # Let the user select an image
  LOADER_FILE=$(whiptail --backtitle "ProxMenuX" --title "SELECT ZimaOS IMAGE" --menu "$(translate "Choose a ZimaOS image:")" 20 70 10 "${IMAGE_OPTIONS[@]}" 3>&1 1>&2 2>&3)
  
  if [ -z "$LOADER_FILE" ]; then
    msg_error "No ZimaOS image selected"
    exit_script
  fi
  
  echo -e "${DGN}${TAB}Using ZimaOS Image: ${BGN}$(basename "$LOADER_FILE")${CL}"
  FILE=$(basename "$LOADER_FILE")
}



# ==========================================================



function download_loader_() {
  echo -e "${DGN}${TAB}Retrieving ZimaOS image${CL}"

  case $LOADER_TYPE in
    latest)
      
      # Get the latest release download URL
      DOWNLOAD_URL=$(curl -s https://api.github.com/repos/IceWhaleTech/ZimaOS/releases/latest \
        | grep "browser_download_url.*\.img" \
        | cut -d '"' -f 4 \
        | head -1)
      
      if [ -z "$DOWNLOAD_URL" ]; then
        msg_error "Failed to get latest ZimaOS release URL"
        sleep 2
        select_loader
        return
      fi
      
      # Extract filename from URL
      FILE=$(basename "$DOWNLOAD_URL")
      LOADER_FILE="$IMAGES_DIR/$FILE"
      
      # Check if file already exists
      if [ -f "$LOADER_FILE" ]; then
        if whiptail --backtitle "ProxMenuX" --title "FILE EXISTS" --yesno "$(translate "ZimaOS image already exists: $FILE\n\nDo you want to re-download it?")" 10 70; then
          rm -f "$LOADER_FILE"
        else
          echo -e "${DGN}${TAB}Using existing file: ${BGN}$FILE${CL}"
          return
        fi
      fi
      
      if wget -q --show-progress -O "$LOADER_FILE" "$DOWNLOAD_URL"; then
        msg_ok "Downloaded ZimaOS image successfully: $FILE"
      else
        msg_error "Failed to download ZimaOS image"
        rm -f "$LOADER_FILE"
        sleep 2
        select_loader
        return
      fi
      ;;
  esac
  
  # Verify the downloaded file
  if [ -f "$LOADER_FILE" ] && [ -s "$LOADER_FILE" ]; then
    echo -e "${DGN}${TAB}ZimaOS Image: ${BGN}$FILE${CL}"
    echo -e "${DGN}${TAB}File Size: ${BGN}$(du -h "$LOADER_FILE" | cut -f1)${CL}"
  else
    msg_error "Downloaded file is empty or corrupted"
    rm -f "$LOADER_FILE"
    sleep 2
    select_loader
  fi
}





function download_loader() {
  echo -e "${DGN}${TAB}Retrieving ZimaOS image${CL}"


  API_URL="https://api.github.com/repos/IceWhaleTech/ZimaOS/releases/latest"


  DOWNLOAD_URL=$(curl -fsSL "$API_URL" \
    | grep -Eo '"browser_download_url":\s*"[^"]*zimaos-x86_64-[^"]*_installer\.img"' \
    | head -1 \
    | cut -d '"' -f 4)


#  if [[ -z "$DOWNLOAD_URL" ]]; then
#    TAG=$(curl -fsSL "$API_URL" | grep -Eo '"tag_name":\s*"[^"]+"' | cut -d '"' -f 4 | head -1)
#    if [[ -n "$TAG" ]]; then
#      DOWNLOAD_URL="https://github.com/IceWhaleTech/ZimaOS/releases/download/${TAG}/zimaos-x86_64-${TAG}_installer.img"
#    fi
#  fi

  if [[ -z "$DOWNLOAD_URL" ]]; then
    msg_error "Failed to get latest ZimaOS release URL"
    sleep 2; select_loader; return
  fi

  FILE="$(basename "$DOWNLOAD_URL")"
  LOADER_FILE="$IMAGES_DIR/$FILE"


  if [[ -f "$LOADER_FILE" ]]; then
    if whiptail --backtitle "ProxMenuX" --title "FILE EXISTS" \
      --yesno "$(translate "ZimaOS image already exists: $FILE\n\nDo you want to re-download it?")" 10 70; then
      rm -f "$LOADER_FILE"
    else
      echo -e "${DGN}${TAB}Using existing file: ${BGN}$FILE${CL}"
      echo -e "${DGN}${TAB}ZimaOS Image: ${BGN}$FILE${CL}"
      echo -e "${DGN}${TAB}File Size: ${BGN}$(du -h "$LOADER_FILE" | cut -f1)${CL}"
      return
    fi
  fi


  if ! curl -fL --retry 3 --retry-delay 2 --retry-connrefused \
        --progress-bar -o "$LOADER_FILE" "$DOWNLOAD_URL"; then
    msg_error "Failed to download ZimaOS image"
    rm -f "$LOADER_FILE"
    sleep 2; select_loader; return
  fi


  if [[ ! -s "$LOADER_FILE" ]] || [[ $(stat -c%s "$LOADER_FILE") -lt $((100*1024*1024)) ]]; then
    msg_error "Downloaded file is empty or unexpectedly small"
    rm -f "$LOADER_FILE"
    sleep 2; select_loader; return
  fi

  msg_ok "Downloaded ZimaOS image successfully: $FILE"
  echo -e "${DGN}${TAB}ZimaOS Image: ${BGN}$FILE${CL}"
  echo -e "${DGN}${TAB}File Size: ${BGN}$(du -h "$LOADER_FILE" | cut -f1)${CL}"
}


# ==========================================================





# ==========================================================
# Select UEFI Storage 
# ==========================================================
function select_efi_storage() {
  local vmid=$1
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location for EFI disk."

  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}

  else
    kill $SPINNER_PID > /dev/null
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "EFI Disk Storage" --radiolist \
        "$(translate "Choose the storage volume for the EFI disk (4MB):\n\nUse Spacebar to select.")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit 

    done

  fi
  
  echo "$STORAGE"
}
# ==========================================================





# ==========================================================
# Select Storage Loader 
# ==========================================================
function select_storage_volume() {
  local vmid=$1
  local purpose=$2
  local STORAGE=""

  STORAGE_MENU=()

  while read -r line; do
    TAG=$(echo $line | awk '{print $1}')
    TYPE=$(echo $line | awk '{printf "%-10s", $2}')
    FREE=$(echo $line | numfmt --field 4-6 --from-unit=K --to=iec --format "%.2f" | awk '{printf( "%9sB", $6)}')
    
    ITEM="  Type: $TYPE Free: $FREE"
    OFFSET=2
    if [[ $((${#ITEM} + $OFFSET)) -gt ${MSG_MAX_LENGTH:-} ]]; then
      MSG_MAX_LENGTH=$((${#ITEM} + $OFFSET))
    fi

    STORAGE_MENU+=("$TAG" "$ITEM" "OFF")
  done < <(pvesm status -content images | awk 'NR>1')

  VALID=$(pvesm status -content images | awk 'NR>1')
  if [ -z "$VALID" ]; then
    msg_error "Unable to detect a valid storage location."
    exit 1
  elif [ $((${#STORAGE_MENU[@]} / 3)) -eq 1 ]; then
    STORAGE=${STORAGE_MENU[0]}
  else
    while [ -z "${STORAGE:+x}" ]; do
      STORAGE=$(whiptail --backtitle "ProxMenuX" --title "Storage Pools" --radiolist \
        "$(translate "Choose the storage volume for $purpose:")" \
        16 $(($MSG_MAX_LENGTH + 23)) 6 \
        "${STORAGE_MENU[@]}" 3>&1 1>&2 2>&3) || exit
    done
  fi
  
  echo "$STORAGE"
}





# ==========================================================
# Create VM
# ==========================================================
function create_vm() {

  # Create the VM
  qm create $VMID -agent 1${MACHINE} -tablet 0 -localtime 1${BIOS_TYPE}${CPU_TYPE} -cores $CORE_COUNT -memory $RAM_SIZE \
    -name $HN -tags proxmenux -net0 virtio,bridge=$BRG,macaddr=$MAC$VLAN$MTU -onboot 1 -ostype l26 -scsihw virtio-scsi-pci \
    -serial0 socket
  msg_ok "Create a $NAME"

  BOOT_ORDER_LIST=()  # Array to store boot order for all disks

  # Check if UEFI (OVMF) is being used ===================
  if [[ "$BIOS_TYPE" == *"ovmf"* ]]; then

    msg_info "Configuring EFI disk"
    EFI_STORAGE=$(select_efi_storage $VMID)
    EFI_DISK_NAME="vm-${VMID}-disk-efivars"
    
    # Determine storage type and extension
    STORAGE_TYPE=$(pvesm status -storage $EFI_STORAGE | awk 'NR>1 {print $2}')
    case $STORAGE_TYPE in
      nfs | dir)
        EFI_DISK_EXT=".raw"
        EFI_DISK_REF="$VMID/"
        ;;
      *)
        EFI_DISK_EXT=""
        EFI_DISK_REF=""
        ;;
    esac
    
    STORAGE_TYPE=$(pvesm status -storage "$EFI_STORAGE" | awk 'NR>1 {print $2}')
    EFI_DISK_ID="efidisk0"

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:4,efitype=4m,format=raw,pre-enrolled-keys=0" >/dev/null 2>&1; then
            msg_ok "EFI disk created (raw) and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
        else
            msg_error "Failed to configure EFI disk"
            ERROR_FLAG=true
        fi
    else
 
        EFI_DISK_NAME="vm-${VMID}-disk-efivars"
        EFI_DISK_EXT=""
        EFI_DISK_REF=""

        if pvesm alloc "$EFI_STORAGE" "$VMID" "$EFI_DISK_NAME" 4M >/dev/null 2>&1; then
            if qm set "$VMID" -$EFI_DISK_ID "$EFI_STORAGE:${EFI_DISK_NAME},pre-enrolled-keys=0" >/dev/null 2>&1; then
                msg_ok "EFI disk created and configured on ${CL}${BL}$EFI_STORAGE${GN}${CL}"
            else
                msg_error "Failed to configure EFI disk"
                ERROR_FLAG=true
            fi
        else
            msg_error "Failed to create EFI disk"
            ERROR_FLAG=true
        fi
    fi

  fi

# Select storage volume for loader =======================
    LOADER_STORAGE=$(select_storage_volume $VMID "loader disk")
      
    #Run the command in the background and capture its PID
    qm importdisk $VMID ${LOADER_FILE} $LOADER_STORAGE > /tmp/import_log_$VMID.txt 2>&1 &
    import_pid=$!

    # Show a simple progress indicator
    echo -n "Importing loader disk: "
    while kill -0 $import_pid 2>/dev/null; do
        echo -n "."
        sleep 2.5
    done

    wait $import_pid
    rm -f /tmp/import_log_$VMID.txt

    IMPORTED_DISK=$(qm config $VMID | grep -E 'unused[0-9]+' | tail -1 | cut -d: -f1)

    # If the disk was not imported correctly, show an error message but continue
    if [ -z "$IMPORTED_DISK" ]; then
          msg_error "Loader import failed. No disk detected."
          ERROR_FLAG=true
      else
          msg_ok "Loader imported successfully to ${CL}${BL}$LOADER_STORAGE${GN}${CL}"
    fi

    STORAGE_TYPE=$(pvesm status -storage "$LOADER_STORAGE" | awk 'NR>1 {print $2}')

    if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then

        UNUSED_LINE=$(qm config "$VMID" | grep -E '^unused[0-9]+:')
        IMPORTED_ID=$(echo "$UNUSED_LINE" | cut -d: -f1)
        IMPORTED_REF=$(echo "$UNUSED_LINE" | cut -d: -f2- | xargs)

        if [[ -n "$IMPORTED_REF" && -n "$IMPORTED_ID" ]]; then
            if qm set "$VMID" -ide0 "$IMPORTED_REF" >/dev/null 2>&1; then
                msg_ok "Configured loader disk as ide0"
            else
                msg_error "Failed to assign loader disk"
                ERROR_FLAG=true
            fi
        else
            msg_error "Loader import failed. No disk detected in config."
            ERROR_FLAG=true
        fi
    else

        DISK_NAME="vm-${VMID}-disk-0"
        if qm set "$VMID" -ide0 "$LOADER_STORAGE:${DISK_NAME}" >/dev/null 2>&1; then
            msg_ok "Configured loader disk as ide0"
        else
            msg_error "Failed to assign loader disk"
            ERROR_FLAG=true
        fi
    fi

    if [ "$DISK_TYPE" = "virtual" ]; then
        if [ ${#VIRTUAL_DISKS[@]} -eq 0 ]; then
            msg_error "No virtual disks configured."
            exit_script
        fi

        DISK_INFO=""
        CONSOLE_DISK_INFO=""

        for i in "${!VIRTUAL_DISKS[@]}"; do
            IFS=':' read -r STORAGE SIZE <<< "${VIRTUAL_DISKS[$i]}"
            
            STORAGE_TYPE=$(pvesm status -storage $STORAGE | awk 'NR>1 {print $2}')
            case $STORAGE_TYPE in
                nfs | dir)
                    DISK_EXT=".raw"
                    DISK_REF="$VMID/"
                    ;;
                *)
                    DISK_EXT=""
                    DISK_REF=""
                    ;;
            esac
            
            DISK_NUM=$((i+1))
            DISK_NAME="vm-${VMID}-disk-${DISK_NUM}${DISK_EXT}"
            INTERFACE_ID="${INTERFACE_TYPE}$i"
            
            # Create virtual disk
            if [[ "$STORAGE_TYPE" == "btrfs" || "$STORAGE_TYPE" == "dir" || "$STORAGE_TYPE" == "nfs" ]]; then
            
              msg_info "Creating virtual disk (format=raw) for $STORAGE_TYPE..."
              if ! qm set "$VMID" -$INTERFACE_ID "$STORAGE:$SIZE,format=raw$DISCARD_OPTS" >/dev/null 2>&1; then
                msg_error "Failed to assign disk $DISK_NUM ($INTERFACE_ID) on $STORAGE"
                ERROR_FLAG=true
                continue
              fi
            else

              msg_info "Allocating virtual disk for $STORAGE_TYPE..."
              if ! pvesm alloc "$STORAGE" "$VMID" "$DISK_NAME" "$SIZE"G >/dev/null 2>&1; then
                msg_error "Failed to allocate virtual disk $DISK_NUM"
                ERROR_FLAG=true
                continue
              fi
              if ! qm set "$VMID" -$INTERFACE_ID "$STORAGE:${DISK_REF}$DISK_NAME$DISCARD_OPTS" >/dev/null 2>&1; then
                msg_error "Failed to configure virtual disk as $INTERFACE_ID"
                ERROR_FLAG=true
                continue
              fi
            fi

            msg_ok "Configured virtual disk as $INTERFACE_ID, ${SIZE}GB on ${CL}${BL}$STORAGE${CL} ${GN}"

            BOOT_ORDER_LIST+=("$INTERFACE_ID")
            
            # Add information to the description
            DISK_INFO="${DISK_INFO}<p>Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} (${INTERFACE_TYPE}${i})</p>"
            CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Virtual Disk $DISK_NUM: ${SIZE}GB on ${STORAGE} ($INTERFACE_ID)\n"
        done


    # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>ZimaOS VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'>$LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/zimaos.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Installer-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"
    
    msg_info "Setting VM description"
    if ! qm set "$VMID" -description "$HTML_DESC" >/dev/null 2>&1; then
        msg_error "Failed to set VM description"
        exit_script
    fi
    msg_ok "Configured VM description"



    elif [ "$DISK_TYPE" = "passthrough" ]; then
        if [ ${#PASSTHROUGH_DISKS[@]} -eq 0 ]; then
            msg_error "No passthrough disks configured."
            exit_script
        fi

        DISK_INFO=""
        CONSOLE_DISK_INFO=""

        for i in "${!PASSTHROUGH_DISKS[@]}"; do
            DISK="${PASSTHROUGH_DISKS[$i]}"
            INTERFACE_ID="${INTERFACE_TYPE}$i"
            
            # Get disk information
            MODEL=$(lsblk -ndo MODEL "$DISK" 2>/dev/null || echo "Unknown")
            SIZE=$(lsblk -ndo SIZE "$DISK" 2>/dev/null || echo "Unknown")
            
            # Configure passthrough disk
            if qm set "$VMID" -$INTERFACE_ID "$DISK$DISCARD_OPTS" >/dev/null 2>&1; then
                msg_ok "Configured passthrough disk as $INTERFACE_ID: $DISK ($MODEL $SIZE)"
                BOOT_ORDER_LIST+=("$INTERFACE_ID")
                
                # Add information to the description
                DISK_INFO="${DISK_INFO}<p>Passthrough Disk $((i+1)): $DISK ($MODEL $SIZE) (${INTERFACE_TYPE}${i})</p>"
                CONSOLE_DISK_INFO="${CONSOLE_DISK_INFO}- Passthrough Disk $((i+1)): $DISK ($MODEL $SIZE) ($INTERFACE_ID)\n"
            else
                msg_error "Failed to configure passthrough disk $DISK as $INTERFACE_ID"
                ERROR_FLAG=true
            fi
        done


      # HTML description
HTML_DESC="<div align='center'>
<table style='width: 100%; border-collapse: collapse;'>
<tr>
<td style='width: 100px; vertical-align: middle;'>
<img src='https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo_desc.png' alt='ProxMenux Logo' style='height: 100px;'>
</td>
<td style='vertical-align: middle;'>
<h1 style='margin: 0;'>ZimaOS VM</h1>
<p style='margin: 0;'>Created with ProxMenuX</p>
<p style='margin: 0;'$LOADER_NAME</p>
</td>
</tr>
</table>

<p>
<a href='https://macrimi.github.io/ProxMenux/' target='_blank'><img src='https://img.shields.io/badge/ğŸ“š_Docs-blue' alt='Docs'></a>
<a href='https://raw.githubusercontent.com/MacRimi/ProxMenux/refs/heads/main/scripts/vm/zimaos.sh' target='_blank'><img src='https://img.shields.io/badge/ğŸ’»_Code-green' alt='Code'></a>
<a href='$LOADER_URL' target='_blank'><img src='https://img.shields.io/badge/ğŸ“¦_Installer-orange' alt='Loader'></a>
<a href='https://ko-fi.com/macrimi' target='_blank'><img src='https://img.shields.io/badge/â˜•_Ko--fi-red' alt='Ko-fi'></a>
</p>

<div>
${DISK_INFO}
</div>
</div>"


      result=$(qm set $VMID -description "$HTML_DESC" 2>&1)
      if [[ $? -eq 0 ]]; then
         msg_ok "Configured VM description"
      fi


    fi





    if [ ${#BOOT_ORDER_LIST[@]} -gt 0 ]; then
        BOOT_ORDER_LIST+=("ide0")  # Add IDE installer as last boot option
        BOOT_ORDER_STRING=$(IFS=';'; echo "${BOOT_ORDER_LIST[*]}")
        
        if qm set "$VMID" -boot order="$BOOT_ORDER_STRING" >/dev/null 2>&1; then
            msg_ok "Boot order configured: $BOOT_ORDER_STRING"
        else
            msg_error "Failed to configure boot order"
            ERROR_FLAG=true
        fi
    fi


if [ "$ERROR_FLAG" = true ]; then
   msg_error "VM created with errors. Check configuration." 
else
  msg_success "$(translate "Completed Successfully!")"

  echo -e "${TAB}${GN}$(translate "Next Steps:")${CL}"
  echo -e "${TAB}1. $(translate "Start the VM")"
  echo -e "${TAB}2. $(translate "Open the VM console and wait for the installer to boot")"
  echo -e "${TAB}3. $(translate "Complete the ZimaOS installation wizard")"
  echo -e


fi


}

# ==========================================================


header_info
sleep 1


if whiptail --backtitle "ProxMenuX" --title "$NAME" --yesno "$(translate "This will create a New $NAME. Proceed?")" 10 58; then
  start_script
else
  clear
  exit
fi


create_vm

# ==========================================================



================================================
FILE: web/components.json
================================================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}


================================================
FILE: web/next.config.mjs
================================================
import { fileURLToPath } from 'url'
import { dirname, join } from 'path'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

/** @type {import('next').NextConfig} */
const nextConfig = {
  output: "export",
  images: {
    unoptimized: true,
    remotePatterns: [
      {
        protocol: "https",
        hostname: "raw.githubusercontent.com",
        pathname: "/MacRimi/ProxMenux/main/images/**",
      },
    ],
  },
  assetPrefix: "/ProxMenux/",
  basePath: "/ProxMenux",
  staticPageGenerationTimeout: 180,
  webpack: (config, { isServer }) => {
    config.resolve.alias["@guides"] = join(__dirname, "..", "guides")
    config.resolve.alias["@changelog"] = join(__dirname, "..", "CHANGELOG.md")
    return config
  },
}

export default nextConfig



================================================
FILE: web/package.json
================================================
{
  "name": "my-v0-project",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-accordion": "^1.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-aspect-ratio": "^1.1.1",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-collapsible": "^1.1.2",
    "@radix-ui/react-context-menu": "^2.2.4",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-hover-card": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-menubar": "^1.1.4",
    "@radix-ui/react-navigation-menu": "^1.2.3",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-progress": "^1.1.1",
    "@radix-ui/react-radio-group": "^1.2.2",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "latest",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-toast": "^1.2.4",
    "@radix-ui/react-toggle": "^1.1.1",
    "@radix-ui/react-toggle-group": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.6",
    "autoprefixer": "^10.4.20",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "1.0.4",
    "date-fns": "^2.30.0",
    "embla-carousel-react": "8.5.1",
    "input-otp": "1.4.1",
    "lucide-react": "^0.454.0",
    "next": "14.2.16",
    "next-themes": "^0.4.4",
    "react": "^18",
    "react-dom": "^18",
    "react-day-picker": "^8.10.1",
    "react-hook-form": "^7.54.1",
    "react-resizable-panels": "^2.1.7",
    "recharts": "2.15.0",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.6",
    "zod": "^3.24.1",
    "fs": "latest",
    "path": "latest",
    "remark": "latest",
    "remark-html": "latest",
    "react-markdown": "^9.0.0",
    "remark-gfm": "^4.0.0",
    "unified": "^11.0.0",
    "remark-breaks": "3.0.0",
    "gray-matter": "^4.0.3",
    "html-react-parser": "^3.0.0"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.10",
    "@types/node": "^22",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
  }
}



================================================
FILE: web/postcss.config.mjs
================================================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;



================================================
FILE: web/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
      typography: (theme) => ({
        DEFAULT: {
          css: {
            color: theme("colors.foreground"),
            a: {
              color: theme("colors.primary.DEFAULT"),
              "&:hover": {
                color: theme("colors.primary.DEFAULT"),
              },
            },
            h1: {
              color: theme("colors.foreground"),
            },
            h2: {
              color: theme("colors.foreground"),
            },
            h3: {
              color: theme("colors.foreground"),
            },
            strong: {
              color: theme("colors.foreground"),
            },
            code: {
              color: theme("colors.foreground"),
            },
            figcaption: {
              color: theme("colors.muted.foreground"),
            },
          },
        },
      }),
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
}




================================================
FILE: web/tsconfig.json
================================================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "target": "ES6",
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================
FILE: web/app/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5.9% 10%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


.prose pre {
  background-color: #f3f4f6; 
  color: #1f2937; 
  padding: 1rem;
  border-radius: 0.5rem;
  overflow-x: auto; 
}


.prose p code,
.prose li code,
.prose td code {
  background-color: #f3f4f6; 
  color: #1f2937; 
  padding: 0.2em 0.4em;
  border-radius: 0.25rem; 
}


.prose code {
  color: #1f2937;
}


button code {
  background-color: transparent;
  color: inherit;
  padding: 0;
  font-weight: normal;
}


.prose {
  color: #1f2937; 
}


.prose h1,
.prose h2,
.prose h3,
.prose h4,
.prose h5,
.prose h6 {
  color: #111827; 
}


.prose strong,
.prose b {
  color: #111827; 
  font-weight: 700; 
}

.prose code::before,
.prose code::after {
  content: "" !important; 
}

.prose a {
  color: #0969da; 
  font-weight: 500;
  text-decoration: none;
}

.prose a:hover {
  color: #0550ae; 
  text-decoration: underline;
}

* {
  border-color: white;
}



================================================
FILE: web/app/layout.tsx
================================================
import "./globals.css"
import { Inter } from "next/font/google"
import Navbar from "@/components/navbar"
import MouseMoveEffect from "@/components/mouse-move-effect"
import type React from "react"

const inter = Inter({ subsets: ["latin"] })

export const metadata = {
  title: "ProxMenux",
  generator: "Next.js",
  applicationName: "ProxMenux",
  referrer: "origin-when-cross-origin",
  keywords: ["Proxmox VE", "VE", "ProxMenux", "MacRimi", "menu-driven", "menu", "scripts", "virtualization"],
  authors: [{ name: "MacRimi" }],
  creator: "MacRimi",
  publisher: "MacRimi",
  description:
    "A menu-driven script for Proxmox VE management, designed to simplify and streamline the execution of commands and tasks.",
  formatDetection: {
    email: false,
    address: false,
    telephone: false,
  },
  metadataBase: new URL(`https://macrimi.github.io/ProxMenux/`),
  openGraph: {
    title: "ProxMenux",
    description:
      "A menu-driven script for Proxmox VE management, designed to simplify and streamline the execution of commands and tasks.",
    url: "https://macrimi.github.io/ProxMenux/",
    siteName: "ProxMenux",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/main.png",
        width: 1363,
        height: 735,
        alt: "ProxMenux",
      },
    ],
    locale: "en_US",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux",
    description:
      "A menu-driven script for Proxmox VE management, designed to simplify and streamline the execution of commands and tasks.",
    images: ["https://macrimi.github.io/ProxMenux/main.png"],
  },
  icons: {
    icon: [
      { url: "https://macrimi.github.io/ProxMenux/favicon.ico", sizes: "any" },
      { url: "https://macrimi.github.io/ProxMenux/icon.svg", type: "image/svg+xml" },
    ],
    apple: [{ url: "https://macrimi.github.io/ProxMenux/apple-touch-icon.png", sizes: "180x180" } as const],
  },
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className="dark">
      <head>
        <meta name="description" content={metadata.description} />
        <meta property="og:title" content={metadata.openGraph?.title} />
        <meta property="og:description" content={metadata.openGraph?.description} />
        <meta property="og:image" content={metadata.openGraph?.images?.[0]?.url} />
        <meta property="og:url" content={metadata.openGraph?.url} />
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content={metadata.twitter?.title} />
        <meta name="twitter:description" content={metadata.twitter?.description} />
        <meta name="twitter:image" content={metadata.twitter?.images?.[0]} />
        <link rel="canonical" href={metadata.metadataBase.href} />

        {/* Favicon y Apple Icons */}
        {metadata.icons.icon.map((icon, index) => (
          <link key={index} rel="icon" type={icon.type} sizes={icon.sizes} href={icon.url} />
        ))}
        {metadata.icons.apple.map((icon, index) => (
          <link key={index} rel="apple-touch-icon" sizes={icon.sizes} href={icon.url} />
        ))}
      </head>
      <body className={`${inter.className} bg-background text-foreground antialiased`}>
        <Navbar />
        <MouseMoveEffect />
        <div className="pt-16 md:pt-16">{children}</div>
      </body>
    </html>
  )
}



================================================
FILE: web/app/metadata.ts
================================================
import type { Metadata } from 'next'



const description = "A menu-driven script for Proxmox VE management, designed to simplify and streamline the execution of commands and tasks."

export const metadata: Metadata = {

  title: "ProxMenux",
  description,
  generator: "Next.js",
  applicationName: "ProxMenux",
  referrer: "origin-when-cross-origin",
  keywords: ["Proxmox VE", "VE", "ProxMenux", "MacRimi", "menu-driven", "menu", "scripts", "virtualization"],
  authors: [{ name: "MacRimi" }],
  creator: "MacRimi",
  publisher: "MacRimi",
  formatDetection: {
    email: false,
    address: false,
    telephone: false,
  },
  metadataBase: new URL(`https://macrimi.github.io/ProxMenux/`),
  openGraph: {
    title: "ProxMenux",
    description,
    url: `https://macrimi.github.io/ProxMenux/`,
    siteName: "ProxMenux",
    images: [
      {
        url: `https://raw.githubusercontent.com/MacRimi/ProxMenux/main/web/public/main.png`,
        width: 1363,
        height: 735,
      },
    ],
    locale: "en_US",
    type: "website",
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux",
    description,
    images: [`https://raw.githubusercontent.com/MacRimi/ProxMenux/main/web/public/main.png`],
  },
  icons: {
    icon: [
      { url: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/web/public/favicon.ico", sizes: "any" },
      { url: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/web/public/icon.svg", type: "image/svg+xml" },
    ],
    apple: [{ url: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/web/public//apple-touch-icon.png" }],
  },
}


================================================
FILE: web/app/page.tsx
================================================
import Hero2 from "@/components/hero2"
import Resources from "@/components/resources"
import SupportProject from "@/components/support-project"
import Footer from "@/components/footer"


export default function Home() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 to-gray-800 text-white pt-16">
      <Hero2 />
      <Resources />
      <SupportProject />
      <Footer />
    </div>
  )
}



================================================
FILE: web/app/changelog/page.tsx
================================================
import fs from "fs"
import path from "path"
import { remark } from "remark"
import html from "remark-html"
import * as gfm from "remark-gfm"
import dynamic from "next/dynamic"
import parse from "html-react-parser"
import Footer from "@/components/footer"
import RSSLink from "@/components/rss-link"


const CopyableCode = dynamic(() => import("@/components/CopyableCode"), { ssr: false })

async function getChangelogContent() {
  try {
    const changelogPath = path.join(process.cwd(), "..", "CHANGELOG.md")

    if (!fs.existsSync(changelogPath)) {
      console.error("âŒ CHANGELOG.md file not found.")
      return "<p class='text-red-600'>Error: CHANGELOG.md file not found</p>"
    }

    const fileContents = fs.readFileSync(changelogPath, "utf8")

    // Add remark-gfm to support images, tables and other advanced Markdown elements
    const result = await remark()
      .use(gfm.default || gfm) // Safe handling of remark-gfm
      .use(html)
      .process(fileContents)

    return result.toString()
  } catch (error) {
    console.error("âŒ Error reading CHANGELOG.md file", error)
    return "<p class='text-red-600'>Error: Could not load changelog content.</p>"
  }
}

// Clean backticks in inline code fragments
function cleanInlineCode(content: string) {
  return content.replace(/<code>(.*?)<\/code>/g, (_, codeContent) => {
    return `<code class="bg-gray-200 text-gray-900 px-1 rounded">${codeContent.replace(/^`|`$/g, "")}</code>`
  })
}

// Wrap code blocks with CopyableCode component
function wrapCodeBlocksWithCopyable(content: string) {
  return parse(content, {
    replace: (domNode: any) => {
      if (domNode.name === "pre" && domNode.children.length > 0) {
        const codeElement = domNode.children.find((child: any) => child.name === "code")
        if (codeElement) {
          const codeContent = codeElement.children[0]?.data?.trim() || ""
          return <CopyableCode code={codeContent} />
        }
      }
    },
  })
}

export default async function ChangelogPage() {
  const changelogContent = await getChangelogContent()
  const cleanedInlineCode = cleanInlineCode(changelogContent) // First clean inline code
  const parsedContent = wrapCodeBlocksWithCopyable(cleanedInlineCode) // Then apply JSX to code blocks

  return (
    <div className="min-h-screen bg-white text-gray-900">
      <div className="container mx-auto px-4 py-16" style={{ maxWidth: "980px" }}>
        {" "}
        {/* Exact adjustment like GitHub */}
        <h1 className="text-4xl font-bold mb-8">Changelog</h1>
        {/* RSS Link Component */}
        <RSSLink />
        <div className="prose max-w-none text-[16px]">{parsedContent}</div> {/* Text adjusted to 16px */}
      </div>
      <Footer />
    </div>
  )
}



================================================
FILE: web/app/docs/layout.tsx
================================================
import type React from "react"
import DocSidebar from "@/components/DocSidebar"
import Footer from "@/components/footer"
import { DocNavigation } from "@/components/ui/doc-navigation"

export default function DocsLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="flex flex-col min-h-screen bg-white text-gray-900">
      <div className="flex flex-col lg:flex-row flex-1 pt-16 lg:pt-0">
        <DocSidebar />
        <main className="flex-1 p-4 lg:p-6 pt-6 lg:pt-6 overflow-y-auto">
          <div className="max-w-3xl mx-auto" style={{ maxWidth: "980px" }}>
            {children}
            <DocNavigation />
          </div>
        </main>
      </div>
      <Footer />
    </div>
  )
}




================================================
FILE: web/app/docs/about/code-of-conduct/page.tsx
================================================
import fs from "fs"
import path from "path"
import { remark } from "remark"
import html from "remark-html"
import * as gfm from "remark-gfm"
import dynamic from "next/dynamic"
import React from "react"
import parse from "html-react-parser"

const CopyableCode = dynamic(() => import("@/components/CopyableCode"), { ssr: false })

async function getCodeOfConductContent() {
  try {
    const codeOfConductPath = path.join(process.cwd(), "..", "CODE_OF_CONDUCT.md")

  if (!fs.existsSync(codeOfConductPath)) {
    console.error("CODE_OF_CONDUCT.md file not found.");
    return "<p class='text-red-600'>Error: CODE_OF_CONDUCT.md file not found.</p>";
  }
  
  const fileContents = fs.readFileSync(codeOfConductPath, "utf8");
  
  const result = await remark()
    .use(gfm.default || gfm)
    .use(html)
    .process(fileContents);
  
  return result.toString();
  } catch (error) {
    console.error("Error reading the CODE_OF_CONDUCT.md file", error);
    return "<p class='text-red-600'>Error: Unable to load the Code of Conduct content.</p>";
  }    
}

function cleanInlineCode(content: string) {
  return content.replace(/<code>(.*?)<\/code>/g, (_, codeContent) => {
    return `<code class="bg-gray-200 text-gray-900 px-1 rounded">${codeContent.replace(/^`|`$/g, "")}</code>`
  })
}

function wrapCodeBlocksWithCopyable(content: string) {
  return parse(content, {
    replace: (domNode: any) => {
      if (domNode.name === "pre" && domNode.children.length > 0) {
        const codeElement = domNode.children.find((child: any) => child.name === "code")
        if (codeElement) {
          const codeContent = codeElement.children[0]?.data?.trim() || ""
          return <CopyableCode code={codeContent} />
        }
      }
    }
  })
}

export default async function CodeOfConductPage() {
  const codeOfConductContent = await getCodeOfConductContent()
  const cleanedInlineCode = cleanInlineCode(codeOfConductContent)
  const parsedContent = wrapCodeBlocksWithCopyable(cleanedInlineCode)

  return (
    <div className="min-h-screen bg-white text-gray-900">
      <div className="container mx-auto px-4 py-16" style={{ maxWidth: "980px" }}>
        <div className="prose max-w-none text-[16px]">{parsedContent}</div>
      </div>
    </div>
  )
}


================================================
FILE: web/app/docs/about/contributors/page.tsx
================================================
import { Users, FlaskRound, Youtube } from "lucide-react"

export const metadata = {
  title: "ProxMenux Contributors â€“ Meet the Team Behind ProxMenux",
  description: "Meet the contributors who make ProxMenux possible. Learn more about the developers, testers, and designers who have contributed to the project.",
  openGraph: {
    title: "ProxMenux Contributors â€“ Meet the Team Behind ProxMenux",
    description: "Meet the contributors who make ProxMenux possible. Learn more about the developers, testers, and designers who have contributed to the project.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/about/contributors",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/contributors-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Contributors",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Contributors â€“ Meet the Team Behind ProxMenux",
    description: "Meet the contributors who make ProxMenux possible. Learn more about the developers, testers, and designers who have contributed to the project.",
    images: ["https://macrimi.github.io/ProxMenux/contributors-image.png"],
  },
};


const contributors = [
  {
    name: "MALOW",
    role: "Testing",
    avatar: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/avatars/malow.png",
  },
  {
    name: "Segarra",
    role: "Testing",
    avatar: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/avatars/segarra.png",
  },
  {
    name: "Aprilia",
    role: "Testing",
    avatar: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/avatars/aprilia.png",
  },
  {
    name: "Jonatan Castro",
    role: "Testing and reviewer",
    avatar: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/avatars/jonatancastro.png",
    youtubeUrl: "https://www.youtube.com/@JonatanCastro",
  },
  {
    name: "Kamunhas",
    role: "Testing",
    avatar: "https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/avatars/Kamunhas.png",
  },
]

export default function Contributors() {
  return (
    <div className="container mx-auto px-4 py-8">
      {/* ğŸ”¹ Icon + Title */}
      <div className="flex items-center justify-center mb-6">
        <Users className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold text-black">Contributors</h1>
      </div>

      {/* ğŸ”¹ Description */}
      <p className="text-lg text-black mb-4 text-left">
        The ProxMenux project grows and thrives thanks to the contribution of its collaborators.
      </p>
      <p className="text-base text-black mb-20">This is the well-deserved recognition of their work:</p>

      {/* ğŸ”¹ Contributors List */}
      <div className="flex justify-center gap-6 flex-wrap">
        {contributors.map((contributor) => (
          <div key={contributor.name} className="text-center">
            <div className="relative inline-block">
              <img
                src={contributor.avatar || "/placeholder.svg"}
                alt={contributor.name}
                className="w-20 h-20 rounded-full border-2 border-gray-300 object-cover"
              />
              <div className="absolute -bottom-1 -right-1 bg-orange-500 rounded-full p-1">
                <FlaskRound className="h-4 w-4 text-white" />
              </div>
            </div>
            <h3 className="text-lg font-bold text-black mt-2">{contributor.name}</h3>
            <p className="text-sm text-black">{contributor.role}</p>
            {contributor.youtubeUrl && (
              <a
                href={contributor.youtubeUrl}
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center mt-1 text-red-600 hover:text-red-700"
              >
                <Youtube className="h-4 w-4 mr-1" />
                <span className="text-xs">YouTube</span>
              </a>
            )}
          </div>
        ))}
      </div>

      {/* ğŸ”¹ Call to Action */}
      <p className="mt-20 text-base text-black text-left">
        Would you like to contribute? You can collaborate as a <strong>tester</strong>, <strong>developer</strong>,{" "}
        <strong>designer</strong>, or by sharing <strong>ideas and suggestions</strong>. Any contribution is welcome!
      </p>
    </div>
  )
}



================================================
FILE: web/app/docs/about/faq/page.tsx
================================================
import type { Metadata } from "next";
import { HelpCircle } from "lucide-react";
import Link from "next/link";

export const metadata: Metadata = {
  title: "ProxMenux FAQ â€“ Frequently Asked Questions",
  description: "Frequently Asked Questions about ProxMenux, including installation, updates, compatibility, and security.",
  openGraph: {
    title: "ProxMenux FAQ â€“ Frequently Asked Questions",
    description: "Frequently Asked Questions about ProxMenux, including installation, updates, compatibility, and security.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/faq",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/faq-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux FAQ",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux FAQ â€“ Frequently Asked Questions",
    description: "Frequently Asked Questions about ProxMenux, including installation, updates, compatibility, and security.",
    images: ["https://macrimi.github.io/ProxMenux/faq-image.png"],
  },
};

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  );
}

export default function FaqPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <HelpCircle className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Frequently Asked Questions (FAQ)</h1>
      </div>

        {/* 1ï¸âƒ£ What is ProxMenux? */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        What is ProxMenux, and what is it used for?
      </h3>
      <p className="mb-4">
        <strong>ProxMenux</strong> is an interactive menu-driven tool designed to make <strong>Proxmox VE</strong> more accessible  
        to all users, regardless of their technical experience. It simplifies command execution, allowing users to perform  
        actions on their system without requiring advanced Linux knowledge.
      </p>
      <p className="mb-4">
        For less experienced users, <strong>ProxMenux</strong> provides an intuitive way to run commands through a structured  
        menu interface, reducing the need for manual terminal input.
      </p>
      <p className="mb-4">
        Proxmox VE is widely used for:
      </p>
      <ul className="list-disc list-inside mb-4 ml-4">
        <li>Enterprise-grade virtualization</li>
        <li>HomeLab and personal cloud solutions</li>
        <li>Multimedia servers, automation, and more</li>
      </ul>

      {/* 2ï¸âƒ£ Installation */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        How do I install ProxMenux?
      </h3>
      <p className="mb-4">
        Follow the instructions in the{" "}
        <Link href="https://macrimi.github.io/ProxMenux/docs/installation" className="text-blue-500 hover:underline">
          Installation Guide
        </Link>. You can install ProxMenux by running:
      </p>
      <pre className="bg-gray-100 p-4 rounded-md overflow-x-auto text-sm">
        <code>
          bash -c "$(wget -qLO - https://raw.githubusercontent.com/MacRimi/ProxMenux/main/install_proxmenux.sh)"
        </code>
      </pre>
      <p className="mt-4">Once installed, simply start it with:</p>
      <pre className="bg-gray-100 p-4 rounded-md overflow-x-auto text-sm">
        <code>menu</code>
      </pre>

      {/* 3ï¸âƒ£ Compatibility */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Is ProxMenux compatible with all Proxmox versions?
      </h3>
      <p className="mb-4">
        No, <strong>ProxMenux is only compatible with Proxmox VE 8 and later versions.</strong>
      </p>

      {/* 4ï¸âƒ£ Customization */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={4} />
        Can I customize ProxMenux?
      </h3>
      <p className="mb-4">
        The core scripts cannot be modified directly as they are hosted on GitHub. However, users can  
        personalize the <strong>console logo</strong> using the <strong>FastFetch</strong> tool available in the  
        <strong>Post-Install options</strong>.
      </p>

      {/* 5ï¸âƒ£ Updates */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={5} />
        How do I update ProxMenux?
      </h3>
      <p className="mb-4">
        When a new version is available, ProxMenux will automatically detect it upon launch and prompt  
        users to update. If accepted, the update process will replace utility files and configurations.
      </p>

      {/* 6ï¸âƒ£ Reporting Issues */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={6} />
        Where can I report issues?
      </h3>
      <p className="mb-4">
        If you encounter bugs or errors, report them in the{" "}
        <Link href="https://github.com/MacRimi/ProxMenux/issues" className="text-blue-500 hover:underline">
          Issues section
        </Link>.
      </p>
      <p className="mb-4">
        If you find a <strong>security issue</strong>, please <strong>do not publish it</strong>.  
        Instead, review the{" "}
        <Link href="https://github.com/MacRimi/ProxMenux/blob/main/CODE_OF_CONDUCT.md" className="text-blue-500 hover:underline">
          Code of Conduct & Best Practices
        </Link>{" "}
        for guidance on how to proceed.
      </p>

      {/* 7ï¸âƒ£ Contributing */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={7} />
        Can I contribute to ProxMenux?
      </h3>
      <p className="mb-4">
      <strong>Absolutely!</strong>
      </p>
      <p className="mb-4">
        ProxMenux is an open-source and collaborative project where you can contribute by developing  
        new features, opening discussions, or sharing ideas and improvements.
      </p>
      <p className="mb-4">
        Join the{" "}
        <Link href="https://github.com/MacRimi/ProxMenux/discussions" className="text-blue-500 hover:underline">
          Discussions section
        </Link>{" "}
        to share ideas and propose enhancements.
      </p>
      <p className="mb-4">
        Make sure to review the{" "}
        <Link href="https://github.com/MacRimi/ProxMenux/blob/main/CODE_OF_CONDUCT.md" className="text-blue-500 hover:underline">
          Code of Conduct & Best Practices
        </Link>.
      </p>
      <p className="mb-4">
        <strong>All ideas are welcome!</strong>
      </p>

      {/* 8ï¸âƒ£ Modifying System Files */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={8} />
        Does ProxMenux modify critical system files?
      </h3>
      <p className="mb-4">
        No, <strong>ProxMenux does not modify critical Proxmox system files.</strong>  
        It only installs dependencies such as <code className="bg-gray-200 px-1 rounded">whiptail</code>, <code className="bg-gray-200 px-1 rounded">curl</code>,  
        <code className="bg-gray-200 px-1 rounded">jq</code>, and <code className="bg-gray-200 px-1 rounded">Python3</code>, sets up a virtual environment for translations,  
        and downloads its scripts into <code className="bg-gray-200 px-1 rounded">/usr/local/share/proxmenux/</code>.  
        The executable <code className="bg-gray-200 px-1 rounded">menu</code> is placed in <code className="bg-gray-200 px-1 rounded">/usr/local/bin/</code>.  
        ProxMenux does not interfere with Proxmoxâ€™s core operations.
      </p>

      {/* 9ï¸âƒ£ Production Use */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={9} />
        Is it safe to use ProxMenux in production?
      </h3>
      <p className="mb-4">
        Yes, <strong>ProxMenux is safe for production</strong>.  
        Since it does not modify core Proxmox files, it can be used in production environments.  
        However, it is always recommended to test it in a controlled environment first.
      </p>

      {/* ğŸ”Ÿ Uninstallation */}
      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={10} />
        How do I uninstall ProxMenux?
      </h3>
      <p className="mb-4">
        You can uninstall ProxMenux from the <strong>Settings menu</strong> using the <strong>Uninstall ProxMenux</strong> option.  
        Detailed steps can be found in the{" "}
        <Link href="https://macrimi.github.io/ProxMenux/docs/settings/uninstall-proxmenux" className="text-blue-500 hover:underline">
          Uninstall Guide
        </Link>.
      </p>

    </div>
  );
}


================================================
FILE: web/app/docs/create-vm/page.tsx
================================================
import type React from "react"
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowRight, Server, ComputerIcon as Windows, LaptopIcon as Linux, HardDrive, Monitor } from "lucide-react"

export const metadata: Metadata = {
  title: "ProxMenux Documentation: Virtual Machines",
  description:
    "Comprehensive guide for creating and configuring virtual machines on Proxmox VE using ProxMenux, with dedicated sections for NAS, Windows, and Linux systems.",
  openGraph: {
    title: "ProxMenux Documentation: Virtual Machines",
    description:
      "Comprehensive guide for creating and configuring virtual machines on Proxmox VE using ProxMenux, with dedicated sections for NAS, Windows, and Linux systems.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/virtual-machines",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/vm/vm-creation-menu.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Virtual Machines Menu",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: Virtual Machines",
    description:
      "Comprehensive guide for creating and configuring virtual machines on Proxmox VE using ProxMenux, with dedicated sections for NAS, Windows, and Linux systems.",
    images: ["https://macrimi.github.io/ProxMenux/vm/vm-creation-menu.png"],
  },
}

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
  
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg"}
          alt={alt}
          width={768}
          height={0}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function VirtualMachinesPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-10">
        <div className="flex items-center gap-3 mb-6">
          <Server className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Virtual Machines Menu</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides an automated system for creating and configuring virtual machines on Proxmox VE through
            an interactive menu interface. Select one of the categories below to explore the available VM creation
            options.
          </p>

          <p className="text-black">
            Each category contains specialized scripts and configurations designed to simplify the process of creating
            virtual machines for different operating systems and use cases. This eliminates the need to remember complex
            command syntax or manually configure VMs when deploying new systems.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/vm/vm-creation-menu.png"
        alt="Virtual Machines Creation Menu"
        caption="Virtual Machines Creation Menu"
      />

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-6 mt-10">
        <VMCard
          title="System NAS"
          description="Create and configure NAS virtual machines including Synology DSM, TrueNAS, and other storage systems"
          icon={<HardDrive className="h-8 w-8 text-blue-500" />}
          href="/docs/create-vm/system-nas"
        />

        <VMCard
          title="System Windows"
          description="Deploy Windows virtual machines with optimized configurations for Windows"
          icon={<Windows className="h-8 w-8 text-blue-500" />}
          href="/docs/create-vm/system-windows"
        />

        <VMCard
          title="System Linux"
          description="Create Linux virtual machines with configurations for popular distributions like Ubuntu, Debian, and CentOS"
          icon={<Linux className="h-8 w-8 text-blue-500" />}
          href="/docs/create-vm/system-linux"
        />

        <VMCard
          title="Other Linux Systems"
          description="Deploy specialized Linux distributions and configurations for specific use cases"
          icon={<Server className="h-8 w-8 text-blue-500" />}
          href="/docs/create-vm/system-linux#other-linux-systems"
        />


        <VMCard
          title="System macOS"
          description="Easily install macOS on Proxmox VE with just a few steps! This guide provides the simplest and most effective way to set up macOS on Proxmox, whether you're using AMD or Intel hardware. This is an external script; for more information, visit the project's page."
          icon={<Monitor className="h-8 w-8 text-blue-500" />}
          href="https://osx-proxmox.com"
          externalLink 
        />
      </div>
    </div>
  )
}

interface VMCardProps {
  title: string
  description: string
  icon: React.ReactNode
  href: string
  externalLink?: boolean 
}

function VMCard({ title, description, icon, href, externalLink = false }: VMCardProps) {
  return (
    <Card className="transition-all duration-300 hover:shadow-md hover:border-blue-300 bg-white text-black border-2 border-gray-200">
      <CardHeader>
        <div className="flex items-center gap-3">
          {icon}
          <CardTitle className="text-xl text-black">{title}</CardTitle>
        </div>
      </CardHeader>
      <CardContent>
        <CardDescription className="text-base text-gray-600">{description}</CardDescription>
      </CardContent>
      <CardFooter>
        {externalLink ? (
          <a
            href={href}
            target="_blank"
            rel="noopener noreferrer"
            className="flex items-center text-blue-500 hover:text-blue-700 transition-colors"
          >
            View details <ArrowRight className="ml-2 h-4 w-4" />
          </a>
        ) : (
          <Link
            href={href}
            className="flex items-center text-blue-500 hover:text-blue-700 transition-colors"
          >
            View details <ArrowRight className="ml-2 h-4 w-4" />
          </Link>
        )}
      </CardFooter>
    </Card>
  )
}



================================================
FILE: web/app/docs/create-vm/synology/page.tsx
================================================
"use client"

import Image from "next/image"
import {
    Wrench,
    Target,
    CheckCircle,
    Github,
    Server,
    HardDrive,
    Download,
    Settings,
    Cpu,
    Zap,
    Sliders,
  } from "lucide-react"
import { useState } from "react"

export default function Page() {
  const [activeLoader, setActiveLoader] = useState("arc")

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">Synology VM Creator Script</h1>

      <section className="mb-10">
        <h2 className="text-2xl font-semibold mb-4 flex items-center">
          <Server className="h-6 w-6 mr-2 text-blue-500" />
          Introduction
        </h2>
        <p className="mb-4">
          ProxMenux provides an automated script that creates and configures a virtual machine (VM) to install Synology
          DSM (DiskStation Manager) on Proxmox VE. This script simplifies the process by downloading and adding one of
          the available loaders to the VM boot, giving you the option between four different choices:
        </p>
        <ul className="list-disc pl-5 mb-4">
          <li>
            <a
              href="https://github.com/AuxXxilium/arc"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 hover:underline"
            >
              AuxXxilium Arc
            </a>{" "}
          </li>
          <li>
            <a
              href="https://github.com/RROrg/rr"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 hover:underline"
            >
              RedPill RR
            </a>{" "}
          </li>
          <li>
            <a
              href="https://github.com/PeterSuh-Q3/tinycore-redpill"
              target="_blank"
              rel="noopener noreferrer"
              className="text-blue-600 hover:underline"
            >
              TinyCore RedPill M-shell
            </a>{" "}
          </li>
          <li>
            Custom Loader â€“ option to use a custom loader if you prefer to modify or create your own configuration
          </li>
        </ul>

        <p className="mb-4">The script simplifies the VM creation process by offering the following options:</p>
        <ul className="list-disc pl-5 mb-4">
          <li>Selection of default or advanced configuration</li>
          <li>Configuration of CPU, RAM, BIOS, and machine type</li>
          <li>Choice between virtual disk or physical disk passthrough</li>
        </ul>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Default and Advanced Configuration
          </h3>
          <p className="mb-3">The script offers two configuration modes:</p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Zap className="h-5 w-5 mr-2 text-green-500" />
            Default Configuration
          </h4>
          <p className="mb-3">
            If you select default configuration, the script will automatically apply the following values:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Default Value</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">2</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">4096 MB</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">vmbr0</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Automatically generated</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Start VM on Completion</td>
                  <td className="py-2 px-4 border-b border-gray-200">No</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p className="mb-4">
            If you want to customize the configuration, select the Advanced Settings option in the menu.
          </p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Sliders className="h-5 w-5 mr-2 text-orange-500" />
            Advanced Configuration
          </h4>
          <p className="mb-3">
            If you select advanced configuration, the script will allow you to customize each parameter:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Options</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35 or i440fx</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI) or SeaBIOS (Legacy)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host or KVM64</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">Number of CPU cores</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">Amount of memory allocated to the VM</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">Network bridge for connection</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Custom MAC address</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN</td>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN tag (if used)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MTU</td>
                  <td className="py-2 px-4 border-b border-gray-200">Maximum Transmission Unit size</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Selection
          </h3>
          <p className="mb-3">
            Once the machine is configured, the script allows you to choose between two types of disks:
          </p>

          <h4 className="text-lg font-medium mt-4 mb-2">Virtual Disk</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script lists the storage options available in Proxmox</li>
            <li>The user selects the disk and size in GB</li>
            <li>The virtual disk is automatically assigned to the VM. If more disks are configured, they will be added as <strong>SATA</strong> (e.g., sata0, sata1, etc.), up to a maximum of 6 virtual disks.</li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">Physical Disk Passthrough</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script detects all available physical disks</li>
            <li>The user selects the physical disk or disks they want to use.</li>
            <li>The physical disk is directly assigned to the VM via passthrough. If more disks are configured, they will be added as <strong>SATA</strong> (e.g., sata0, sata1, etc.), up to a maximum of 6 physical disks.</li>
          </ul>
        </div>

        <div className="mt-8">
        <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Download className="h-5 w-5 mr-2 text-blue-500" />
            Loader Installation
        </h3>
        <p className="mb-3">
            The script automatically downloads and extracts the loader from the developer's repository. If the download fails, the script will display an error message.
        </p>
        <p className="mb-4">
            <strong>AuxXxilium Arc</strong>, <strong>RedPill RR</strong>, and <strong>TinyCore RedPill M-shell</strong>.  
            <span className="block mt-1">Downloads and extracts automatically.</span>
        </p>
        <p className="mb-4">
            For <strong>Custom Loader</strong>, the script searches for files in <code>/var/lib/vz/template/iso</code>. 
            If multiple files are found, you will be prompted to select the desired file.  
        </p>   
        <p className="mt-12 mb-4"></p>
        <p>You can upload custom loaders from the local storage options:</p>

        <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/add_loader.png" 
                alt="Add Custom Loader" 
                caption="Add Custom Loader"
              />
        </div>


        <div className="mt-16">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Cpu className="h-5 w-5 mr-2 text-blue-500" />
            VM Creation
          </h3>
          <p className="mb-3">Once the loader is downloaded, the script creates the VM using the following commands:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>
              <code>qm create</code> â€“ Creates the virtual machine with the configured parameters
            </li>
            <li>
              <code>qm importdisk</code> â€“ Imports the boot loader disk to the VM. For greater compatibility the loader is imported as an IDE disk
            </li>
            <li>
              <code>qm set</code> â€“ Assigns configuration values such as CPU, RAM, and storage
            </li>
            <li>
              <code>qm set -boot</code> â€“ Configures the boot order
            </li>
          </ul>
        </div>
      </section>

      <section className="mb-10">
        <h2 className="text-2xl font-semibold mt-24 mb-4 flex items-center">
          <Wrench className="h-6 w-6 mr-2 text-blue-500" />
          Step-by-Step Boot Loader Configuration Guide
        </h2>
        <p className="mb-4">
        While all loaders share similarities, each one has its own structure and configuration methods. 
        This section provides a basic guide covering the 6 steps involved in setting up a Synology DSM loader. 
        The exact steps may vary depending on the loader and any changes introduced by the developer. 
        Therefore, understanding these common basic steps is crucial to correctly building and configuring 
        the loader of your choice for proper Synology DSM functionality.
        </p>


        {/* Selector de loader global */}
        <div className="bg-blue-50 p-4 rounded-lg mb-6">
          <h3 className="text-lg font-semibold mb-2">Select your loader type:</h3>
          <div className="flex space-x-4">
            <button
              onClick={() => setActiveLoader("arc")}
              className={`px-4 py-2 rounded-md font-medium ${
                activeLoader === "arc"
                  ? "bg-blue-500 text-white"
                  : "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50"
              }`}
            >
              Arc Loader
            </button>
            <button
              onClick={() => setActiveLoader("rr")}
              className={`px-4 py-2 rounded-md font-medium ${
                activeLoader === "rr"
                  ? "bg-blue-500 text-white"
                  : "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50"
              }`}
            >
              RR Loader
            </button>
            <button
              onClick={() => setActiveLoader("tinycore")}
              className={`px-4 py-2 rounded-md font-medium ${
                activeLoader === "tinycore"
                  ? "bg-blue-500 text-white"
                  : "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50"
              }`}
            >
              TinyCore Loader
            </button>
          </div>
        </div>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step1">
          <StepNumber number={1} />
          Start the VM and Access the Main Menu
        </h2>
        <p className="mb-4">
        Once the VM is created, start it. The first time you boot the VM, you'll access the loader's main menu to select 
        and configure the DSM model you want to build. Once the loader is created, this step will be skipped unless you 
        manually force a reconfiguration from the boot monitor. All loaders also have the option to configure the loader 
        via a web interface.
        </p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-8">

              <p className="mt-16 mb-2">
                  <strong>Web interface</strong>, To access the web interface, simply open a web browser and enter 
                  the IP address shown in the VM's console output. For example, in our case: http://192.169.0.32.
                </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_0_1.png"
                alt="Arc Loader Web Interface"
                caption="Arc Loader Web Interface"
              />

            <p className="mt-16 mb-2">
                  <strong>Terminal interface</strong>, Access it directly from the VM's console output.
                </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_1_1.png"
                alt="Arc Loader Terminal Interface"
                caption="Arc Loader Terminal Interface"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-8">
              
              <p className="mt-16 mb-2">
                <strong>Web interface</strong>, To access the web interface, simply open a web browser and enter 
                the IP address shown in the VM's console output, followed by port <strong>7681</strong>.  
                For example, in our case: <code>http://192.169.0.33:7681</code>.
              </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_0_2.png"
                alt="RR Command Example"
                caption="RR Loader Web Interface"
              />

              <p className="mt-16 mb-2">
                  <strong>Terminal interface</strong>, Access it directly from the VM's console output by typing <strong>menu.sh</strong> on the screen
                </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_1_1.png"
                alt="RR Loader Interface"
                caption="RR Loader Terminal Interface"
              />     
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-8">

<p className="mt-16 mb-2">
                <strong>Web interface</strong>, To access the web interface, simply open a web browser and enter 
                the IP address shown in the VM's console output, followed by port <strong>7681</strong>.  
                For example, in our case: <code>http://192.169.0.35:7681</code>.
              </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_0_1.png"
                alt="TinyCore Loader Interface"
                caption="TinyCore Loader Web Interface"
              />

               <p className="mt-16 mb-2">
                <strong>Terminal interface</strong>, Access it directly from the VM's console output. Keep an eye on 
                the screen, as at some point it may prompt you to press a key to continue or ask if you want to change the language.
                </p>

              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_1_1.png"
                alt="TinyCore Loader Interface"
                caption="TinyCore Loader Terminal Interface"
              />
            </div>
          )}
        </div>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step2">
          <StepNumber number={2} />
          Select Model
        </h2>
        <p className="mb-4">
          After loading the menu, select the Synology DSM model you want to install. Depending on the loader, you may
          sometimes need to expand the options to see more models.
        </p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_2_1.png"
                alt="Arc Model Selection"
                caption="Arc Model Selection"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_2_1.png"
                alt="RR Model Selection"
                caption="RR Model Selection"
              />
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_2_1.png"
                alt="TinyCore Model Selection"
                caption="TinyCore Model Selection"
              />
            </div>
          )}
        </div>
        <p className="mt-4">In our example, we'll choose the SA6400 model.</p>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step3">
          <StepNumber number={3} />
          Select DSM Version
        </h2>
        <p className="mb-4">
          After selecting the model, you need to choose the DSM version you want to install.
        </p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-16">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_3_1.png"
                alt="Arc Version Selection - Step 1"
                caption="Arc Version Selection - Step 1"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_3_2.png"
                alt="Arc Version Selection - Step 2"
                caption="Arc Version Selection - Step 2"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-16">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_3_1.png"
                alt="RR Version Selection - Step 1"
                caption="RR Version Selection - Step 1"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_3_2.png"
                alt="RR Version Selection - Step 2"
                caption="RR Version Selection - Step 2"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_3_3.png"
                alt="RR Version Selection - Step 3"
                caption="RR Version Selection - Step 3"
              />
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-16">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_3_1.png"
                alt="TinyCore Version Selection - Step 1"
                caption="TinyCore Version Selection - Step 1"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_3_2.png"
                alt="TinyCore Version Selection - Step 2"
                caption="TinyCore Version Selection - Step 2"
              />
            </div>
          )}
        </div>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step4">
          <StepNumber number={4} />
          Select Addons
        </h2>
        <p className="mb-4">This step allows you to add additional features or custom configurations to the loader.</p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-16">
              <p className="mb-2">
                <strong>Arc</strong> gives you the option to configure automatically or manually adjust the settings. 
                If automatic configuration is selected, the loader will start applying the necessary settings and will 
                automatically reboot once the process is complete.
              </p>
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_4_1.png"
                alt="Arc Auto Configuration"
                caption="Arc Auto Configuration"
              />
              <p className="mb-2">
                If we choose not to use automatic mode, we enter the menu to configure different options necessary for
                the loader:
              </p>
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_4_2.png"
                alt="Arc Manual Configuration"
                caption="Arc Manual Configuration"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_4_3.png"
                alt="Arc SN/Mac Configuration"
                caption="Arc SN/Mac Configuration"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_4_4.png"
                alt="Arc Sata Portmap"
                caption="Arc Sata Portmap (use the recommended option)"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_4_5.png"
                alt="Arc Addons Selection"
                caption="Arc Addons Selection"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_4_1.png"
                alt="RR Addon Step 1"
                caption="RR Addon Step 1"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_4_2.png"
                alt="RR Addon Step 2"
                caption="RR Addon Step 2 - Press to add addons"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_4_3.png"
                alt="RR Addon Step 3"
                caption="RR Addon Step 3 - Select the one you want by clicking on it. If you want to add more, repeat the process from images 2.4.2 and 2.4.3"
              />
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_4_1.png"
                alt="TinyCore SN Configuration"
                caption="TinyCore SN Configuration"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_4_2.png"
                alt="TinyCore Random Option"
                caption="TinyCore Random Option - The random option is recommended"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_4_3.png"
                alt="TinyCore MAC Configuration"
                caption="TinyCore MAC Configuration"
              />
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_4_4.png"
                alt="TinyCore VM MAC"
                caption="TinyCore VM MAC - Choose to use your VM's MAC or a random one"
              />
            </div>
          )}
        </div>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step5">
          <StepNumber number={5} />
          Build the Loader
        </h2>
        <p className="mb-4">
          Once you have selected the model, DSM version, and addons, proceed to build the loader. This process might
          take a few minutes depending on the loader and the selected configuration. To start, select the "Build the
          Loader" option.
        </p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_5_1.png"
                alt="Arc Build Loader"
                caption="Arc Build Loader"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_5_1.png"
                alt="RR Build Loader"
                caption="RR Build Loader"
              />
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_5_1.png"
                alt="TinyCore Build Loader"
                caption="TinyCore Build Loader"
              />
            </div>
          )}
        </div>
      </section>

      <section className="mb-12 border-b pb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center" id="step6">
          <StepNumber number={6} />
          Boot the Loader
        </h2>
        <p className="mb-4">
          Once the loader has been built, it will prompt you to boot. The VM will restart with the configuration you've
          created and start the DSM installation.
        </p>

        <div className="mt-6">
          {activeLoader === "arc" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/arc/arc_1_6_1.png"
                alt="Arc Boot Loader"
                caption="Arc Boot Loader"
              />
            </div>
          )}

          {activeLoader === "rr" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/rr/rr_2_6_1.png"
                alt="RR Boot Loader"
                caption="RR Boot Loader"
              />
            </div>
          )}

          {activeLoader === "tinycore" && (
            <div className="flex flex-col space-y-8">
              <ImageWithCaption
                src="https://macrimi.github.io/ProxMenux/vm/synology/tinycore/tinycore_3_6_1.png"
                alt="TinyCore Boot Loader"
                caption="TinyCore Boot Loader"
              />
            </div>
          )}
        </div>
      </section>

      {/* STARTING DSM INSTALLATION */}
      <section className="mb-8">
        <h2 className="text-xl font-semibold mb-4 flex items-center">
          <CheckCircle className="h-6 w-6 mr-3 text-green-500" />
          Starting the DSM Installation
        </h2>
        <p className="mb-4">Once the loader is booted, you can find your Synology device using:</p>
        <div className="bg-gray-100 p-4 rounded-md overflow-x-auto text-sm mb-4">
          <code>https://finds.synology.com</code>
        </div>
        <p className="mb-6">Follow the on-screen steps to complete the DSM installation.</p>
        <div className="flex flex-col space-y-8">
          <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/vm/synology/install_DSM.png"
            alt="DSM Setup"
            caption="DSM Setup Screen"
          />
          <p className="mt-8 mb-8">
          Please be patient â€“ The process may take a few minutes to complete. The progress percentage will 
          update automatically as the setup progresses. A countdown will start once the installation 
          is nearing completion.
        </p>
          <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/vm/synology/finish_install_DSM.png"
            alt="Installation Complete"
            caption="Installation Complete"
          />
        </div>
      </section>

      <section className="mb-8">
        <h2 className="text-2xl font-semibold mt-20 mb-4 flex items-center">
          <Target className="h-6 w-6 mr-2 text-blue-500" />
          Tips
        </h2>
        <ul className="list-disc pl-5 space-y-4">
          <li>
            Keep in mind that available options may change depending on the loader version and developer updates. If you
            encounter issues during the loader creation process, consult the loader documentation:
          </li>

          <div className="flex flex-wrap gap-4 mt-2">
              <a
                href="https://github.com/AuxXxilium/arc"
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center px-3 py-2 text-sm font-medium rounded-md bg-gray-100 text-gray-800 hover:bg-gray-200 transition-colors"
              >
                <Github className="h-5 w-5 mr-2" />
                Arc Documentation
              </a>
              <a
                href="https://github.com/RROrg/rr"
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center px-3 py-2 text-sm font-medium rounded-md bg-gray-100 text-gray-800 hover:bg-gray-200 transition-colors"
              >
                <Github className="h-5 w-5 mr-2" />
                RR Documentation
              </a>
              <a
                href="https://github.com/PeterSuh-Q3/tinycore-redpill"
                target="_blank"
                rel="noopener noreferrer"
                className="inline-flex items-center px-3 py-2 text-sm font-medium rounded-md bg-gray-100 text-gray-800 hover:bg-gray-200 transition-colors"
              >
                <Github className="h-5 w-5 mr-2" />
                TinyCore Documentation
              </a>
            </div>

          <li>
            Some older DSM models may have issues recognizing disks or the network card. It is recommended to use more
            recent models.
          </li>

          <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4">
            <p className="font-semibold">Update:</p>
            <p>
            Some loaders offer the option to update the loader directly from the menu.
            </p>
          </div>

          <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
            <p className="font-semibold">Important:</p>
            <p>
            ProxMenux does not provide support for the different loaders.
            </p>
          </div>

        </ul>
      </section>
    </div>
  )
}



function ImageWithCaption({ src, alt, caption }: { src: string; alt: string; caption: string }) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden">
        <Image
          src={src || "/placeholder.svg"}
          alt={alt}
          width={768}
          height={0}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

function StepNumber({ number }: { number: number }) {
  return (
    <div
      className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full"
      aria-hidden="true"
    >
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}




================================================
FILE: web/app/docs/create-vm/system-linux/page.tsx
================================================
"use client"

import Image from "next/image"
import CopyableCode from "@/components/CopyableCode"
import { Monitor, Settings, Zap, Sliders, HardDrive, ExternalLink, FileCode, Server, Terminal, Cloud } from "lucide-react"


interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg?height=400&width=768&query=Linux VM configuration"}
          alt={alt}
          width={768}
          height={400}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function LinuxVMContent() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-4">
        <div className="flex items-center gap-3 mb-6">
          <Monitor className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Linux VM Creator Script</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides automated scripts that create and configure Linux virtual machines on Proxmox VE. These
            scripts simplify the process by handling the necessary configurations and optimizations for various Linux
            distributions, including Ubuntu, Debian, Fedora, and many others.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/vm/menu_linux.png"
        alt="Linux VM Menu"
        caption="Linux VM Creation Menu in ProxMenux"
      />

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-black">Script Overview</h2>
        <p className="mb-4">
          The Linux VM creation script automates the process of setting up virtual machines optimized for running Linux
          operating systems. The script handles all aspects of VM configuration, including hardware allocation, disk
          setup, and boot options.
        </p>

        <p className="mb-4">The script simplifies the VM creation process by offering the following options:</p>
        <ul className="list-disc pl-5 mb-4">
          <li>Selection of default or advanced configuration</li>
          <li>Configuration of CPU, RAM, BIOS, and machine type</li>
          <li>Choice between virtual disk or physical disk passthrough</li>
          <li>Selection of disk interface type (SCSI, SATA, VirtIO, or IDE)</li>
          <li>Automatic configuration of EFI for UEFI boot</li>
          <li>Multiple installation methods: official ISOs, Cloud-Init, or local ISO</li>
        </ul>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Default and Advanced Configuration
          </h3>
          <p className="mb-3">The script offers two configuration modes:</p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Zap className="h-5 w-5 mr-2 text-green-500" />
            Default Configuration
          </h4>
          <p className="mb-3">
            If you select default configuration, the script will automatically apply the following values:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Default Value</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">2</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">4096 MB</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">vmbr0</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Automatically generated</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Start VM on Completion</td>
                  <td className="py-2 px-4 border-b border-gray-200">No</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p className="mb-4">
            If you want to customize the configuration, select the Advanced Settings option in the menu.
          </p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Sliders className="h-5 w-5 mr-2 text-orange-500" />
            Advanced Configuration
          </h4>
          <p className="mb-3">
            If you select advanced configuration, the script will allow you to customize each parameter:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Options</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35 or i440fx</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI) or SeaBIOS (Legacy)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host or KVM64</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">Number of CPU cores</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">Amount of memory allocated to the VM</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">Network bridge for connection</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Custom MAC address</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN</td>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN tag (if used)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MTU</td>
                  <td className="py-2 px-4 border-b border-gray-200">Maximum Transmission Unit size</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Interface Selection
          </h3>
          <p className="mb-3">
            The script allows you to choose the disk interface type for both virtual and physical disks:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Interface Type</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Description</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Best For</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SCSI</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Modern interface with good performance and features
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Recommended for most Linux distributions (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SATA</td>
                  <td className="py-2 px-4 border-b border-gray-200">Standard interface with high compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Good general-purpose choice (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VirtIO</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Paravirtualized interface with highest performance
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Best performance for Linux (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">IDE</td>
                  <td className="py-2 px-4 border-b border-gray-200">Legacy interface with maximum compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">Legacy systems only (no discard/trim support)</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Selection
          </h3>
          <p className="mb-3">
            Once the machine is configured, the script allows you to choose between two types of disks:
          </p>

          <h4 className="text-lg font-medium mt-4 mb-2">Virtual Disk</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script lists the storage options available in Proxmox</li>
            <li>The user selects the disk and size in GB</li>
            <li>
              The virtual disk is automatically assigned to the VM using the selected interface type (SCSI, SATA,
              VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">Physical Disk Passthrough</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script detects all available physical disks</li>
            <li>The user selects the physical disk or disks they want to use</li>
            <li>
              The physical disk is directly assigned to the VM via passthrough using the selected interface type (SCSI,
              SATA, VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Additional Features
          </h3>

          <h4 className="text-lg font-medium mt-4 mb-2">EFI Disk Configuration</h4>
          <p className="mb-3">
            When UEFI BIOS (OVMF) is selected, the script automatically configures an EFI system disk:
          </p>
          <ul className="list-disc pl-5 mb-4">
            <li>You'll be prompted to select the storage location for the EFI disk</li>
            <li>A 4MB EFI disk is created and attached to the VM</li>
            <li>
              The disk is formatted appropriately based on the selected storage backend (e.g., raw format for
              directory-based storage)
            </li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">ISO Mounting</h4>
          <p className="mb-3">The script also handles ISO mounting automatically:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>
              The installation ISO is mounted to the first available IDE slot (typically <code>ide2</code>)
            </li>
            <li>For VirtIO disk interfaces, the VirtIO drivers ISO can be mounted if needed</li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">QEMU Guest Agent</h4>
          <p className="mb-3">The script automatically configures QEMU Guest Agent support:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>Enables the QEMU Guest Agent in the VM configuration</li>
            <li>Sets up the necessary communication channel</li>
            <li>Provides instructions for installing the guest agent inside the VM after installation</li>
          </ul>
        </div>

        <div className="mt-12">
          <h2 className="text-2xl font-bold mb-6 text-black">Linux Installation Options</h2>
          <p className="mb-6">ProxMenux offers three methods for installing Linux on your virtual machine:</p>

          <div className="space-y-24 mt-8">
            <div>
              <div className="flex items-center gap-3 mb-8">
                <Server className="h-12 w-12 text-blue-500" />
                <h3 className="text-xl font-semibold">Official ISO Installation</h3>
              </div>

              <p className="mb-4">
                This option allows you to install Linux using official distribution ISOs. ProxMenux provides a curated
                list of popular Linux distributions that can be automatically downloaded and used for installation.
              </p>

              <h4 className="font-medium mb-2">Available Distributions:</h4>
              <ul className="list-disc pl-5 mb-4 space-y-1">
                <li>Ubuntu (Desktop & Server)</li>
                <li>Debian (Full & Netinst)</li>
                <li>Fedora Workstation</li>
                <li>Rocky Linux</li>
                <li>Linux Mint</li>
                <li>openSUSE Leap</li>
                <li>Alpine Linux</li>
                <li>Kali Linux</li>
                <li>Manjaro</li>
              </ul>

              <div className="mt-4">
                <ImageWithCaption
                  src="https://macrimi.github.io/ProxMenux/vm/distro_linux.png"
                  alt="Linux Distribution Selection"
                  caption="Linux Distribution Selection in ProxMenux"
                />
              </div>
            </div>

            <div>
              <div className="flex items-center gap-3 mb-8">
                <Cloud className="h-12 w-12 text-blue-500" />
                <h3 className="text-xl font-semibold">Cloud-Init Installation</h3>
              </div>

              <p className="mb-4">
                This option uses Cloud-Init to automate the installation process. It's faster than traditional
                installation and provides a pre-configured system ready to use.
              </p>

              <h4 className="font-medium mb-2">Available Cloud-Init Images:</h4>
              <ul className="list-disc pl-5 mb-4 space-y-1">
                <li>Arch Linux</li>
                <li>Debian 12</li>
                <li>Ubuntu 22.04 LTS</li>
                <li>Ubuntu 24.04 LTS</li>
                <li>Ubuntu 24.10</li>
              </ul>

              <div className="mt-4 bg-blue-50 border border-blue-200 rounded-md p-4">
                <div className="flex items-center gap-2 mb-2">
                  <ExternalLink className="h-4 w-4 text-blue-500" />
                  <h5 className="font-medium text-blue-800">External Scripts</h5>
                </div>
                <p className="text-sm text-blue-800">
                  Cloud-Init installations use external helper scripts from the community. For more information, visit:
                </p>
                <a
                  href="https://community-scripts.github.io/ProxmoxVE/"
                  target="_blank"
                  rel="noopener noreferrer"
                  className="text-sm text-blue-600 hover:text-blue-800 flex items-center mt-1"
                >
                  community-scripts.github.io/ProxmoxVE
                  <ExternalLink className="h-3 w-3 ml-1" />
                </a>
              </div>
            </div>

            <div>
              <div className="flex items-center gap-3 mb-8">
                <HardDrive className="h-12 w-12 text-blue-500" />
                <h3 className="text-xl font-semibold">Local ISO Installation</h3>
              </div>

              <p className="mb-4">
                This option allows you to use your own Linux ISO file that's already uploaded to your Proxmox server's
                local storage. Ideal if you have custom or specific Linux installation media.
              </p>

              <div className="mt-4">
                <ImageWithCaption
                  src="https://macrimi.github.io/ProxMenux/vm/local-store.png"
                  alt="Local ISO Selection Menu"
                  caption="Local ISO Selection Menu in ProxMenux"
                />
              </div>
            </div>
          </div>
        </div>

        <div className="mt-24 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 className="text-xl font-bold mb-4 text-black">Installation Process</h2>
          <p className="mb-4">
            After configuring the VM settings and selecting your installation method, the script will:
          </p>
          <ol className="list-decimal pl-5 space-y-2">
            <li>Create the VM with the specified configuration</li>
            <li>Configure EFI disk if UEFI BIOS is selected</li>
            <li>Create and attach virtual disks or pass through physical disks</li>
            <li>Download and mount the Linux ISO (if using official distribution) or mount your local ISO</li>
            <li>Set the boot order (disk first, then ISO)</li>
            <li>Configure the QEMU Guest Agent</li>
            <li>Start the VM if requested</li>
          </ol>
        </div>

        <div className="mt-12 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 className="text-xl font-bold mb-4 text-black flex items-center">
            <Terminal className="h-6 w-6 mr-2 text-blue-500" />
            Linux-Specific Tips
          </h2>

          <div className="space-y-6">
            <div>
              <h3 className="text-lg font-medium mb-2">Installing QEMU Guest Agent</h3>
              <p className="mb-3">
                For better integration with Proxmox, it's recommended to install the QEMU Guest Agent inside your Linux
                VM. This enables features like proper shutdown, file system freeze for snapshots, and more accurate
                memory reporting.
              </p>

              <div className="bg-gray-100 p-4 rounded-md">
                <h4 className="font-medium mb-2">Installation commands by distribution:</h4>
                  <div className="space-y-3">
                    <div>
                      
                      <p className="font-medium text-sm">Debian / Ubuntu:</p>
                      <CopyableCode
                        code={encodeURIComponent(`sudo apt update && sudo apt install qemu-guest-agent -y
                  sudo systemctl enable qemu-guest-agent
                  sudo systemctl start qemu-guest-agent`)}
                      />
                    </div>

                    <div>
                      <p className="font-medium text-sm">Fedora / CentOS / Rocky Linux:</p>
                      <CopyableCode
                        code={encodeURIComponent(`sudo dnf install qemu-guest-agent -y
                  sudo systemctl enable qemu-guest-agent
                  sudo systemctl start qemu-guest-agent`)}
                      />
                    </div>

                    <div>
                      <p className="font-medium text-sm">Arch Linux:</p>
                      <CopyableCode
                        code={encodeURIComponent(`sudo pacman -S qemu-guest-agent
                  sudo systemctl enable qemu-guest-agent
                  sudo systemctl start qemu-guest-agent`)}
                      />
                    </div>

                    <div>
                      <p className="font-medium text-sm">openSUSE:</p>
                      <CopyableCode
                        code={encodeURIComponent(`sudo zypper install qemu-guest-agent
                  sudo systemctl enable qemu-guest-agent
                  sudo systemctl start qemu-guest-agent`)}
                      />
                    </div>
                  </div>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-medium mb-2">VirtIO Drivers in Linux</h3>
              <p className="mb-3">
                Most modern Linux distributions include VirtIO drivers by default, which means you can use VirtIO disk
                and network interfaces without additional configuration. This provides the best performance for your
                Linux VM.
              </p>

              <div className="bg-yellow-50 border-l-4 border-yellow-400 p-4">
                <p className="font-medium">Note:</p>
                <p>
                  If you're using an older Linux distribution (pre-2.6.25 kernel) and VirtIO disk interfaces, you might
                  need to load the VirtIO modules during installation. In such cases, you may need to provide a driver
                  disk or use SATA/SCSI interfaces instead.
                </p>
              </div>
            </div>

            <div>
              <h3 className="text-lg font-medium mb-2">Optimizing Linux VMs</h3>
              <ul className="list-disc pl-5 space-y-2">
                <li>
                  <strong>Enable disk trim/discard:</strong> To enable TRIM support for better SSD performance, add the{" "}
                  <code className="bg-gray-100 px-1 py-0.5 rounded">discard</code> mount option in{" "}
                  <code className="bg-gray-100 px-1 py-0.5 rounded">/etc/fstab</code> for your partitions.
                </li>
                <li>
                  <strong>CPU type selection:</strong> For best performance, use the "host" CPU type which passes
                  through all CPU features from your host to the VM.
                </li>
                <li>
                  <strong>Memory ballooning:</strong> Enable memory ballooning to allow dynamic memory allocation. The
                  balloon driver is included in most Linux distributions.
                </li>
                <li>
                  <strong>Use VirtIO network interfaces:</strong> VirtIO network interfaces provide better performance
                  than emulated network cards.
                </li>
              </ul>
            </div>

          </div>
        </div>

       <div className="mt-8 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 id="other-linux-systems" className="text-xl font-bold mb-4 text-black">
            Other Linux Systems
          </h2>
          <p className="mb-4">
            ProxMenux provides access to external community scripts that allow the creation of specialized Linux virtual machines for specific use cases:
          </p>


          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
            <div className="border rounded-lg p-4 bg-white">
              <div className="flex items-center gap-2 mb-2">
                <Server className="h-5 w-5 text-blue-500" />
                <h3 className="font-semibold">Home Assistant OS VM (HAOS)</h3>
              </div>
              <p className="text-sm mb-3">
                Create a virtual machine that runs Home Assistant OS using a helper script from the community. Ideal for smart home automation.
              </p>
            </div>

            <div className="border rounded-lg p-4 bg-white">
              <div className="flex items-center gap-2 mb-2">
                <Terminal className="h-5 w-5 text-blue-500" />
                <h3 className="font-semibold">Docker VM (Debian + SSH + Docker)</h3>
              </div>
              <p className="text-sm mb-3">
                Deploy a lightweight Debian-based virtual machine with Docker and SSH pre-installed using an external script.
              </p>
            </div>
          </div>

          <div className="mt-6 bg-blue-50 border border-blue-200 rounded-md p-4">
            <div className="flex items-center gap-2 mb-2">
              <ExternalLink className="h-4 w-4 text-blue-500" />
              <h5 className="font-medium text-blue-800">External Scripts</h5>
            </div>
            <p className="text-sm text-blue-800">
              These installations are handled by community-maintained scripts. For more information or to contribute, visit:
            </p>
            <a
              href="https://community-scripts.github.io/ProxmoxVE/"
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-blue-600 hover:text-blue-800 flex items-center mt-1"
            >
              community-scripts.github.io/ProxmoxVE
              <ExternalLink className="h-3 w-3 ml-1" />
            </a>
          </div>
        </div>
      </div>
    </div>
  )
}



================================================
FILE: web/app/docs/create-vm/system-nas/page.tsx
================================================
import type React from "react"
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { HardDrive, Info, Database, Server, MonitorIcon, Star, Cpu, Github } from "lucide-react"
import { Badge } from "@/components/ui/badge"

export const metadata: Metadata = {
  title: "ProxMenux Documentation: System NAS Virtual Machines",
  description:
    "Guide for creating and configuring NAS virtual machines on Proxmox VE using ProxMenux, including Synology DSM, TrueNAS, and other storage systems.",
  openGraph: {
    title: "ProxMenux Documentation: System NAS Virtual Machines",
    description:
      "Guide for creating and configuring NAS virtual machines on Proxmox VE using ProxMenux, including Synology DSM, TrueNAS, and other storage systems.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/virtual-machines/system-nas",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/vm/system-nas-menu.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux System NAS Menu",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: System NAS Virtual Machines",
    description:
      "Guide for creating and configuring NAS virtual machines on Proxmox VE using ProxMenux, including Synology DSM, TrueNAS, and other storage systems.",
    images: ["https://macrimi.github.io/ProxMenux/vm/system-nas-menu.png"],
  },
}

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg"}
          alt={alt}
          width={768}
          height={400}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

interface NASSystemProps {
  name: string
  description: string
  icon: React.ReactNode
  features: string[]
  technicalDetails: string[]
  href: string
  isExternal?: boolean
  externalUrl?: string
}

function NASSystemItem({
  name,
  description,
  icon,
  features,
  technicalDetails,
  href,
  isExternal,
  externalUrl,
}: NASSystemProps) {
  return (
    <div className="border rounded-md mb-6 border-gray-200 overflow-hidden">
      <div className="px-4 py-3 bg-gray-50 border-b border-gray-200 hover:bg-blue-50 transition-colors">
        <div className="flex items-center justify-between">
          {isExternal && externalUrl ? (
            <a href={externalUrl} target="_blank" rel="noopener noreferrer" className="flex items-center gap-3">
              {icon}
              <h3 className="text-lg font-medium text-black hover:text-blue-600">{name}</h3>
            </a>
          ) : (
            <Link href={href} className="flex items-center gap-3">
              {icon}
              <h3 className="text-lg font-medium text-black hover:text-blue-600">{name}</h3>
            </Link>
          )}

          {isExternal && (
            <div className="flex items-center">
              <Badge
                variant="outline"
                className="flex items-center gap-1 bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300"
              >
                <Github className="h-3.5 w-3.5 text-gray-700" />
                <span className="text-xs font-medium">External Script</span>
              </Badge>

            </div>
          )}
        </div>
      </div>

      <div className="px-4 py-4">
        <div className="space-y-4">
          <p className="text-gray-700">{description}</p>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <h4 className="font-semibold mb-2 text-black flex items-center">
                <Star className="h-5 w-5 mr-2 text-green-500" />
                Key Features:
              </h4>
              <ul className="list-disc pl-5 space-y-1 text-gray-700">
                {features.map((feature, index) => (
                  <li key={index}>{feature}</li>
                ))}
              </ul>
            </div>

            <div>
              <h4 className="font-semibold mb-2 text-black flex items-center">
                <Cpu className="h-5 w-5 mr-2 text-purple-500" />
                Technical Details:
              </h4>
              <ul className="list-disc pl-5 space-y-1 text-gray-700">
                {technicalDetails.map((detail, index) => (
                  <li key={index}>{detail}</li>
                ))}
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default function SystemNASPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-4">
        <div className="flex items-center gap-3 mb-6">
          <HardDrive className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">System NAS Virtual Machines</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides automated scripts that create and configure virtual machines for various NAS systems on
            Proxmox VE. These scripts simplify the process by handling the necessary configurations and optimizations
            for each NAS platform.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/vm/system-nas-menu.png"
        alt="System NAS Menu"
        caption="System NAS Menu"
      />

      <div className="mt-8 mb-6">
        <div className="flex items-center gap-2">
          <Info className="h-5 w-5 text-blue-500" />
          <h2 className="text-xl font-semibold text-black">Available NAS Systems</h2>
        </div>
        <p className="mt-2 text-gray-600">
          Select one of the NAS systems below to view detailed documentation on installation and configuration.
        </p>
      </div>

      <div className="mt-6">
        <NASSystemItem
          name="Synology DSM"
          description="Synology DSM (DiskStation Manager) is a popular NAS operating system with a comprehensive set of features for home and business users."
          icon={<HardDrive className="h-6 w-6 text-blue-500" />}
          features={[
            "User-friendly web interface",
            "Extensive app ecosystem",
            "File sharing and synchronization",
            "Media streaming capabilities",
          ]}
          technicalDetails={[
            "Base OS: Linux (Custom)",
            "File Systems: Btrfs, ext4",
            "Virtualization: Yes (Docker)",
            "Hardware Requirements: Moderate",
          ]}
          href="/docs/create-vm/synology"
        />

        <NASSystemItem
          name="TrueNAS SCALE"
          description="TrueNAS SCALE is a Linux-based version of TrueNAS that combines the simplicity of TrueNAS with the scalability of Linux, including support for containerization and hyperconvergence."
          icon={<Database className="h-6 w-6 text-blue-500" />}
          features={[
            "Linux-based (Debian)",
            "Docker container support",
            "Kubernetes integration",
            "Scale-out clustering capabilities",
          ]}
          technicalDetails={[
            "Base OS: Debian Linux",
            "File System: ZFS",
            "Virtualization: Yes (KVM)",
            "Hardware Requirements: High",
          ]}
          href="/docs/create-vm/system-nas/system-nas-others"
        />

        <NASSystemItem
          name="TrueNAS CORE"
          description="TrueNAS CORE (formerly FreeNAS) is a FreeBSD-based open-source NAS operating system that provides file and object storage with enterprise-grade reliability."
          icon={<Database className="h-6 w-6 text-blue-500" />}
          features={["FreeBSD-based", "ZFS file system", "Snapshots and replication", "Encryption"]}
          technicalDetails={[
            "Base OS: FreeBSD",
            "File System: ZFS",
            "Virtualization: Yes (Jails)",
            "Hardware Requirements: Moderate to High",
          ]}
          href="/docs/create-vm/system-nas/system-nas-others"
        />

        <NASSystemItem
          name="OpenMediaVault"
          description="OpenMediaVault (OMV) is a Debian-based NAS solution with a lightweight web interface designed for small home offices and personal use."
          icon={<Server className="h-6 w-6 text-blue-500" />}
          features={[
            "Modular plugin architecture",
            "Multiple filesystem support",
            "Docker support via plugins",
            "Low resource requirements",
          ]}
          technicalDetails={[
            "Base OS: Debian Linux",
            "File Systems: ext4, XFS, Btrfs",
            "Virtualization: Yes (via plugins)",
            "Hardware Requirements: Low",
          ]}
          href="/docs/create-vm/system-nas/system-nas-others"
        />

        <NASSystemItem
          name="Rockstor"
          description="Rockstor is a Linux-based NAS solution built on CentOS with the BTRFS file system, offering advanced storage features with a user-friendly interface."
          icon={<HardDrive className="h-6 w-6 text-blue-500" />}
          features={[
            "BTRFS file system",
            "Web-based UI",
            "Docker-based app framework (Rock-ons)",
            "Snapshots and replication",
          ]}
          technicalDetails={[
            "Base OS: openSUSE based",
            "File System: Btrfs",
            "Virtualization: Yes (Docker)",
            "Hardware Requirements: Moderate",
          ]}
          href="/docs/create-vm/system-nas/system-nas-others"
        />

        <NASSystemItem
          name="ZimaOS"
          description="ZimaOS is a lightweight, customizable NAS operating system designed for simplicity and performance, with a focus on media streaming and home automation."
          icon={<MonitorIcon className="h-6 w-6 text-blue-500" />}
          features={[
            "Low resource footprint",
            "Docker support",
            "Media streaming optimization",
            "Home automation integration",
          ]}
          technicalDetails={[
            "Base OS: ROGGER proxmox-zimaos",
            "File Systems: ext4, XFS",
            "Virtualization: Yes (Docker)",
            "Hardware Requirements: Low",
          ]}
          href="/docs/virtual-machines/system-nas/zimaos"
          isExternal={true}
          externalUrl="https://github.com/R0GGER/proxmox-zimaos"
        />
      </div>

      <div className="mt-12 p-6 bg-gray-50 rounded-lg border border-gray-200">
        <h2 className="text-xl font-bold mb-4 text-black">About NAS Virtual Machines</h2>
        <div className="space-y-4">
          <p className="text-black">
            Network Attached Storage (NAS) systems provide file-level data storage services to other devices on the
            network. Running NAS software in a virtual machine on Proxmox VE allows you to leverage the reliability and
            management features of Proxmox while providing flexible storage solutions.
          </p>

          <p className="text-black">
            ProxMenux simplifies the creation of NAS virtual machines by automating the configuration process, including
            network settings, storage allocation, and system optimization for each specific NAS platform.
          </p>
        </div>
      </div>
    </div>
  )
}



================================================
FILE: web/app/docs/create-vm/system-nas/system-nas-others/page.tsx
================================================
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { ArrowLeft, HardDrive, Settings, Zap, Sliders, Server, Database, ExternalLink } from "lucide-react"

export const metadata: Metadata = {
  title: "ProxMenux Documentation: Other NAS Systems VM Creation",
  description:
    "Guide for creating and configuring virtual machines for TrueNAS SCALE, TrueNAS CORE, OpenMediaVault, and Rockstor on Proxmox VE using ProxMenux.",
  openGraph: {
    title: "ProxMenux Documentation: Other NAS Systems VM Creation",
    description:
      "Guide for creating and configuring virtual machines for TrueNAS SCALE, TrueNAS CORE, OpenMediaVault, and Rockstor on Proxmox VE using ProxMenux.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/virtual-machines/system-nas/others",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/vm/other-nas-systems.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Other NAS Systems",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: Other NAS Systems VM Creation",
    description:
      "Guide for creating and configuring virtual machines for TrueNAS SCALE, TrueNAS CORE, OpenMediaVault, and Rockstor on Proxmox VE using ProxMenux.",
    images: ["https://macrimi.github.io/ProxMenux/vm/other-nas-systems.png"],
  },
}

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg?height=400&width=768&query=NAS systems configuration"}
          alt={alt}
          width={768}
          height={400}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function OtherNASSystemsPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-4">

        <div className="flex items-center gap-3 mb-6">
          <HardDrive className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">NAS Systems VM Creation</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides automated scripts that create and configure virtual machines for various NAS systems on
            Proxmox VE. This documentation covers the VM creation process for TrueNAS SCALE, TrueNAS CORE,
            OpenMediaVault, and Rockstor.
          </p>
        </div>
      </div>


      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-black">Script Overview</h2>
        <p className="mb-4">
          The VM creation script for NAS systems automates the process of setting up virtual machines optimized for
          running various Network Attached Storage solutions. The script handles all aspects of VM configuration,
          including hardware allocation, disk setup, and boot options.
        </p>

        <p className="mb-4">The script simplifies the VM creation process by offering the following options:</p>
        <ul className="list-disc pl-5 mb-4">
          <li>Selection of default or advanced configuration</li>
          <li>Configuration of CPU, RAM, BIOS, and machine type</li>
          <li>Choice between virtual disk or physical disk passthrough</li>
          <li>Selection of disk interface type (SCSI, SATA, VirtIO, or IDE)</li>
          <li>Automatic configuration of EFI and TPM when required</li>
          <li>Automatic mounting of installation ISO images</li>
        </ul>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Default and Advanced Configuration
          </h3>
          <p className="mb-3">The script offers two configuration modes:</p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Zap className="h-5 w-5 mr-2 text-green-500" />
            Default Configuration
          </h4>
          <p className="mb-3">
            If you select default configuration, the script will automatically apply the following values:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Default Value</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">2</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">8192 MB</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">vmbr0</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Automatically generated</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Start VM on Completion</td>
                  <td className="py-2 px-4 border-b border-gray-200">No</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p className="mb-4">
            If you want to customize the configuration, select the Advanced Settings option in the menu.
          </p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Sliders className="h-5 w-5 mr-2 text-orange-500" />
            Advanced Configuration
          </h4>
          <p className="mb-3">
            If you select advanced configuration, the script will allow you to customize each parameter:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Options</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35 or i440fx</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI) or SeaBIOS (Legacy)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host or KVM64</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">Number of CPU cores</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">Amount of memory allocated to the VM</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">Network bridge for connection</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Custom MAC address</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN</td>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN tag (if used)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MTU</td>
                  <td className="py-2 px-4 border-b border-gray-200">Maximum Transmission Unit size</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Interface Selection
          </h3>
          <p className="mb-3">
            Unlike the Synology-specific script, this script allows you to choose the disk interface type for both
            virtual and physical disks:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Interface Type</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Description</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Best For</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SCSI</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Modern interface with good performance and features
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Recommended for Linux and Windows (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SATA</td>
                  <td className="py-2 px-4 border-b border-gray-200">Standard interface with high compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Good general-purpose choice (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VirtIO</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Paravirtualized interface with highest performance
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Advanced users seeking maximum performance (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">IDE</td>
                  <td className="py-2 px-4 border-b border-gray-200">Legacy interface with maximum compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">Legacy systems only (no discard/trim support)</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Selection
          </h3>
          <p className="mb-3">
            Once the machine is configured, the script allows you to choose between two types of disks:
          </p>

          <h4 className="text-lg font-medium mt-4 mb-2">Virtual Disk</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script lists the storage options available in Proxmox</li>
            <li>The user selects the disk and size in GB</li>
            <li>
              The virtual disk is automatically assigned to the VM using the selected interface type (SCSI, SATA,
              VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">Physical Disk Passthrough</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script detects all available physical disks</li>
            <li>The user selects the physical disk or disks they want to use</li>
            <li>
              The physical disk is directly assigned to the VM via passthrough using the selected interface type (SCSI,
              SATA, VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Additional Features
          </h3>

          <h4 className="text-lg font-medium mt-4 mb-2">EFI Disk Configuration</h4>
          <p className="mb-3">When UEFI BIOS (OVMF) is selected, the script automatically configures an EFI disk:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>The script prompts for storage location for the EFI disk</li>
            <li>A 4MB EFI disk is created and configured</li>
            <li>
              The EFI disk is properly formatted based on the storage type (raw format for directory-based storage)
            </li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">ISO Mounting</h4>
          <p className="mb-3">The script handles ISO mounting for installation:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>The installation ISO is automatically mounted to the ide2 device</li>
            <li>For Windows VMs, VirtIO driver ISO can be automatically downloaded and mounted to ide3</li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">QEMU Guest Agent</h4>
          <p className="mb-3">The script automatically configures QEMU Guest Agent support:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>Enables the QEMU Guest Agent in the VM configuration</li>
            <li>Sets up the necessary communication channel</li>
            <li>Provides instructions for installing the guest agent inside the VM after installation</li>
          </ul>
        </div>

        <div className="mt-8">
          <h2 className="text-2xl font-bold mb-4 text-black">NAS-Specific Installation Notes</h2>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-4">
            <div className="border rounded-lg p-6 bg-gray-50">
              <div className="flex items-center gap-2 mb-3">
                <Database className="h-6 w-6 text-blue-500" />
                <h3 className="text-xl font-semibold">TrueNAS SCALE</h3>
              </div>
              <ul className="list-disc pl-5 space-y-2">
                <li>
                  Recommended interface: <strong>SATA</strong> or <strong>SCSI</strong>
                </li>
                <li>
                  Minimum RAM: <strong>8GB</strong> (16GB+ recommended)
                </li>
                <li>
                  Minimum CPU cores: <strong>2</strong> (4+ recommended)
                </li>
                <li>UEFI boot is recommended</li>
                <li>VirtIO network adapter provides best performance</li>
              </ul>
            </div>

            <div className="border rounded-lg p-6 bg-gray-50">
              <div className="flex items-center gap-2 mb-3">
                <Database className="h-6 w-6 text-blue-500" />
                <h3 className="text-xl font-semibold">TrueNAS CORE</h3>
              </div>
              <ul className="list-disc pl-5 space-y-2">
                <li>
                  Recommended interface: <strong>SATA</strong>
                </li>
                <li>
                  Minimum RAM: <strong>8GB</strong> (16GB+ recommended)
                </li>
                <li>
                  Minimum CPU cores: <strong>2</strong> (4+ recommended)
                </li>
                <li>UEFI boot is recommended</li>
                <li>VirtIO network adapter provides best performance</li>
              </ul>
            </div>

            <div className="border rounded-lg p-6 bg-gray-50">
              <div className="flex items-center gap-2 mb-3">
                <Server className="h-6 w-6 text-blue-500" />
                <h3 className="text-xl font-semibold">OpenMediaVault</h3>
              </div>
              <ul className="list-disc pl-5 space-y-2">
                <li>
                  Recommended interface: <strong>SATA</strong> or <strong>VirtIO</strong>
                </li>
                <li>
                  Minimum RAM: <strong>2GB</strong> (4GB+ recommended)
                </li>
                <li>
                  Minimum CPU cores: <strong>1</strong> (2+ recommended)
                </li>
                <li>Both UEFI and Legacy BIOS are supported</li>
                <li>VirtIO network adapter provides best performance</li>
              </ul>
            </div>

            <div className="border rounded-lg p-6 bg-gray-50">
              <div className="flex items-center gap-2 mb-3">
                <HardDrive className="h-6 w-6 text-blue-500" />
                <h3 className="text-xl font-semibold">Rockstor</h3>
              </div>
              <ul className="list-disc pl-5 space-y-2">
                <li>
                  Recommended interface: <strong>SATA</strong> or <strong>VirtIO</strong>
                </li>
                <li>
                  Minimum RAM: <strong>2GB</strong> (4GB+ recommended)
                </li>
                <li>
                  Minimum CPU cores: <strong>2</strong>
                </li>
                <li>UEFI boot is recommended</li>
                <li>VirtIO network adapter provides best performance</li>
              </ul>
            </div>
          </div>
        </div>

        <div className="mt-12 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 className="text-xl font-bold mb-4 text-black">Installation Process</h2>
          <p className="mb-4">After configuring the VM settings and disk options, the script will:</p>
          <ol className="list-decimal pl-5 space-y-2">
            <li>Create the VM with the specified configuration</li>
            <li>Configure EFI disk if UEFI BIOS is selected</li>
            <li>Create and attach virtual disks or pass through physical disks</li>
            <li>Mount the installation ISO</li>
            <li>Set the boot order (disk first, then ISO)</li>
            <li>Configure the QEMU Guest Agent</li>
            <li>Generate a detailed HTML description for the VM</li>
            <li>Start the VM if requested</li>
          </ol>
          <p className="mt-4">
            Once the VM is created, you can proceed with the installation of your chosen NAS system by following the
            on-screen instructions in the VM console.
          </p>
        </div>

        <div className="mt-12">
          <h2 className="text-2xl font-bold mb-6 text-black">NAS Systems Interfaces</h2>
          <p className="mb-6">
            Below are screenshots of the shell and web interfaces for each NAS system after successful installation:
          </p>

          {/* TrueNAS SCALE */}
          <div className="mb-12">
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <Database className="h-6 w-6 mr-2 text-blue-500" />
              TrueNAS SCALE
              <a
                href="https://www.truenas.com/truenas-scale/"
                target="_blank"
                rel="noopener noreferrer"
                className="ml-2 text-sm text-blue-500 hover:text-blue-700 flex items-center"
              >
                Official Website <ExternalLink className="h-3.5 w-3.5 ml-1" />
              </a>
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h4 className="font-medium mb-2">Shell Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/truenas/truenas-scale-shell.png"
                    alt="TrueNAS SCALE Shell Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
              <div>
                <h4 className="font-medium mb-2">Web Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/truenas/truenas-scale-web.png"
                    alt="TrueNAS SCALE Web Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* TrueNAS CORE */}
          <div className="mb-12">
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <Database className="h-6 w-6 mr-2 text-blue-500" />
              TrueNAS CORE
              <a
                href="https://www.truenas.com/truenas-core/"
                target="_blank"
                rel="noopener noreferrer"
                className="ml-2 text-sm text-blue-500 hover:text-blue-700 flex items-center"
              >
                Official Website <ExternalLink className="h-3.5 w-3.5 ml-1" />
              </a>
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h4 className="font-medium mb-2">Shell Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/truenas/truenas-core-shell.png"
                    alt="TrueNAS CORE Shell Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
              <div>
                <h4 className="font-medium mb-2">Web Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/truenas/truenas-core-web.png"
                    alt="TrueNAS CORE Web Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* OpenMediaVault */}
          <div className="mb-12">
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <Server className="h-6 w-6 mr-2 text-blue-500" />
              OpenMediaVault
              <a
                href="https://www.openmediavault.org"
                target="_blank"
                rel="noopener noreferrer"
                className="ml-2 text-sm text-blue-500 hover:text-blue-700 flex items-center"
              >
                Official Website <ExternalLink className="h-3.5 w-3.5 ml-1" />
              </a>
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h4 className="font-medium mb-2">Shell Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/openmediavault/openmediavault-shell.png"
                    alt="OpenMediaVault Shell Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
              <div>
                <h4 className="font-medium mb-2">Web Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/openmediavault/openmediavault-web.png"
                    alt="OpenMediaVault Web Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
            </div>
          </div>

          {/* Rockstor */}
          <div className="mb-12">
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <HardDrive className="h-6 w-6 mr-2 text-blue-500" />
              Rockstor
              <a
                href="https://rockstor.com"
                target="_blank"
                rel="noopener noreferrer"
                className="ml-2 text-sm text-blue-500 hover:text-blue-700 flex items-center"
              >
                Official Website <ExternalLink className="h-3.5 w-3.5 ml-1" />
              </a>
            </h3>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <h4 className="font-medium mb-2">Shell Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/rockstor/rockstor-shell.png"
                    alt="Rockstor Shell Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
              <div>
                <h4 className="font-medium mb-2">Web Interface</h4>
                <div className="border rounded-md overflow-hidden">
                  <Image
                    src="https://macrimi.github.io/ProxMenux/vm/rockstor/rockstor-web.png"
                    alt="Rockstor Web Interface"
                    width={600}
                    height={400}
                    className="w-full"
                  />
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}



================================================
FILE: web/app/docs/create-vm/system-windows/page.tsx
================================================
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { ArrowLeft, Monitor, Settings, Zap, Sliders, HardDrive, ExternalLink, Server, Target } from "lucide-react"

export const metadata: Metadata = {
  title: "ProxMenux Documentation: Windows Virtual Machines",
  description:
    "Guide for creating and configuring Windows virtual machines on Proxmox VE using ProxMenux, including UUP Dump ISO and local ISO options.",
  openGraph: {
    title: "ProxMenux Documentation: Windows Virtual Machines",
    description:
      "Guide for creating and configuring Windows virtual machines on Proxmox VE using ProxMenux, including UUP Dump ISO and local ISO options.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/virtual-machines/windows",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/vm/menu_windows.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Windows VM Menu",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: Windows Virtual Machines",
    description:
      "Guide for creating and configuring Windows virtual machines on Proxmox VE using ProxMenux, including UUP Dump ISO and local ISO options.",
    images: ["https://macrimi.github.io/ProxMenux/vm/menu_windows.png"],
  },
}

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg?height=400&width=768&query=Windows VM configuration"}
          alt={alt}
          width={768}
          height={400}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function WindowsVMPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-4">

        <div className="flex items-center gap-3 mb-6">
          <Monitor className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Windows VM Creator Script</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides automated scripts that create and configure Windows virtual machines on Proxmox VE. These
            scripts simplify the process by handling the necessary configurations and optimizations for Windows
            installations, including VirtIO drivers setup and TPM configuration.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/vm/menu_windows.png"
        alt="Windows VM Menu"
        caption="Windows VM Creation Menu in ProxMenux"
      />

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-black">Script Overview</h2>
        <p className="mb-4">
          The Windows VM creation script automates the process of setting up virtual machines optimized for running
          Windows operating systems. The script handles all aspects of VM configuration, including hardware allocation,
          disk setup, and boot options.
        </p>

        <p className="mb-4">The script simplifies the VM creation process by offering the following options:</p>
        <ul className="list-disc pl-5 mb-4">
          <li>Selection of default or advanced configuration</li>
          <li>Configuration of CPU, RAM, BIOS, and machine type</li>
          <li>Choice between virtual disk or physical disk passthrough</li>
          <li>Selection of disk interface type (SCSI, SATA, VirtIO, or IDE)</li>
          <li>Automatic configuration of EFI and TPM for secure boot</li>
          <li>Automatic VirtIO drivers setup for optimal performance</li>
        </ul>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Default and Advanced Configuration
          </h3>
          <p className="mb-3">The script offers two configuration modes:</p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Zap className="h-5 w-5 mr-2 text-green-500" />
            Default Configuration
          </h4>
          <p className="mb-3">
            If you select default configuration, the script will automatically apply the following values:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Default Value</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">4</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">8192 MB</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">vmbr0</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Automatically generated</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">TPM</td>
                  <td className="py-2 px-4 border-b border-gray-200">Enabled (v2.0)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Start VM on Completion</td>
                  <td className="py-2 px-4 border-b border-gray-200">No</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p className="mb-4">
            If you want to customize the configuration, select the Advanced Settings option in the menu.
          </p>

          <h4 className="text-lg font-medium mt-12 mb-2 flex items-center">
            <Sliders className="h-5 w-5 mr-2 text-orange-500" />
            Advanced Configuration
          </h4>
          <p className="mb-3">
            If you select advanced configuration, the script will allow you to customize each parameter:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Parameter</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Options</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Machine Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">q35 or i440fx</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">BIOS Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">OVMF (UEFI) or SeaBIOS (Legacy)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">CPU Type</td>
                  <td className="py-2 px-4 border-b border-gray-200">Host or KVM64</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Core Count</td>
                  <td className="py-2 px-4 border-b border-gray-200">Number of CPU cores</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">RAM Size</td>
                  <td className="py-2 px-4 border-b border-gray-200">Amount of memory allocated to the VM</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">Bridge</td>
                  <td className="py-2 px-4 border-b border-gray-200">Network bridge for connection</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MAC Address</td>
                  <td className="py-2 px-4 border-b border-gray-200">Custom MAC address</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN</td>
                  <td className="py-2 px-4 border-b border-gray-200">VLAN tag (if used)</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">MTU</td>
                  <td className="py-2 px-4 border-b border-gray-200">Maximum Transmission Unit size</td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">TPM</td>
                  <td className="py-2 px-4 border-b border-gray-200">Enable or disable TPM</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Interface Selection
          </h3>
          <p className="mb-3">
            The script allows you to choose the disk interface type for both virtual and physical disks:
          </p>

          <div className="overflow-x-auto mb-4">
            <table className="min-w-full bg-white border border-gray-200">
              <thead>
                <tr>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Interface Type</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Description</th>
                  <th className="py-2 px-4 border-b border-gray-200 bg-gray-50 text-left">Best For</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SCSI</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Modern interface with good performance and features
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Recommended for Windows 10/11 (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">SATA</td>
                  <td className="py-2 px-4 border-b border-gray-200">Standard interface with high compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Good general-purpose choice (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">VirtIO</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Paravirtualized interface with highest performance
                  </td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Advanced users seeking maximum performance (includes discard/trim support)
                  </td>
                </tr>
                <tr>
                  <td className="py-2 px-4 border-b border-gray-200">IDE</td>
                  <td className="py-2 px-4 border-b border-gray-200">Legacy interface with maximum compatibility</td>
                  <td className="py-2 px-4 border-b border-gray-200">
                    Legacy Windows systems only (no discard/trim support)
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>

                <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <HardDrive className="h-5 w-5 mr-2 text-blue-500" />
            Disk Selection
          </h3>
          <p className="mb-3">
            Once the machine is configured, the script allows you to choose between two types of disks:
          </p>

          <h4 className="text-lg font-medium mt-4 mb-2">Virtual Disk</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script lists the storage options available in Proxmox</li>
            <li>The user selects the disk and size in GB</li>
            <li>
              The virtual disk is automatically assigned to the VM using the selected interface type (SCSI, SATA,
              VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>

          <h4 className="text-lg font-medium mt-4 mb-2">Physical Disk Passthrough</h4>
          <ul className="list-disc pl-5 mb-4">
            <li>The script detects all available physical disks</li>
            <li>The user selects the physical disk or disks they want to use</li>
            <li>
              The physical disk is directly assigned to the VM via passthrough using the selected interface type (SCSI,
              SATA, VirtIO, or IDE)
            </li>
            <li>
              Multiple disks can be added and will be assigned sequential device numbers (e.g., scsi0, scsi1, etc.)
            </li>
          </ul>
        </div>

        <div className="mt-8">
          <h3 className="text-xl font-semibold mb-3 flex items-center">
            <Settings className="h-5 w-5 mr-2 text-blue-500" />
            Additional Features
          </h3>

          <h4 className="text-lg font-medium mt-4 mb-2">EFI Disk Configuration</h4>
          <p className="mb-3">
            When UEFI BIOS (OVMF) is selected, the script automatically configures an EFI system disk to ensure compatibility with modern bootloaders:
          </p>
          <ul className="list-disc pl-5 mb-4">
            <li>Youâ€™ll be prompted to select the storage location for the EFI disk</li>
            <li>A 4MB EFI disk is created and attached to the VM</li>
            <li>The disk is formatted appropriately based on the selected storage backend (e.g., raw format for directory-based storage)</li>
          </ul>
          <p className="mb-4">
            For Windows systems, a <strong>TPM 2.0 device</strong> is also added automatically to meet installation requirements for modern versions like Windows 11 and Windows Server 2022.
          </p>

          <h4 className="text-lg font-medium mt-4 mb-2">ISO Mounting</h4>
          <p className="mb-3">
            The script also handles ISO mounting automatically for both installation media and optional drivers:
          </p>
          <ul className="list-disc pl-5 mb-4">
            <li>The main installation ISO is mounted to the first available IDE slot (typically <code>ide2</code>)</li>
            <li>If the system is Windows, the VirtIO drivers ISO is downloaded and mounted to the next IDE slot (typically <code>ide3</code>)</li>
          </ul>


          <h4 className="text-lg font-medium mt-4 mb-2">QEMU Guest Agent</h4>
          <p className="mb-3">The script automatically configures QEMU Guest Agent support:</p>
          <ul className="list-disc pl-5 mb-4">
            <li>Enables the QEMU Guest Agent in the VM configuration</li>
            <li>Sets up the necessary communication channel</li>
            <li>Provides instructions for installing the guest agent inside the VM after installation</li>
          </ul>
        </div>

        <div className="mt-12">
          <h2 className="text-2xl font-bold mb-6 text-black">Windows Installation Options</h2>
          <p className="mb-6">ProxMenux offers two methods for installing Windows on your virtual machine:</p>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
            <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
              <div className="flex items-center gap-3 mb-4">
                <div className="w-12 h-12 flex items-center justify-center">
                  <Image
                    src="https://uupdump.net/static/images/logo.svg"
                    alt="UUP Dump Logo"
                    width={48}
                    height={48}
                    className="object-contain"
                  />
                </div>
                <h3 className="text-xl font-semibold">Script UUP Dump ISO Creator</h3>
              </div>

              <p className="mb-4">
                 The <strong>UUP Dump ISO Creator</strong> script is a utility included in <strong>ProxMenux</strong> that allows you to 
                 download and create Windows installation media directly from Microsoft's Windows Update servers. 
                 This option provides access to the latest Windows builds, including Insider Preview versions.
              </p>

              <h4 className="font-medium mb-2">Features:</h4>
              <ul className="list-disc pl-5 mb-4 space-y-1">
                <li>Access to the latest Windows builds</li>
                <li>Ability to download Insider Preview versions</li>
                <li>Clean, official Microsoft installation files</li>
                <li>Automatic ISO creation and mounting</li>
                <li>Support for various Windows editions (Home, Pro, Enterprise)</li>
              </ul>

              <p className="mt-4 text-sm text-blue-600">
                <Link href="/docs/utils/UUp-Dump-ISO-Creator" className="hover:underline">
                  Learn more about UUP Dump ISO Creator 
                </Link>
              </p>
            </div>

            <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
              <div className="flex items-center gap-3 mb-4">
                <Server className="h-12 w-12 text-blue-500" />
                <h3 className="text-xl font-semibold">Install with Local ISO</h3>
              </div>

              <p className="mb-4">
                This option allows you to use your own Windows ISO file that's already uploaded to your Proxmox server's
                local storage. Ideal if you have custom or specific Windows installation media.
              </p>

              <div className="mt-4">
                <ImageWithCaption
                  src="https://macrimi.github.io/ProxMenux/vm/local-store-windows.png"
                  alt="Local ISO Selection Menu"
                  caption="Local ISO Selection Menu in ProxMenux"
                />
              </div>
            </div>
          </div>
        </div>

                <div className="mt-8 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 className="text-xl font-bold mb-4 text-black">Installation Process</h2>
          <p className="mb-4">
            After configuring the VM settings and selecting your installation method, the script will:
          </p>
          <ol className="list-decimal pl-5 space-y-2">
            <li>Create the VM with the specified configuration</li>
            <li>Configure EFI disk and TPM for secure boot support</li>
            <li>Create and attach virtual disks or pass through physical disks</li>
            <li>Download and mount the Windows ISO (UUP Dump option) or mount your local ISO</li>
            <li>Download and mount the VirtIO drivers ISO</li>
            <li>Set the boot order (disk first, then ISO)</li>
            <li>Configure the QEMU Guest Agent</li>
            <li>Start the VM if requested</li>
          </ol>
        </div>

        <div className="mt-12 p-6 bg-gray-50 rounded-lg border border-gray-200">
          <h2 className="text-xl font-bold mb-4 text-black">VirtIO Drivers Setup</h2>
          <p className="mb-4">
            For optimal performance, Windows VMs require VirtIO drivers. The script automatically handles this by:
          </p>
          <ul className="list-disc pl-5 space-y-2">
            <li>Downloading the latest VirtIO drivers ISO or using an existing one</li>
            <li>Mounting the VirtIO drivers ISO to the VM</li>
            <li>Providing instructions for loading the drivers during Windows installation</li>
          </ul>
          <p className="mt-4">
            If you select a <strong>SCSI</strong> or <strong>VirtIO</strong> disk interface for the virtual machine, 
            Windows installation will not detect the disk by default. In this case, you must click <em>"Load Driver"</em> during the disk selection 
            step and browse to the mounted VirtIO ISO to install the necessary storage drivers.
            <br />
            These interfaces offer significantly better performance compared to traditional <strong>SATA</strong> disks, 
            and are therefore recommended for optimal disk I/O.
          </p>
        </div>

        <section className="mb-8">
          <h2 className="text-2xl font-semibold mt-20 mb-4 flex items-center">
            <Target className="h-6 w-6 mr-2 text-blue-500" />
            Tips
          </h2>
          <ul className="list-disc pl-5 space-y-4">

            <li>
              If you select <strong>VirtIO</strong> as the <strong>network interface</strong> (recommended for performance), 
              you must also install the VirtIO network drivers from the same ISO. This ensures that the Windows installer can access 
              the network to complete updates or activate the system.
            </li>

            <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
              <p className="font-semibold">Important:</p>
              <p>
                Without the VirtIO network driver, the virtual machine will not have internet access during installation,
                which may prevent Windows from completing activation or downloading necessary updates.
              </p>
            </div>
          </ul>
        </section>


        <div className="mt-6 space-y-8">
          {/* Step 1 */}
          <div>
            <h3 className="text-lg font-medium mb-3">
              Step 1: Access the "Where do you want to install Windows?" screen
            </h3>
            <p className="mb-3">
              During Windows installation, if no disks are shown on the â€œWhere do you want to install Windows?â€ screen, it means the required storage drivers for your selected disk interface (such as SCSI or VirtIO) are not available. You'll need to load them manually.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/vm/windows/virtio-step-1.png"
              alt="Windows installation - No disks shown"
              caption="Windows installation screen with no disks available"
            />
          </div>

          {/* Step 2 */}
          <div>
            <h3 className="text-lg font-medium mb-3">Step 2: Click "Load driver"</h3>
            <p className="mb-3">
              Click the â€œLoad driverâ€ button to browse the mounted VirtIO ISO. This will allow you to load the necessary storage drivers so Windows can detect the virtual disk.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/vm/windows/virtio-step-2.png"
              alt="Windows installation - Load driver button"
              caption="Click 'Load driver' to browse for VirtIO drivers"
            />
          </div>

          {/* Step 3 */}
          <div>
            <h3 className="text-lg font-medium mb-3">Step 3: Browse to the correct driver location</h3>
            <p className="mb-3">
              On the mounted VirtIO ISO, navigate to the appropriate driver folder that matches your selected disk interface and Windows version.
              For example, the <code className="bg-gray-100 px-1 py-0.5 rounded">viostor</code> folder contains storage drivers, and you'll find subfolders organized by version (e.g., Windows 10, 11, Server).
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/vm/windows/virtio-step-3.png"
              alt="Windows installation - Browse for driver"
              caption="Browse to the appropriate driver folder on the VirtIO ISO"
            />
          </div>

          {/* Step 4 */}
          <div>
            <h3 className="text-lg font-medium mb-3">Step 4: Select the appropriate driver</h3>
            <p className="mb-3">
              After selecting the folder, Windows will list the available drivers. Choose the appropriate one â€” usually â€œRed Hat VirtIO SCSI controllerâ€ â€” and click â€œNextâ€ to proceed with the installation.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/vm/windows/virtio-step-4.png"
              alt="Windows installation - Select driver"
              caption="Select the appropriate VirtIO driver for your disk interface"
            />
          </div>

          {/* Step 5 */}
          <div>
            <h3 className="text-lg font-medium mb-3">Step 5: Install network drivers (recommended)</h3>
            <p className="mb-3">
              <strong>Pro Tip:</strong> If you selected <strong>VirtIO</strong> as the network interface, Windows will not recognize it by default. To enable internet access during installation, load the VirtIO network driver from the ISO by browsing to the <code className="bg-gray-100 px-1 py-0.5 rounded">NetKVM</code> folder and selecting the correct subfolder for your Windows version.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/vm/windows/virtio-step-5.png"
              alt="Windows installation - Network drivers"
              caption="Select the appropriate VirtIO network driver to enable internet access"
            />
          </div>


          {/* Post-installation block */}
          <div className="mt-6 bg-blue-50 border border-blue-200 rounded-md p-4">
            <h3 className="text-lg font-medium mb-2 text-blue-800">Post-Installation Driver Setup</h3>
            <p className="text-blue-800">
              After the Windows installation is complete, it's recommended to install the remaining VirtIO drivers for full hardware support and optimal performance.
              To do this, open the mounted VirtIO ISO in File Explorer and run the installer named{" "}
              <code className="bg-white px-1 py-0.5 rounded text-sm">virtio-win-guest-tools.exe</code>. This will install drivers for network, display, input, ballooning, and other virtualized components.
            </p>
          </div>
        </div>


      </div>
    </div>
  )
}



================================================
FILE: web/app/docs/external-repositories/page.tsx
================================================
import type { Metadata } from "next"
import { Link2 } from "lucide-react"
import Link from "next/link"

export const metadata: Metadata = {
  title: "ProxMenux - External Repositories",
  description:
    "Learn about the external repositories used in ProxMenux, how they are selected, and how to report issues or suggest new integrations.",
  openGraph: {
    title: "ProxMenux - External Repositories",
    description:
      "Learn about the external repositories used in ProxMenux, how they are selected, and how to report issues or suggest new integrations.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/external-repositories",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/external-repos-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux External Repositories",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux - External Repositories",
    description:
      "Learn about the external repositories used in ProxMenux, how they are selected, and how to report issues or suggest new integrations.",
    images: ["https://macrimi.github.io/ProxMenux/external-repos-image.png"],
  },
}

function SectionHeader({ number, title }: { number: number; title: string }) {
  return (
    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
      <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
        <span className="text-sm font-bold">{number}</span>
      </div>
      {title}
    </h3>
  )
}

export default function ExternalRepositoriesPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Link2 className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">External Repositories</h1>
      </div>

      {/* Introduction */}
      <p className="mb-4">
        ProxMenux integrates with selected external repositories to provide alternative scripts for various
        functionalities. These scripts come from <strong>trusted sources</strong> and serve as additional options in
        some menu sections.
      </p>
      <p className="mb-4">
        When an external script is available as an alternative, ProxMenux will clearly indicate that it originates from
        an external repository and specify which one.
      </p>

      {/* 1ï¸âƒ£ Example of External Repository */}
      <SectionHeader number={1} title="Example of External Repositories" />
      <p className="mb-4">Essential repositories for Proxmox VE users include:</p>
      <p className="mb-4">
        <Link
          href="https://community-scripts.github.io/ProxmoxVE/"
          className="text-blue-500 hover:underline"
          target="_blank"
        >
          Proxmox VE Helper-Scripts
        </Link>{" "}
        - A highly recommended repository that provides additional tools and utilities for managing Proxmox VE more
        efficiently.
      </p>
      <p className="mb-4">
        <Link href="https://github.com/R0GGER/proxmox-zimaos" className="text-blue-500 hover:underline" target="_blank">
          Proxmox ZimaOS
        </Link>{" "}
        - Script para instalar una VM del sistema NAS ZimaOS en menos de 5 minutos.
      </p>

      {/* 2ï¸âƒ£ Attribution & Recognition */}
      <SectionHeader number={2} title="Attribution & Recognition" />
      <ul className="list-disc list-inside mb-4 ml-4">
        <li>Credit is always given to the original authors.</li>
        <li>A link to the source repository is provided.</li>
        <li>Users are encouraged to support the developers of these external projects.</li>
      </ul>

      {/* 3ï¸âƒ£ Reporting Issues with External Scripts */}
      <SectionHeader number={3} title="Reporting Issues with External Scripts" />
      <p className="mb-4">
        If you encounter an issue with an external script,{" "}
        <strong>please report it directly to the original repository</strong> instead of opening an issue in the
        ProxMenux repository.
      </p>
      <p className="mb-4">
        <strong>ProxMenux does not modify external scripts</strong>; it simply provides a link to the original source.
        Therefore, any problems related to functionality should be reported to the respective developers.
      </p>

      {/* 4ï¸âƒ£ Suggesting New External Repositories */}
      <SectionHeader number={4} title="Suggesting New External Repositories" />
      <p className="mb-4">
        If you know of a script or repository that could enhance ProxMenux, feel free to suggest it by opening a
        discussion or issue in our GitHub repository.
      </p>
      <p className="mb-4">
        ğŸ”—{" "}
        <Link
          href="https://github.com/MacRimi/ProxMenux/discussions"
          className="text-blue-500 hover:underline"
          target="_blank"
        >
          Open a Discussion
        </Link>{" "}
        |{" "}
        <Link
          href="https://github.com/MacRimi/ProxMenux/issues"
          className="text-blue-500 hover:underline"
          target="_blank"
        >
          Report an Issue
        </Link>
      </p>
    </div>
  )
}



================================================
FILE: web/app/docs/hardware/coral-tpu-lxc/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"
import Image from "next/image"

export const metadata = {
  title: "Enable Coral TPU in LXC | ProxMenux Documentation",
  description: "Step-by-step guide to enable Google Coral TPU support in an LXC container using ProxMenux.",
}

export default function CoralTPULXC() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Enable Coral TPU in an LXC</h1>

      <p className="mb-4">
        This guide explains how to configure Google Coral TPU support for LXC containers in Proxmox VE using <strong>ProxMenux</strong>.
        Coral TPU provides dedicated AI acceleration, improving inference performance for machine learning applications. It is particularly useful for video surveillance applications with real-time video analysis, such as <a href='https://frigate.video/' target='_blank' className='text-blue-600 hover:underline'>Frigate</a> or <a href='https://www.ispyconnect.com' target='_blank' className='text-blue-600 hover:underline'>Agent DVR</a> or <a href='https://blueirissoftware.com/' target='_blank' className='text-blue-600 hover:underline'>Blue Iris</a> using <a href='https://www.codeproject.com/ai/index.aspx' target='_blank' className='text-blue-600 hover:underline'>CodeProject.AI</a>.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview</h2>
      <p className="mb-4">The script automates the complete configuration of Coral TPU support in LXC containers, including USB and M.2 variants. It applies Proxmox-specific container settings, manages device passthrough permissions, and installs required drivers both on the host and inside the container.</p>
      <p className="mb-4">The USB variant uses a persistent mapping based on <code>/dev/coral</code> via <code>udev</code> rules, avoiding reliance on dynamic USB paths like <code>/dev/bus/usb/*</code>. This ensures consistent device assignment across reboots and hardware reordering.</p>
      <p className="mb-4">The M.2 version is detected automatically and configured only if present.</p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Implementation Steps</h2>
      <Steps>
        <Steps.Step title="Select an LXC Container">
          <p>The script lists available LXC containers and prompts for selection.</p>
        </Steps.Step>
        <Steps.Step title="Modify Container Configuration">
          <p>The script applies necessary changes to enable Coral TPU:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Switches the container to privileged mode if required.</li>
            <li>Enables nesting to allow GPU and TPU usage.</li>
            <li>Sets device permissions for TPU and iGPU.</li>
            <li>Configures proper device mounts.</li>
          </ul>
          <CopyableCode
            code={`# Coral USB persistent passthrough example:
/etc/udev/rules.d/99-coral-usb.rules
SUBSYSTEM=="usb", ATTRS{idVendor}=="18d1", ATTRS{idProduct}=="9302", SYMLINK+="coral", MODE="0666"

# LXC config:
lxc.cgroup2.devices.allow: c 189:* rwm
lxc.mount.entry: /dev/coral dev/coral none bind,optional,create=file`}
            className="my-4"
          />
          <CopyableCode
            code={`# Coral M.2 passthrough example (automatically added if detected):
lxc.cgroup2.devices.allow: c 245:0 rwm
lxc.mount.entry: /dev/apex_0 dev/apex_0 none bind,optional,create=file`}
            className="my-4"
          />
        </Steps.Step>
        <Steps.Step title="Install Required Drivers">
          <p>The script installs the necessary components inside the container:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>GPU drivers:</li>
            <ul className="list-disc pl-10">
              <li><code>va-driver-all</code></li>
              <li><code>ocl-icd-libopencl1</code></li>
              <li><code>intel-opencl-icd</code></li>
              <li><code>vainfo</code></li>
              <li><code>intel-gpu-tools</code></li>
            </ul>
            <li>Coral TPU dependencies:</li>
            <ul className="list-disc pl-10">
              <li><code>python3</code></li>
              <li><code>python3-pip</code></li>
              <li><code>python3-venv</code></li>
              <li><code>gnupg</code></li>
              <li><code>curl</code></li>
            </ul>
            <li>Coral TPU drivers:</li>
            <ul className="list-disc pl-10">
              <li><code>libedgetpu1-std</code> (standard performance)</li>
              <li><code>libedgetpu1-max</code> (maximum performance, optional)</li>
            </ul>
          </ul>
        </Steps.Step>
        <Steps.Step title="Select Coral TPU Driver Version">
          <p>If a Coral M.2 device is detected, the script prompts the user to select:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li><strong>Standard mode</strong> - balanced performance.</li>
            <li><strong>Maximum performance mode</strong> - higher speed, increased power usage.</li>
          </ul>
        </Steps.Step>
      </Steps>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The selected container is correctly configured for TPU and iGPU usage.</li>
        <li>Required drivers and dependencies are installed inside the container.</li>
        <li>The container will restart as needed during the process.</li>
        <li>After completion, applications inside the container can utilize Coral TPU acceleration.</li>
      </ul>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The script supports both USB and M.2 Coral TPU devices.</li>
        <li>The Proxmox host must have the required Coral TPU and Intel GPU drivers installed.</li>
        <li>Additional application-specific configurations may be required inside the container.</li>
        <li>Coral USB passthrough uses a persistent device alias <code>/dev/coral</code> created by a udev rule. This improves stability and avoids issues with changing USB port identifiers.</li>
        <li>Coral M.2 devices are detected dynamically using <code>lspci</code> and configured only if present.</li>
      </ul>
    </div>
  )
}



================================================
FILE: web/app/docs/hardware/igpu-acceleration-lxc/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"
import Image from "next/image"

export const metadata = {
  title: "Enable iGPU Acceleration in LXC | ProxMenux Documentation",
  description: "Step-by-step guide to enable Intel iGPU acceleration in an LXC container using ProxMenux.",
}

export default function IGPUAccelerationLXC() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Enable Intel iGPU Acceleration in an LXC</h1>
      
      <p className="mb-4">
        This guide explains how to configure Intel Integrated GPU (iGPU) acceleration for LXC containers in Proxmox VE
        using <strong>ProxMenux</strong>. Enabling iGPU support allows containers to use the hostâ€™s GPU for hardware acceleration
        in applications such as video transcoding and rendering.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview of the Process</h2>
      <p className="mb-4">When you run this script in ProxMenux, it performs the following steps:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Prompts you to select an existing LXC container.</li>
        <li>Checks if the container is privileged and adjusts its settings accordingly.</li>
        <li>Modifies the containerâ€™s configuration to allow GPU access.</li>
        <li>Installs the required Intel GPU drivers inside the container.</li>
      </ol>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Step-by-Step Guide</h2>
      <Steps>
        <Steps.Step title="Select an LXC Container">
          <p>You will be presented with a list of your LXC containers to choose from.</p>
          <Image src="https://macrimi.github.io/ProxMenux/igpu/select-container.png" alt="Select LXC Container" width={800} height={400} className="rounded shadow-lg" />
        </Steps.Step>
        <Steps.Step title="Modify Container Configuration">
          <p>The script applies the following changes to your container:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Switches to privileged mode if required.</li>
            <li>Enables the nesting feature.</li>
            <li>Grants permissions for GPU access.</li>
            <li>Configures necessary device mounts.</li>
          </ul>
        </Steps.Step>
        <Steps.Step title="Install Intel GPU Drivers">
          <p>Inside the container, the following GPU-related packages will be installed:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li><strong>va-driver-all</strong> - Video acceleration drivers</li>
            <li><strong>ocl-icd-libopencl1</strong> - OpenCL runtime</li>
            <li><strong>intel-opencl-icd</strong> - Intel OpenCL implementation</li>
            <li><strong>vainfo</strong> - Tool to verify VAAPI support</li>
            <li><strong>intel-gpu-tools</strong> - Intel GPU debugging tools</li>
          </ul>
        </Steps.Step>
      </Steps>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Outcome</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Your LXC container will be configured for Intel iGPU acceleration.</li>
        <li>The required GPU drivers and tools will be installed inside the container.</li>
        <li>The container will briefly stop and restart as part of the setup.</li>
        <li>After completion, applications inside the container will be able to leverage the GPU for acceleration.</li>
      </ul>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Notes</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>This script is designed specifically for Intel iGPUs.</li>
        <li>Some applications inside the container may need additional setup to use the GPU.</li>
      </ul>
      
    </div>
  )
}



================================================
FILE: web/app/docs/hardware/install-coral-tpu-host/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"

export const metadata = {
  title: "Install Coral TPU on the Host | ProxMenux Documentation",
  description: "Step-by-step guide to install Google Coral TPU drivers on a Proxmox VE host using ProxMenux.",
}

export default function InstallCoralTPUHost() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Install Coral TPU on the Host</h1>

      <p className="mb-4">
        <strong>Before using Coral TPU inside an LXC container, the drivers must first be installed on the Proxmox VE host. This script automates that process, ensuring the necessary setup is completed.</strong>
        <br /><br />
        This guide explains how to install and configure Google Coral TPU drivers on a Proxmox VE host using <strong>ProxMenux</strong>. This setup enables hardware acceleration for AI-based applications that leverage Coral TPU.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview</h2>
      <p className="mb-4">The script automates the following steps:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Prompts for confirmation before proceeding with installation.</li>
        <li>Verifies and configures necessary repositories on the host.</li>
        <li>Installs required build dependencies and kernel headers for driver compilation.</li>
        <li>Clones the Coral TPU driver repository and builds the drivers.</li>
        <li>Installs the compiled Coral TPU drivers.</li>
        <li>Prompts for a system restart to apply changes.</li>
      </ol>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Implementation Steps</h2>
      <Steps>
        <Steps.Step title="Pre-Installation Confirmation">
          <p>The script prompts the user for confirmation before proceeding, as a system restart is required after installation.</p>
        </Steps.Step>

        <Steps.Step title="Repository Configuration">
          <p>The script verifies and configures required repositories:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Adds the <strong>pve-no-subscription</strong> repository if not present.</li>
            <li>Adds <strong>non-free-firmware</strong> repositories for required packages.</li>
            <li>Runs <code>apt-get update</code> to fetch the latest package lists.</li>
          </ul>
        </Steps.Step>

        <Steps.Step title="Driver Installation">
          <p>The script installs and compiles the required Coral TPU drivers:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Installs the following packages:</li>
            <ul className="list-disc pl-10">
              <li><code>git</code></li>
              <li><code>devscripts</code></li>
              <li><code>dh-dkms</code></li>
              <li><code>dkms</code></li>
              <li><code>pve-headers-$(uname -r)</code> (Proxmox kernel headers)</li>
            </ul>
            <li>Clones the Coral TPU driver source from:</li>
            <ul className="list-disc pl-10">
              <li><code>https://github.com/google/gasket-driver</code></li>
            </ul>
            <li>Builds the driver using <code>debuild</code> and installs it using <code>dpkg -i</code>.</li>
          </ul>

          <CopyableCode
            code={`# Commands used to build and install Coral TPU driver on host
apt install -y git devscripts dh-dkms dkms pve-headers-$(uname -r)
git clone https://github.com/google/gasket-driver.git
cd gasket-driver
debuild -us -uc -tc -b
dpkg -i ../gasket-dkms_*.deb`}
            className="my-4"
          />
        </Steps.Step>

        <Steps.Step title="Post-Installation Confirmation">
          <p>The script prompts the user to restart the server to apply the changes.</p>
        </Steps.Step>
      </Steps>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The Coral TPU drivers are installed successfully on the Proxmox VE host.</li>
        <li>Required repositories and dependencies are configured properly.</li>
        <li>A system restart is performed to complete the installation.</li>
      </ul>
    </div>
  )
}



================================================
FILE: web/app/docs/help-info/page.tsx
================================================
import type React from "react"
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import {
  ArrowRight,
  Terminal,
  HardDrive,
  Network,
  Package,
  Cpu,
  Database,
  Archive,
  PenToolIcon as Tool,
  BookOpenCheck,
  Book,
} from "lucide-react"


export const metadata: Metadata = {
  title: "ProxMenux Documentation: Help and Info",
  description:
    "Comprehensive collection of useful commands and references for Proxmox VE, organized by category for easy access and quick reference.",
  openGraph: {
    title: "ProxMenux Documentation: Help and Info",
    description:
      "Comprehensive collection of useful commands and references for Proxmox VE, organized by category for easy access and quick reference.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/help-info",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/help/help-info-menu.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Help and Info Menu",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: Help and Info",
    description:
      "Comprehensive collection of useful commands and references for Proxmox VE, organized by category for easy access and quick reference.",
    images: ["https://macrimi.github.io/ProxMenux/help/help-info-menu.png"],
  },
}


interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg"}
          alt={alt}
          width={768}
          height={0}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function HelpAndInfoPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-10">
        <div className="flex items-center gap-3 mb-6">
          <BookOpenCheck className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Help and Info Menu</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            ProxMenux provides an interactive command reference menu for Proxmox VE through a dialog-based interface.
            Select one of the categories below to explore the available commands.
          </p>


          <p className="text-black">
            Each category contains commands with descriptions, making it easier to find exactly what
            you need when you need it. This eliminates the need to remember complex command syntax or search through
            documentation when performing administrative tasks.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/help/help-info-menu.png"
        alt="Help and Info Menu"
        caption="Help and Info Menu"
      />

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mt-10">
        <CommandCard
          title="Useful System Commands"
          description="Basic commands to manage and monitor the Proxmox system"
          icon={<Terminal className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/system-commands"
        />

        <CommandCard
          title="VM and CT Management"
          description="Commands to manage virtual machines and containers"
          icon={<Cpu className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/vm-ct-commands"
        />

        <CommandCard
          title="Storage and Disks"
          description="Commands to manage storage devices and partitions"
          icon={<HardDrive className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/storage-commands"
        />

        <CommandCard
          title="Network Commands"
          description="Commands to configure and monitor the network"
          icon={<Network className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/network-commands"
        />

        <CommandCard
          title="Updates and Packages"
          description="Commands to update the system and manage packages"
          icon={<Package className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/update-commands"
        />

        <CommandCard
          title="GPU Passthrough"
          description="Commands to configure and manage GPU passthrough"
          icon={<Cpu className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/gpu-commands"
        />

        <CommandCard
          title="ZFS Management"
          description="Commands to manage ZFS file systems"
          icon={<Database className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/zfs-commands"
        />

        <CommandCard
          title="Backup and Restore"
          description="Commands to perform and manage backups"
          icon={<Archive className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/backup-commands"
        />

        <CommandCard
          title="System CLI Tools"
          description="Useful command-line tools for administration"
          icon={<Tool className="h-8 w-8 text-blue-500" />}
          href="/docs/help-info/tools-commands"
        />
      </div>

      <div className="mt-16 mb-6">
        <div className="flex items-center gap-3 mb-6">
          <Book className="h-8 w-8 mr-2 text-blue-500" />
          <h2 className="text-2xl font-bold text-black">ProxMenux Guides</h2>
        </div>

        <p className="text-lg mb-6 text-black">
          Check out the guides section for additional resources, tutorials, and documentation to help you get the most
          out of Proxmox VE and ProxMenux.
        </p>

        <div className="flex justify-center">
          <Link
            href="/guides"
            className="inline-flex items-center px-6 py-3 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
          >
            View Guides <ArrowRight className="ml-2 h-5 w-5" />
          </Link>
        </div>
      </div>
    </div>
  )
}

interface CommandCardProps {
  title: string
  description: string
  icon: React.ReactNode
  href: string
}

function CommandCard({ title, description, icon, href }: CommandCardProps) {
  return (
    <Card className="transition-all duration-300 hover:shadow-md hover:border-blue-300 bg-white text-black border-2 border-gray-200">
      <CardHeader>
        <div className="flex items-center gap-3">
          {icon}
          <CardTitle className="text-xl text-black">{title}</CardTitle>
        </div>
      </CardHeader>
      <CardContent>
        <CardDescription className="text-base text-gray-600">{description}</CardDescription>
      </CardContent>
      <CardFooter>
        <Link href={href} className="flex items-center text-blue-500 hover:text-blue-700 transition-colors">
          View commands <ArrowRight className="ml-2 h-4 w-4" />
        </Link>
      </CardFooter>
    </Card>
  )
}



================================================
FILE: web/app/docs/help-info/backup-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Archive, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function BackupRestorePage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "VM Backup",
      commands: [
        { command: "vzdump <vmid>", description: "Create a backup of a specific VM/CT" },
        { command: "vzdump <vmid> --storage <storage>", description: "Backup VM to specific storage" },
        { command: "vzdump <vmid> --mode snapshot", description: "Create snapshot backup (for VMs)" },
        { command: "vzdump <vmid> --mode suspend", description: "Suspend VM during backup" },
        { command: "vzdump <vmid> --mode stop", description: "Stop VM during backup" },
        { command: "vzdump --all", description: "Backup all VMs and containers" },
        { command: "vzdump --exclude <vmid1>,<vmid2>", description: "Backup all except specified VMs" },
      ],
    },
    {
      title: "Backup Options",
      commands: [
        { command: "vzdump <vmid> --compress zstd", description: "Use zstd compression for backup" },
        { command: "vzdump <vmid> --pigz <threads>", description: "Use pigz with multiple threads" },
        { command: "vzdump <vmid> --notes <text>", description: "Add notes to backup" },
        { command: "vzdump <vmid> --mailto <email>", description: "Send notification email" },
        { command: "vzdump <vmid> --maxfiles <n>", description: "Keep only n backups per VM" },
        { command: "vzdump <vmid> --stdexcludes 0", description: "Don't exclude temporary files" },
        { command: "vzdump <vmid> --quiet 1", description: "Suppress output messages" },
      ],
    },
    {
      title: "Restore Backups",
      commands: [
        { command: "qmrestore <backup-file> <vmid>", description: "Restore VM from backup" },
        { command: "qmrestore <backup-file> <vmid> --storage <storage>", description: "Restore to specific storage" },
        { command: "qmrestore <backup-file> <vmid> --unique", description: "Create a VM with unique ID" },
        { command: "pct restore <vmid> <backup-file>", description: "Restore container from backup" },
        {
          command: "pct restore <vmid> <backup-file> --storage <storage>",
          description: "Restore container to specific storage",
        },
        { command: "pct restore <vmid> <backup-file> --rootfs <storage>", description: "Restore to specific rootfs" },
        { command: "pct restore <vmid> <backup-file> --unprivileged 1", description: "Restore as unprivileged CT" },
      ],
    },
    {
      title: "Backup Management",
      commands: [
        { command: "ls -la /var/lib/vz/dump/", description: "List backups in default location" },
        { command: 'find /var/lib/vz/dump/ -name "*.vma*"', description: "Find VM backups" },
        { command: 'find /var/lib/vz/dump/ -name "*.tar*"', description: "Find container backups" },
        { command: "pvesm list <storage>", description: "List backups in specific storage" },
        { command: "rm /var/lib/vz/dump/<backup-file>", description: "Delete a backup file" },
        { command: "cat /etc/vzdump.conf", description: "Show backup configuration" },
      ],
    },
    {
      title: "Scheduled Backups",
      commands: [
        { command: "cat /etc/cron.d/vzdump", description: "Show backup schedule" },
        { command: "nano /etc/vzdump.conf", description: "Edit backup configuration" },
        { command: "systemctl list-timers", description: "List all scheduled tasks" },
        { command: "systemctl status cron", description: "Check cron service status" },
        { command: "grep vzdump /var/log/syslog", description: "Check backup logs in syslog" },
        { command: "tail -f /var/log/vzdump.log", description: "Monitor backup log in real-time" },
      ],
    },
    {
      title: "Advanced Operations",
      commands: [
        { command: "qmrestore <backup> <vmid> --force", description: "Force restore, overwriting existing VM" },
        { command: "vzdump <vmid> --dumpdir <directory>", description: "Specify custom backup directory" },
        { command: "vzdump <vmid> --script <script>", description: "Run hook script during backup" },
        { command: "vzdump <vmid> --exclude-path <path>", description: "Exclude specific paths from backup" },
        { command: "vzdump <vmid> --ionice <priority>", description: "Set I/O priority for backup process" },
        { command: "vzdump <vmid> --lockwait <minutes>", description: "Wait for lock" },
        { command: "qm importdisk <vmid> <backup> <storage>", description: "Import disk from backup" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Archive className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Backup and Restore Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for backing up and restoring virtual machines and containers in Proxmox VE.
          Learn how to create backups, restore from backups, manage backup storage, and schedule automated backups.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">Backup Best Practices</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;vmid&gt;</code> with your VM or
            container ID
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;storage&gt;</code> with your
            storage name
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;backup-file&gt;</code> with the
            path to your backup file
          </li>
          <li>Schedule regular backups during off-peak hours to minimize impact on production workloads</li>
          <li>Store backups on a separate storage device or location for better disaster recovery protection</li>
          <li>Test your backups regularly by performing test restores to ensure they are working correctly</li>
          <li>
            Use <code className="bg-gray-100 px-1 py-0.5 rounded text-black">--maxfiles</code> to implement backup
            rotation and prevent storage from filling up
          </li>
          <li>
            Consider using <code className="bg-gray-100 px-1 py-0.5 rounded text-black">--compress zstd</code> for
            better compression ratio and performance
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/gpu-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Cpu, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function GPUPassthroughPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "Device Identification",
      commands: [
        { command: "lspci -nn | grep -i nvidia", description: "List NVIDIA PCI devices" },
        { command: "lspci -nn | grep -i vga", description: "List all VGA compatible devices" },
        { command: "lspci -nn | grep -i amd", description: "List AMD PCI devices" },
        { command: "lspci -nnk | grep -A3 VGA", description: "List VGA devices with kernel drivers" },
        { command: "lspci -v -s <PCI_ID>", description: "Show detailed info for specific PCI device" },
      ],
    },
    {
      title: "VFIO Configuration",
      commands: [
        { command: "dmesg | grep -i vfio", description: "Check VFIO module messages" },
        { command: "cat /etc/modprobe.d/vfio.conf", description: "Review VFIO passthrough configuration" },
        { command: "ls -la /etc/modprobe.d/", description: "List all modprobe configuration files" },
        { command: "cat /etc/modules", description: "Show modules loaded at boot time" },
        { command: "lsmod | grep vfio", description: "Check if VFIO modules are loaded" },
      ],
    },
    {
      title: "IOMMU Configuration",
      commands: [
        { command: "cat /etc/default/grub", description: "Review GRUB options for IOMMU" },
        { command: "update-grub", description: "Apply GRUB changes" },
        { command: "dmesg | grep -i iommu", description: "Check IOMMU messages in kernel log" },
        { command: "dmesg | grep -e DMAR -e IOMMU", description: "Check DMAR and IOMMU messages" },
        { command: "find /sys/kernel/iommu_groups/ -type l | sort -V", description: "List IOMMU groups" },
      ],
    },
    {
      title: "System Updates",
      commands: [
        { command: "update-initramfs -u", description: "Apply initramfs changes (VFIO)" },
        { command: "update-initramfs -u -k all", description: "Update initramfs for all kernels" },
        { command: "cat /proc/cmdline", description: "Show current kernel boot parameters" },
      ],
    },
    {
      title: "VM Configuration",
      commands: [
        { command: "qm config <vmid> | grep hostpci", description: "Show PCI passthrough config for a VM" },
        {
          command: "qm set <vmid> -hostpci0 <PCI_ID>,pcie=1,x-vga=1",
          description: "Add GPU passthrough to a VM",
        },
        { command: "cat /etc/pve/qemu-server/<vmid>.conf", description: "View VM configuration file" },
        {
          command: "qm set <vmid> -machine q35",
          description: "Set VM to use Q35 chipset (recommended for passthrough)",
        },
        {
          command: "qm set <vmid> -bios ovmf",
          description: "Set VM to use UEFI/OVMF (required for GPU passthrough)",
        },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Cpu className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">GPU Passthrough Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for configuring and managing GPU passthrough in Proxmox VE. Learn how to
          identify GPU devices, configure VFIO and IOMMU, and set up VMs for GPU passthrough.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">GPU Passthrough Tips</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;PCI_ID&gt;</code> with your GPU's
            PCI ID (e.g., 01:00.0)
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;vmid&gt;</code> with your VM's ID
          </li>
          <li>
            For IOMMU to work, you need to enable it in BIOS/UEFI (look for settings like "VT-d", "AMD-Vi", or "IOMMU")
          </li>
          <li>
            Common GRUB parameters for IOMMU:
            <ul className="list-disc pl-5 mt-1">
              <li>
                For Intel: <code className="bg-gray-100 px-1 py-0.5 rounded text-black">intel_iommu=on</code>
              </li>
              <li>
                For AMD: <code className="bg-gray-100 px-1 py-0.5 rounded text-black">amd_iommu=on</code>
              </li>
              <li>
                Additional options:{" "}
                <code className="bg-gray-100 px-1 py-0.5 rounded text-black">
                  iommu=pt video=efifb:off video=vesa:off
                </code>
              </li>
            </ul>
          </li>
          <li>
            After making changes to GRUB or modprobe configurations, run{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">update-grub</code> and{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">update-initramfs -u</code>, then reboot
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/network-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Network, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function NetworkCommandsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "Network Information",
      commands: [
        { command: "ip a", description: "Show network interfaces and IPs" },
        { command: "ip r", description: "Show routing table" },
        { command: "ip -s link", description: "Show traffic statistics per interface" },
        { command: "brctl show", description: "Show configured network bridges" },
        { command: "cat /etc/network/interfaces", description: "Show raw network configuration" },
      ],
    },
    {
      title: "Network Testing",
      commands: [
        { command: "ping <host>", description: "Check connectivity with another host" },
        { command: "traceroute <host>", description: "Trace route to a host" },
        { command: "mtr <host>", description: "Combine ping and traceroute in real-time" },
        { command: "dig <domain>", description: "DNS lookup for a domain" },
        { command: "nslookup <domain>", description: "Alternative DNS lookup" },
      ],
    },
    {
      title: "Network Configuration",
      commands: [
        { command: "ifreload -a", description: "Reload network configuration (ifupdown2)" },
        { command: "ethtool <iface>", description: "Show Ethernet device info" },
        { command: "resolvectl status", description: "Show DNS resolution status" },
        { command: "nmcli device show", description: "Show network device details (if NetworkManager is used)" },
        { command: "ip link set <iface> up", description: "Bring network interface up" },
        { command: "ip link set <iface> down", description: "Bring network interface down" },
      ],
    },
    {
      title: "Network Monitoring",
      commands: [
        { command: "ss -tuln", description: "Show listening ports (TCP/UDP)" },
        { command: "netstat -tuln", description: "Alternative to show listening ports" },
        { command: "lsof -i", description: "List open network files and connections" },
        { command: "tcpdump -i <iface>", description: "Capture packets on interface" },
        { command: "iftop -i <iface>", description: "Monitor bandwidth usage on interface" },
      ],
    },
    {
      title: "Firewall Management",
      commands: [
        { command: "iptables -L -n -v", description: "Show active firewall rules (iptables)" },
        { command: "nft list ruleset", description: "Show nftables rules" },
        { command: "pve-firewall status", description: "Check Proxmox firewall status" },
        { command: "pve-firewall compile", description: "Compile firewall rules for all nodes" },
        { command: "pve-firewall reload", description: "Reload Proxmox firewall rules" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Network className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Network Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for configuring, monitoring, and troubleshooting network connections in Proxmox
          VE. Learn how to view network interfaces, test connectivity, configure network settings, and manage firewall
          rules.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">Usage Tips</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;host&gt;</code> with an IP address
            or hostname
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;iface&gt;</code> with your network
            interface name (e.g., eth0, vmbr0)
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;domain&gt;</code> with a domain
            name for DNS lookups
          </li>
          <li>
            Use <code className="bg-gray-100 px-1 py-0.5 rounded text-black">ip a</code> to find the names of your
            network interfaces
          </li>
          <li>
            For more detailed packet capture with tcpdump, add filters like{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">tcpdump -i eth0 port 80 -n</code> to capture
            HTTP traffic
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/storage-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { HardDrive, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function StorageCommandsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "Disk Information",
      commands: [
        { command: "lsblk", description: "List block devices and partitions" },
        { command: "fdisk -l", description: "List disks with detailed info" },
        { command: "blkid", description: "Show UUID and filesystem type of block devices" },
        { command: "ls -lh /dev/disk/by-id/", description: "List disk persistent identifiers" },
        { command: "parted -l", description: "Detailed partition layout with GPT info" },
      ],
    },
    {
      title: "Storage Usage",
      commands: [
        { command: "df -h", description: "Show disk usage by mount point" },
        { command: "du -sh /path", description: "Show size of a directory" },
        { command: "mount | grep ^/dev", description: "Show mounted storage devices" },
        { command: "cat /proc/mounts", description: "Show all active mounts from the kernel" },
      ],
    },
    {
      title: "LVM Management",
      commands: [
        { command: "pvdisplay", description: "Display physical volumes (LVM)" },
        { command: "vgdisplay", description: "Display volume groups (LVM)" },
        { command: "lvdisplay", description: "Display logical volumes (LVM)" },
        { command: "pvs", description: "Concise output of physical volumes" },
        { command: "vgs", description: "Concise output of volume groups" },
        { command: "lvs", description: "Concise output of logical volumes" },
      ],
    },
    {
      title: "Proxmox Storage",
      commands: [
        { command: "cat /etc/pve/storage.cfg", description: "Show Proxmox storage configuration" },
        { command: "pvesm status", description: "Show status of all storage pools" },
        { command: "pvesm list", description: "List all available storage" },
        { command: "pvesm list <storage>", description: "List content of specific storage" },
        { command: "pvesm scan <storage>", description: "Scan storage for new content" },
      ],
    },
    {
      title: "Disk Actions",
      commands: [
        { command: "qm importdisk <vmid> <image_path> <storage>", description: "Attach disk image to VM" },
        { command: "qm set <vmid> -<bus><index> <disk_path>", description: "Assign physical disk to VM (passthrough mode)" },
        { command: "qemu-img convert -O <format> <input> <output>", description: "Convert disk image format)" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <HardDrive className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Storage and Disks Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for managing and monitoring storage devices and disk partitions in Proxmox VE.
          Learn how to list disks, check storage usage, manage LVM volumes, and configure Proxmox storage.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">Usage Tips</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Use <code className="bg-gray-100 px-1 py-0.5 rounded text-black">lsblk</code> for a quick overview of all
            block devices
          </li>
          <li>
            For detailed partition information,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">fdisk -l</code> provides comprehensive output
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;storage&gt;</code> with your
            storage name when using pvesm commands
          </li>
          <li>
            LVM commands (pvs, vgs, lvs) provide more concise output than their display counterparts (pvdisplay,
            vgdisplay, lvdisplay)
          </li>
          <li>
            When using <code className="bg-gray-100 px-1 py-0.5 rounded text-black">du -sh /path</code>, replace{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">/path</code> with the directory you want to
            check
          </li>
          <li>
            Replace placeholders like <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;vmid&gt;</code>,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;bus&gt;&lt;index&gt;</code>,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;disk&gt;</code>,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;format&gt;</code>,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;input&gt;</code> and{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;output&gt;</code> with the actual values you
            intend to use.
          </li>
        </ul>
      </div>

    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/system-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Terminal, ArrowLeft, Copy, Check } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function SystemCommandsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "System Information",
      commands: [
        { command: "pveversion", description: "Show Proxmox version" },
        { command: "pveversion -v", description: "Detailed Proxmox version info" },
        { command: "hostnamectl", description: "System hostname and kernel info" },
        { command: "uname -a", description: "Kernel and architecture info" },
        { command: "cat /etc/os-release", description: "OS release details" },
      ],
    },
    {
      title: "System Status",
      commands: [
        { command: "uptime", description: "System uptime" },
        { command: "uptime -p", description: "Pretty uptime format" },
        { command: "free -h", description: "RAM and swap usage" },
        { command: "who -b", description: "Last system boot time" },
        { command: "last -x | grep shutdown", description: "Previous shutdowns" },
      ],
    },
    {
      title: "Service Management",
      commands: [
        { command: "systemctl status pveproxy", description: "Check Proxmox Web UI status" },
        { command: "systemctl restart pveproxy", description: "Restart Web UI proxy" },
        { command: "journalctl -xe", description: "System errors and logs" },
        { command: "dmesg -T | tail -n 50", description: "Last 50 kernel log lines" },
      ],
    },
    {
      title: "User Information",
      commands: [
        { command: "whoami", description: "Current user" },
        { command: "id", description: "Current user UID, GID and groups" },
        { command: "who", description: "Logged-in users" },
        { command: "w", description: "User activity and uptime" },
        { command: "uptime && w", description: "Uptime and who is logged in" },
        { command: "cut -d: -f1,3,4 /etc/passwd", description: "All users with UID and GID" },
        { command: "getent passwd | column -t -s :", description: "Readable user table (UID, shell, etc.)" },
      ],
    },
		{
	  title: "Auditing & Summary Tools",
	  commands: [
		{ command: "lynis audit system", description: "Run a full system security audit" },
		{ command: "fastfetch", description: "Display system summary in ASCII format" },
	  ],
	},
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Terminal className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Useful System Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides a collection of essential system commands for managing and monitoring your Proxmox VE
          system. Each command is accompanied by a brief description of its function.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/tools-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { PenToolIcon as Tool, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function SystemCLIToolsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "System Monitoring",
      commands: [
        { command: "htop", description: "Interactive process viewer with CPU/memory usage" },
        { command: "top", description: "Display Linux processes in real-time" },
        { command: "atop", description: "Advanced system & process monitor" },
        { command: "glances", description: "System monitoring tool with web interface" },
        { command: "nmon", description: "Performance monitoring tool" },
        { command: "iotop", description: "Monitor disk I/O usage by processes" },
        { command: "vmstat 1", description: "Report virtual memory statistics every second" },
      ],
    },
    {
      title: "Network Tools",
      commands: [
        { command: "iftop", description: "Display bandwidth usage on an interface" },
        { command: "nmap <host>", description: "Network exploration and security scanning" },
        { command: "tcpdump -i <interface>", description: "Dump network traffic" },
        { command: "netstat -tuln", description: "Display network connections" },
        { command: "ss -tuln", description: "Another utility to investigate sockets" },
        { command: "mtr <host>", description: "Network diagnostic tool combining ping and traceroute" },
        { command: "iperf3 -s", description: "Run iperf server for bandwidth testing" },
      ],
    },
    {
      title: "File and Text Tools",
      commands: [
        { command: "find / -name <filename>", description: "Find files by name" },
        { command: "grep -r 'pattern' /path", description: "Search for pattern in files" },
        { command: "sed -i 's/old/new/g' file", description: "Replace text in files" },
        { command: "awk '{print $1}' file", description: "Text processing tool" },
        { command: "tail -f /var/log/syslog", description: "Follow log file in real-time" },
        { command: "less /var/log/messages", description: "View file with pagination" },
        { command: "journalctl -f", description: "Follow systemd journal logs" },
      ],
    },
    {
      title: "Performance Analysis",
      commands: [
        { command: "iostat -x 1", description: "Report CPU and I/O statistics" },
        { command: "mpstat -P ALL 1", description: "Report CPU utilization" },
        { command: "perf top", description: "System profiling tool" },
        { command: "strace <command>", description: "Trace system calls and signals" },
        { command: "lsof", description: "List open files" },
        { command: "pstree", description: "Display process tree" },
        { command: "slabtop", description: "Display kernel slab cache information" },
      ],
    },
    {
      title: "Security Tools",
      commands: [
        { command: "fail2ban-client status", description: "Show fail2ban status" },
        { command: "chage -l <username>", description: "Show password expiry information" },
        { command: "lastlog", description: "Show last login of all users" },
        { command: "last", description: "Show listing of last logged in users" },
        { command: "w", description: "Show who is logged on and what they are doing" },
        { command: "lynis audit system", description: "Security auditing tool" },
        { command: "openssl s_client -connect host:port", description: "Test SSL/TLS connections" },
      ],
    },
    {
      title: "Remote Administration",
      commands: [
        { command: "ssh <user>@<host>", description: "Secure shell connection" },
        { command: "scp <file> <user>@<host>:<path>", description: "Secure copy files" },
        { command: "rsync -avz <src> <dest>", description: "Synchronize files/folders" },
        { command: "screen", description: "Terminal multiplexer" },
        { command: "tmux", description: "Terminal multiplexer alternative" },
        { command: "ssh-keygen -t rsa -b 4096", description: "Generate SSH key pair" },
        { command: "ssh-copy-id <user>@<host>", description: "Copy SSH key to server" },
      ],
    },
    {
      title: "System Configuration",
      commands: [
        { command: "systemctl status <service>", description: "Check service status" },
        { command: "journalctl -u <service>", description: "View service logs" },
        { command: "timedatectl", description: "Control system time and date" },
        { command: "hostnamectl", description: "Control system hostname" },
        { command: "localectl", description: "Control system locale and keyboard" },
        { command: "update-alternatives --config <name>", description: "Configure system alternatives" },
        { command: "dpkg-reconfigure <package>", description: "Reconfigure an installed package" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Tool className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">System CLI Tools</h1>
        </div>

        <div className="space-y-4 mb-6">
          <p className="text-lg">
            This section provides a collection of useful command-line tools for system administration in Proxmox VE.
            These tools help you monitor system performance, troubleshoot issues, manage files, analyze network traffic,
            and perform various administrative tasks.
          </p>

          <div className="p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
            <p className="text-gray-700">
              Many of these tools may have been installed during the post-installation process. For information about
              the post-installation setup and basic settings, please refer to the{" "}
              <a
                href="https://macrimi.github.io/ProxMenux/docs/post-install/basic-settings"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-600 hover:text-blue-800 underline"
              >
                Post-Installation Documentation
              </a>
              .
            </p>
          </div>
        </div>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">CLI Tool Tips</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;host&gt;</code> with a hostname or
            IP address
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;interface&gt;</code> with your
            network interface (e.g., eth0)
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;filename&gt;</code>,{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;service&gt;</code>, etc. with appropriate
            values
          </li>
          <li>
            Many tools have additional options. Use{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">man &lt;command&gt;</code> or{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;command&gt; --help</code> to see all
            available options
          </li>
          <li>
            <strong>Installation:</strong> If a tool is not available, you can install it using{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">apt install &lt;package&gt;</code>. Most of
            these tools may have been installed during the post-installation process.
          </li>
          <li>
            For tools that continuously update (like top, htop), press <kbd>q</kbd> to quit
          </li>
          <li>
            For screen and tmux sessions, use <kbd>Ctrl</kbd>+<kbd>a</kbd> or <kbd>Ctrl</kbd>+<kbd>b</kbd> as the prefix
            key followed by other commands
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/update-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Package, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function UpdateCommandsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "System Updates",
      commands: [
        { command: "apt update && apt upgrade -y", description: "Update and upgrade all system packages" },
        { command: "apt dist-upgrade -y", description: "Full system upgrade, including dependencies" },
        { command: "apt update", description: "Update package lists only" },
        { command: "apt upgrade", description: "Upgrade packages only (interactive)" },
        { command: "apt full-upgrade", description: "Upgrade packages with dependency handling (interactive)" },
      ],
    },
    {
      title: "Proxmox Updates",
      commands: [
        { command: "pveupdate", description: "Update Proxmox package lists" },
        { command: "pveupgrade", description: "Show available Proxmox upgrades" },
        { command: "pve-upgrade", description: "Perform Proxmox VE upgrade" },
        { command: "pveceph upgrade", description: "Upgrade Ceph packages (if Ceph is installed)" },
      ],
    },
    {
      title: "Package Management",
      commands: [
        { command: "apt autoremove --purge", description: "Remove unused packages and their config" },
        { command: "apt clean", description: "Clear out the local repository of retrieved package files" },
        { command: "apt autoclean", description: "Clear out only outdated package files" },
        { command: "apt install <package>", description: "Install a specific package" },
        { command: "apt remove <package>", description: "Remove a package" },
        { command: "apt purge <package>", description: "Remove a package and its configuration files" },
      ],
    },
    {
      title: "Package Information",
      commands: [
        { command: "apt list --installed", description: "List all installed packages" },
        { command: "apt search <keyword>", description: "Search for packages by keyword" },
        { command: "apt show <package>", description: "Show detailed information about a package" },
        { command: "dpkg -l", description: "List all installed packages (alternative)" },
        { command: "dpkg -l | grep <keyword>", description: "Search installed packages by keyword" },
        { command: "apt-cache policy <package>", description: "Show package versions and priorities" },
      ],
    },
    {
      title: "Repository Management",
      commands: [
        { command: "cat /etc/apt/sources.list", description: "Show main APT repository sources" },
        { command: "ls -la /etc/apt/sources.list.d/", description: "List additional repository source files" },
        {
          command: "cat /etc/apt/sources.list.d/pve-enterprise.list",
          description: "Show Proxmox Enterprise repo config",
        },
        { command: "apt-key list", description: "List repository signing keys" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Package className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">Updates and Packages Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for managing system updates and packages in Proxmox VE. Learn how to update
          your system, install and remove packages, search for software, and manage repositories.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">Update Best Practices</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Always run <code className="bg-gray-100 px-1 py-0.5 rounded text-black">apt update</code> before installing
            or upgrading packages
          </li>
          <li>Consider creating a VM snapshot or backup before performing major system upgrades</li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;package&gt;</code> with the actual
            package name
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;keyword&gt;</code> with your search
            term
          </li>
          <li>
            Use <code className="bg-gray-100 px-1 py-0.5 rounded text-black">apt autoremove --purge</code> periodically
            to clean up unused packages and free disk space
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/vm-ct-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Cpu, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function VMCTCommandsPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "Listing and Information",
      commands: [
        { command: "qm list", description: "List all virtual machines" },
        { command: "pct list", description: "List all LXC containers" },
        { command: "qm config <vmid>", description: "Show VM configuration. Use the correct <vmid>" },
        { command: "pct config <ctid>", description: "Show container configuration. Use the correct <ctid>" },
      ],
    },
    {
      title: "VM Management",
      commands: [
        { command: "qm start <vmid>", description: "Start a virtual machine. Use the correct <vmid>" },
        { command: "qm stop <vmid>", description: "Force stop a virtual machine. Use the correct <vmid>" },
        { command: "qm shutdown <vmid>", description: "Gracefully shutdown a virtual machine" },
        { command: "qm reset <vmid>", description: "Reset a virtual machine (hard reboot)" },
        { command: "qm suspend <vmid>", description: "Suspend a virtual machine" },
        { command: "qm resume <vmid>", description: "Resume a suspended virtual machine" },
        { command: "qm destroy <vmid>", description: "Delete a VM (irreversible). Use the correct <vmid>" },
      ],
    },
    {
      title: "Container Management",
      commands: [
        { command: "pct start <ctid>", description: "Start a container. Use the correct <ctid>" },
        { command: "pct stop <ctid>", description: "Force stop a container. Use the correct <ctid>" },
        { command: "pct shutdown <ctid>", description: "Gracefully shutdown a container" },
        { command: "pct restart <ctid>", description: "Restart a container" },
        { command: "pct destroy <ctid>", description: "Delete a CT (irreversible). Use the correct <ctid>" },
      ],
    },
    {
      title: "Container Operations",
      commands: [
        {
          command: "pct exec <ctid> -- getent passwd | column -t -s :",
          description: "Show CT users in table format",
        },
        {
          command: "pct exec <ctid> -- ps aux --sort=-%mem | head",
          description: "Top memory processes in CT",
        },
        {
          command: "pct enter <ctid>",
          description: "Enter container shell",
        },
        {
          command: "pct push <ctid> <source> <dest>",
          description: "Copy file from host to container",
        },
        {
          command: "pct pull <ctid> <source> <dest>",
          description: "Copy file from container to host",
        },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Cpu className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">VM and CT Management Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for managing virtual machines (VMs) and containers (CTs) in Proxmox VE. Learn
          how to list, start, stop, configure, and perform other operations on your virtualized environments.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">Usage Notes</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;vmid&gt;</code> with the ID of your
            virtual machine
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;ctid&gt;</code> with the ID of your
            container
          </li>
          <li>
            Use <code className="bg-gray-100 px-1 py-0.5 rounded text-black">qm list</code> or{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">pct list</code> to find the IDs of your VMs and
            containers
          </li>
          <li>Be careful with destroy commands as they permanently delete the VM or container</li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/help-info/zfs-commands/page.tsx
================================================
"use client"

import React, { useState } from "react"
import Link from "next/link"
import { Database, ArrowLeft, Copy, Check, Terminal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"

export default function ZFSManagementPage() {
  const [viewMode, setViewMode] = useState<"table" | "accordion">("table")

  // Group commands by category for better organization
  const commandGroups = [
    {
      title: "Pool Information",
      commands: [
        { command: "zpool list", description: "List all ZFS pools" },
        { command: "zpool status", description: "Show detailed pool status and health" },
        { command: "zpool status -v", description: "Show verbose pool status with errors" },
        { command: "zpool history", description: "Show command history for all pools" },
        { command: "zpool history <pool>", description: "Show command history for specific pool" },
        { command: "zpool get all <pool>", description: "Show all properties of a pool" },
      ],
    },
    {
      title: "Dataset Management",
      commands: [
        { command: "zfs list", description: "List all ZFS datasets" },
        { command: "zfs list -r <pool>", description: "List all datasets in a pool recursively" },
        { command: "zfs create <pool>/<dataset>", description: "Create a new dataset" },
        { command: "zfs destroy <pool>/<dataset>", description: "Destroy a dataset" },
        { command: "zfs rename <pool>/<dataset> <pool>/<new-name>", description: "Rename a dataset" },
        { command: "zfs get all <pool>/<dataset>", description: "Show all properties of a dataset" },
        { command: "zfs set compression=on <pool>/<dataset>", description: "Enable compression on a dataset" },
      ],
    },
    {
      title: "Snapshot Management",
      commands: [
        { command: "zfs list -t snapshot", description: "List all snapshots" },
        { command: "zfs list -t snapshot -r <pool>", description: "List all snapshots in a pool" },
        { command: "zfs snapshot <pool>/<dataset>@<snapshot-name>", description: "Create a snapshot" },
        { command: "zfs destroy <pool>/<dataset>@<snapshot-name>", description: "Delete a snapshot" },
        { command: "zfs rollback <pool>/<dataset>@<snapshot-name>", description: "Rollback to a snapshot" },
        { command: "zfs hold <tag> <pool>/<dataset>@<snapshot-name>", description: "Place a hold on a snapshot" },
        { command: "zfs release <tag> <pool>/<dataset>@<snapshot-name>", description: "Release a hold on a snapshot" },
      ],
    },
    {
      title: "Clone and Send/Receive",
      commands: [
        {
          command: "zfs clone <pool>/<dataset>@<snapshot> <pool>/<clone-name>",
          description: "Create a clone from a snapshot",
        },
        { command: "zfs send <pool>/<dataset>@<snapshot> > backup.zfs", description: "Send a snapshot to a file" },
        { command: "zfs receive <pool>/<dataset> < backup.zfs", description: "Receive a snapshot from a file" },
        {
          command: "zfs send -i <pool>/<dataset>@<snap1> <pool>/<dataset>@<snap2> > incr.zfs",
          description: "Send incremental snapshot",
        },
        {
          command: "zfs send -R <pool>/<dataset>@<snapshot> > full-recursive.zfs",
          description: "Send recursive snapshot",
        },
      ],
    },
    {
      title: "Maintenance and Repair",
      commands: [
        { command: "zpool scrub <pool>", description: "Start a scrub operation on a pool" },
        { command: "zpool scrub -s <pool>", description: "Stop a running scrub" },
        { command: "zpool clear <pool>", description: "Clear error counts in a pool" },
        { command: "zpool clear <pool> <device>", description: "Clear errors on a specific device" },
        { command: "zpool replace <pool> <old-device> <new-device>", description: "Replace a failed device" },
        { command: "zpool offline <pool> <device>", description: "Take a device offline" },
        { command: "zpool online <pool> <device>", description: "Bring a device online" },
      ],
    },
    {
      title: "Performance and Monitoring",
      commands: [
        { command: "zpool iostat", description: "Show I/O statistics for pools" },
        { command: "zpool iostat -v", description: "Show detailed I/O statistics" },
        { command: "zpool iostat 5", description: "Show I/O statistics every 5 seconds" },
        { command: "arc_summary", description: "Show ARC statistics (if installed)" },
        { command: "zfs get compressratio <pool>/<dataset>", description: "Show compression ratio" },
        { command: "zfs get used,available,referenced <pool>/<dataset>", description: "Show space usage" },
      ],
    },
  ]

  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-6">
        <Link
          href="/docs/help-info"
          className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6"
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Back to Help and Info
        </Link>

        <div className="flex items-center gap-3 mb-4">
          <Database className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">ZFS Management Commands</h1>
        </div>

        <p className="text-lg mb-6">
          This section provides commands for managing ZFS file systems in Proxmox VE. Learn how to create and manage
          pools, datasets, snapshots, and perform maintenance operations on your ZFS storage.
        </p>

        <div className="flex gap-2 mb-6">
          <Button
            variant={viewMode === "table" ? "default" : "outline"}
            onClick={() => setViewMode("table")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Table View
          </Button>
          <Button
            variant={viewMode === "accordion" ? "default" : "outline"}
            onClick={() => setViewMode("accordion")}
            className="bg-blue-500 hover:bg-blue-600 text-white"
          >
            Accordion View
          </Button>
        </div>
      </div>

      {viewMode === "table" ? (
        <div className="space-y-8">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-8">
              <h2 className="text-xl font-semibold mb-4 text-black">{group.title}</h2>
              <div className="border-2 border-gray-200 rounded-md overflow-hidden">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-1/3 bg-gray-100 text-black font-bold">Command</TableHead>
                      <TableHead className="w-1/2 bg-gray-100 text-black font-bold">Description</TableHead>
                      <TableHead className="w-1/6 bg-gray-100 text-black font-bold">Action</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {group.commands.map((cmd, cmdIndex) => (
                      <TableRow key={cmdIndex} className="border-t border-gray-200">
                        <TableCell className="font-mono text-black bg-white">{cmd.command}</TableCell>
                        <TableCell className="text-gray-700 bg-white">{cmd.description}</TableCell>
                        <TableCell className="bg-white">
                          <CopyButton text={cmd.command} />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </div>
            </div>
          ))}
        </div>
      ) : (
        <div className="space-y-6">
          {commandGroups.map((group, index) => (
            <div key={index} className="mb-6">
              <h2 className="text-xl font-semibold mb-3 text-black">{group.title}</h2>
              <Accordion type="single" collapsible className="border-2 border-gray-200 rounded-md overflow-hidden">
                {group.commands.map((cmd, cmdIndex) => (
                  <AccordionItem
                    key={cmdIndex}
                    value={`item-${index}-${cmdIndex}`}
                    className="border-b border-gray-200"
                  >
                    <AccordionTrigger className="px-4 py-3 hover:bg-gray-50 text-black">
                      <div className="flex items-center">
                        <Terminal className="h-4 w-4 mr-2 text-blue-500" />
                        <span className="font-mono">{cmd.command}</span>
                      </div>
                    </AccordionTrigger>
                    <AccordionContent className="px-4 py-3 bg-gray-50">
                      <div className="space-y-3">
                        <div className="p-3 bg-white border border-gray-200 rounded-md">
                          <pre className="font-mono text-black whitespace-pre-wrap select-text">{cmd.command}</pre>
                        </div>
                        <div className="flex justify-between items-center">
                          <p className="text-gray-700">{cmd.description}</p>
                          <CopyButton text={cmd.command} />
                        </div>
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
              </Accordion>
            </div>
          ))}
        </div>
      )}

      <div className="mt-10 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h3 className="text-lg font-semibold mb-2 text-black">ZFS Best Practices</h3>
        <ul className="list-disc pl-5 space-y-2 text-gray-700">
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;pool&gt;</code> with your ZFS pool
            name
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;dataset&gt;</code> with your
            dataset name
          </li>
          <li>
            Replace <code className="bg-gray-100 px-1 py-0.5 rounded text-black">&lt;snapshot-name&gt;</code> with a
            descriptive name, often including a timestamp (e.g., daily-2023-05-01)
          </li>
          <li>Run regular scrubs to maintain data integrity (weekly or monthly)</li>
          <li>
            Keep at least 10-15% of pool space free for optimal performance (ZFS performance degrades significantly when
            pools are over 80% full)
          </li>
          <li>
            Use meaningful snapshot names and consider implementing an automated snapshot rotation policy for important
            datasets
          </li>
          <li>
            When replacing devices, always use{" "}
            <code className="bg-gray-100 px-1 py-0.5 rounded text-black">zpool replace</code> rather than removing and
            adding to preserve data redundancy
          </li>
        </ul>
      </div>
    </div>
  )
}

interface CopyButtonProps {
  text: string
}

function CopyButton({ text }: CopyButtonProps) {
  const [copied, setCopied] = React.useState(false)

  const copyToClipboard = () => {
    navigator.clipboard.writeText(text)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <Button
      variant="outline"
      size="sm"
      onClick={copyToClipboard}
      className="flex items-center gap-1 h-8 bg-white text-blue-500 border-blue-200 hover:bg-blue-50 hover:text-blue-600"
    >
      {copied ? (
        <>
          <Check className="h-4 w-4" />
          <span>Copied</span>
        </>
      ) : (
        <>
          <Copy className="h-4 w-4" />
          <span>Copy</span>
        </>
      )}
    </Button>
  )
}



================================================
FILE: web/app/docs/installation/page.tsx
================================================
"use client"

import CopyableCode from "@/components/CopyableCode"
import Image from "next/image"
import Link from "next/link"
import { AlertTriangle, FileCode, Shield } from "lucide-react"

export default function InstallationPage() {
  const installationCode = `bash -c \"$(wget -qLO - https://raw.githubusercontent.com/MacRimi/ProxMenux/main/install_proxmenux.sh)\"`

  return (
    <div className="w-full max-w-4xl mx-auto px-4 py-8 text-gray-900">
      <h1 className="text-3xl font-bold mb-6">Installing ProxMenux</h1>

      <h2 className="text-xl font-semibold mt-6 mb-2">Installation</h2>
      <p className="mb-2">To install ProxMenux, simply run the following command in your Proxmox server terminal:</p>
      <div className="w-full mb-4">
        <CopyableCode code={installationCode} />
      </div>

        {/* Security Notice */}
        <div className="my-4 text-sm">
          <p className="flex items-center mb-2">
            <AlertTriangle className="h-4 w-4 text-yellow-500 mr-2 flex-shrink-0" />
            <span>Be careful when copying scripts from the internet. Always remember to check the source!</span>
          </p>
          <p className="flex items-center mb-2">
            <FileCode className="h-4 w-4 text-blue-500 mr-2 flex-shrink-0" />
            <span>You can <a href="https://github.com/MacRimi/ProxMenux/blob/main/install_proxmenux.sh" className="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">review the source code</a> before execution.</span>
          </p>
          <p className="flex items-center">
            <Shield className="h-4 w-4 text-green-500 mr-2 flex-shrink-0" />
            <span>All executable links follow our <a href="https://github.com/MacRimi/ProxMenux?tab=coc-ov-file#-2-security--code-responsibility" className="text-blue-600 hover:underline" target="_blank" rel="noopener noreferrer">Code of Conduct</a>.</span>
          </p>
        </div>
   
      <p className="mt-8 mb-4">During installation, ProxMenux will automatically install and configure the following dependencies:</p>
      <ul className="list-disc list-inside mb-4">
        <li>whiptail - for interactive menus</li>
        <li>curl - for downloading remote files</li>
        <li>jq - for handling JSON data</li>
        <li>Python 3 and virtual environment - required for translations</li>
        <li>Google Translate (googletrans) - for multi-language support</li>
      </ul>

      <h2 className="text-xl font-semibold mt-6 mb-2">Installation Progress</h2>
      <p className="mb-2">The installation process will look like this:</p>
      <div className="w-full mb-4">
        <Image src="https://macrimi.github.io/ProxMenux/install/install.png" alt="ProxMenux Installation" width={800} height={400} className="rounded shadow-lg" />
      </div>

      <h2 className="text-xl font-semibold mt-6 mb-2">How to Use</h2>
      <p className="mb-2">Once installed, launch <strong>ProxMenux</strong> by running:</p>
      <div className="w-full mb-4">
        <CopyableCode code="menu" />
      </div>

      <h2 className="text-xl font-semibold mt-6 mb-2">First Execution and Language Selection</h2>
      <p className="mb-4">
        On the first execution, you will be prompted to define the language for ProxMenux. The recommended language is English. Translations are generated automatically using a predefined translation package and Google Translate. Automatic translations may contain errors, so English is the preferred language for accuracy.
      </p>

      <h2 className="text-xl font-semibold mt-6 mb-2">Uninstalling ProxMenux</h2>
      <p className="mb-4">
        If you ever need to uninstall ProxMenux, there is a function in the Settings section designed for this purpose. For detailed instructions on how to uninstall, please refer to the{" "}
        <Link href="/docs/settings/uninstall-proxmenux" className="text-blue-600 hover:underline">
          uninstall documentation
        </Link>.
      </p>

      <h2 className="text-xl font-semibold mt-8 mb-4">Troubleshooting</h2>
      <p className="mb-4">
        If you encounter any issues during installation or usage, please check the {" "}
        <a href="https://github.com/MacRimi/ProxMenux/issues" className="text-blue-600 hover:underline">
          GitHub Issues
        </a>{" "}
        page or open a new issue if your problem isn't already addressed.
      </p>
    </div>
  )
}


================================================
FILE: web/app/docs/introduction/page.tsx
================================================
import Image from "next/image"
import Link from "next/link"
import { AlertTriangle, FileCode, Shield } from "lucide-react"

export default function IntroductionPage() {
  return (
    <div className="w-full max-w-4xl mx-auto px-4 py-8 text-gray-900">
      {/* Logo + Title Section */}
      <div className="flex items-start mb-6">
        <Image 
          src="https://macrimi.github.io/ProxMenux/logo.png" 
          alt="ProxMenux Logo" 
          width={80} 
          height={80} 
          className="mr-4"
        />
        <p className="mb-4">
        ProxMenux is a tool designed to make Proxmox VE accessible to all users, regardless of their experience and technical knowledge.
        </p>
      </div>

      <p className="mb-4">
      Designed with a menu-based interface, ProxMenux simplifies the execution of commands to perform actions on:
      </p>
      <ul className="list-disc list-inside mb-4 ml-4">
        <li>The Proxmox server</li>
        <li>Virtual machines (VMs)</li>
        <li>Containers (LXC)</li>
      </ul>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Core Features</h2>
      <p className="mb-4">
        ProxMenux enables streamlined management of:
      </p>
      <ul className="list-disc list-inside mb-6 ml-4">
        <li>System resources</li>
        <li>Network and storage configurations</li>
        <li>VM and LXC container administration</li>
        <li>Hardware integration and optimizations</li>
        <li>Automated server maintenance</li>
      </ul>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Key Advantages</h2>
      <ul className="list-disc list-inside mb-6 ml-4">
        <li>Intuitive menu-driven interface</li>
        <li>Simplification of management tasks</li>
      </ul>

      <p className="mt-6">
        The following sections provide detailed instructions on installing and using ProxMenux, along with comprehensive documentation on its available functionalities.
      </p>

      {/* Guides Link */}
      <p className="mt-6">
        For additional Proxmox-related information, including official documentation, forums, and discussions, visit the{" "}
        <Link href="/guides" className="text-blue-500 hover:underline">
          Guides
        </Link>{" "} 
        section.
      </p>

      {/* Security Notice */}
      <div>
          <h3 className="text-2xl font-semibold mt-8 mb-2 flex items-center">
            <AlertTriangle className="h-5 w-5 text-yellow-500 mr-2" />
            Security Information
          </h3>
          <p className="mb-3">
            Be careful when running scripts from the Internet. Always remember to check the source!
            All executable links follow our Code of Conduct.
          </p>
          <div className="flex flex-wrap gap-2">
            <a
              href="https://github.com/MacRimi/ProxMenux/tree/main/scripts" 
              className="inline-flex items-center px-3 py-2 text-sm font-medium rounded-md bg-blue-600 hover:bg-blue-700 text-white"
              target="_blank"
              rel="noopener noreferrer"
            >
              <FileCode className="h-4 w-4 mr-2" />
              View Source Code
            </a>
            <a
              href="https://github.com/MacRimi/ProxMenux?tab=coc-ov-file#-2-security--code-responsibility" 
              className="inline-flex items-center px-3 py-2 text-sm font-medium rounded-md bg-green-600 hover:bg-green-700 text-white"
              target="_blank"
              rel="noopener noreferrer"
            >
              <Shield className="h-4 w-4 mr-2" />
              Code of Conduct
            </a>
          </div>
        </div>

    </div>
  )
}



================================================
FILE: web/app/docs/network/repair-network/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"

export const metadata = {
  title: "Repair Network | ProxMenux Documentation",
  description: "Step-by-step guide to repair network configurations in Proxmox VE using ProxMenux.",
}

export default function RepairNetwork() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Repair Network</h1>
      
      <p className="mb-4">
        The <strong>Repair Network</strong> function in <strong>ProxMenux</strong> addresses issues caused by changes in network interface identifiers
        that occur when modifying hardware components such as network adapters, GPUs, or other PCI devices. This can lead to a loss of
        network connectivity because the system retains old configurations that no longer match the new interface IDs.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Purpose</h2>
      <p className="mb-4">
        In many cases, when adding or removing hardware (e.g., network cards, GPUs, storage controllers), network interfaces may be renamed
        due to changes in the system's PCI device enumeration. As a result, Proxmox VE may fail to establish a network
        connection because the <code>/etc/network/interfaces</code> file references outdated interface names.
      </p>
      <p className="mb-4">
        Restoring a backup of <code>/etc/network/interfaces</code> is not a viable solution, as the IDs of the interfaces have changed. Instead,
        the system needs to detect the new identifiers and update the configuration accordingly. <strong>Repair Network</strong>
        automates this process by identifying the correct interface names and applying the necessary corrections.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">How It Works</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Detects the current physical network interfaces and their updated identifiers.</li>
        <li>Checks the <code>/etc/network/interfaces</code> file for outdated interface names.</li>
        <li>Replaces incorrect or missing network interface names with the correct ones.</li>
        <li>Verifies the integrity of bridge configurations and updates them if necessary.</li>
        <li>Provides an option to restart the network service to apply changes.</li>
      </ul>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Network connectivity is restored automatically without manual intervention.</li>
        <li>Updated interface names are correctly assigned in <code>/etc/network/interfaces</code>.</li>
        <li>Bridges and other network settings remain functional after hardware changes.</li>
      </ul>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>This script is useful when network connectivity is lost due to hardware modifications.</li>
        <li>Having an alternative access method (such as IPMI or console) is advisable in case of unforeseen issues.</li>
      </ul>
      
    </div>
  )
}



================================================
FILE: web/app/docs/network/show-ip-information/page.tsx
================================================
import type { Metadata } from "next"
import { Steps } from "@/components/ui/steps"

export const metadata: Metadata = {
  title: "Show IP Information | ProxMenux Documentation",
  description: "Learn how to display IP information for Proxmox VE and its virtual machines using ProxMenux.",
}

export default function ShowIPInformation() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Show IP Information</h1>

      <p className="mb-4">
        The Show IP Information function it provides a quick and
        easy way to view the IP configurations of all relevant network interfaces in your Proxmox VE system.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">What Does Show IP Information Do?</h2>
      <p className="mb-4">When you select the Show IP Information option, the script performs the following actions:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Detects all relevant network interfaces (physical and bridges)</li>
        <li>Retrieves the IP address for each detected interface</li>
        <li>Displays a comprehensive list of interfaces and their associated IP addresses</li>
        <li>Indicates if an interface has no IP assigned</li>
      </ol>



      <h2 className="text-2xl font-semibold mt-8 mb-4">Key Features of Show IP Information</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Comprehensive detection of all relevant network interfaces</li>
        <li>Display of IP addresses for each detected interface</li>
        <li>Indication of interfaces without assigned IP addresses</li>
        <li>Quick and easy access to network configuration information</li>
        <li>Non-intrusive operation (does not make any changes to the system)</li>
      </ul>
    </div>
  )
}



================================================
FILE: web/app/docs/network/verify-network/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"

export const metadata = {
  title: "Verify Network | ProxMenux Documentation",
  description: "Step-by-step guide to verify network configuration and connectivity in Proxmox VE using ProxMenux.",
}

export default function VerifyNetwork() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Verify Network</h1>
      
      <p className="mb-4">
        The <strong>Verify Network</strong> function in ProxMenux allows users to check the current network
        configuration and connectivity in <strong>Proxmox VE</strong>. It provides a quick way to identify potential
        network issues and verify that all network interfaces are correctly configured.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview</h2>
      <p className="mb-4">When executed, the script performs the following actions:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Detects and lists all physical network interfaces.</li>
        <li>Retrieves the current IP configuration for each detected interface.</li>
        <li>Verifies network connectivity by testing external server reachability.</li>
        <li>Displays a summary of the network status.</li>
      </ol>
      
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>All active network interfaces are detected and displayed.</li>
        <li>Current IP configurations are listed for reference.</li>
        <li>Connectivity to an external server is confirmed or flagged if there is an issue.</li>
      </ul>
      
    </div>
  )
}



================================================
FILE: web/app/docs/post-install/page.tsx
================================================
import type { Metadata } from "next"
import Link from "next/link"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install Script Documentation",
  description:
    "Comprehensive guide to the customizable post-install script for Proxmox VE, covering various optimization categories and settings.",
  openGraph: {
    title: "ProxMenux Post-Install Script Documentation",
    description:
      "Comprehensive guide to the customizable post-install script for Proxmox VE, covering various optimization categories and settings.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/post-install-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Script Documentation",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install Script Documentation",
    description:
      "Comprehensive guide to the customizable post-install script for Proxmox VE, covering various optimization categories and settings.",
    images: ["https://macrimi.github.io/ProxMenux/post-install-image.png"],
  },
}

const categories = [
  { name: "Basic Settings", order: 1 },
  { name: "System", order: 2 },
  { name: "Virtualization", order: 3 },
  { name: "Network", order: 4 },
  { name: "Storage", order: 5 },
  { name: "Security", order: 6 },
  { name: "Customization", order: 7 },
  { name: "Monitoring", order: 8 },
  { name: "Performance", order: 9 },
  { name: "Optional", order: 10 },
]

export default function PostInstallPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">ProxMenux Post-Install Script Documentation</h1>
      <p className="mb-4">
        The <strong>Customizable Post-Install Script</strong> is a utility designed to optimize the installation of
        Proxmox VE by adjusting system configurations. One of the advantages of its modular and selectable structure is
        that it allows users to choose specific settings based on their requirements, needs, and preferences.
      </p>
      <p className="mb-4">
        This script is primarily based on the work of{" "}
        <Link href="https://github.com/extremeshok/xshok-proxmox" className="text-blue-500 hover:underline">
          extremeshok â€“ Scripts for working with and optimizing Proxmox
        </Link>{" "}
        and the{" "}
        <Link href="https://github.com/community-scripts/ProxmoxVE" className="text-blue-500 hover:underline">
          Proxmox VE Post Install script from Proxmox VE Helper-Scripts
        </Link>
        .
      </p>
      <p className="mb-6">
        This script includes {categories.length} main categories, each targeting a key aspect of Proxmox VE performance,
        security, and usability:
      </p>
      <ul className="list-disc pl-5 mb-6">
        {categories.map((category) => (
          <li key={category.order} className="mb-2">
            <Link
              href={`/docs/post-install/${category.name.toLowerCase().replace(" ", "-")}`}
              className="text-blue-500 hover:underline"
            >
              {category.name}
            </Link>
          </li>
        ))}
      </ul>
      <p className="mb-6">
        Each category includes selectable options, ensuring that users can tailor the system adjustments to their
        specific needs without applying unnecessary modifications. Click on a category to explore available settings.
      </p>

      <div className="bg-green-100 border-l-4 border-green-500 text-green-800 p-4 mb-6">
        <p className="font-semibold mb-2">Uninstall Option</p>
        <p className="mb-2">
          The Post-Install Menu Script now includes an option to uninstall packages and utilities that were previously
          installed by the script. This feature allows you to:
        </p>
        <ul className="list-disc pl-5">
          <li>Remove specific utilities that are no longer needed</li>
        </ul>
      </div>

      <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
        <p className="font-semibold">Important: Avoid Running Multiple Post-Install Scripts</p>
        <p>
          It is not recommended to use different post-installation scripts, as this can cause conflicts by overwriting
          or duplicating files and settings.
        </p>
        <ul className="list-disc pl-5">
          <li>
            The <strong>ProxMenux Post-Install Script</strong> is designed to avoid overwriting existing configurations
            where possible.
          </li>
          <li>
            If you have already run the <strong>eXtremeSHOK Post-Install Script</strong>, there is no need to run the
            ProxMenux Post-Install Script again, except for <strong>Option 35</strong> (console customization).
          </li>
          <li>
            If you have used the <strong>Helper-Scripts Post-Install Script</strong>, you can run all ProxMenux options{" "}
            <strong>except for options 4 and 27</strong>, as they will already be configured.
          </li>
        </ul>
      </div>
    </div>
  )
}



================================================
FILE: web/app/docs/post-install/basic-settings/page.tsx
================================================
import type { Metadata } from "next"
import { Settings } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Basic Settings",
  description:
    "Detailed guide to the Basic Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
  openGraph: {
    title: "ProxMenux Post-Install: Basic Settings",
    description:
      "Detailed guide to the Basic Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/basic-settings",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/basic-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Basic Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Basic Settings",
    description:
      "Detailed guide to the Basic Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    images: ["https://macrimi.github.io/ProxMenux/basic-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function BasicSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Settings className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Basic Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Basic Settings</strong> category focuses on foundational configurations for your Proxmox VE
        installation, including installing essential utilities, adding repositories, managing packages, and keeping the
        system up to date.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Select and Install System Utilities
      </h3>
      <p className="mb-4">
        This option presents a menu where you can select which system utilities to install based on your needs.
      </p>

      
      <div className="mb-6">
        <img
          src="https://macrimi.github.io/ProxMenux/basic/menu_utilities.png"
          alt="System Utilities Selection Menu"
          className="rounded shadow-lg border border-gray-200"
        />
        <p className="text-sm text-gray-600 mt-2 text-center">The utilities selection menu allows you to choose which tools to install</p>
      </div>
      
      <h4 className="text-lg font-semibold mb-2">Available utilities:</h4>
      <ul className="list-disc pl-5 mb-4 space-y-12">

      <li>
        <strong>axel</strong>: A light command-line download accelerator
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">axel -n 10 http://example.com/largefile.zip</code>
      </li>
      <li>
        <strong>dialog</strong>: A tool for creating TUI interfaces
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">dialog --title "Hello" --msgbox "Hello, World!" 10 20</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/dialog.png"
          alt="Dialog Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
      <li>
        <strong>dos2unix</strong>: Text file format converter to remove Windows-style line endings.
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">dos2unix file.txt</code>
      </li>
      <li>
        <strong>grc</strong>: Generic colouriser for everything
        <p className="mt-2">Example usage (colorize ping output):</p>
        <code className="block bg-gray-100 p-2 rounded">grc ping example.com</code>
      </li>
      <li>
        <strong>htop</strong>: An interactive process viewer
        <p className="mt-2">To start htop, simply type:</p>
        <code className="block bg-gray-100 p-2 rounded">htop</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/htop.png"
          alt="htop Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
      <li>
        <strong>btop</strong>: A resource monitor that shows usage and stats for processor, memory, disks, network and processes
        <p className="mt-2">To start btop, type:</p>
        <code className="block bg-gray-100 p-2 rounded">btop</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/btop.png"
          alt="btop Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
     <li>
        <strong>iftop</strong>: A tool to display bandwidth usage on an interface
        <p className="mt-2">To start iftop (requires root):</p>
        <code className="block bg-gray-100 p-2 rounded">iftop</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/iftop.png"
          alt="iftop Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
      <li>
        <strong>iotop</strong>: A tool to display I/O usage by processes
        <p className="mt-2">To start iotop (requires root):</p>
        <code className="block bg-gray-100 p-2 rounded">siotop</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/iotop.png"
          alt="iotop Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
      <li>
        <strong>iperf3</strong>: A tool for active measurements of the maximum achievable bandwidth on IP networks
        <p className="mt-2">Example usage (server mode):</p>
        <code className="block bg-gray-100 p-2 rounded">iperf3 -s</code>
        <p className="mt-2">Example usage (client mode):</p>
        <code className="block bg-gray-100 p-2 rounded">iperf3 -c server_ip</code>
      </li>
      <li>
        <strong>ipset</strong>: A tool to manage IP sets in the Linux kernel
        <p className="mt-2">Example usage (create a new set):</p>
        <code className="block bg-gray-100 p-2 rounded">ipset create myset hash:ip</code>
      </li>
      <li>
        <strong>iptraf-ng</strong>: An interactive colorful IP LAN monitor
        <p className="mt-2">To start iptraf-ng:</p>
        <code className="block bg-gray-100 p-2 rounded">iptraf-ng</code>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/iptraf-ng.png"
          alt="iptraf-ng Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
     <li>
        <strong>mlocate</strong>: A tool to find files by name quickly
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">locate filename</code>
      </li>
      <li>
        <strong>msr-tools</strong>: Tools for accessing CPU model-specific registers
        <p className="mt-2">Example usage (read MSR):</p>
        <code className="block bg-gray-100 p-2 rounded">rdmsr 0x1a0</code>
      </li>
      <li>
        <strong>net-tools</strong>: A collection of programs that form the base set of the NET-3 networking distribution for the Linux operating system
        <p className="mt-2">Example usage (show network interfaces):</p>
        <code className="block bg-gray-100 p-2 rounded">ifconfig</code>
      </li>
      <li>
        <strong>sshpass</strong>: A tool for non-interactive SSH password authentication.
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">sshpass -p 'password' ssh user@hostname</code>
      </li>
      <li>
        <strong>tmux</strong>: A terminal multiplexer that allows managing multiple sessions in a single terminal.
        <p className="mt-2">To start a new tmux session:</p>
        <code className="block bg-gray-100 p-2 rounded">tmux</code>
        <p className="mt-2">In tmux, most commands are executed using <strong>Ctrl + b</strong>, followed by another key:</p>
        <table className="table-auto border-collapse border border-gray-300 mt-2">
          <thead>
            <tr>
              <th className="border border-gray-300 p-2">Action</th>
              <th className="border border-gray-300 p-2">Shortcut</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td className="border border-gray-300 p-2">Detach session (leave it running)</td>
              <td className="border border-gray-300 p-2">Ctrl + b, then d</td>
            </tr>
            <tr>
              <td className="border border-gray-300 p-2">List active sessions</td>
              <td className="border border-gray-300 p-2">tmux ls</td>
            </tr>
            <tr>
              <td className="border border-gray-300 p-2">Reattach a session</td>
              <td className="border border-gray-300 p-2">tmux attach -t session_name</td>
            </tr>
            <tr>
              <td className="border border-gray-300 p-2">Exit session</td>
              <td className="border border-gray-300 p-2">exit or Ctrl + d</td>
            </tr>
          </tbody>
        </table>
        <img
          src="https://macrimi.github.io/ProxMenux/basic/tmux.png"
          alt="tmux Example"
          className="mt-2 rounded shadow-lg"
        />
      </li>
      <li>
        <strong>unzip</strong>: A tool for extracting and viewing files in .zip archives
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">unzip file.zip</code>
      </li>
      <li>
        <strong>whois</strong>: A client for the whois directory service
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">whois example.com</code>
      </li>
      <li>
        <strong>zip</strong>: A compression and file packaging utility
        <p className="mt-2">Example usage:</p>
        <code className="block bg-gray-100 p-2 rounded">zip archive.zip file1 file2 file3</code>
      </li>
      <li>
        <strong>libguestfs-tools</strong>: A set of tools for accessing and modifying virtual machine disk images.
        <p className="mt-2">Example usage (list files in a VM disk image):</p>
        <code className="block bg-gray-100 p-2 rounded">guestfish -a disk.img -m /dev/sda1 ls /</code>
      </li>

      </ul>
      <p className="text-lg mt-12 mb-2">This option automatically installs these utilities by running this command:</p>
      <CopyableCode
        code={`
# Update package lists
sudo apt-get update

# Install common system utilities
sudo apt-get install -y axel dialog dos2unix grc htop btop iftop iotop iperf3 ipset iptraf-ng mlocate msr-tools net-tools omping sshpass tmux unzip zip libguestfs-tools

        `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Skip Downloading Additional Languages
      </h3>
      <p className="mb-4">
        This optimization configures APT to skip downloading additional language packages, which can save disk space and
        speed up package operations.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        By skipping unnecessary language packages, you can reduce disk usage and
        improve the speed of package management operations. This is particularly useful in server environments where
        multiple language support is often not required.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following command:</p>
      <CopyableCode
        code={`
# Configure APT to skip downloading additional languages
echo 'Acquire::Languages "none";' | sudo tee /etc/apt/apt.conf.d/99-disable-translations
        `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Synchronize Time Automatically
      </h3>
      <p className="mb-4">
        This optimization configures the system to automatically synchronize its time, ensuring accurate timekeeping.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Accurate timekeeping is crucial for many system operations, log
        consistency, and proper functioning of time-sensitive applications. Automatic synchronization ensures your
        Proxmox VE system maintains the correct time without manual intervention.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following command:</p>
      <CopyableCode
        code={`
# Note: To set timezone automatically based on IP, you can use:
IP=$(dig +short myip.opendns.com @resolver1.opendns.com)
TIMEZONE=$(curl -s "https://ipapi.co/$IP/timezone")
sudo timedatectl set-timezone "$TIMEZONE"
        `}
      />

<h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={4} />
        Update and Upgrade System
      </h3>
      <p className="mb-4">
        This optimization updates the system's package lists, upgrades installed packages, and configures Proxmox
        repositories. It also includes additional steps to properly set up Debian repositories, disable certain
        warnings, and perform safety checks after the update process.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Keeping your system up-to-date is essential for security, stability, and
        performance. This optimization ensures you have the latest patches and features, while also configuring the
        correct repositories for Proxmox VE, enabling access to necessary updates and tools. The disk metadata check helps prevent potential issues with storage devices that may have been modified by virtual machines.
      </p>
      <h4 className="text-lg font-semibold mb-2">Repository changes:</h4>
      <ul className="list-disc pl-5 mb-4 space-y-2">
        <li>
          <strong>Disabled:</strong> Enterprise Proxmox repository (pve-enterprise.list) - This repository is for users
          with a paid subscription.
        </li>
        <li>
          <strong>Disabled:</strong> Enterprise Proxmox Ceph repository (ceph.list) - This repository is for enterprise
          Ceph storage solutions.
        </li>
        <li>
          <strong>Added:</strong> Free public Proxmox repository (pve-public-repo.list) - This provides access to free
          Proxmox VE updates and packages.
        </li>
        <li>
          <strong>Configured:</strong> Main Debian repositories - These provide access to the core Debian packages and
          security updates.
        </li>
      </ul>
      <p className="text-lg mb-2">This adjustment automates the following command:</p>
      <CopyableCode
        code={`
# Disable enterprise Proxmox repository
if [ -f /etc/apt/sources.list.d/pve-enterprise.list ]; then
  sudo sed -i 's/^deb/#deb/g' /etc/apt/sources.list.d/pve-enterprise.list
fi

# Disable enterprise Proxmox Ceph repository
if [ -f /etc/apt/sources.list.d/ceph.list ]; then
  sudo sed -i 's/^deb/#deb/g' /etc/apt/sources.list.d/ceph.list
fi

# Enable free public Proxmox repository
echo "deb http://download.proxmox.com/debian/pve $(lsb_release -cs) pve-no-subscription" | sudo tee /etc/apt/sources.list.d/pve-public-repo.list


# Configure main Debian repositories
cat <<EOF | sudo tee /etc/apt/sources.list
deb http://deb.debian.org/debian $(lsb_release -cs) main contrib non-free non-free-firmware
deb http://deb.debian.org/debian $(lsb_release -cs)-updates main contrib non-free non-free-firmware
deb http://security.debian.org/debian-security $(lsb_release -cs)-security main contrib non-free non-free-firmware
EOF

# Disable non-free firmware warnings
echo 'APT::Get::Update::SourceListWarnings::NonFreeFirmware "false";' | sudo tee /etc/apt/apt.conf.d/no-bookworm-firmware.conf

# Update and upgrade
sudo apt-get update
sudo apt-get dist-upgrade -y

# Update PVE application manager
pveam update

# Install additional packages
sudo apt-get install -y zfsutils-linux proxmox-backup-restore-image chrony
  `}
/>
<div className="mt-6 p-4 bg-blue-50 border-l-4 border-blue-500 rounded-md">
        <h4 className="text-lg font-semibold mb-2 text-black">Post-Update Safety Check</h4>
        <p className="text-gray-700 mb-2">
          After updating the system, the script performs an important safety check to detect disks with old PV (Physical Volume) headers that might have been modified by virtual machines.
        </p>
        <p className="text-gray-700 mb-2">
          <strong>Why this matters:</strong> When VMs have direct access to disks through passthrough, they can sometimes modify the disk metadata. This can cause issues with storage management on the host system, potentially leading to data access problems or errors when using LVM (Logical Volume Manager).
        </p>
        <p className="text-gray-700">
          If any issues are detected, the script will display a warning message and suggest running the <code className="bg-gray-100 px-1 py-0.5 rounded text-black">pvs</code> command to identify the affected disks. This early detection helps prevent potential storage problems before they impact your system.
        </p>
      </div>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/customization/page.tsx
================================================
import type { Metadata } from "next"
import { Sliders } from "lucide-react"


export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Customization Settings",
  description:
    "Guide to Customization Settings in the ProxMenux post-install script for configuring the Proxmox VE environment.",
  openGraph: {
    title: "ProxMenux Post-Install: Customization Settings",
    description:
      "Guide to Customization Settings in the ProxMenux post-install script for configuring the Proxmox VE environment.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/customization",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/customization-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Customization Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Customization Settings",
    description:
      "Guide to Customization Settings in the ProxMenux post-install script for configuring the Proxmox VE environment.",
    images: ["https://macrimi.github.io/ProxMenux/customization-settings-image.png"],
  },
}


function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function CustomizationSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Sliders className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Customization Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Customization Settings</strong> section allows you to configure and personalize the Proxmox VE
        environment with specific adjustments.
      </p>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Customize Bash Prompt and Aliases
      </h3>
      <p className="mb-4">
        This option modifies the root user's <code>.bashrc</code> to enhance command-line usability by adding colorized
        prompts and useful aliases.
      </p>
      <p className="mb-4">What it does:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>
          Backs up the original <code>.bashrc</code> file
        </li>
        <li>Configures a custom prompt with timestamp</li>
        <li>
          Adds colorized <code>ls</code> and <code>grep</code> aliases
        </li>
        <li>
          Ensures <code>.bashrc</code> is sourced in <code>.bash_profile</code>
        </li>
      </ul>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <div className="bg-gray-100 text-gray-800 p-4 rounded-md overflow-x-auto mb-6 border border-gray-300">
        <pre className="whitespace-pre-wrap text-sm">
          {`# Modify .bashrc for root
cp /root/.bashrc /root/.bashrc.bak
sed -i '/HISTTIMEFORMAT/d' /root/.bashrc
sed -i '/PS1/d' /root/.bashrc
sed -i '/alias/d' /root/.bashrc

echo 'export HISTTIMEFORMAT="%d/%m/%y %T "' >> /root/.bashrc
echo 'export PS1="\\u@\\h:\\W \\\$ "' >> /root/.bashrc
echo "alias ll='ls -alF'" >> /root/.bashrc
source /root/.bashrc`}
        </pre>
      </div>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Configure MOTD (Message of the Day)
      </h3>
      <p className="mb-4">This option customizes the MOTD to display a ProxMenux optimization message upon login.</p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <div className="bg-gray-100 text-gray-800 p-4 rounded-md overflow-x-auto mb-6 border border-gray-300">
        <pre className="whitespace-pre-wrap text-sm">
          {`# Backup original MOTD
cp /etc/motd /etc/motd.bak

echo "This system is optimized by: ProxMenux" | cat - /etc/motd > temp && mv temp /etc/motd`}
        </pre>
      </div>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Remove Proxmox Subscription Banner
      </h3>
      <p className="mb-4">
        This option removes the Proxmox subscription banner and nag prompts from the web interface.
      </p>
      <p className="mb-4">What it does:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>
          Patches <code>proxmoxlib.js</code> to disable banner checks
        </li>
        <li>Creates a cron job to ensure banner removal persists</li>
        <li>Configures APT to prevent nagging messages</li>
      </ul>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <div className="bg-gray-100 text-gray-800 p-4 rounded-md overflow-x-auto mb-6 border border-gray-300">
        <pre className="whitespace-pre-wrap text-sm">
          {`# Remove Proxmox subscription banner
sed -i "s/data.status !== 'Active'/false/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js
sed -i "s/checked_command: function(orig_cmd) {/checked_command: function() {} || function(orig_cmd) {/g" /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js

echo "DPkg::Post-Invoke { \\"dpkg -V proxmox-widget-toolkit | grep -q '/proxmoxlib\\\\.js$'; if [ $\\? -eq 1 ]; then { echo 'Removing subscription nag from UI...'; sed -i '/data.status/{s/\\!/\\!/;s/Active/NoMoreNagging/}' /usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js; }; fi\\"; };" > /etc/apt/apt.conf.d/xs-pve-no-nag`}
        </pre>
      </div>

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Customization Application</h2>
        <p>
          These customization settings are applied automatically when selected in the post-install process. Adjustments
          can be made manually as needed.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/monitoring/page.tsx
================================================
import type { Metadata } from "next"
import { LineChart } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Monitoring Settings",
  description:
    "Guide to Monitoring Settings in the ProxMenux post-install script for enhancing your Proxmox VE monitoring capabilities.",
  openGraph: {
    title: "ProxMenux Post-Install: Monitoring Settings",
    description:
      "Guide to Monitoring Settings in the ProxMenux post-install script for enhancing your Proxmox VE monitoring capabilities.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/monitoring",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/monitoring-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Monitoring Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Monitoring Settings",
    description:
      "Guide to Monitoring Settings in the ProxMenux post-install script for enhancing your Proxmox VE monitoring capabilities.",
    images: ["https://macrimi.github.io/ProxMenux/monitoring-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function MonitoringSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <LineChart className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Monitoring Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Monitoring Settings</strong> category focuses on enhancing the monitoring capabilities of your
        Proxmox VE installation. These settings are designed to provide better insights into your system's performance
        and health.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Install OVH Real Time Monitoring (RTM)
      </h3>
      <p className="mb-4">
        This optimization detects if the server is hosted by OVH and installs the OVH Real Time Monitoring (RTM) tool if
        applicable.
      </p>
      <p className="mb-4">The following steps are performed:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>Detects the server's public IP address</li>
        <li>Checks if the IP belongs to OVH using WHOIS information</li>
        <li>If it's an OVH server, installs the OVH RTM tool</li>
      </ul>
      <p className="mb-4">
        <strong>Note:</strong> This optimization is only applicable to servers hosted by OVH. If your server is not
        hosted by OVH, this step will be skipped.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Get the public IP and check if it belongs to OVH
public_ip=$(curl -s ipinfo.io/ip)
is_ovh=$(whois -h v4.whois.cymru.com " -t $public_ip" | tail -n 1 | cut -d'|' -f3 | grep -i "ovh")

if [ -n "$is_ovh" ]; then
    # Install OVH RTM
    wget -qO - https://last-public-ovh-infra-yak.snap.mirrors.ovh.net/yak/archives/apply.sh | OVH_PUPPET_MANIFEST=distribyak/catalog/master/puppet/manifests/common/rtmv2.pp bash
fi
      `}
      />

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          This monitoring optimization is automatically applied when selected in the Monitoring section. The automation
          ensures that the OVH RTM tool is installed correctly if your server is hosted by OVH, enhancing your server's
          monitoring capabilities without manual intervention.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/network/page.tsx
================================================
import type { Metadata } from "next"
import { Network } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Network Settings",
  description:
    "Comprehensive guide to Network Settings in the ProxMenux post-install script for optimizing Proxmox VE network performance and configuration.",
  openGraph: {
    title: "ProxMenux Post-Install: Network Settings",
    description:
      "Comprehensive guide to Network Settings in the ProxMenux post-install script for optimizing Proxmox VE network performance and configuration.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/network",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/network-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Network Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Network Settings",
    description:
      "Comprehensive guide to Network Settings in the ProxMenux post-install script for optimizing Proxmox VE network performance and configuration.",
    images: ["https://macrimi.github.io/ProxMenux/network-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function NetworkSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Network className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Network Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Network Settings</strong> category focuses on optimizing network performance and configuration in Proxmox VE. 
        These settings are essential for efficient network operations in virtualized environments where multiple VMs and containers 
        share network resources.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Apply Network Optimizations
      </h3>
      <p className="mb-4">
      This setting adjusts various <strong>sysctl</strong> parameters to enhance network performance, security, and stability.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Improves throughput, reduces latency, and enhances security
        by fine-tuning kernel network settings. These optimizations are critical in virtualization environments where network 
        efficiency directly impacts VMs and container performance.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
cat <<EOF | sudo tee /etc/sysctl.d/99-network-performance.conf
net.core.netdev_max_backlog=8192
net.core.optmem_max=8192
net.core.rmem_max=16777216
net.core.somaxconn=8151
net.core.wmem_max=16777216
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.all.log_martians = 0
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv4.conf.default.log_martians = 0
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.ip_local_port_range=1024 65535
net.ipv4.tcp_base_mss = 1024
net.ipv4.tcp_challenge_ack_limit = 999999999
net.ipv4.tcp_fin_timeout=10
net.ipv4.tcp_keepalive_intvl=30
net.ipv4.tcp_keepalive_probes=3
net.ipv4.tcp_keepalive_time=240
net.ipv4.tcp_limit_output_bytes=65536
net.ipv4.tcp_max_syn_backlog=8192
net.ipv4.tcp_max_tw_buckets = 1440000
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_rfc1337=1
net.ipv4.tcp_rmem=8192 87380 16777216
net.ipv4.tcp_sack=1
net.ipv4.tcp_slow_start_after_idle=0
net.ipv4.tcp_syn_retries=3
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_tw_recycle = 0
net.ipv4.tcp_tw_reuse = 0
net.ipv4.tcp_wmem=8192 65536 16777216
net.netfilter.nf_conntrack_generic_timeout = 60
net.netfilter.nf_conntrack_helper=0
net.netfilter.nf_conntrack_max = 524288
net.netfilter.nf_conntrack_tcp_timeout_established = 28800
net.unix.max_dgram_qlen = 4096
EOF

sudo sysctl -p /etc/sysctl.d/99-network-performance.conf
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Enable TCP BBR and Fast Open
      </h3>
      <p className="mb-4">This optimization enables  <strong>TCP BBR</strong>, Google's congestion control algorithm, and  <strong>TCP Fast Open</strong>.</p>
      <p className="mb-4">
      <strong>Why it's beneficial:</strong>
      <ul className="list-disc pl-5">
        <li><strong>TCP BBR</strong> improves network throughput and reduces latency, especially over long-distance or congested links.</li>
        <li><strong>TCP Fast Open</strong> accelerates connection establishment, benefiting short-lived connections.</li>
      </ul>
     </p>
     <p className="mb-4">These enhancements improve network responsiveness in virtualized environments 
     where efficient communication between systems is critical.
     </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
echo "net.core.default_qdisc = fq" | sudo tee -a /etc/sysctl.d/99-tcp-bbr.conf
echo "net.ipv4.tcp_congestion_control = bbr" | sudo tee -a /etc/sysctl.d/99-tcp-bbr.conf
echo "net.ipv4.tcp_fastopen = 3" | sudo tee -a /etc/sysctl.d/99-tcp-fastopen.conf

sudo modprobe tcp_bbr
sudo sysctl -p /etc/sysctl.d/99-tcp-bbr.conf
sudo sysctl -p /etc/sysctl.d/99-tcp-fastopen.conf
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Force APT to Use IPv4
      </h3>
      <p className="mb-4">This setting forces <strong>APT (Advanced Package Tool)</strong> to use <strong>IPv4</strong> exclusively.</p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Ensures reliable package management operations in environments where IPv6
        is misconfigured or causes slow downloads. This is particularly useful in networks where IPv6 connectivity 
        is unstable or unsupported, reducing potential update and repository access issues.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
echo 'Acquire::ForceIPv4 "true";' | sudo tee /etc/apt/apt.conf.d/99force-ipv4
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={4} />
        Install Open vSwitch
      </h3>

      <p className="mb-4">
        This optimization installs <strong>Open vSwitch (OVS)</strong>, a multilayer virtual switch 
        designed for modern virtualized environments. OVS enhances network management by enabling 
        advanced features for virtualized infrastructures.
      </p>

      <p className="mb-4">
        <strong className="block">Why it's beneficial:</strong>
        Open vSwitch provides powerful networking capabilities, including:
      </p>

      <ul className="list-disc pl-5 mb-4">
        <li><strong>VLAN Support:</strong> Enables segmentation of virtual networks for better security and isolation.</li>
        <li><strong>Trunking:</strong> Allows multiple VLANs on a single physical or virtual interface.</li>
        <li><strong>Traffic Shaping:</strong> Implements bandwidth control and rate limiting per interface or flow.</li>
        <li><strong>Quality of Service (QoS):</strong> Prioritizes network traffic for optimized performance.</li>
        <li><strong>Integration with SDN (Software Defined Networking):</strong> Works seamlessly with OpenFlow for programmable network control.</li>
      </ul>

      <p className="text-lg mb-2">This adjustment automates the following commands:</p>

      <CopyableCode
        code={`
      # Install Open vSwitch packages
      DEBIAN_FRONTEND=noninteractive apt-get -y install openvswitch-switch openvswitch-common

      # Verify installation
      ovs-vsctl --version
        `}
      />

      <h4 className="text-lg font-semibold mt-6">Basic Usage: Creating a Virtual Switch</h4>
      <p className="mb-4">
        Once installed, Open vSwitch can be used to create virtual network bridges. Below is an example of how to create a virtual switch named <code>br0</code> and add a network interface to it.
      </p>

      <CopyableCode
        code={`
      # Create a new OVS bridge
      ovs-vsctl add-br br0

      # Add a network interface (e.g., eth1) to the bridge
      ovs-vsctl add-port br0 eth1

      # Show the current Open vSwitch configuration
      ovs-vsctl show
        `}
      />

      <h4 className="text-lg font-semibold mt-6">Adding VLANs to Open vSwitch</h4>
      <p className="mb-4">
        Open vSwitch allows VLAN tagging to segment network traffic. Below is an example of how to add an interface to a specific VLAN.
      </p>

      <CopyableCode
        code={`
      # Add eth1 to br0 and assign it to VLAN 100
      ovs-vsctl add-port br0 eth1 tag=100
        `}
      />

      <h4 className="text-lg font-semibold mt-6">Trunking Multiple VLANs</h4>
      <p className="mb-4">
        If an interface needs to carry multiple VLANs (trunk mode), use the following command:
      </p>

      <CopyableCode
        code={`
      # Configure eth1 as a trunk port allowing VLANs 100 and 200
      ovs-vsctl add-port br0 eth1 trunks=100,200
        `}
      />

      <h4 className="text-lg font-semibold mt-6">Deleting a Bridge or Port</h4>
      <p className="mb-4">
        If you need to remove a bridge or a port from Open vSwitch, use these commands:
      </p>

      <CopyableCode
        code={`
      # Delete a bridge
      ovs-vsctl del-br br0

      # Remove a port from a bridge
      ovs-vsctl del-port br0 eth1
        `}
      />

      <p className="mt-4">
        Open vSwitch enables advanced networking capabilities for virtual environments, allowing greater 
        control over network traffic, security, and performance optimizations.
      </p>


      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={5} />
        Optimize Network Interface Settings
      </h3>
      <p className="mb-4">
      This setting adjusts network interface parameters to enhance performance and reliability.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        PProper NIC tuning reduces latency, packet loss, and improves stability 
        in environments with high network loads. Adjustments like increasing TX queue length prevent packet drops 
        and enhance network responsiveness, which is essential in virtualized infrastructures with multiple VMs and containers.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Replace eth0 with your actual interface name
sudo ip link set eth0 txqueuelen 10000

# Make the change persistent
echo 'ACTION=="add", SUBSYSTEM=="net", KERNEL=="eth0", RUN+="/sbin/ip link set eth0 txqueuelen 10000"' | sudo tee /etc/udev/rules.d/60-net-txqueue.rules

# Enable TCP timestamps
echo 'net.ipv4.tcp_timestamps = 1' | sudo tee -a /etc/sysctl.d/99-network-performance.conf

sudo sysctl -p /etc/sysctl.d/99-network-performance.conf
      `}
      />

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          All of these optimizations are automatically applied when selected in the Network section. This automation
          ensures that these beneficial settings are applied consistently and correctly, saving time and reducing the
          potential for human error during manual configuration.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/optional/page.tsx
================================================
import type { Metadata } from "next"
import { Plus } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Optional Settings",
  description:
    "Guide to Optional Settings in the ProxMenux post-install script for additional Proxmox VE features and optimizations.",
  openGraph: {
    title: "ProxMenux Post-Install: Optional Settings",
    description:
      "Guide to Optional Settings in the ProxMenux post-install script for additional Proxmox VE features and optimizations.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/optional",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/optional-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Optional Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Optional Settings",
    description:
      "Guide to Optional Settings in the ProxMenux post-install script for additional Proxmox VE features and optimizations.",
    images: ["https://macrimi.github.io/ProxMenux/optional-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function OptionalSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Plus className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Optional Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Optional Settings</strong> category provides additional features and optimizations that you can
        choose to apply to your Proxmox VE installation. These settings are not essential but can enhance your system's
        capabilities in specific scenarios.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optional Features</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Add Latest Ceph Support
      </h3>
      <p className="mb-4">
        This option installs the latest Ceph storage system support for Proxmox VE. Ceph is a distributed storage system
        that provides high performance, reliability, and scalability.
      </p>
      <p className="mb-4">What it does:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>Adds the Ceph repository to your system</li>
        <li>Updates package lists</li>
        <li>Installs Ceph packages using the 'pveceph install' command</li>
        <li>Verifies the installation</li>
      </ul>
      <p className="mb-4">
        How to use: After installation, you can configure and manage Ceph storage using the Proxmox VE web interface or
        command-line tools.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Add Ceph repository
echo "deb https://download.proxmox.com/debian/ceph-squid $(lsb_release -cs) no-subscription" > /etc/apt/sources.list.d/ceph-squid.list

# Update package lists
apt-get update

# Install Ceph
pveceph install

# Verify installation
pveceph status
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Apply AMD CPU Fixes
      </h3>
      <p className="mb-4">
        This option applies specific fixes for AMD EPYC and Ryzen CPUs to improve stability and compatibility.
      </p>
      <p className="mb-4">What it does:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>Detects if an AMD EPYC or Ryzen CPU is present</li>
        <li>Applies kernel parameter 'idle=nomwait' to prevent random crashes</li>
        <li>Configures KVM to ignore certain MSRs (Model Specific Registers) for better Windows guest compatibility</li>
        <li>Installs the latest Proxmox VE kernel</li>
      </ul>
      <p className="mb-4">
        How to use: These fixes are applied automatically and require a system reboot to take effect.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Set kernel parameter
sed -i 's/GRUB_CMDLINE_LINUX_DEFAULT="/GRUB_CMDLINE_LINUX_DEFAULT="idle=nomwait /g' /etc/default/grub
update-grub

# Configure KVM
echo "options kvm ignore_msrs=Y" >> /etc/modprobe.d/kvm.conf
echo "options kvm report_ignored_msrs=N" >> /etc/modprobe.d/kvm.conf

# Install latest Proxmox VE kernel
apt-get install pve-kernel-$(uname -r | cut -d'-' -f1-2)
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Enable High Availability Services
      </h3>
      <p className="mb-4">
        This option enables High Availability (HA) services in Proxmox VE, allowing for automatic failover of VMs and
        containers in case of node failure.
      </p>
      <p className="mb-4">What it does:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>Enables and starts the pve-ha-lrm (Local Resource Manager) service</li>
        <li>Enables and starts the pve-ha-crm (Cluster Resource Manager) service</li>
        <li>Enables and starts the corosync service for cluster communication</li>
      </ul>
      <p className="mb-4">
        How to use: After enabling these services, you can configure HA groups and resources in the Proxmox VE web
        interface.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
systemctl enable --now pve-ha-lrm pve-ha-crm corosync
      `}
      />


    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
      <StepNumber number={4} />
      Enable Proxmox Testing Repository
    </h3>
    <p className="mb-4">
      This option enables the Proxmox testing repository, allowing access to the latest, potentially unstable versions of Proxmox VE packages.
    </p>
    <p className="mb-4">What it does:</p>
    <ul className="list-disc pl-5 mb-4">
      <li>Adds the Proxmox testing repository to the system's package sources</li>
      <li>Creates a new file in /etc/apt/sources.list.d/ for the testing repository</li>
      <li>Updates the package lists to include packages from the new repository</li>
    </ul>
    <p className="mb-4">
      How to use: After enabling this repository, you can update and upgrade your system to get the latest testing versions of Proxmox VE packages. Use with caution as these versions may be unstable.
    </p>
    <p className="text-lg mb-2">To manually add the Proxmox testing repository, you can use these commands:</p>
    <CopyableCode
      code={`
    # Add Proxmox testing repository
    echo "deb http://download.proxmox.com/debian/pve $(lsb_release -cs) pvetest" | sudo tee /etc/apt/sources.list.d/pve-testing-repo.list

    # Update package lists
    sudo apt update
      `}
    />
    <p className="mt-4 text-sm text-gray-600">
      Note: $(lsb_release -cs) automatically detects your Proxmox VE version codename (e.g., bullseye).
    </p>
    <p className="mt-4 text-yellow-600">
      Warning: Enabling the testing repository may lead to system instability. It's recommended for testing environments only.
    </p>


    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
      <StepNumber number={5} />
      Install and Configure Fastfetch
    </h3>

    <p className="mb-4">
      This option silently installs and configures Fastfetch, a system information tool that displays system specs and a
      custom logo at login.
    </p>

    <p className="mb-4">
      <strong>What it does:</strong>
    </p>
    <ul className="list-disc pl-5 mb-4">
      <li>Silently downloads and installs the latest version of Fastfetch</li>
      <li>
        Allows you to choose a custom logo (
        <strong>ProxMenux, Proxmox, Helper-Scripts, Home-Labs-Club, Proxmology</strong>, or a custom one)
      </li>
      <li>
        Configures Fastfetch to display <em>"System optimised by ProxMenux"</em>
      </li>
      <li>Sets up Fastfetch to run automatically at console login</li>
    </ul>

    <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
      <p className="font-semibold">Important:</p>
      <p>
        If you connect to Proxmox via SSH, you should select the <strong>Proxmox</strong> logo or create a custom one
        using <code>jp2a</code> or <code>img2txt</code>. The other logos are generated using <code>chafa</code> and may
        not display correctly in a standard SSH session.
      </p>
    </div>

    <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4">
      <p className="font-semibold">Custom Logos:</p>
      <p>
        To use a custom logo, place your ASCII art text file in: <code>/usr/local/share/fastfetch/logos/</code>
      </p>
      <p>
        You can create custom logos using tools like <code>chafa</code>, <code>jp2a</code>, or <code>img2txt</code>.</p>
      <p>
        For best results:
      </p>
      <ul className="list-disc pl-5 mt-2">
        <li>Keep the logo height to 35 lines or less to maintain proportions and fit in the terminal</li>
        <li>
          Use <code>chafa</code> for color logos (may not display correctly in SSH sessions)
        </li>
        <li>
          Use <code>jp2a</code> or <code>img2txt</code> for SSH-compatible logos
        </li>
      </ul>
    </div>

    <p className="mb-4">
      <strong>Example Logos:</strong>
    </p>

    <div className="grid grid-cols-2 md:grid-cols-3 gap-4">
      <div>
        <p className="font-semibold text-center">ProxMenux</p>
        <img
          src="https://macrimi.github.io/ProxMenux/fastfetch/proxmenux.png"
          alt="ProxMenux Logo"
          className="rounded shadow-lg"
        />
      </div>
      <div>
        <p className="font-semibold text-center">Proxmox</p>
        <img
          src="https://macrimi.github.io/ProxMenux/fastfetch/proxmox.png"
          alt="Proxmox Logo"
          className="rounded shadow-lg"
        />
      </div>
      <div>
        <p className="font-semibold text-center">Helper-Scripts</p>
        <img
          src="https://macrimi.github.io/ProxMenux/fastfetch/helper-scripts.png"
          alt="Helper-Scripts Logo"
          className="rounded shadow-lg"
        />
      </div>
      <div>
        <p className="font-semibold text-center">Home-Labs-Club</p>
        <img
          src="https://macrimi.github.io/ProxMenux/fastfetch/home-labs-club.png"
          alt="Home-Labs-Club Logo"
          className="rounded shadow-lg"
        />
      </div>
      <div>
        <p className="font-semibold text-center">Proxmology</p>
        <img
          src="https://macrimi.github.io/ProxMenux/fastfetch/proxmology.png"
          alt="Proxmology Logo"
          className="rounded shadow-lg"
        />
      </div>
    </div>

    <p className="text-lg mb-2">This adjustment automates the following commands:</p>
    <CopyableCode
      code={`
# Download and install the latest version of Fastfetch
FASTFETCH_URL=$(curl -s https://api.github.com/repos/fastfetch-cli/fastfetch/releases/latest | grep "browser_download_url.*fastfetch-linux-amd64.deb" | cut -d '"' -f 4)
wget -q -O /tmp/fastfetch.deb "$FASTFETCH_URL"
dpkg -i /tmp/fastfetch.deb 
apt-get install -f -y 

# Configure Fastfetch (logo selection remains interactive)
# The configuration is done through a series of jq commands

# Set Fastfetch to run at login
echo "clear && fastfetch" >> ~/.bashrc
      `}
    />

    
	<h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={6} />
        Install and Configure Figurine
      </h3>

      <p className="mb-4">
        This option installs and configures Figurine, a tool that creates stylish ASCII text banners for your terminal,
        displaying your hostname in a visually appealing 3D format.
      </p>

      <p className="mb-4">
        <strong>What it does:</strong>
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Downloads and installs Figurine v1.3.0 from GitHub</li>
        <li>Creates a welcome message that displays your hostname in 3D ASCII art when you log in</li>
        <li>Automatically removes any previous Figurine installation if present</li>
        <li>Sets up the welcome message to run automatically at login</li>
      </ul>

      <div className="bg-blue-100 border-l-4 border-blue-500 text-blue-700 p-4 mb-4">
        <p className="font-semibold">Practical Use:</p>
        <p>
          When managing multiple Proxmox nodes in a cluster, Figurine provides an immediate visual indication of which
          node you're currently logged into. This helps prevent accidental commands on the wrong node and improves your
          workflow when managing multiple servers.
        </p>
      </div>

      <p className="mb-4">
        <strong>Example Output:</strong>
      </p>

      <div className="mb-6 flex justify-center">
        <img
          src="https://macrimi.github.io/ProxMenux/figurine/figurine.png"
          alt="Figurine Example Output"
          className="rounded-md shadow-lg border border-gray-200"
          style={{ maxWidth: "100%" }}
        />
      </div>

      <p className="text-lg mb-2">This adjustment automates the following process:</p>
      <CopyableCode
        code={`
# Check for previous installation and remove if found
if command -v figurine &> /dev/null; then
  rm -f "/usr/local/bin/figurine"
fi

# Download and install Figurine
version="1.3.0"
file="figurine_linux_amd64_v\${version}.tar.gz"
url="https://github.com/arsham/figurine/releases/download/v\${version}/\${file}"
wget -qO "/tmp/\${file}" "\${url}"
tar -xf "/tmp/\${file}" -C "/tmp"
mv "/tmp/deploy/figurine" "/usr/local/bin/figurine"
chmod +x "/usr/local/bin/figurine"

# Create welcome message script
cat << 'EOF' > "/etc/profile.d/figurine.sh"
/usr/local/bin/figurine -f "3d.flf" $(hostname)
EOF
chmod +x "/etc/profile.d/figurine.sh"
  `}
     />

      <p className="mt-4">
        After installation, you'll see your hostname displayed in 3D ASCII art each time you log in, making it
        immediately clear which Proxmox node you're working on.
      </p>
	

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          These optional features are applied only when specifically selected during the post-install process. Each
          feature can be individually chosen based on your specific needs and preferences.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/performance/page.tsx
================================================
import type { Metadata } from "next"
import { Zap } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Performance Settings",
  description:
    "Guide to Performance Settings in the ProxMenux post-install script for optimizing your Proxmox VE system performance.",
  openGraph: {
    title: "ProxMenux Post-Install: Performance Settings",
    description:
      "Guide to Performance Settings in the ProxMenux post-install script for optimizing your Proxmox VE system performance.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/performance",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/performance-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Performance Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Performance Settings",
    description:
      "Guide to Performance Settings in the ProxMenux post-install script for optimizing your Proxmox VE system performance.",
    images: ["https://macrimi.github.io/ProxMenux/performance-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function PerformanceSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Zap className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Performance Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Performance Settings</strong> category focuses on optimizing various aspects of your Proxmox VE
        system to enhance overall performance. These settings are designed to improve system efficiency and speed up
        certain operations.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>



    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
      <StepNumber number={1} />
      Configure pigz for Faster gzip Compression
    </h3>

    <p className="mb-4">
      This optimization replaces the default <strong>gzip</strong> compression with 
      <strong>pigz</strong>, a parallelized version that speeds up compression by 
      utilizing multiple CPU cores.
    </p>

    <h4 className="text-lg font-semibold mt-4">What does this configuration do?</h4>
    <ul className="list-disc pl-5 mb-4">
      <li><strong>Forces pigz usage</strong> in vzdump backups to accelerate Proxmox VE backup compression.</li>
      <li><strong>Ensures pigz is installed</strong> before applying optimizations.</li>
      <li><strong>Creates a pigz wrapper script</strong> to enforce compression behavior.</li>
      <li><strong>Replaces gzip with the pigz wrapper</strong>, making pigz the system-wide default compressor.</li>
    </ul>

    <h4 className="text-lg font-semibold mt-4">How is pigz configured?</h4>

    <p className="text-lg mb-2">This automation executes the following commands:</p>

    <CopyableCode
      code={`
    # Force pigz usage in vzdump configuration (for Proxmox backups)
    sed -i "s/#pigz:.*/pigz: 1/" /etc/vzdump.conf

    # Install pigz package
    apt-get -y install pigz

    # Create a pigz wrapper script
    cat <<EOF > /bin/pigzwrapper
    #!/bin/sh
    PATH=/bin:\$PATH
    GZIP="-1"
    exec /usr/bin/pigz "\$@"
    EOF
    chmod +x /bin/pigzwrapper

    # Replace gzip with pigz wrapper (backup original gzip binary)
    if [ ! -f /bin/gzip.original ]; then
        mv -f /bin/gzip /bin/gzip.original
        cp -f /bin/pigzwrapper /bin/gzip
        chmod +x /bin/gzip
    fi
      `}
    />

    <h4 className="text-lg font-semibold mt-6">How to Verify pigz is Active</h4>

    <p className="mb-4">
      You can confirm that <strong>pigz</strong> is being used by running the following command:
    </p>

    <CopyableCode
      code={`
    # Check if gzip now points to pigz
    gzip --version
      `}
    />

    <p className="mb-4">
      If the output mentions <code>pigz</code>, the replacement was successful.
    </p>


    <p className="mt-4">
      With this optimization, vzdump backups and all gzip compression tasks benefit from parallel processing,
      reducing execution time considerably.
    </p>



      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          This performance optimization is automatically applied when selected in the Performance section. The
          automation ensures that pigz is correctly configured and integrated into your system, potentially improving
          the speed of compression operations without requiring manual intervention.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/security/page.tsx
================================================
import type { Metadata } from "next"
import { Shield } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Security Settings",
  description:
    "Comprehensive guide to Security Settings in the ProxMenux post-install script for enhancing Proxmox VE security.",
  openGraph: {
    title: "ProxMenux Post-Install: Security Settings",
    description:
      "Comprehensive guide to Security Settings in the ProxMenux post-install script for enhancing Proxmox VE security.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/security",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/security-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Security Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Security Settings",
    description:
      "Comprehensive guide to Security Settings in the ProxMenux post-install script for enhancing Proxmox VE security.",
    images: ["https://macrimi.github.io/ProxMenux/security-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function SecuritySettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Shield className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Security Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Security Settings</strong> category focuses on enhancing the security of your Proxmox VE
        installation. These settings are crucial for protecting your virtualization environment from potential threats
        and unauthorized access.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Disable portmapper/rpcbind
      </h3>
      <p className="mb-4">This optimization disables the portmapper/rpcbind service for improved security.</p>
      <p className="mb-4">
        <strong>Why it's beneficial:</strong> Disabling unnecessary services like portmapper/rpcbind reduces the attack
        surface of your system. This service is often not needed in modern environments and can be a potential security
        risk if left enabled.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Disable and stop rpcbind
systemctl disable rpcbind
systemctl stop rpcbind
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Install Lynis Security Tool
      </h3>
      <p className="mb-4">
        Lynis is a comprehensive security auditing tool that analyzes your system, detects vulnerabilities, and provides
        recommendations for improving security.
      </p>
      <p className="mb-4">
        <strong>How it works:</strong> Lynis scans the system and evaluates various security parameters, including:
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Kernel security and system settings</li>
        <li>Authentication policies (SSH, user passwords, etc.)</li>
        <li>Network configurations and firewall rules</li>
        <li>File permissions and system integrity</li>
        <li>Malware detection and system hardening suggestions</li>
      </ul>
      <p className="mb-4">
        <strong>Installation method:</strong> ProxMenux now installs the latest version of Lynis directly from the
        official GitHub repository to ensure you have the most up-to-date security scanning capabilities.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following process:</p>
      <CopyableCode
        code={`
# Install Git (if not already installed)
apt-get update -qq
apt-get install -y git

# Clone Lynis from GitHub
git clone https://github.com/CISOfy/lynis.git /opt/lynis

# Create wrapper script for easy execution
cat << 'EOF' > /usr/local/bin/lynis
#!/bin/bash
cd /opt/lynis && ./lynis "$@"
EOF
chmod +x /usr/local/bin/lynis
        `}
      />
      <p className="text-lg mt-4">To run a system security audit, execute:</p>
      <CopyableCode
        code={`
# Perform a full security audit
lynis audit system
        `}
      />
      <p className="text-lg mt-4">To check the installed Lynis version:</p>
      <CopyableCode
        code={`
# Display Lynis version
lynis show version
        `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Protect Web Interface with Fail2Ban
      </h3>
      <p className="mb-4">
        Fail2Ban enhances security by monitoring login attempts and banning malicious IPs that attempt unauthorized
        access.
      </p>
      <p className="mb-4">
        <strong>How it works:</strong> Fail2Ban analyzes logs, detects repeated authentication failures, and
        automatically bans the source IP address to prevent further attacks.
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Protects the Proxmox VE web interface from brute-force attacks</li>
        <li>Prevents unauthorized SSH access by banning repeated failed login attempts</li>
        <li>Automatically blocks malicious IPs to reduce attack vectors</li>
      </ul>

      <h4 className="text-lg font-semibold mt-4">Fail2Ban Configuration Overview</h4>
      <p className="mb-4">Fail2Ban is configured with the following security policies:</p>
      <ul className="list-disc pl-5 mb-4">
        <li>
          <strong>Ban Duration:</strong> 24 hours for SSH and 1 hour for Proxmox
        </li>
        <li>
          <strong>Max Retries:</strong> 2 failed attempts for SSH, 3 for Proxmox
        </li>
        <li>
          <strong>Find Time:</strong> 30 minutes for SSH, 10 minutes for Proxmox
        </li>
        <li>
          <strong>Log Monitoring:</strong> <code>/var/log/auth.log</code> for SSH and <code>/var/log/daemon.log</code>{" "}
          for Proxmox
        </li>
      </ul>

      <p className="text-lg mb-2">This adjustment automates the following command:</p>
      <CopyableCode
        code={`
    # Install Fail2Ban
    apt-get -y install fail2ban
      `}
      />

      <p className="text-lg mt-4"></p>
      <CopyableCode
        code={`
    # Create the Fail2Ban filter for Proxmox
    cat <<EOF > /etc/fail2ban/filter.d/proxmox.conf
    [Definition]
    failregex = pvedaemon\\[.*authentication failure; rhost=<HOST> user=.* msg=.*
    ignoreregex =
    EOF
      `}
      />

      <p className="text-lg mt-4"></p>
      <CopyableCode
        code={`
    # Create a jail configuration for Proxmox
    cat <<EOF > /etc/fail2ban/jail.d/proxmox.conf
    [proxmox]
    enabled = true
    port = https,http,8006,8007
    filter = proxmox
    logpath = /var/log/daemon.log
    maxretry = 3
    bantime = 3600
    findtime = 600
    EOF
      `}
      />

      <p className="text-lg mt-4"></p>
      <CopyableCode
        code={`
    # Configure general Fail2Ban settings
    cat <<EOF > /etc/fail2ban/jail.local
    [DEFAULT]
    ignoreip = 127.0.0.1
    bantime = 86400
    maxretry = 2
    findtime = 1800

    [ssh-iptables]
    enabled = true
    filter = sshd
    action = iptables[name=SSH, port=ssh, protocol=tcp]
    logpath = /var/log/auth.log
    maxretry = 2
    findtime = 3600
    bantime = 32400
    EOF
      `}
      />

      <p className="text-lg mt-4"></p>
      <CopyableCode
        code={`
    # Enable and restart Fail2Ban
    systemctl enable fail2ban
    systemctl restart fail2ban
      `}
      />

      <p className="text-lg mt-4">Check active Fail2Ban jails:</p>
      <CopyableCode
        code={`
    # Display Fail2Ban status
    fail2ban-client status

    # Check status of Proxmox protection
    fail2ban-client status proxmox

    # Check status of SSH protection
    fail2ban-client status ssh-iptables
      `}
      />

      <h4 className="text-lg font-semibold mt-4">Managing Fail2Ban</h4>
      <p className="mb-4">You can manually unban an IP if needed:</p>
      <CopyableCode
        code={`
    # Unban an IP from SSH protection
    fail2ban-client set ssh-iptables unbanip <IP_ADDRESS>

    # Unban an IP from Proxmox protection
    fail2ban-client set proxmox unbanip <IP_ADDRESS>
      `}
      />

      <p className="mt-4">
        Fail2Ban automatically protect your Proxmox VE and SSH access, reducing the risk of brute-force attacks.
      </p>

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          All of these optimizations are automatically applied when selected in the Security section. This automation
          ensures that these beneficial settings are applied consistently and correctly, saving time and reducing the
          potential for human error during manual configuration.
        </p>
      </section>
    </div>
  )
}



================================================
FILE: web/app/docs/post-install/storage/page.tsx
================================================
import type { Metadata } from "next"
import { HardDrive } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Storage Settings",
  description:
    "Comprehensive guide to Storage Settings in the ProxMenux post-install script for optimizing Proxmox VE storage performance and configuration.",
  openGraph: {
    title: "ProxMenux Post-Install: Storage Settings",
    description:
      "Comprehensive guide to Storage Settings in the ProxMenux post-install script for optimizing Proxmox VE storage performance and configuration.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/storage",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/storage-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Storage Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Storage Settings",
    description:
      "Comprehensive guide to Storage Settings in the ProxMenux post-install script for optimizing Proxmox VE storage performance and configuration.",
    images: ["https://macrimi.github.io/ProxMenux/storage-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function StorageSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <HardDrive className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Storage Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Storage Settings</strong> category optimizes storage configuration and performance in Proxmox VE. 
        These optimizations are essential for efficient storage operations in virtualized environments where multiple VMs 
        and containers share storage resources.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Increase vzdump Backup Speed
      </h3>
      <p className="mb-4">
      This optimization configures <strong>vzdump</strong> to enhance backup speed by adjusting bandwidth limits and I/O priority.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Faster backups reduce the impact on system performance during backup
        operations and allow for more frequent backups, improving data protection. This is particularly important in
        environments with large amounts of data or tight backup windows.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Configure bandwidth limit
sed -i '/^#*bwlimit:/d' /etc/vzdump.conf
echo "bwlimit: 0" >> /etc/vzdump.conf

# Configure I/O priority
sed -i '/^#*ionice:/d' /etc/vzdump.conf
echo "ionice: 5" >> /etc/vzdump.conf
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Install and Configure ZFS Auto-snapshot
      </h3>
      <p className="mb-4">
        This optimization installs the zfs-auto-snapshot package and configures automatic ZFS snapshots at various
        intervals.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Automatic ZFS snapshots provide a robust and efficient method for
        point-in-time recovery, protecting against data loss or corruption. This is especially useful in virtualized
        environments where quick recovery options are crucial.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Install zfs-auto-snapshot
apt-get -y install zfs-auto-snapshot

# Configure snapshot schedules
sed -i 's|^\*/[0-9]*.*--keep=[0-9]*|*/15 * * * * root /usr/sbin/zfs-auto-snapshot --quiet --syslog --label=frequent --keep=4|' /etc/cron.d/zfs-auto-snapshot
sed -i 's|--keep=[0-9]*|--keep=1|g' /etc/cron.hourly/zfs-auto-snapshot
sed -i 's|--keep=[0-9]*|--keep=1|g' /etc/cron.daily/zfs-auto-snapshot
sed -i 's|--keep=[0-9]*|--keep=1|g' /etc/cron.weekly/zfs-auto-snapshot
sed -i 's|--keep=[0-9]*|--keep=1|g' /etc/cron.monthly/zfs-auto-snapshot
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Optimize ZFS ARC Size
      </h3>
      <p className="mb-4">
        This optimization adjusts the ZFS Adaptive Replacement Cache (ARC) size based on the system's available memory.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Properly tuned ZFS ARC can significantly improve storage performance by
        caching frequently accessed data in RAM. This optimization ensures that ZFS uses an appropriate amount of memory
        based on the system's resources, balancing between storage performance and leaving enough memory for other
        processes.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# Calculate ZFS ARC sizes based on RAM
RAM_SIZE_GB=$(free -g | awk '/^Mem:/{print $2}')
if [[ "$RAM_SIZE_GB" -le 16 ]]; then
    MY_ZFS_ARC_MIN=536870911  # 512MB
    MY_ZFS_ARC_MAX=536870912  # 512MB
elif [[ "$RAM_SIZE_GB" -le 32 ]]; then
    MY_ZFS_ARC_MIN=1073741823  # 1GB
    MY_ZFS_ARC_MAX=1073741824  # 1GB
else
    MY_ZFS_ARC_MIN=$((RAM_SIZE_GB * 1073741824 / 16))
    MY_ZFS_ARC_MAX=$((RAM_SIZE_GB * 1073741824 / 8))
fi

# Apply ZFS tuning parameters
cat <<EOF > /etc/modprobe.d/99-zfsarc.conf
# ZFS tuning
options zfs zfs_arc_min=$MY_ZFS_ARC_MIN
options zfs zfs_arc_max=$MY_ZFS_ARC_MAX

# Enable prefetch method
options zfs l2arc_noprefetch=0

# Set max write speed to L2ARC (500MB)
options zfs l2arc_write_max=524288000
options zfs zfs_txg_timeout=60
EOF
      `}
      />

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          All of these optimizations are automatically applied when selected in the Storage section. This automation
          ensures that these beneficial settings are applied consistently and correctly, saving time and reducing the
          potential for human error during manual configuration.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/system/page.tsx
================================================
import type { Metadata } from "next"
import { Server } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: System Settings",
  description:
    "Detailed guide to the System Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
  openGraph: {
    title: "ProxMenux Post-Install: System Settings",
    description:
      "Detailed guide to the System Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/system",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/system-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install System Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: System Settings",
    description:
      "Detailed guide to the System Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    images: ["https://macrimi.github.io/ProxMenux/system-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function SystemSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Server className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">System Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>System Settings</strong> category includes core system configurations and optimizations for Proxmox VE, 
        focusing on performance, stability, and resource management.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Enable Fast Reboots
      </h3>
      <p className="mb-4">
        This optimization enables <code>kexec</code>, allowing the system to boot directly into a new kernel 
        without going through the BIOS/firmware and bootloader.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Fast reboots reduce system downtime during updates and maintenance. 
        This is particularly useful in virtualization environments where minimizing host downtime helps maintain service availability.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
sudo apt-get install -y kexec-tools
sudo systemctl enable kexec-pve.service
echo "alias reboot-quick='systemctl kexec'" >> ~/.bash_profile
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Configure Kernel Panic Behavior
      </h3>
      <p className="mb-4">
      This setting configures the system to automatically reboot after a <strong>kernel panic</strong> instead of remaining unresponsive.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Automatic recovery reduces downtime and prevents the need for manual intervention, 
        which is critical in remote or unattended environments where physical access is limited.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
echo "kernel.panic = 10" | sudo tee /etc/sysctl.d/99-kernelpanic.conf
echo "kernel.panic_on_oops = 1" | sudo tee -a /etc/sysctl.d/99-kernelpanic.conf
sudo sysctl -p /etc/sysctl.d/99-kernelpanic.conf
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={3} />
        Increase System Limits
      </h3>
      <p className="mb-4">
      This optimization increases system resource limits, including the maximum number of <strong>file watches</strong> and <strong>open file descriptors.</strong>
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Higher limits enhance resource utilization, improving performance for applications 
        that monitor large numbers of files or handle high concurrent connections. This is essential 
        for servers running multiple VMs or containers.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
echo "fs.inotify.max_user_watches = 1048576" | sudo tee /etc/sysctl.d/99-maxwatches.conf
echo "* soft nofile 1048576" | sudo tee /etc/security/limits.d/99-limits.conf
sudo sysctl -p
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={4} />
        Optimize Journald
      </h3>
      <p className="mb-4">
      This setting configures <strong>systemd-journald</strong> to limit disk usage and optimize logging performance.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Restricting log size prevents excessive disk consumption, 
        reducing the risk of system partitions filling up. Optimized logging also decreases I/O operations, 
        improving system performance, especially in disk-constrained environments.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
echo "SystemMaxUse=64M" | sudo tee -a /etc/systemd/journald.conf
sudo systemctl restart systemd-journald
      `}
      />

    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
      <StepNumber number={5} />
      Optimize Memory Management
    </h3>

    <p className="mb-4">
      This memory optimization configures low-level kernel parameters to improve <strong>system responsiveness</strong> and <strong>RAM availability</strong>, especially on hosts with limited memory.
    </p>

    <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
      By tuning how Linux handles dirty memory pages, swap usage, and virtual memory mappings, this adjustment helps the system free memory more proactively and avoid sudden out-of-memory (OOM) errors â€” particularly valuable on Proxmox nodes with 1â€“4â€¯GB of RAM.
    </p>

    <p className="mb-4">
      It also enables safe overcommit behavior and, if supported, proactive memory compaction to make memory use more efficient across multiple processes and containers.
    </p>

    <p className="text-lg mb-2">This optimization applies the following configuration:</p>

    <CopyableCode
      code={`
    cat <<EOF | sudo tee /etc/sysctl.d/99-memory.conf
    # Balanced Memory Optimization
    vm.swappiness = 10
    vm.dirty_ratio = 15
    vm.dirty_background_ratio = 5
    vm.overcommit_memory = 1
    vm.max_map_count = 65530
    EOF

    # Enable memory compaction if supported by the system
    if [ -f /proc/sys/vm/compaction_proactiveness ]; then
      echo "vm.compaction_proactiveness = 20" | sudo tee -a /etc/sysctl.d/99-memory.conf
    fi

    # Apply settings
    sudo sysctl -p /etc/sysctl.d/99-memory.conf
      `}
    />


<   h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={6} />
        Improve Entropy Generation with Haveged
      </h3>

      <p className="mb-4">
        <strong>What is entropy?</strong> In computing, entropy is a measure of randomness used by the system for cryptographic operations, secure connections, and random number generation.
      </p>

      <p className="mb-4">
        On Proxmox VE and other virtualized or headless environments, entropy can become insufficientâ€”causing delays or even freezes during operations like generating SSH keys or starting services that rely on encryption.
      </p>

      <p className="mb-4">
        This optimization installs and configures <code>haveged</code>, a daemon that generates high-quality entropy using CPU timing variations to ensure the system always has enough randomness available.
      </p>

      <p className="mb-4">
        <strong>Why it's beneficial:</strong>
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Prevents system slowdowns during cryptographic operations</li>
        <li>Improves reliability of secure services and key generation</li>
        <li>Essential for virtual machines and servers without input peripherals</li>
      </ul>

      <p className="text-lg mb-2">This adjustment automates the following steps:</p>
      <CopyableCode
        code={`
      # Install haveged
      apt-get install -y haveged

      # Configure daemon with low-entropy threshold
      cat <<EOF > /etc/default/haveged
      DAEMON_ARGS="-w 1024"
      EOF

      # Enable haveged to run at startup
      systemctl daemon-reload
      systemctl enable haveged
        `}
      />

      <p className="mt-4">
        Once applied, your system will maintain sufficient entropy levels at all timesâ€”leading to better performance, stability, and responsiveness.
     </p>




     <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={7} />
        Install Kernel Headers
      </h3>

      <p className="mb-4">
        <strong>What are kernel headers?</strong> Kernel headers are essential files that allow software and modules to interface directly with the Linux kernel. They are required when compiling or installing drivers, DKMS modules, or virtualization tools that integrate at a low system level.
      </p>

      <p className="mb-4">
        This optimization automatically detects the current kernel version and installs the appropriate <code>linux-headers</code> package.
      </p>

      <p className="mb-4">
        <strong>Why it's beneficial:</strong>
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Enables the installation of kernel modules such as GPU or ZFS drivers</li>
        <li>Essential for software that compiles components at runtime (e.g., DKMS)</li>
        <li>Improves compatibility with hardware acceleration and advanced features</li>
      </ul>

      <p className="text-lg mb-2">This adjustment automates the following logic:</p>
      <CopyableCode
        code={`
      # Detect current kernel version
      KERNEL_VERSION=$(uname -r)
      PACKAGE="linux-headers-\${KERNEL_VERSION}"

      # Install headers if not present
      if ! dpkg -s "\$PACKAGE" >/dev/null 2>&1; then
        apt-get install -y "\$PACKAGE"
      fi
        `}
     />

      <p className="mt-4">
        After installation, some modules may require a system reboot to activate properly. ProxMenux will notify you if a reboot is recommended.
      </p>



    <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={8} />
        Optimize Logrotate Configuration
      </h3>

      <p className="mb-4">
        <strong>What is logrotate?</strong> Logrotate is a utility that manages the automatic rotation and compression of log files to prevent them from consuming excessive disk space.
      </p>

      <p className="mb-4">
        This optimization replaces the default configuration with a cleaner and more efficient policy that rotates logs daily, compresses them, and limits their size.
      </p>

      <p className="mb-4">
        <strong>Why it's beneficial:</strong>
      </p>
      <ul className="list-disc pl-5 mb-4">
        <li>Prevents system logs from consuming disk space over time</li>
        <li>Improves system performance by reducing log clutter</li>
        <li>Ensures clean, consistent log management across reboots and services</li>
      </ul>

      <p className="text-lg mb-2">This adjustment automates the following logic:</p>
      <CopyableCode
        code={`
      # Backup current config
      cp /etc/logrotate.conf /etc/logrotate.conf.bak

      # Apply optimized configuration
      cat <<EOF > /etc/logrotate.conf
      # ProxMenux optimized configuration
      daily
      su root adm
      rotate 7
      create
      compress
      size=10M
      delaycompress
      copytruncate

      include /etc/logrotate.d
      EOF

      # Restart service
      systemctl restart logrotate
        `}
     />

      <p className="mt-4">
        After applying this optimization, your system will automatically rotate and compress logs based on usage and file size, keeping your disk clean and performance stable.
      </p>


 

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          All of these optimizations are automatically applied when selected in the System section. This automation
          ensures that these beneficial settings are applied consistently and correctly, saving time and reducing the
          potential for human error during manual configuration.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/post-install/virtualization/page.tsx
================================================
import type { Metadata } from "next"
import { Box } from "lucide-react"
import CopyableCode from "@/components/CopyableCode"

export const metadata: Metadata = {
  title: "ProxMenux Post-Install: Virtualization Settings",
  description:
    "Detailed guide to the Virtualization Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
  openGraph: {
    title: "ProxMenux Post-Install: Virtualization Settings",
    description:
      "Detailed guide to the Virtualization Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/post-install/virtualization",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/virtualization-settings-image.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux Post-Install Virtualization Settings",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Post-Install: Virtualization Settings",
    description:
      "Detailed guide to the Virtualization Settings category in the ProxMenux post-install script for Proxmox VE optimization.",
    images: ["https://macrimi.github.io/ProxMenux/virtualization-settings-image.png"],
  },
}

function StepNumber({ number }: { number: number }) {
  return (
    <div className="inline-flex items-center justify-center w-8 h-8 mr-3 text-white bg-blue-500 rounded-full">
      <span className="text-sm font-bold">{number}</span>
    </div>
  )
}

export default function VirtualizationSettingsPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <div className="flex items-center mb-6">
        <Box className="h-8 w-8 mr-2 text-blue-500" />
        <h1 className="text-3xl font-bold">Virtualization Settings</h1>
      </div>
      <p className="mb-4">
        The <strong>Virtualization Settings</strong> category optimizes Proxmox VE for enhanced virtualization performance, 
        compatibility, and functionality.
      </p>
      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Optimizations</h2>

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={1} />
        Enable VFIO IOMMU Support
      </h3>
      <p className="mb-4">
      This setting enables <strong>IOMMU</strong> (Input-Output Memory Management Unit) and configures <strong>VFIO</strong> (Virtual Function I/O) 
      for PCI passthrough, allowing direct assignment of PCI devices to virtual machines.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Enables near-native performance for PCI devices, such as GPUs or network cards, 
        by allowing direct access from VMs. This is essential forGPU acceleration, low-latency networking, 
        and high-performance workloads, reducing hypervisor overhead and improving efficiency.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# For Intel CPUs
echo "intel_iommu=on" | sudo tee -a /etc/default/grub
# For AMD CPUs
echo "amd_iommu=on" | sudo tee -a /etc/default/grub

echo "vfio vfio_iommu_type1 vfio_pci vfio_virqfd" | sudo tee -a /etc/modules

sudo update-grub
sudo update-initramfs -u -k all
      `}
      />

      <h3 className="text-xl font-semibold mt-16 mb-4 flex items-center">
        <StepNumber number={2} />
        Install Relevant Guest Agent
      </h3>
      <p className="mb-4">
      This optimization installs the appropriate <strong>guest agent</strong> based on the virtualization environment.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Enhances host-guest integration by enabling graceful shutdown, 
        file sharing, performance monitoring, and better resource allocation. 
        This improves VM management and overall system efficiency.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
# For QEMU/KVM VMs
sudo apt-get install -y qemu-guest-agent

# For VMware VMs
sudo apt-get install -y open-vm-tools

# For VirtualBox VMs
sudo apt-get install -y virtualbox-guest-utils
      `}
      />

      <h3 className="text-xl font-semibold mt-20 mb-4 flex items-center">
        <StepNumber number={3} />
        Configure KSM (Kernel Samepage Merging)
      </h3>
      <p className="mb-4">
      This setting enables and configures <strong>KSM</strong> to optimize memory usage by sharing identical 
      memory pages across multiple virtual machines.
      </p>
      <p className="mb-4">
      <strong className="block">Why it's beneficial:</strong>
        Reduces RAM consumption in environments with similar VMs, 
        allowing for higher VM density on a single host. This is particularly useful for systems 
        running multiple instances of the same OS or application, improving memory efficiency and overall performance.
      </p>
      <p className="text-lg mb-2">This adjustment automates the following commands:</p>
      <CopyableCode
        code={`
sudo apt-get install -y ksm-control-daemon

echo "KSM_ENABLED=1" | sudo tee -a /etc/default/ksm
echo "KSM_SLEEP_MSEC=100" | sudo tee -a /etc/default/ksm

sudo systemctl enable ksm
sudo systemctl start ksm
      `}
      />

      <section className="mt-12 p-4 bg-blue-100 rounded-md">
        <h2 className="text-xl font-semibold mb-2">Automatic Application</h2>
        <p>
          All of these optimizations are automatically applied when selected in the Virtualization section. This
          automation ensures that these beneficial settings are applied consistently and correctly, saving time and
          reducing the potential for human error during manual configuration.
        </p>
      </section>
    </div>
  )
}




================================================
FILE: web/app/docs/settings/change-language/page.tsx
================================================
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "Change Language | ProxMenux Documentation",
  description: "Guide to changing the language settings in ProxMenux for Proxmox VE.",
}

export default function ChangeLanguage() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Change Language in ProxMenux</h1>
      
      <p className="mb-4">
        ProxMenux supports multiple languages to improve accessibility for users worldwide. The recommended language is <strong>English</strong>. 
        Translations are generated automatically using a predefined translation package and Google Translate. Automatic translations may contain errors, 
        so English is the preferred language for accuracy.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Available Languages</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>English (Recommended)</li>
        <li>Spanish</li>
        <li>French</li>
        <li>German</li>
        <li>Italian</li>
        <li>Portuguese</li>
      </ul>

      <h2 className="text-2xl font-semibold mt-8 mb-4">How It Works</h2>
      <p className="mb-4">
        The language configuration is stored in the ProxMenux settings file. When a new language is selected, the configuration file is updated, and the menu reloads with the new language.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Key Functions</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Displays a menu with available languages.</li>
        <li>Updates the ProxMenux configuration with the selected language.</li>
        <li>Reloads the menu to apply the new language setting.</li>
      </ul>
    </div>
  )
}



================================================
FILE: web/app/docs/settings/show-version-information/page.tsx
================================================
import type { Metadata } from "next"


export const metadata: Metadata = {
  title: "Show Version Information | ProxMenux Documentation",
  description: "Displays ProxMenux version details and installed components.",
}

export default function ShowVersionInformation() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Show Version Information</h1>
      
      <p className="mb-4">
        The <strong>Show Version Information</strong> function provides details about the current ProxMenux installation, including
        the version number, installed components, and configuration files. This helps users verify their setup.
      </p>
      
    </div>
  )
}



================================================
FILE: web/app/docs/settings/uninstall-proxmenux/page.tsx
================================================
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "Uninstall ProxMenux | ProxMenux Documentation",
  description: "Guide to uninstalling ProxMenux from your Proxmox VE system.",
}

export default function UninstallProxMenux() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Uninstall ProxMenux</h1>
      
      <p className="mb-4">
        The <strong>Uninstall ProxMenux</strong> function, remove ProxMenux and its related components from their Proxmox VE system.
        The script provides an interactive option to remove dependencies as well, ensuring a clean uninstallation process.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">How It Works</h2>
      <p className="mb-4">
        When executed, the script performs the following actions:
      </p>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Prompts the user for confirmation before proceeding with the uninstallation.</li>
        <li>Provides an option to remove dependencies such as Python virtual environment and package manager.</li>
        <li>Deletes the ProxMenux installation directory and its configuration files.</li>
        <li>Removes cached data and stored settings.</li>
        <li>Ensures the removal of installed components and performs cleanup.</li>
      </ul>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Removing dependencies is optional. If selected, system-wide packages used by other applications might also be removed.</li>
        <li>Once uninstalled, ProxMenux cannot be restored unless reinstalled manually.</li>
      </ul>

    </div>
  )
}



================================================
FILE: web/app/docs/storage/disk-passthrough-ct/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import { HardDrive, ArrowRight } from "lucide-react"
import { ImageWithCaption } from "@/components/ui/image-with-caption"
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "Disk Passthrough to a CT | ProxMenux Documentation",
  description: "Step-by-step guide to configure disk passthrough to a container (CT) in Proxmox VE using ProxMenux.",
  openGraph: {
    title: "Disk Passthrough to a CT | ProxMenux Documentation",
    description: "Step-by-step guide to configure disk passthrough to a container (CT) in Proxmox VE using ProxMenux.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/disk-ct",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/disk-ct/disk-selection.png",
        width: 1200,
        height: 630,
        alt: "Disk Passthrough to a CT",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "Disk Passthrough to a CT | ProxMenux Documentation",
    description: "Step-by-step guide to configure disk passthrough to a container (CT) in Proxmox VE using ProxMenux.",
    images: ["https://macrimi.github.io/ProxMenux/disk-ct/disk-selection.png"],
  },
}

export default function DiskPassthroughCT() {
  return (
    <div className="max-w-3xl mx-auto">
      <div className="flex items-center mb-6">
        <HardDrive className="h-8 w-8 mr-2 text-blue-500" />
        <ArrowRight className="h-5 w-5 mr-2 text-gray-500" />
        <h1 className="text-3xl font-bold">
          Disk Passthrough to a <span className="text-blue-500">CT</span>
        </h1>
      </div>

      <p className="mb-4">
        This guide explains how to assign a <strong>dedicated physical disk</strong> to a container (CT) in{" "}
        <strong>Proxmox VE</strong> using <strong>ProxMenux</strong>. Assigning a full disk to a container is useful
        when you need isolation, ease of access, or the ability to move the disk between systems, especially for
        services handling large volumes of data such as Samba, Nextcloud, or video surveillance software, among others.
      </p>

      <p className="mb-4">
        While it's more common to passthrough entire disks to virtual machines (VMs), there are scenarios where giving
        full disk access to an LXC container can be very useful.
      </p>

      <ul className="list-disc pl-6 mb-4 space-y-1">
        <li>
          A user running a video surveillance system like <strong>Frigate</strong> or <strong>Agent DVR</strong> might
          want recordings saved on a dedicated disk, so they can easily transfer it to another system for review.
        </li>
        <li>
          A <strong>Nextcloud</strong> container might need full disk access to manage user files and take advantage of
          the entire disk capacity.
        </li>
        <li>
          A container may be used for downloads, storing files on a dedicated disk and sharing them over the local
          network.
        </li>
        <li>Another use case could be writing backups to an isolated disk.</li>
      </ul>

      <p className="mb-6">
        As you can see, there are many different use cases where assigning a physical disk directly to a CT is the ideal
        solution.
      </p>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Description</h2>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Lists physical disks on the Proxmox host, excluding the system disk and mounted system disks.</li>
        <li>Displays all existing LXC containers (CTs) for user selection.</li>
        <li>
          Allows the user to select <strong>one physical disk</strong> per execution.
        </li>
        <li>
          Formats the disk (with user confirmation) or reuses it, then assigns it as a mount point in the selected CT.
        </li>
      </ol>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Step-by-Step Instructions</h2>
      <Steps>
        <Steps.Step title="CT Selection">
        <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/disk/select-container.png"
            alt="Select CT"
            caption="CT Selection Menu."
          />
          
          <p>The user selects the destination LXC container (CT) to which the disk will be assigned.</p>
        </Steps.Step>
        <Steps.Step title="Disk Detection">
          <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/disk/disk-selection-ct.png"
            alt="Disk Selection Menu"
            caption="Disk Selection Menu"
          />
          <p>
            The script lists all physical disks, excluding those used by the system. It also displays metadata like ZFS,
            LVM, and RAID, and shows warnings if the disk is already in use.
          </p>
        </Steps.Step>
        <Steps.Step title="Disk Preparation">
          <p>The script performs the following actions:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Detects whether the disk has a supported filesystem (ext4, xfs, btrfs).</li>
            <li>Offers to format the disk if no valid filesystem is found.</li>
            <li>
              Prompts the user to define the mount point (e.g. <code>/mnt/disk_passthrough</code>).
            </li>
          </ul>
        </Steps.Step>
        <Steps.Step title="Assignment to CT">
        <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/disk/assignment-ct.png"
            alt="Assignment to CT"
            caption="Assignment to CT"
          />
          <p>
            The selected disk is mounted inside the container at the specified path, and permissions are set
            automatically.
          </p>
        </Steps.Step>
      </Steps>

      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The selected disk is successfully mounted and accessible within the specified container.</li>
        <li>The script shows a summary of the operation, including any warnings or errors.</li>
        <li>The container can use the assigned storage immediately.</li>
        <ImageWithCaption
            src="https://macrimi.github.io/ProxMenux/disk/result-point.png"
            alt="Mount point created successfully"
            caption="Mount point created successfully"
          />
      </ul>


      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4">
        <p className="font-semibold">Important:</p>
        <p>
          The container must be <strong>privileged</strong> to allow direct read/write access to the physical disk.
        </p>
      </div>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>
          Only <strong>one disk</strong> can be assigned per script execution.
        </li>
        <li>Avoid assigning the same disk to multiple VMs or CTs that may run at the same time, as this can lead to data corruption or file loss.</li>
        <li>
          Clean any RAID, ZFS, or LVM metadata <strong>manually</strong> before assigning the disk.
        </li>
      </ul>
    </div>
  )
}



================================================
FILE: web/app/docs/storage/disk-passthrough-vm/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"

export const metadata = {
  title: "Disk Passthrough to a VM | ProxMenux Documentation",
  description: "Step-by-step guide to configure disk passthrough to a virtual machine in Proxmox VE using ProxMenux.",
}

export default function DiskPassthroughVM() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Disk Passthrough to a VM</h1>
      
      <p className="mb-4">
        This guide explains how to assign physical disks to virtual machines (VMs) in <strong>Proxmox VE</strong> using <strong>ProxMenux</strong>.
        Disk passthrough allows a VM to have direct access to a physical disk, providing improved performance and compatibility for certain applications.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview</h2>
      <p className="mb-4">The script automates the following steps:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Lists available physical disks on the Proxmox host, excluding the system disk.</li>
        <li>Displays a list of available virtual machines (VMs) for selection.</li>
        <li>Allows the user to select multiple disks to assign to a VM.</li>
        <li>Ensures selected disks are not already in use by another VM.</li>
        <li>Configures the selected disks for passthrough to the chosen VM.</li>
      </ol>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Implementation Steps</h2>
      <Steps>
        <Steps.Step title="Disk Selection">
          <img src="https://macrimi.github.io/ProxMenux/disk/disk-selection.png" alt="Disk Selection Menu" className="mt-4 rounded shadow-lg" />
          <p>The script scans the system and displays a list of available physical disks, excluding the system disk.</p>
        </Steps.Step>
        <Steps.Step title="VM Selection">
          <p>The user selects the virtual machine (VM) to which the disk(s) will be assigned.</p>
        </Steps.Step>
        <Steps.Step title="Disk Assignment">
          <img src="https://macrimi.github.io/ProxMenux/disk/disk-assigment.png" alt="Disk Assigment Menu" className="mt-4 rounded shadow-lg" />
          <p>The script performs the following actions:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Ensures the selected disk is not in use by another VM.</li>
            <li>Provides an interface choice (SATA, SCSI, VirtIO, or IDE).</li>
            <li>Automatically configures the disk passthrough and assigns it to the VM.</li>
          </ul>
        </Steps.Step>
        <Steps.Step title="Confirmation & Finalization">
          <p>The script verifies the operation and confirms the successful disk passthrough.</p>
        </Steps.Step>
      </Steps>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The selected physical disk(s) are successfully assigned to the specified VM.</li>
        <li>Users are provided with a confirmation of the disk assignment.</li>
        <li>The VM is configured to recognize the disk(s) upon startup.</li>
      </ul>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Ensure the selected disk is not already in use by another VM.</li>
        <li>VMs must be powered off before adding disks to prevent data corruption.</li>
        <li>Using disk passthrough limits certain VM features, such as live migration.</li>
      </ul>
      

    </div>
  )
}



================================================
FILE: web/app/docs/storage/import-disk-image-vm/page.tsx
================================================
import { Steps } from "@/components/ui/steps"
import CopyableCode from "@/components/CopyableCode"

export const metadata = {
  title: "Import Disk Image to a VM | ProxMenux Documentation",
  description: "Step-by-step guide to import a disk image into a virtual machine in Proxmox VE using ProxMenux.",
}

export default function ImportDiskImageVM() {
  return (
    <div className="max-w-3xl mx-auto">
      <h1 className="text-3xl font-bold mb-6">Import Disk Image to a VM</h1>
      
      <p className="mb-4">
        This guide explains how to import a disk image into a virtual machine (VM) in <strong>Proxmox VE</strong> using <strong>ProxMenux</strong>.
        The script simplifies the process by scanning for available disk images and allowing users to attach them to VMs without manual configuration.
      </p>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Overview</h2>
      <p className="mb-4">The script automates the following steps:</p>
      <ol className="list-decimal pl-6 space-y-2 mb-6">
        <li>Scans for disk images (.img, .qcow2, .vmdk) in <code>/var/lib/vz/template/images/</code>.</li>
        <li>Displays a list of available virtual machines (VMs) for selection.</li>
        <li>Allows users to choose one or multiple disk images for import.</li>
        <li>Provides storage volume options for placing the imported disk.</li>
        <li>Offers an interface choice (SATA, SCSI, VirtIO, or IDE) for each imported disk.</li>
        <li>Imports and attaches the selected disk images to the chosen VM.</li>
      </ol>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Implementation Steps</h2>
      <Steps>
        <Steps.Step title="Preparation">
          <p>Ensure that the disk images you want to import are placed in <code>/var/lib/vz/template/images/</code>.</p>
        </Steps.Step>
        <Steps.Step title="VM Selection">
          <p>Select the VM where the disk image(s) will be imported.</p>
        </Steps.Step>
        <Steps.Step title="Storage Selection">
          <p>Choose the Proxmox storage volume where the imported disk(s) will be placed.</p>
        </Steps.Step>
        <Steps.Step title="Image Selection">
          <p>Select one or more disk images to import from the list of detected compatible images.</p>
        </Steps.Step>
        <Steps.Step title="Configuration">
          <p>For each selected image:</p>
          <ul className="list-disc pl-6 space-y-1 mt-2">
            <li>Choose the interface type (SATA, SCSI, VirtIO, or IDE).</li>
            <li>Optionally enable SSD emulation (for non-VirtIO interfaces).</li>
            <li>Decide whether to make the disk bootable.</li>
          </ul>
        </Steps.Step>
        <Steps.Step title="Import Process">
          <p>The script will import each selected disk image and display real-time progress updates.</p>
        </Steps.Step>
        <Steps.Step title="Finalization">
          <p>After the import is complete, the script attaches the disks to the VM and applies the selected settings.</p>
        </Steps.Step>
      </Steps>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Expected Results</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>The selected disk images are successfully imported and attached to the specified VM.</li>
        <li>Users receive confirmation of the import operation.</li>
        <li>The VM is configured to recognize the new disks upon startup.</li>
      </ul>
      
      <h2 className="text-2xl font-semibold mt-8 mb-4">Important Considerations</h2>
      <ul className="list-disc pl-6 space-y-2 mb-6">
        <li>Ensure you have sufficient storage space in the selected Proxmox storage volume.</li>
        <li>Supported disk image formats include <code>.img</code>, <code>.qcow2</code>, and <code>.vmdk</code>.</li>
        <li>The target VM must be powered off before importing disk images.</li>
        <li>SSD emulation is only available for non-VirtIO interfaces (SATA, SCSI, IDE).</li>
        <li>Importing a disk as bootable will modify the VMâ€™s boot order. Adjust boot settings as needed.</li>
      </ul>
      
    </div>
  )
}



================================================
FILE: web/app/docs/utils/UUp-Dump-ISO-Creator/page.tsx
================================================
import type { Metadata } from "next"
import Link from "next/link"
import Image from "next/image"
import { ArrowLeft, Download, Package, Code, Server, Clock, ExternalLink } from "lucide-react"

export const metadata: Metadata = {
  title: "ProxMenux Documentation: UUP Dump ISO Creator",
  description:
    "Guide for using the UUP Dump ISO Creator utility in ProxMenux to download and create Windows installation media directly from Microsoft's Windows Update servers.",
  openGraph: {
    title: "ProxMenux Documentation: UUP Dump ISO Creator",
    description:
      "Guide for using the UUP Dump ISO Creator utility in ProxMenux to download and create Windows installation media directly from Microsoft's Windows Update servers.",
    type: "article",
    url: "https://macrimi.github.io/ProxMenux/docs/utilities/uup-dump-iso-creator",
    images: [
      {
        url: "https://macrimi.github.io/ProxMenux/utils/uup-dump-iso-creator.png",
        width: 1200,
        height: 630,
        alt: "ProxMenux UUP Dump ISO Creator",
      },
    ],
  },
  twitter: {
    card: "summary_large_image",
    title: "ProxMenux Documentation: UUP Dump ISO Creator",
    description:
      "Guide for using the UUP Dump ISO Creator utility in ProxMenux to download and create Windows installation media directly from Microsoft's Windows Update servers.",
    images: ["https://macrimi.github.io/ProxMenux/utils/uup-dump-iso-creator.png"],
  },
}

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
}

function ImageWithCaption({ src, alt, caption }: ImageWithCaptionProps) {
  return (
    <div className="flex flex-col items-center w-full max-w-[768px] mx-auto my-4">
      <div className="w-full rounded-md overflow-hidden border border-gray-200">
        <Image
          src={src || "/placeholder.svg?height=400&width=768&query=UUP Dump ISO Creator"}
          alt={alt}
          width={768}
          height={400}
          style={{ height: "auto" }}
          className="object-contain w-full"
          sizes="(max-width: 768px) 100vw, 768px"
        />
      </div>
      <span className="mt-2 text-sm text-gray-600">{caption}</span>
    </div>
  )
}

export default function UUPDumpISOCreatorPage() {
  return (
    <div className="container mx-auto py-10 px-4 bg-white text-black">
      <div className="mb-4">

        <div className="flex items-center gap-3 mb-6">
          <Download className="h-8 w-8 mr-2 text-blue-500" />
          <h1 className="text-3xl font-bold text-black">UUP Dump ISO Creator</h1>
        </div>

        <div className="space-y-4 mt-6">
          <p className="text-lg text-black">
            The UUP Dump ISO Creator script is a ProxMenux utility that allows you to download and create Windows
            installation media directly from Microsoft's Windows Update servers. This option provides access to the
            latest Windows builds, including Insider Preview versions.
          </p>
        </div>
      </div>

      <ImageWithCaption
        src="https://macrimi.github.io/ProxMenux/utils/uup-dump-iso-creator.png"
        alt="UUP Dump ISO Creator"
        caption="UUP Dump ISO Creator in ProxMenux"
      />

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-black">What is UUP Dump?</h2>
        <p className="mb-4">
          UUP Dump is a service that allows users to download Unified Update Platform (UUP) files directly from
          Microsoft's Windows Update servers. These files can be converted into complete, official Windows installation
          ISO images.
        </p>

        <p className="mb-4">The main advantages of using UUP Dump include:</p>
        <ul className="list-disc pl-5 mb-4">
          <li>Access to the latest Windows versions, including Insider builds</li>
          <li>Ability to download specific Windows versions that are no longer officially available</li>
          <li>Obtaining clean, official ISO images directly from Microsoft's servers</li>
          <li>Support for multiple Windows editions (Home, Pro, Enterprise, etc.)</li>
          <li>Ability to select specific languages</li>
        </ul>
      </div>

      <div className="mt-8">
        <h2 className="text-2xl font-bold mb-4 text-black">Script Functionality</h2>
        <p className="mb-4">
          The ProxMenux UUP Dump ISO Creator script automates the entire process of downloading and creating Windows ISO
          images. The main features of the script include:
        </p>

        <div className="space-y-8 mt-6">
          <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
            <div className="flex items-center gap-3 mb-4">
              <Package className="h-6 w-6 text-blue-500" />
              <h3 className="text-xl font-semibold">Dependency Management</h3>
            </div>
            <p className="mb-3">
              The script automatically verifies and installs all necessary dependencies for the download and conversion
              process:
            </p>
            <ul className="list-disc pl-5 space-y-1 mb-4">
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">curl</code> - For downloading files
              </li>
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">aria2</code> - Advanced download manager
              </li>
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">cabextract</code> - For extracting CAB files
              </li>
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">wimtools</code> - For manipulating WIM files
              </li>
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">genisoimage</code> - For creating ISO images
              </li>
              <li>
                <code className="bg-gray-100 px-1 py-0.5 rounded">chntpw</code> - For modifying Windows registries
              </li>
            </ul>
            <div className="bg-gray-100 p-3 rounded-md overflow-x-auto">
              <pre className="text-sm">
                <code>apt-get install curl aria2 cabextract wimtools genisoimage chntpw</code>
              </pre>
            </div>
          </div>

          <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
            <div className="flex items-center gap-3 mb-4">
              <Code className="h-6 w-6 text-blue-500" />
              <h3 className="text-xl font-semibold">Conversion Process</h3>
            </div>
            <p className="mb-3">
              The script handles the entire process of converting UUP files to a bootable ISO image:
            </p>
            <ul className="list-disc pl-5 space-y-1">
              <li>Downloading the official UUP Dump converter script</li>
              <li>Generating the file list to download based on the provided URL</li>
              <li>Downloading all necessary files using aria2 (parallel download)</li>
              <li>Converting the downloaded files to a bootable ISO image</li>
              <li>Cleaning up temporary files after creation</li>
            </ul>
          </div>

          <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
            <div className="flex items-center gap-3 mb-4">
              <Server className="h-6 w-6 text-blue-500" />
              <h3 className="text-xl font-semibold">Proxmox Integration</h3>
            </div>
            <p className="mb-3">The script integrates seamlessly with the Proxmox VE environment:</p>
            <ul className="list-disc pl-5 space-y-1 mb-4">
              <li>Automatic detection of the ISO storage directory in Proxmox</li>
              <li>Storage of the resulting ISO image in the correct location</li>
              <li>Immediate availability of the ISO for use in VM creation</li>
              <li>Compatibility with different Proxmox storage configurations</li>
            </ul>
            <p className="mb-2">The script automatically detects the ISO storage directory in Proxmox by:</p>
            <p className="text-sm text-gray-600">
              If none is found, uses the default directory /var/lib/vz/template/iso
            </p>
          </div>

          <div className="border rounded-lg p-6 bg-gray-50 hover:shadow-md transition-shadow">
            <div className="flex items-center gap-3 mb-4">
              <Clock className="h-6 w-6 text-blue-500" />
              <h3 className="text-xl font-semibold">Download Process</h3>
            </div>
            <p className="mb-3">
              The script uses aria2 to download files with optimized configurations. The typical processing time is
              approximately 10 minutes, depending on your internet connection speed and server performance.
            </p>
            <div className="bg-gray-100 p-3 rounded-md overflow-x-auto mb-3">
              <pre className="text-sm">
                <code>
                  aria2c --no-conf --console-log-level=warn --log-level=info --log="aria2_download.log" -x16 -s16 -j5 -c
                  -R -d"$destDir" -i"$tempScript"
                </code>
              </pre>
            </div>
            <p className="text-sm text-gray-600">
              Where:
              <br />
              <code>-x16</code>: Maximum 16 connections per server
              <br />
              <code>-s16</code>: Splits each file into 16 segments
              <br />
              <code>-j5</code>: Downloads 5 files in parallel
              <br />
              <code>-c</code>: Continues partial downloads if possible
              <br />
              <code>-R</code>: Retries failed downloads
            </p>
          </div>
        </div>
      </div>

      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-6 text-black">Step-by-Step Guide: Getting the UUP Dump URL</h2>
        <p className="mb-6">
          Before using the UUP Dump ISO Creator script, you'll need to obtain a specific UUP Dump URL that contains the
          necessary parameters (id, pack, edition). Follow these steps to generate the correct URL:
        </p>

        <div className="space-y-10">
          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                1
              </span>
              Select Windows Version
            </h3>
            <p className="mb-4">
              Visit the UUP Dump website (
              <a
                href="https://uupdump.net/"
                target="_blank"
                rel="noopener noreferrer"
                className="text-blue-500 hover:text-blue-700"
              >
                https://uupdump.net/
              </a>
              ) and select the Windows version you want to download.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/step-1-select-version-windows.png"
              alt="Select Windows Version"
              caption="UUP Dump main page for selecting Windows version"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                2
              </span>
              Select Specific Build
            </h3>
            <p className="mb-4">
              Choose the specific Windows build you want to download. You can select from the latest builds, Insider
              Preview builds, or specific versions.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/step-2-select-version-windows.png"
              alt="Select Specific Build"
              caption="Selection of the specific Windows build"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                3
              </span>
              Select Language
            </h3>
            <p className="mb-4">
              Choose the language for the Windows image. You can select any language available for that specific build.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/step-3-select-version-windows.png"
              alt="Select Language"
              caption="Selection of the language for the Windows image"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                4
              </span>
              Select Editions
            </h3>
            <p className="mb-4">
              Select the Windows editions you want to include in the ISO image. You can choose one or multiple editions
              (Home, Pro, Enterprise, etc.).
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/step-4-select-version-windows.png"
              alt="Select Editions"
              caption="Selection of Windows editions to include"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                5
              </span>
              Get Download URL
            </h3>
            <p className="mb-4">
              On the final page, you'll see download options. What you need is the URL that appears in your browser,
              which should contain the parameters <code className="bg-gray-100 px-1 py-0.5 rounded">id</code>,{" "}
              <code className="bg-gray-100 px-1 py-0.5 rounded">pack</code>, and{" "}
              <code className="bg-gray-100 px-1 py-0.5 rounded">edition</code>.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/step-5-select-version-windows.png"
              alt="Get Download URL"
              caption="Final page with the URL containing the necessary parameters"
            />
          </div>
        </div>
      </div>

      <div className="mt-12">
        <h2 className="text-2xl font-bold mb-6 text-black">Using the UUP Dump ISO Creator Script</h2>
        <p className="mb-6">
          Once you have the UUP Dump URL, you can use the ProxMenux UUP Dump ISO Creator script to download and create
          the ISO image:
        </p>

        <div className="space-y-10">
          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                1
              </span>
              Paste the UUP Dump URL
            </h3>
            <p className="mb-4">
              When prompted, paste the complete UUP Dump URL you obtained in the previous steps. The script will verify
              that the URL contains all the necessary parameters.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/add-url-iso-creator.png"
              alt="Paste UUP Dump URL"
              caption="Window for pasting the UUP Dump URL"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                2
              </span>
              Start the UUP Dump ISO Creator Script
            </h3>
            <p className="mb-4">Access the Utilities section in ProxMenux and select "UUP Dump ISO Creator".</p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/start-uupdump-iso-creator.png"
              alt="Start UUP Dump ISO Creator"
              caption="Starting the UUP Dump ISO Creator script in ProxMenux"
            />
          </div>

          <div>
            <h3 className="text-xl font-semibold mb-4 flex items-center">
              <span className="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center mr-3">
                3
              </span>
              Process Completion
            </h3>
            <p className="mb-4">
              Once the process is complete, the script will display a success message and the location of the created
              ISO image. The ISO will be immediately available for use in creating virtual machines in Proxmox.
            </p>
            <ImageWithCaption
              src="https://macrimi.github.io/ProxMenux/iso-creator/end-uupdump-iso-creator.png"
              alt="Process Completion"
              caption="Successful completion message of the ISO creation process"
            />
          </div>
        </div>
      </div>

    </div>
  )
}



================================================
FILE: web/app/guides/page.tsx
================================================
import fs from "fs"
import path from "path"
import matter from "gray-matter"
import Link from "next/link"
import { Play, MessageCircle, Users, Book, Database, Code, BookOpen } from "lucide-react"
import Footer2 from "@/components/footer2"

const guidesDirectory = path.join(process.cwd(), "..", "guides")

interface Guide {
  title: string
  description: string
  slug: string
}

function getGuides(): Guide[] {
  const guides: Guide[] = []

  function findGuides(dir: string, basePath = "") {
    fs.readdirSync(dir, { withFileTypes: true }).forEach((entry) => {
      const fullPath = path.join(dir, entry.name)
      const relativePath = path.join(basePath, entry.name)

      if (entry.isDirectory()) {
        findGuides(fullPath, relativePath)
      } else if (entry.isFile() && entry.name.endsWith(".md")) {
        const slug = relativePath.replace(/\.md$/, "")

        const fileContents = fs.readFileSync(fullPath, "utf8")
        const { data } = matter(fileContents)

        guides.push({
          title: data.title || slug.replace(/_/g, " "),
          description: data.description || "No description available.",
          slug,
        })
      }
    })
  }

  findGuides(guidesDirectory)
  return guides
}

export default function GuidesPage() {
  const guides = getGuides()

  return (
    <div className="min-h-screen bg-gradient-to-b from-gray-900 to-gray-800 text-white pt-16 flex flex-col">
      <div className="flex-grow container mx-auto px-4 py-16">
        <h1 className="text-4xl font-bold mb-8">ProxMenux Guides</h1>
        <p className="text-xl mb-8">Complementary guides to make the most of your Proxmox VE.</p>

        {/* Dynamic Guides */}
        <div className="grid md:grid-cols-2 gap-6 mb-12">
          {guides.map((guide) => (
            <Link
              key={guide.slug}
              href={`/guides/${guide.slug}`}
              className="block p-6 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow"
            >
              <h2 className="text-2xl font-semibold mb-2 text-gray-900">{guide.title}</h2>
              <p className="text-gray-600">{guide.description}</p>
            </Link>
          ))}
        </div>

        {/* Additional Resources */}
        <h2 className="text-3xl font-bold mb-6">Additional Resources</h2>
        <div className="grid md:grid-cols-2 gap-6 mb-12">
          <a
            href="https://github.com/community-scripts/ProxmoxVE/blob/main/.github/CONTRIBUTOR_AND_GUIDES/USER_SUBMITTED_GUIDES.md"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-blue-600 rounded-lg shadow-md hover:bg-blue-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Book className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Guides Helper-Scripts</h2>
            </div>
            <p className="text-gray-200">
              User-submitted guides for Proxmox VE from the community Helper-Scripts.
            </p>
          </a>
          <a
            href="https://pve.proxmox.com/pve-docs/index.html"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-green-600 rounded-lg shadow-md hover:bg-green-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Book className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Official Documentation</h2>
            </div>
            <p className="text-gray-200">
              Comprehensive Proxmox VE documentation and administration guide available.
            </p>
          </a>
          <a
            href="https://community-scripts.github.io/ProxmoxVE/"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-indigo-600 rounded-lg shadow-md hover:bg-indigo-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Code className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Proxmox VE Helper-Scripts</h2>
            </div>
            <p className="text-gray-200">
              Proxmox VE Helper-Scripts is a set of tools for simplifying the installation of applications and the management of Proxmox VE, maintained by the community.
            </p>
          </a>
          
          <Link
            href="/guides/linux-resources"
            className="block p-6 bg-teal-600 rounded-lg shadow-md hover:bg-teal-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <BookOpen className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Linux Resources</h2>
            </div>
            <p className="text-gray-200">
              A collection of useful resources for learning Linux commands, security practices, monitoring tools, and
              more.
            </p>
          </Link>
        </div>

        {/* PBS Documentation */}
        <h2 className="text-3xl font-bold mb-6">Backup Server Documentation</h2>
        <div className="mb-12">
          <a
            href="https://pbs.proxmox.com/docs/index.html"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-yellow-600 rounded-lg shadow-md hover:bg-yellow-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Database className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Backup Server Docs</h2>
            </div>
            <p className="text-gray-200">
              Information about Proxmox Backup Server, a powerful backup solution for Proxmox VE.
            </p>
          </a>
        </div>

        {/* Video Tutorials */}
        <h2 className="text-3xl font-bold mb-6">Video Tutorials</h2>
        <div className="mb-12">
          <a
            href="https://www.proxmox.com/en/services/training-courses/videos?utm_source"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-red-600 rounded-lg shadow-md hover:bg-red-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Play className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Official Video Training</h2>
            </div>
            <p className="text-gray-200">
              Access official Proxmox video tutorials and training courses for skill development.
            </p>
          </a>
        </div>

        {/* Community Discussion */}
        <h2 className="text-3xl font-bold mb-6">Community Discussion</h2>
        <div className="grid md:grid-cols-2 gap-6">
          <a
            href="https://forum.proxmox.com/"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-purple-600 rounded-lg shadow-md hover:bg-purple-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <MessageCircle className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Proxmox Forum</h2>
            </div>
            <p className="text-gray-200">Access the official Proxmox forum for questions, troubleshooting, and shared experiences.</p>
          </a>
          <a
            href="https://www.reddit.com/r/Proxmox/"
            target="_blank"
            rel="noopener noreferrer"
            className="block p-6 bg-orange-600 rounded-lg shadow-md hover:bg-orange-700 transition-colors"
          >
            <div className="flex items-center gap-3 mb-2">
              <Users className="h-6 w-6 text-white" />
              <h2 className="text-2xl font-semibold text-white">Proxmox Reddit</h2>
            </div>
            <p className="text-gray-200">Access the Proxmox community on Reddit for discussions, tips, and technical support.</p>
          </a>
        </div>
      </div>
      <Footer2 />
    </div>
  )
}



================================================
FILE: web/app/guides/[slug]/page.tsx
================================================
import fs from "fs"
import path from "path"
import { remark } from "remark"
import html from "remark-html"
import * as gfm from "remark-gfm"
import matter from "gray-matter"
import dynamic from "next/dynamic"
import React from "react"
import parse from "html-react-parser"
import Footer2 from "@/components/footer2"

const CopyableCode = dynamic(() => import("@/components/CopyableCode"), { ssr: false })

const guidesDirectory = path.join(process.cwd(), "..", "guides")


function getMarkdownFiles() {
  return fs
    .readdirSync(guidesDirectory)
    .filter((file) => file.endsWith(".md"))
    .map((file) => ({
      slug: file.replace(/\.md$/, ""), 
      path: path.join(guidesDirectory, file),
    }))
}


async function getGuideContent(slug: string) {
  try {
    const markdownFiles = getMarkdownFiles()
    const guideFile = markdownFiles.find((file) => file.slug === slug)

    if (!guideFile) {
      console.error(`Guide not found.: ${slug}`)
      return { content: "<p class='text-red-600'>Error: Guide not found.</p>", metadata: null }
    }

    const fileContents = fs.readFileSync(guideFile.path, "utf8")
    const { content, data } = matter(fileContents) 

    
    const result = await remark()
      .use(gfm.default || gfm)
      .use(html)
      .process(content)

    return { content: result.toString(), metadata: data }
  } catch (error) {
    console.error(`âŒ Error al leer la guÃ­a ${slug}`, error)
    return { content: "<p class='text-red-600'>Error: No se pudo cargar la guÃ­a.</p>", metadata: null }
  }
}


export async function generateStaticParams() {
  try {
    const markdownFiles = getMarkdownFiles()
    return markdownFiles.map((file) => ({ slug: file.slug }))
  } catch (error) {
    console.error("âŒ Error al generar las rutas estÃ¡ticas para guides:", error)
    return []
  }
}


function cleanInlineCode(content: string) {
  return content.replace(/<code>(.*?)<\/code>/g, (_, codeContent) => {
    return `<code class="bg-gray-200 text-gray-900 px-1 rounded">${codeContent.replace(/^`|`$/g, "")}</code>`
  })
}


function wrapCodeBlocksWithCopyable(content: string) {
  return parse(content, {
    replace: (domNode: any) => {
      if (domNode.name === "pre" && domNode.children.length > 0) {
        const codeElement = domNode.children.find((child: any) => child.name === "code")
        if (codeElement) {
          const codeContent = codeElement.children[0]?.data?.trim() || ""
          return <CopyableCode code={codeContent} />
        }
      }
    }
  })
}


export default async function GuidePage({ params }: { params: { slug: string } }) {
  const { content, metadata } = await getGuideContent(params.slug)
  const cleanedInlineCode = cleanInlineCode(content)
  const parsedContent = wrapCodeBlocksWithCopyable(cleanedInlineCode)

  return (
    <div className="min-h-screen bg-white text-gray-900">
      <div className="container mx-auto px-4 py-16" style={{ maxWidth: "980px" }}>
        {metadata?.title && <h1 className="text-4xl font-bold mb-4">{metadata.title}</h1>}
        {metadata?.description && <p className="text-lg text-gray-700 mb-8">{metadata.description}</p>}
        <div className="prose max-w-none text-[16px]">{parsedContent}</div>
      </div>
      <Footer2 />
    </div>
  )
}



================================================
FILE: web/app/guides/linux-resources/page.tsx
================================================
import Link from "next/link"
import { BookOpen, ExternalLink, Shield, Activity, Database, FileCode, ArrowLeft } from "lucide-react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import Footer2 from "@/components/footer2"

export default function LinuxResourcesPage() {
  const resourceCategories = [
    {
      title: "Linux General",
      icon: <BookOpen className="h-6 w-6 text-blue-500" />,
      resources: [
        {
          title: "TLDR Pages",
          url: "https://tldr.sh/",
          description:
            "Terminal commands explained briefly with practical examples. Ideal for quickly remembering how to use tar, find, rsync, etc.",
        },
        {
          title: "Explainshell",
          url: "https://explainshell.com/",
          description:
            "Enter a command and this site breaks it down explaining each part. Very useful for learning complex commands.",
        },
        {
          title: "Cheat.sh",
          url: "https://cheat.sh/",
          description:
            "Online service to quickly search commands from browser or terminal (curl cheat.sh/tar). Very powerful and practical.",
        },
      ],
    },
    {
      title: "Security and Administration",
      icon: <Shield className="h-6 w-6 text-blue-500" />,
      resources: [
        {
          title: "SSH Hardening Guide",
          url: "https://www.ssh.com/academy/ssh/security",
          description:
            "Advanced guide to secure SSH access. Covers ciphers, versions, authentication, and other recommended practices.",
        },
        {
          title: "Fail2ban Wiki (GitHub)",
          url: "https://github.com/fail2ban/fail2ban/wiki",
          description: "Official documentation and usage examples for Fail2ban, an essential tool for servers.",
        },
      ],
    },
    {
      title: "Monitoring and Diagnostics",
      icon: <Activity className="h-6 w-6 text-blue-500" />,
      resources: [
        {
          title: "nmon Performance Monitor",
          url: "http://nmon.sourceforge.net/pmwiki.php",
          description: "Advanced system monitoring tool, with documentation on its usage.",
        },
        {
          title: "htop Official",
          url: "https://htop.dev/",
          description: "Official page of htop, one of the most used tools for viewing processes and resource usage.",
        },
      ],
    },
    {
      title: "ZFS and Storage",
      icon: <Database className="h-6 w-6 text-blue-500" />,
      resources: [
        {
          title: "OpenZFS Documentation",
          url: "https://openzfs.github.io/openzfs-docs/",
          description:
            "Official and modern guide on ZFS, ideal for administrators using Proxmox with this file system.",
        },
        {
          title: "ZFS Cheatsheet (DigitalOcean)",
          url: "https://www.digitalocean.com/community/tutorials/how-to-use-zfs-on-ubuntu-20-04",
          description: "Clear and simple explanation of basic ZFS usage in Linux.",
        },
      ],
    },
    {
      title: "Extra: General Cheatsheets",
      icon: <FileCode className="h-6 w-6 text-blue-500" />,
      resources: [
        {
          title: "OverAPI.com",
          url: "https://overapi.com/linux",
          description: "Collection of interactive cheatsheets on multiple technologies, including Linux commands.",
        },
        {
          title: "DevHints.io Linux",
          url: "https://devhints.io/bash",
          description:
            "Bash shortcuts and basic scripting, useful for automating tasks in Proxmox and other environments.",
        },
      ],
    },
  ]

  return (
    <div className="min-h-screen bg-white text-gray-900">
      <div className="container mx-auto px-4 py-16" style={{ maxWidth: "980px" }}>
        <div className="mb-8">
          <Link href="/guides" className="flex items-center text-blue-500 hover:text-blue-700 transition-colors mb-6">
            <ArrowLeft className="mr-2 h-4 w-4" />
            Back to Guides
          </Link>

          <h1 className="text-4xl font-bold mb-4 text-black">Linux Resources</h1>

          <p className="text-lg mb-8 text-gray-700">
            A collection of useful resources for learning Linux commands, security practices, monitoring tools, and
            more. These resources complement the commands available in ProxMenux and will help you deepen your knowledge
            of Linux system administration.
          </p>
        </div>

        <div className="space-y-10 mb-16">
          {resourceCategories.map((category, index) => (
            <div key={index} className="mb-8">
              <div className="flex items-center gap-3 mb-4">
                {category.icon}
                <h2 className="text-2xl font-bold text-black">{category.title}</h2>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {category.resources.map((resource, resourceIndex) => (
                  <ResourceCard key={resourceIndex} resource={resource} />
                ))}
              </div>
            </div>
          ))}
        </div>
      </div>
      <Footer2 />
    </div>
  )
}

interface ResourceProps {
  resource: {
    title: string
    url: string
    description: string
  }
}

function ResourceCard({ resource }: ResourceProps) {
  return (
    <Card className="transition-all duration-300 hover:shadow-md hover:border-blue-300 bg-white text-black border-2 border-gray-200">
      <CardHeader className="pb-2">
        <CardTitle className="text-xl text-black flex items-center justify-between">
          {resource.title}
          <a
            href={resource.url}
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-500 hover:text-blue-700"
            aria-label={`Visit ${resource.title} (opens in a new window)`}
          >
            <ExternalLink className="h-5 w-5" />
          </a>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <CardDescription className="text-base text-gray-600">{resource.description}</CardDescription>
        <div className="mt-4">
          <a
            href={resource.url}
            target="_blank"
            rel="noopener noreferrer"
            className="text-sm text-blue-500 hover:text-blue-700 flex items-center"
          >
            Visit resource <ExternalLink className="ml-1 h-3 w-3" />
          </a>
        </div>
      </CardContent>
    </Card>
  )
}



================================================
FILE: web/app/rss.xml/route.ts
================================================
import { NextResponse } from "next/server"
import fs from "fs"
import path from "path"

interface ChangelogEntry {
  version: string
  date: string
  content: string
  url: string
  title: string
}

// Function to clean and format markdown content for RSS
function formatContentForRSS(content: string): string {
  return (
    content
      // Convert ### headers to bold text
      .replace(/^### (.+)$/gm, "**$1**")
      // Convert ** bold ** to simple bold
      .replace(/\*\*(.*?)\*\*/g, "$1")
      // Clean code blocks - remove ``` and format nicely
      .replace(/```[\s\S]*?```/g, (match) => {
        const code = match.replace(/```/g, "").trim()
        return `\n${code}\n`
      })
      // Convert - bullet points to â€¢
      .replace(/^- /gm, "â€¢ ")
      // Clean up multiple newlines
      .replace(/\n{3,}/g, "\n\n")
      // Remove backslashes used for line breaks
      .replace(/\\\s*$/gm, "")
      // Clean up extra spaces
      .replace(/\s+/g, " ")
      .trim()
  )
}

async function parseChangelog(): Promise<ChangelogEntry[]> {
  try {
    const changelogPath = path.join(process.cwd(), "..", "CHANGELOG.md")

    if (!fs.existsSync(changelogPath)) {
      return []
    }

    const fileContents = fs.readFileSync(changelogPath, "utf8")
    const entries: ChangelogEntry[] = []

    // Split by ## headers (both versions and dates)
    const lines = fileContents.split("\n")
    let currentEntry: Partial<ChangelogEntry> | null = null
    let contentLines: string[] = []

    for (const line of lines) {
      // Check for version header: ## [1.1.1] - 2025-03-21
      const versionMatch = line.match(/^##\s+\[([^\]]+)\]\s*-\s*(\d{4}-\d{2}-\d{2})/)

      // Check for date-only header: ## 2025-05-13
      const dateMatch = line.match(/^##\s+(\d{4}-\d{2}-\d{2})$/)

      if (versionMatch || dateMatch) {
        // Save previous entry if exists
        if (currentEntry && contentLines.length > 0) {
          const rawContent = contentLines.join("\n").trim()
          currentEntry.content = formatContentForRSS(rawContent)
          if (currentEntry.version && currentEntry.date && currentEntry.title) {
            entries.push(currentEntry as ChangelogEntry)
          }
        }

        // Start new entry
        if (versionMatch) {
          const version = versionMatch[1]
          const date = versionMatch[2]
          currentEntry = {
            version,
            date,
            url: `https://macrimi.github.io/ProxMenux/changelog#${version}`,
            title: `ProxMenux ${version}`,
          }
        } else if (dateMatch) {
          const date = dateMatch[1]
          currentEntry = {
            version: date,
            date,
            url: `https://macrimi.github.io/ProxMenux/changelog#${date}`,
            title: `ProxMenux Update ${date}`,
          }
        }

        contentLines = []
      } else if (currentEntry && line.trim()) {
        // Add content lines (skip empty lines at the beginning)
        if (contentLines.length > 0 || line.trim() !== "") {
          contentLines.push(line)
        }
      }
    }

    // Don't forget the last entry
    if (currentEntry && contentLines.length > 0) {
      const rawContent = contentLines.join("\n").trim()
      currentEntry.content = formatContentForRSS(rawContent)
      if (currentEntry.version && currentEntry.date && currentEntry.title) {
        entries.push(currentEntry as ChangelogEntry)
      }
    }

    return entries.slice(0, 20) // Latest 20 entries
  } catch (error) {
    console.error("Error parsing changelog:", error)
    return []
  }
}

export async function GET() {
  const entries = await parseChangelog()
  const siteUrl = "https://macrimi.github.io/ProxMenux"

  const rssXml = `<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ProxMenux Changelog</title>
    <description>Latest updates and changes in ProxMenux</description>
    <link>${siteUrl}/changelog</link>
    <atom:link href="${siteUrl}/rss.xml" rel="self" type="application/rss+xml"/>
    <language>en-US</language>
    <lastBuildDate>${new Date().toUTCString()}</lastBuildDate>
    <generator>ProxMenux RSS Generator</generator>
    <ttl>60</ttl>
    
    ${entries
      .map(
        (entry) => `
    <item>
      <title>${entry.title}</title>
      <description><![CDATA[${entry.content.length > 1000 ? entry.content.substring(0, 1000) + "..." : entry.content}]]></description>
      <link>${entry.url}</link>
      <guid isPermaLink="true">${entry.url}</guid>
      <pubDate>${new Date(entry.date).toUTCString()}</pubDate>
      <category>Changelog</category>
    </item>`,
      )
      .join("")}
  </channel>
</rss>`

  return new NextResponse(rssXml, {
    headers: {
      "Content-Type": "application/rss+xml; charset=utf-8",
      "Cache-Control": "public, max-age=3600, s-maxage=3600",
    },
  })
}



================================================
FILE: web/components/CopyableCode.tsx
================================================
"use client"

import type React from "react"
import { useState } from "react"
import { Copy, Check } from "lucide-react"
import { cn } from "@/lib/utils"

interface CopyableCodeProps {
  code: string
  language?: string
  className?: string
}

const CopyableCode: React.FC<CopyableCodeProps> = ({ code, language, className }) => {
  const [isCopied, setIsCopied] = useState(false)

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(decodeURIComponent(code))
      setIsCopied(true)
      setTimeout(() => setIsCopied(false), 2000)
    } catch (err) {
      console.error("Failed to copy text: ", err)
    }
  }

  return (
    <div className={cn("relative w-full", className)}>
      <pre
        className={cn(
          "bg-gray-100 p-2 rounded-md",
          "text-base",
          "w-full overflow-x-auto",
          "flex items-center",
          language ? `language-${language}` : "",
        )}
      >
        <code className="whitespace-pre flex-1 min-w-0">{decodeURIComponent(code)}</code>
      </pre>
      <button
        onClick={copyToClipboard}
        className="absolute top-2 right-2 p-1 bg-white rounded-md shadow-sm hover:bg-gray-100 transition-colors"
        aria-label="Copy code"
      >
        {isCopied ? <Check className="h-4 w-4 text-green-500" /> : <Copy className="h-4 w-4 text-gray-500" />}
      </button>
    </div>
  )
}

export default CopyableCode



================================================
FILE: web/components/DocSidebar.tsx
================================================
"use client"

import Link from "next/link"
import { usePathname } from "next/navigation"
import { useState, useEffect } from "react"
import { ChevronDown, ChevronRight, Menu, X } from "lucide-react"

interface SubMenuItem {
  title: string
  href: string
}

interface MenuItem {
  title: string
  href?: string
  submenu?: SubMenuItem[]
}

export const sidebarItems: MenuItem[] = [
  { title: "Introduction", href: "/docs/introduction" },
  { title: "Installation", href: "/docs/installation" },
  {
    title: "Post-Install Script",
    submenu: [
      { title: "Overview", href: "/docs/post-install" },
      { title: "Basic Settings", href: "/docs/post-install/basic-settings" },
      { title: "System", href: "/docs/post-install/system" },
      { title: "Virtualization", href: "/docs/post-install/virtualization" },
      { title: "Network", href: "/docs/post-install/network" },
      { title: "Storage", href: "/docs/post-install/storage" },
      { title: "Security", href: "/docs/post-install/security" },
      { title: "Customization", href: "/docs/post-install/customization" },
      { title: "Monitoring", href: "/docs/post-install/monitoring" },
      { title: "Performance", href: "/docs/post-install/performance" },
      { title: "Optional", href: "/docs/post-install/optional" },
    ],
  },
  {
    title: "Help and Info",
    submenu: [
      { title: "Overview", href: "/docs/help-info" },
      { title: "Useful System Commands", href: "/docs/help-info/system-commands" },
      { title: "VM and CT Management", href: "/docs/help-info/vm-ct-commands" },
      { title: "Storage and Disks", href: "/docs/help-info/storage-commands" },
      { title: "Network Commands", href: "/docs/help-info/network-commands" },
      { title: "Updates and Packages", href: "/docs/help-info/update-commands" },
      { title: "GPU Passthrough", href: "/docs/help-info/gpu-commands" },
      { title: "ZFS Management", href: "/docs/help-info/zfs-commands" },
      { title: "Backup and Restore", href: "/docs/help-info/backup-commands" },
      { title: "System CLI Tools", href: "/docs/help-info/tools-commands" },
    ],
  },
  {
    title: "GPUs and Coral",
    submenu: [
      { title: "HW iGPU acceleration to an LXC", href: "/docs/hardware/igpu-acceleration-lxc" },
      { title: "Coral TPU to an LXC", href: "/docs/hardware/coral-tpu-lxc" },
      { title: "Install Coral TPU on the Host", href: "/docs/hardware/install-coral-tpu-host" },
    ],
  },
  {
    title: "Create VM",
    submenu: [
      { title: "Overview", href: "/docs/create-vm" },
      { title: "System NAS", href: "/docs/create-vm/system-nas" },
      { title: "Synology VM", href: "/docs/create-vm/synology" },
      { title: "Others System NAS", href: "/docs/create-vm/system-nas/system-nas-others" },
      { title: "System Windows", href: "/docs/create-vm/system-windows" },
      { title: "UUP Dump ISO Creator", href: "/docs/utils/UUp-Dump-ISO-Creator" },
      { title: "System Linux", href: "/docs/create-vm/system-linux" },
    ],
  },
  {
    title: "Storage",
    submenu: [
      { title: "Disk Passthrough to a VM", href: "/docs/storage/disk-passthrough-vm" },
      { title: "Disk Passthrough to a CT", href: "/docs/storage/disk-passthrough-ct" },
      { title: "Import Disk Image to a VM", href: "/docs/storage/import-disk-image-vm" },
    ],
  },
  {
    title: "Network",
    submenu: [
      { title: "Verify Network", href: "/docs/network/verify-network" },
      { title: "Show IP Information", href: "/docs/network/show-ip-information" },
    ],
  },
  {
    title: "Settings ProxMenux",
    submenu: [
      { title: "Change Language", href: "/docs/settings/change-language" },
      { title: "Show Version Information", href: "/docs/settings/show-version-information" },
      { title: "Uninstall ProxMenux", href: "/docs/settings/uninstall-proxmenux" },
    ],
  },
  {
    title: "About",
    submenu: [
      { title: "Code of Conduct", href: "/docs/about/code-of-conduct" },
      { title: "FAQ", href: "/docs/about/faq" },
      { title: "Contributors", href: "/docs/about/contributors" }, 
    ],
  },
  { title: "External Repositories", href: "/docs/external-repositories" },
]

export default function DocSidebar() {
  const pathname = usePathname()
  const [openSections, setOpenSections] = useState<{ [key: string]: boolean }>({})
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false)

  const toggleSection = (title: string) => {
    setOpenSections((prev) => ({ ...prev, [title]: !prev[title] }))
  }

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen)
  }

  useEffect(() => {
    const handleResize = () => {
      if (window.innerWidth >= 768) {
        setIsMobileMenuOpen(false)
      }
    }

    window.addEventListener("resize", handleResize)
    return () => window.removeEventListener("resize", handleResize)
  }, [])

  const renderMenuItem = (item: MenuItem) => {
    if (item.submenu) {
      const isOpen = openSections[item.title] || false
      return (
        <li key={item.title} className="mb-2">
          <button
            onClick={() => toggleSection(item.title)}
            className="flex items-center justify-between w-full text-left p-2 rounded hover:bg-gray-200"
          >
            <span>{item.title}</span>
            {isOpen ? <ChevronDown className="h-4 w-4" /> : <ChevronRight className="h-4 w-4" />}
          </button>
          {isOpen && (
            <ul className="ml-4 mt-2 space-y-2">
              {item.submenu.map((subItem) => (
                <li key={subItem.href}>
                  <Link
                    href={subItem.href}
                    className={`block p-2 rounded ${
                      pathname === subItem.href
                        ? "bg-blue-500 text-white"
                        : "text-gray-700 hover:bg-gray-200 hover:text-gray-900"
                    }`}
                    onClick={() => setIsMobileMenuOpen(false)}
                  >
                    {subItem.title}
                  </Link>
                </li>
              ))}
            </ul>
          )}
        </li>
      )
    } else {
      return (
        <li key={item.href}>
          <Link
            href={item.href!}
            className={`block p-2 rounded ${
              pathname === item.href ? "bg-blue-500 text-white" : "text-gray-700 hover:bg-gray-200 hover:text-gray-900"
            }`}
            onClick={() => setIsMobileMenuOpen(false)}
          >
            {item.title}
          </Link>
        </li>
      )
    }
  }

  return (
    <>
      <div className="lg:hidden fixed top-16 left-0 right-0 z-50 bg-gray-100 border-b border-gray-200">
        <button
          className="w-full p-4 text-left flex items-center justify-between"
          onClick={toggleMobileMenu}
          aria-label="Toggle menu"
        >
          <span className="font-semibold">Documentation</span>
          {isMobileMenuOpen ? <X className="h-6 w-6" /> : <Menu className="h-6 w-6" />}
        </button>
      </div>
      <nav
        className={`fixed lg:static top-[104px] left-0 w-full lg:w-72 h-[calc(100vh-104px)] lg:h-[calc(100vh-64px)] bg-gray-100 p-4 lg:p-6 pt-16 lg:pt-6 transform ${
          isMobileMenuOpen ? "translate-y-0" : "-translate-y-full"
        } lg:translate-y-0 transition-transform duration-300 ease-in-out overflow-y-auto z-30`}
      >
        <h2 className="text-lg font-semibold mb-4 text-gray-900 lg:mt-0 sr-only lg:not-sr-only">Documentation</h2>
        <ul className="space-y-2">{sidebarItems.map(renderMenuItem)}</ul>
      </nav>
    </>
  )
}



================================================
FILE: web/components/footer.tsx
================================================
"use client"

import Link from "next/link"
import { MessageCircle } from "lucide-react"
import Image from "next/image"

export default function Footer() {
  return (
    <footer className="bg-gray-900 text-white py-12">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between">
          {/* Support Section - Left Side */}
          <div className="flex flex-col items-start mb-8 md:mb-0">
            <h4 className="text-lg font-semibold mb-4">Sponsor</h4>
            <p className="text-gray-400 mb-4 max-w-md">
              If you would like to support the project.
            </p>
            <a
              href="https://ko-fi.com/G2G313ECAN"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:opacity-90 transition-opacity flex items-center"
            >
              <Image
                src="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/kofi.png"
                alt="Support me on Ko-fi"
                width={140}
                height={40}
                className="w-[140px]"
                loading="lazy"
              />
            </a>
          </div>

          {/* Connect Section - Right Side */}
          <div className="flex flex-col items-start md:items-end">
            <h4 className="text-lg font-semibold mb-4">Connect</h4>
            <p className="text-gray-400 mb-4 max-w-md md:text-right">
              Join the community discussions on GitHub to get help, share ideas, and contribute to the project. Every idea is welcome!
            </p>
            <Link
              href="https://github.com/MacRimi/ProxMenux/discussions"
              className="flex items-center text-blue-400 hover:text-blue-300 transition-colors duration-200"
              target="_blank"
              rel="noopener noreferrer"
            >
              <MessageCircle className="mr-2 h-5 w-5" />
              Join the Discussion
            </Link>
          </div>
        </div>

        {/* Copyright - Center */}
        <div className="mt-8 pt-8 border-t border-gray-800 text-center text-gray-400">
        <p>
          ProxMenux, an open-source and collaborative project by{' '}
          <a
            href="https://macrimi.pro"
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-400 hover:underline"
          >
            MacRimi
          </a>.
        </p>
      </div>
      </div>
    </footer>
  )
}




================================================
FILE: web/components/footer2.tsx
================================================
"use client"

import Link from "next/link"
import { MessageCircle } from "lucide-react"
import Image from "next/image"

export default function Footer() {
  return (
    <footer className="bg-gray-900 text-white py-12">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex flex-col md:flex-row justify-between">
          
             {/* Support Section - Left Side */}
          <div className="flex items-start mb-8 md:mb-0">
            <a
              href="https://ko-fi.com/G2G313ECAN"
              target="_blank"
              rel="noopener noreferrer"
              className="hover:opacity-90 transition-opacity"
            >
              <Image
                src="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/kofi.png"
                alt="Support me on Ko-fi"
                width={140}
                height={40}
                className="w-[140px]"
                loading="lazy"
              />
            </a>
          </div>

          {/* Connect Section - Right Side */}
          <div className="flex flex-col items-start md:items-end">
            <h4 className="text-lg font-semibold mb-4">Connect</h4>
            <p className="text-gray-400 mb-4 max-w-md md:text-right">
              Join the community discussions on GitHub to get help, share ideas, and contribute to the project. Every idea is welcome!
            </p>
            <Link
              href="https://github.com/MacRimi/ProxMenux/discussions"
              className="flex items-center text-blue-400 hover:text-blue-300 transition-colors duration-200"
              target="_blank"
              rel="noopener noreferrer"
            >
              <MessageCircle className="mr-2 h-5 w-5" />
              Join the Discussion
            </Link>
          </div>
        </div>

        {/* Copyright - Center */}
        <div className="mt-8 pt-8 border-t border-gray-800 text-center text-gray-400">
        <p>
          ProxMenux, an open-source and collaborative project by{' '}
          <a
            href="https://macrimi.pro"
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-400 hover:underline"
          >
            MacRimi
          </a>.
        </p>
      </div>
      </div>
    </footer>
  )
}



================================================
FILE: web/components/hero.tsx
================================================
"use client"

import { Button } from "@/components/ui/button"
import { ArrowRight } from "lucide-react"
import Link from "next/link"


export default function Hero() {
  return (
    <section className="py-20 px-4 sm:px-6 lg:px-8 text-center">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-extrabold mb-6">
        ProxMenux{" "}
        <span className="bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
        An Interactive Menu for Proxmox VE Management
        </span>
      </h1>
      <p className="text-base sm:text-lg md:text-xl mb-8 max-w-4xl mx-auto text-gray-300">
      ProxMenux is a management tool for Proxmox VE that simplifies system administration 
      through an interactive menu, allowing you to execute commands and scripts with ease.
      </p>
      <div className="flex justify-center">
        <Button size="lg" className="bg-blue-500 hover:bg-blue-600" asChild>
          <Link href="/docs/installation">
            Install Now
            <ArrowRight className="ml-2 h-4 w-4" />
          </Link>
        </Button>
      </div>
    </section>
  )
}




================================================
FILE: web/components/hero2.tsx
================================================
"use client"

import { Button } from "@/components/ui/button"
import { ArrowRight } from "lucide-react"
import Link from "next/link"
import Image from "next/image"

export default function Hero() {
  return (
    <div className="bg-gradient-to-b from-gray-900 to-gray-800 text-white">
      {/* Mobile version (visible only on small screens) */}
      <section className="md:hidden py-20 px-4 sm:px-6 text-center">
        <h1 className="text-4xl sm:text-5xl font-extrabold mb-6">
          ProxMenux{" "}
          <span className="block mt-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 font-bold">
            An Interactive Menu for Proxmox VE Management
          </span>
        </h1>
        <p className="text-base sm:text-lg mb-8 max-w-4xl mx-auto text-gray-300">
          ProxMenux is a management tool for Proxmox VE that simplifies system administration through an interactive
          menu, allowing you to execute commands and scripts with ease.
        </p>
        <div className="flex justify-center">
          <Button size="lg" className="bg-blue-500 hover:bg-blue-600" asChild>
            <Link href="/docs/installation">
              Install Now
              <ArrowRight className="ml-2 h-4 w-4" />
            </Link>
          </Button>
        </div>
      </section>

      {/* Desktop version (visible only on medium and large screens) */}
      <section className="hidden md:flex py-20 px-4 sm:px-6 lg:px-8 flex-col justify-center">
        <div className="flex items-center justify-center mb-8">
          <div className="flex items-center">
            <div className="w-40 h-40 lg:w-48 lg:h-48 xl:w-56 xl:h-56 relative">
              <Image
                src="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo.png"
                alt="ProxMenux Logo"
                fill
                className="object-contain"
                sizes="(max-width: 1024px) 10rem, (max-width: 1280px) 12rem, 14rem"
              />
            </div>
            <div className="w-0.5 h-40 lg:h-48 xl:h-56 bg-white mx-6 self-center"></div>
            <div className="text-left max-w-md lg:max-w-lg xl:max-w-xl">
              <h1 className="text-4xl md:text-5xl lg:text-6xl font-extrabold text-white leading-tight">ProxMenux</h1>
              <p className="text-xl md:text-2xl lg:text-3xl xl:text-4xl mt-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 font-bold leading-tight">
                An Interactive Menu for Proxmox VE Management
              </p>
            </div>
          </div>
        </div>
        <p className="text-base md:text-lg lg:text-xl mb-8 max-w-2xl lg:max-w-3xl xl:max-w-4xl mx-auto text-gray-300 text-center leading-relaxed">
          ProxMenux is a management tool for Proxmox VE that simplifies system administration through an interactive
          menu, allowing you to execute commands and scripts with ease.
        </p>
        <div className="flex justify-center">
          <Button size="lg" className="bg-blue-500 hover:bg-blue-600" asChild>
            <Link href="/docs/installation">
              Install Now
              <ArrowRight className="ml-2 h-4 w-4" />
            </Link>
          </Button>
        </div>
      </section>
    </div>
  )
}




================================================
FILE: web/components/mouse-move-effect.tsx
================================================
"use client"

import { useEffect, useState } from "react"

export default function MouseMoveEffect() {
  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 })

  useEffect(() => {
    const handleMouseMove = (event: MouseEvent) => {
      setMousePosition({ x: event.clientX, y: event.clientY })
    }

    window.addEventListener("mousemove", handleMouseMove)

    return () => {
      window.removeEventListener("mousemove", handleMouseMove)
    }
  }, [])

  return (
    <div
      className="pointer-events-none fixed inset-0 z-30 transition-opacity duration-300"
      style={{
        background: `radial-gradient(600px at ${mousePosition.x}px ${mousePosition.y}px, rgba(29, 78, 216, 0.15), transparent 80%)`,
      }}
    />
  )
}




================================================
FILE: web/components/navbar.tsx
================================================
"use client"

import Link from "next/link"
import Image from "next/image"
import { Book, GitBranch, FileText, Github, Menu, Rss } from "lucide-react"
import { useState } from "react"

export default function Navbar() {
  const [isMenuOpen, setIsMenuOpen] = useState(false)

  const navItems = [
    { href: "/docs/introduction", icon: <Book className="h-4 w-4" />, label: "Documentation" },
    { href: "/changelog", icon: <FileText className="h-4 w-4" />, label: "Changelog" },
    { href: "/guides", icon: <GitBranch className="h-4 w-4" />, label: "Guides" },
    { href: "https://github.com/MacRimi/ProxMenux", icon: <Github className="h-4 w-4" />, label: "GitHub" },
  ]

  return (
    <header className="fixed top-0 left-0 right-0 z-50 bg-background/95 backdrop-blur border-b border-border/40">
      <div className="container mx-auto px-4">
        <div className="flex items-center justify-between h-16">
          <Link href="/" className="flex items-center space-x-2">
            <Image
              src="https://raw.githubusercontent.com/MacRimi/ProxMenux/main/images/logo.png"
              alt="ProxMenux Logo"
              width={32}
              height={32}
              className="w-8 h-8"
            />
            <span className="text-xl font-bold">ProxMenux</span>
          </Link>

          {/* Desktop menu */}
          <nav className="hidden md:flex items-center space-x-6 text-sm font-medium">
            {navItems.map((item) => (
              <Link
                key={item.href}
                href={item.href}
                className="flex items-center space-x-2 transition-colors hover:text-primary"
                {...(item.label === "GitHub" ? { target: "_blank", rel: "noopener noreferrer" } : {})}
              >
                {item.icon}
                <span>{item.label}</span>
              </Link>
            ))}

            {/* RSS Feed Link */}
            <Link
              href="https://macrimi.github.io/ProxMenux/rss.xml"
              className="flex items-center space-x-2 transition-colors hover:text-primary text-orange-600 hover:text-orange-700"
              target="_blank"
              rel="noopener noreferrer"
              title="RSS Feed"
            >
              <Rss className="h-4 w-4" />
              <span>RSS</span>
            </Link>
          </nav>

          {/* Mobile menu button */}
          <button className="md:hidden p-2" onClick={() => setIsMenuOpen(!isMenuOpen)}>
            <Menu className="h-6 w-6" />
          </button>
        </div>

        {/* Mobile menu */}
        {isMenuOpen && (
          <nav className="md:hidden py-4">
            {navItems.map((item) => (
              <Link
                key={item.href}
                href={item.href}
                className="flex items-center space-x-2 py-2 transition-colors hover:text-primary"
                onClick={() => setIsMenuOpen(false)}
                {...(item.label === "GitHub" ? { target: "_blank", rel: "noopener noreferrer" } : {})}
              >
                {item.icon}
                <span>{item.label}</span>
              </Link>
            ))}

            {/* RSS Feed Link - Mobile */}
            <Link
              href="https://macrimi.github.io/ProxMenux/rss.xml"
              className="flex items-center space-x-2 py-2 transition-colors hover:text-primary text-orange-600 hover:text-orange-700"
              onClick={() => setIsMenuOpen(false)}
              target="_blank"
              rel="noopener noreferrer"
              title="RSS Feed"
            >
              <Rss className="h-4 w-4" />
              <span>RSS</span>
            </Link>
          </nav>
        )}
      </div>
    </header>
  )
}



================================================
FILE: web/components/resources.tsx
================================================
"use client"

import { Book, GitBranch, FileText, Github } from "lucide-react"
import Link from "next/link"

const resources = [
  {
    icon: <Book className="h-6 w-6" />,
    title: "Documentation",
    description: "System description and user guides",
    link: "/docs/introduction",
  },
  {
    icon: <FileText className="h-6 w-6" />,
    title: "Changelog",
    description: "Information on the latest updates",
    link: "/changelog",
  },
  {
    icon: <GitBranch className="h-6 w-6" />,
    title: "Guides",
    description: "Step-by-step tutorials and guides for common tasks",
    link: "/guides",
  },
  {
    icon: <Github className="h-6 w-6" />,
    title: "GitHub Repository",
    description: "Explore the source code.",
    link: "https://github.com/MacRimi/ProxMenux",
  },
]

export default function Resources() {
  return (
    <section className="py-20 bg-gray-900">
      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8">
          {resources.map((resource, index) => (
            <Link key={index} href={resource.link} className="block h-full">
              <div className="bg-gray-800 p-6 rounded-lg shadow-lg hover:bg-gray-700 transition-colors duration-200 h-full flex flex-col justify-between">
                <div className="flex items-center mb-4">
                  {resource.icon}
                  <h3 className="text-xl font-semibold ml-2">{resource.title}</h3>
                </div>
                <p className="text-gray-400 min-h-[48px]">{resource.description}</p>
              </div>
            </Link>
          ))}
        </div>
      </div>
    </section>
  )
}



================================================
FILE: web/components/rss-link.tsx
================================================
"use client"

import { Rss, Copy, Check } from "lucide-react"
import Link from "next/link"
import { useState } from "react"

export default function RSSLink() {
  const [copied, setCopied] = useState(false)
  const rssUrl = "https://macrimi.github.io/ProxMenux/rss.xml"

  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(rssUrl)
      setCopied(true)
      setTimeout(() => setCopied(false), 2000)
    } catch (err) {
      console.error("Failed to copy: ", err)
    }
  }

  return (
    <div className="mb-8 p-4 bg-orange-50 border border-orange-200 rounded-lg">
      <div className="space-y-3">
        <div>
          <h3 className="text-lg font-semibold text-orange-900 mb-1">Stay Updated!</h3>
          <p className="text-orange-700 text-sm">Subscribe to our RSS feed to get notified of new changes.</p>
        </div>

        {/* RSS URL and buttons - Responsive layout */}
        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <code className="bg-orange-100 text-orange-800 px-2 py-1 rounded text-xs flex-1 min-w-0 truncate">
              {rssUrl}
            </code>
            <button
              onClick={copyToClipboard}
              className="flex items-center gap-1 px-2 py-1 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors text-xs whitespace-nowrap"
              title="Copy RSS URL"
            >
              {copied ? <Check className="h-3 w-3" /> : <Copy className="h-3 w-3" />}
              <span className="hidden sm:inline">{copied ? "Copied!" : "Copy"}</span>
            </button>
          </div>

          <Link
            href={rssUrl}
            className="inline-flex items-center justify-center space-x-2 px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors w-full sm:w-auto"
            target="_blank"
            rel="noopener noreferrer"
            title="Open RSS Feed"
          >
            <Rss className="h-4 w-4" />
            <span>Open RSS Feed</span>
          </Link>
        </div>
      </div>
    </div>
  )
}



================================================
FILE: web/components/support-project.tsx
================================================
"use client"

import { Button } from "@/components/ui/button"
import { Star } from "lucide-react"

export default function SupportProject() {
  const handleClick = () => {
    window.open("https://github.com/MacRimi/ProxMenux", "_blank")
  }

  return (
    <section className="py-16 bg-gray-900">
      <div className="container mx-auto px-4 text-center">
        <h2 className="text-3xl font-bold mb-6">Support the Project!</h2>
        <p className="text-xl mb-8">
          If you find <span className="font-bold">ProxMenux</span> useful, consider giving it a â­ on GitHub to help
          others discover it!
        </p>
        <div className="flex justify-center items-center">
          <Button className="bg-yellow-400 text-gray-900 hover:bg-yellow-500" onClick={handleClick}>
            <Star className="mr-2" />
            Star on GitHub
          </Button>
        </div>
      </div>
    </section>
  )
}




================================================
FILE: web/components/testimonials.tsx
================================================
const testimonials = [
  {
    quote: "StreamLine has revolutionized our team's workflow. It's a game-changer!",
    author: "Jane Doe",
    company: "Tech Innovators Inc.",
  },
  {
    quote: "The best project management tool we've ever used. Highly recommended!",
    author: "John Smith",
    company: "Creative Solutions LLC",
  },
  {
    quote: "StreamLine helped us increase productivity by 40%. It's incredible!",
    author: "Emily Johnson",
    company: "Startup Ventures",
  },
]

export default function Testimonials() {
  return (
    <section className="py-20 px-4 sm:px-6 lg:px-8 bg-gray-900">
      <h2 className="text-3xl font-bold text-center mb-12">What Our Customers Say</h2>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
        {testimonials.map((testimonial, index) => (
          <div key={index} className="bg-gray-800 p-6 rounded-lg shadow-lg">
            <p className="text-lg mb-4">"{testimonial.quote}"</p>
            <p className="font-semibold">{testimonial.author}</p>
            <p className="text-sm text-gray-400">{testimonial.company}</p>
          </div>
        ))}
      </div>
    </section>
  )
}




================================================
FILE: web/components/theme-provider.tsx
================================================
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}



================================================
FILE: web/components/ui/accordion.tsx
================================================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }



================================================
FILE: web/components/ui/alert-dialog.tsx
================================================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}



================================================
FILE: web/components/ui/alert.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }



================================================
FILE: web/components/ui/aspect-ratio.tsx
================================================
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }



================================================
FILE: web/components/ui/avatar.tsx
================================================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }



================================================
FILE: web/components/ui/badge.tsx
================================================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }



================================================
FILE: web/components/ui/breadcrumb.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}



================================================
FILE: web/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }



================================================
FILE: web/components/ui/calendar.tsx
================================================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }



================================================
FILE: web/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }



================================================
FILE: web/components/ui/carousel.tsx
================================================
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}



================================================
FILE: web/components/ui/chart.tsx
================================================
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}



================================================
FILE: web/components/ui/checkbox.tsx
================================================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }



================================================
FILE: web/components/ui/collapsible.tsx
================================================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }



================================================
FILE: web/components/ui/command.tsx
================================================
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}



================================================
FILE: web/components/ui/context-menu.tsx
================================================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}



================================================
FILE: web/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}



================================================
FILE: web/components/ui/doc-navigation.tsx
================================================
"use client"

import Link from "next/link"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { usePathname } from "next/navigation"
import { sidebarItems } from "@/components/DocSidebar"

interface DocNavigationProps {
  className?: string
}

export function DocNavigation({ className }: DocNavigationProps) {
  const pathname = usePathname()

  const flattenSidebarItems = () => {
    const flatItems: Array<{ title: string; href: string; section?: string }> = []

    sidebarItems.forEach((item) => {
      if (item.href) {
        flatItems.push({ title: item.title, href: item.href })
      }

      if (item.submenu) {
        item.submenu.forEach((subItem) => {
          flatItems.push({
            title: subItem.title,
            href: subItem.href,
            section: item.title, 
          })
        })
      }
    })

    return flatItems
  }

  const allPages = flattenSidebarItems()

  const currentPageIndex = allPages.findIndex((page) => page.href === pathname)

  const prevPage = currentPageIndex > 0 ? allPages[currentPageIndex - 1] : null
  const nextPage = currentPageIndex < allPages.length - 1 ? allPages[currentPageIndex + 1] : null

  if (!prevPage && !nextPage) return null

  return (
    <div className={`mt-16 ${className || ""}`}>

      <div className="w-full h-0.5 bg-gray-300 mb-8"></div>

      <div className="flex flex-col sm:flex-row justify-between gap-4">
        {prevPage ? (
          <Link
            href={prevPage.href}
            className="flex items-center p-4 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all duration-200 group w-full sm:w-[calc(50%-0.5rem)] sm:max-w-[calc(50%-0.5rem)]"
          >
            <ChevronLeft className="h-5 w-5 mr-2 text-gray-500 group-hover:text-blue-500 flex-shrink-0" />
            <div className="min-w-0 overflow-hidden">
              <div className="text-sm text-gray-500 group-hover:text-blue-600 truncate">
                {prevPage.section ? `${prevPage.section}: ` : ""}Previous
              </div>
              <div className="font-medium group-hover:text-blue-700 truncate">{prevPage.title}</div>
            </div>
          </Link>
        ) : (
          <div className="hidden sm:block sm:w-[calc(50%-0.5rem)]"></div> 
        )}

        {nextPage ? (
          <Link
            href={nextPage.href}
            className="flex items-center justify-end p-4 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all duration-200 group sm:text-right w-full sm:w-[calc(50%-0.5rem)] sm:max-w-[calc(50%-0.5rem)] ml-auto"
          >
            <div className="min-w-0 overflow-hidden">
              <div className="text-sm text-gray-500 group-hover:text-blue-600 truncate">
                {nextPage.section ? `${nextPage.section}: ` : ""}Next
              </div>
              <div className="font-medium group-hover:text-blue-700 truncate">{nextPage.title}</div>
            </div>
            <ChevronRight className="h-5 w-5 ml-2 text-gray-500 group-hover:text-blue-500 flex-shrink-0" />
          </Link>
        ) : (
          <div className="hidden sm:block sm:w-[calc(50%-0.5rem)]"></div> 
        )}
      </div>
    </div>
  )
}



================================================
FILE: web/components/ui/drawer.tsx
================================================
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}



================================================
FILE: web/components/ui/dropdown-menu.tsx
================================================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}



================================================
FILE: web/components/ui/form.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}



================================================
FILE: web/components/ui/hover-card.tsx
================================================
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }



================================================
FILE: web/components/ui/image-with-caption.tsx
================================================
"use client"

import Image from "next/image"

interface ImageWithCaptionProps {
  src: string
  alt: string
  caption: string
  width?: number
  height?: number
}

export function ImageWithCaption({ src, alt, caption, width = 800, height = 450 }: ImageWithCaptionProps) {
  return (
    <figure className="my-4">
      <Image
        src={src || "/placeholder.svg"}
        alt={alt}
        width={width}
        height={height}
        className="rounded-lg shadow-md w-full"
      />
      <figcaption className="text-center text-sm text-gray-600 mt-2">{caption}</figcaption>
    </figure>
  )
}


================================================
FILE: web/components/ui/input-otp.tsx
================================================
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }



================================================
FILE: web/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }



================================================
FILE: web/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }



================================================
FILE: web/components/ui/menubar.tsx
================================================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}



================================================
FILE: web/components/ui/navigation-menu.tsx
================================================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}



================================================
FILE: web/components/ui/pagination.tsx
================================================
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}



================================================
FILE: web/components/ui/popover.tsx
================================================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }



================================================
FILE: web/components/ui/progress.tsx
================================================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }



================================================
FILE: web/components/ui/radio-group.tsx
================================================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }



================================================
FILE: web/components/ui/resizable.tsx
================================================
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }



================================================
FILE: web/components/ui/scroll-area.tsx
================================================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }



================================================
FILE: web/components/ui/select.tsx
================================================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}



================================================
FILE: web/components/ui/separator.tsx
================================================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }



================================================
FILE: web/components/ui/sheet.tsx
================================================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}



================================================
FILE: web/components/ui/sidebar.tsx
================================================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}



================================================
FILE: web/components/ui/skeleton.tsx
================================================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }



================================================
FILE: web/components/ui/slider.tsx
================================================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }



================================================
FILE: web/components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }



================================================
FILE: web/components/ui/steps.tsx
================================================
import React from "react"

interface StepProps {
  title: string
  children: React.ReactNode
}

const Step: React.FC<StepProps> = ({ title, children }) => (
  <div className="mb-8">
    <h3 className="text-xl font-semibold mb-2 text-gray-900">{title}</h3>
    {children}
  </div>
)

interface StepsProps {
  children: React.ReactNode
}

const Steps: React.FC<StepsProps> & { Step: typeof Step } = ({ children }) => (
  <div className="space-y-4">
    {React.Children.map(children, (child, index) => (
      <div className="flex items-start">
        <div className="flex-shrink-0 w-8 h-8 bg-blue-500 text-white rounded-full flex items-center justify-center mr-4 mt-1">
          {index + 1}
        </div>
        <div className="flex-grow">{child}</div>
      </div>
    ))}
  </div>
)

Steps.Step = Step

export { Steps }




================================================
FILE: web/components/ui/switch.tsx
================================================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }



================================================
FILE: web/components/ui/table.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}



================================================
FILE: web/components/ui/tabs.tsx
================================================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }



================================================
FILE: web/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }



================================================
FILE: web/components/ui/toast.tsx
================================================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}



================================================
FILE: web/components/ui/toaster.tsx
================================================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}



================================================
FILE: web/components/ui/toggle-group.tsx
================================================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }



================================================
FILE: web/components/ui/toggle.tsx
================================================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }



================================================
FILE: web/components/ui/tooltip.tsx
================================================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }



================================================
FILE: web/components/ui/use-mobile.tsx
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: web/components/ui/use-toast.ts
================================================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



================================================
FILE: web/hooks/use-mobile.tsx
================================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}



================================================
FILE: web/hooks/use-toast.ts
================================================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }



================================================
FILE: web/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}



================================================
FILE: web/styles/globals.css
================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}



================================================
FILE: .github/ISSUE_TEMPLATE/bug_report.md
================================================
---
name: Bug Report
about: Report a problem in the project
title: "[BUG] Describe the issue"
labels: bug
assignees: 'MacRimi'
---

## Description
Describe the bug clearly and concisely.

## Steps to Reproduce
1. ...
2. ...
3. ...

## Expected Behavior
What should happen?

## Screenshots (Required)
Add images to help illustrate the issue.

## Environment
- Operating system:
- Software version:
- Other relevant details:

## Additional Information
Add any other context about the problem here.



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
blank_issues_enabled: false
contact_links:
  - name: Soporte General
    url: https://github.com/MacRimi/ProxMenux/discussions
    about: If your request is neither a bug nor a feature, please use Discussions.



================================================
FILE: .github/ISSUE_TEMPLATE/feature_request.md
================================================
---
name: Feature Request
about: Suggest a new feature or improvement
title: "[FEATURE] Describe your proposal"
labels: enhancement
assignees: 'MacRimi'
---

## Description
Explain the feature you are proposing.

## Motivation
Why is this improvement important? What problem does it solve?

## Alternatives Considered
Are there other solutions you have thought about?

## Additional Information
Add any extra details that help understand your proposal.



================================================
FILE: .github/scripts/generate_helpers_cache.py
================================================
#!/usr/bin/env python3
import json
import re
import sys
from pathlib import Path

import requests

# ---------- Config ----------
API_URL = "https://api.github.com/repos/community-scripts/ProxmoxVE/contents/frontend/public/json"
SCRIPT_BASE = "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main"

# Escribimos siempre en <raiz_repo>/json/helpers_cache.json, independientemente del cwd
REPO_ROOT = Path(__file__).resolve().parents[2]
OUTPUT_FILE = REPO_ROOT / "json" / "helpers_cache.json"
OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
# ----------------------------


def to_mirror_url(raw_url: str) -> str:
    """
    Convierte una URL raw de GitHub al raw del mirror.
    GH : https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main/ct/docker.sh
    MIR: https://git.community-scripts.org/community-scripts/ProxmoxVE/raw/branch/main/ct/docker.sh
    """
    m = re.match(r"^https://raw\.githubusercontent\.com/([^/]+)/([^/]+)/([^/]+)/(.+)$", raw_url or "")
    if not m:
        return ""
    org, repo, branch, path = m.groups()
    if org.lower() != "community-scripts" or repo != "ProxmoxVE":
        return ""
    return f"https://git.community-scripts.org/community-scripts/ProxmoxVE/raw/branch/{branch}/{path}"


def guess_os_from_script_path(script_path: str) -> str | None:
    """
    HeurÃ­stica suave cuando el JSON no publica resources.os:
      - tools/pve/*   -> proxmox
      - ct/alpine-*   -> alpine
      - tools/addon/* -> generic (suele ejecutarse sobre LXC existente)
      - ct/*          -> debian (por defecto para CTs)
    """
    if not script_path:
        return None
    if script_path.startswith("tools/pve/") or script_path == "tools/pve/host-backup.sh" or script_path.startswith("vm/"):
        return "proxmox"
    if "/alpine-" in script_path or script_path.startswith("ct/alpine-"):
        return "alpine"
    if script_path.startswith("tools/addon/"):
        return "generic"
    if script_path.startswith("ct/"):
        return "debian"
    return None


def fetch_directory_json(api_url: str) -> list[dict]:
    r = requests.get(api_url, timeout=30)
    r.raise_for_status()
    data = r.json()
    if not isinstance(data, list):
        raise RuntimeError("GitHub API no devolviÃ³ una lista.")
    return data


def main() -> int:
    try:
        directory = fetch_directory_json(API_URL)
    except Exception as e:
        print(f"ERROR: No se pudo leer el Ã­ndice de JSONs: {e}", file=sys.stderr)
        return 1

    cache: list[dict] = []
    seen: set[tuple[str, str]] = set()  # (slug, script) para evitar duplicados

    total_items = len(directory)
    processed = 0
    kept = 0

    for item in directory:
        url = item.get("download_url")
        name_in_dir = item.get("name", "")
        if not url or not url.endswith(".json"):
            continue

        try:
            raw = requests.get(url, timeout=30).json()
            if not isinstance(raw, dict):
                continue
        except Exception:
            print(f"âŒ Error al obtener/parsing {name_in_dir}", file=sys.stderr)
            continue

        processed += 1

        name = raw.get("name", "")
        slug = raw.get("slug")
        type_ = raw.get("type", "")
        desc = raw.get("description", "")
        categories = raw.get("categories", [])
        notes = [n.get("text", "") for n in raw.get("notes", []) if isinstance(n, dict)]

        # Credenciales (si existen, se copian tal cual)
        credentials = raw.get("default_credentials", {})
        cred_username = credentials.get("username") if isinstance(credentials, dict) else None
        cred_password = credentials.get("password") if isinstance(credentials, dict) else None
        add_credentials = any([
            cred_username not in (None, ""),
            cred_password not in (None, "")
        ])

        install_methods = raw.get("install_methods", [])
        if not isinstance(install_methods, list) or not install_methods:
            # Sin install_methods vÃ¡lidos -> continuamos
            continue

        for im in install_methods:
            if not isinstance(im, dict):
                continue
            script = im.get("script", "")
            if not script:
                continue

            # OS desde resources u heurÃ­stica
            resources = im.get("resources", {}) if isinstance(im, dict) else {}
            os_name = resources.get("os") if isinstance(resources, dict) else None
            if not os_name:
                os_name = guess_os_from_script_path(script)
            if isinstance(os_name, str):
                os_name = os_name.strip().lower()

            full_script_url = f"{SCRIPT_BASE}/{script}"
            script_url_mirror = to_mirror_url(full_script_url)

            key = (slug or "", script)
            if key in seen:
                continue
            seen.add(key)

            entry = {
                "name": name,
                "slug": slug,
                "desc": desc,
                "script": script,
                "script_url": full_script_url,
                "script_url_mirror": script_url_mirror,  # nuevo
                "os": os_name,                            # nuevo
                "categories": categories,
                "notes": notes,
                "type": type_,
            }
            if add_credentials:
                entry["default_credentials"] = {
                    "username": cred_username,
                    "password": cred_password,
                }

            cache.append(entry)
            kept += 1

            # Progreso ligero
            print(f"[{kept:03d}] {slug or name:<24} â†’ {script:<28} os={os_name or 'n/a'} src={'GH+MR' if script_url_mirror else 'GH'}")

    # Orden estable para commits reproducibles
    cache.sort(key=lambda x: (x.get("slug") or "", x.get("script") or ""))

    with OUTPUT_FILE.open("w", encoding="utf-8") as f:
        json.dump(cache, f, ensure_ascii=False, indent=2)

    print(f"\nâœ… helpers_cache.json â†’ {OUTPUT_FILE}")
    print(f"   Total JSON en Ã­ndice: {total_items}")
    print(f"   Procesados: {processed} | Guardados: {kept} | Ãšnicos (slug,script): {len(seen)}")

    return 0


if __name__ == "__main__":
    sys.exit(main())



================================================
FILE: .github/scripts/generate_helpers_cache_.py
================================================
import requests, json
from pathlib import Path

# GitHub API URL to fetch all .json files describing scripts
API_URL = "https://api.github.com/repos/community-scripts/ProxmoxVE/contents/frontend/public/json"

# Base path to build the full URL for the installable scripts
SCRIPT_BASE = "https://raw.githubusercontent.com/community-scripts/ProxmoxVE/main"

# Output file where the consolidated helper scripts cache will be stored
OUTPUT_FILE = Path("json/helpers_cache.json")
OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)

res = requests.get(API_URL)
data = res.json()
cache = []

# Loop over each file in the JSON directory
for item in data:
    url = item.get("download_url")
    if not url or not url.endswith(".json"):
        continue
    try:
        raw = requests.get(url).json()
        if not isinstance(raw, dict):
            continue
    except:
        continue

    # Extract fields required to identify a valid helper script
    name = raw.get("name", "")
    slug = raw.get("slug")
    type_ = raw.get("type", "")
    script = raw.get("install_methods", [{}])[0].get("script", "")
    if not slug or not script:
        continue  # Skip if it's not a valid script

    desc = raw.get("description", "")
    categories = raw.get("categories", [])
    notes = [note.get("text", "") for note in raw.get("notes", []) if isinstance(note, dict)]
    full_script_url = f"{SCRIPT_BASE}/{script}"


    credentials = raw.get("default_credentials", {})
    cred_username = credentials.get("username")
    cred_password = credentials.get("password")
 
    add_credentials = (
        (cred_username is not None and str(cred_username).strip() != "") or
        (cred_password is not None and str(cred_password).strip() != "")
    )

    entry = {
        "name": name,
        "slug": slug,
        "desc": desc,
        "script": script,
        "script_url": full_script_url,
        "categories": categories,
        "notes": notes,
        "type": type_
    }
    if add_credentials:
        entry["default_credentials"] = {
            "username": cred_username,
            "password": cred_password
        }

    cache.append(entry)


# Write the JSON cache to disk
with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
    json.dump(cache, f, indent=2)

print(f"âœ… helpers_cache.json created at {OUTPUT_FILE} with {len(cache)} valid scripts.")



================================================
FILE: .github/workflows/build-appimage-manual.yml
================================================
name: Build ProxMenux Monitor AppImage

on:

  workflow_dispatch:  
  
permissions:
  contents: write
  
jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Install dependencies
      working-directory: AppImage
      run: npm install --legacy-peer-deps
      
    - name: Build Next.js app
      working-directory: AppImage
      run: npm run build
      
    - name: Install Python dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip python3-venv
        
    - name: Make build script executable
      working-directory: AppImage
      run: chmod +x scripts/build_appimage.sh
      
    - name: Build AppImage
      working-directory: AppImage
      run: ./scripts/build_appimage.sh
      
    - name: Get version from package.json
      id: version
      working-directory: AppImage
      run: echo "VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
      
    - name: Upload AppImage artifact
      uses: actions/upload-artifact@v4
      with:
        name: ProxMenux-${{ steps.version.outputs.VERSION }}-AppImage
        path: AppImage/dist/*.AppImage
        retention-days: 30

    - name: Generate SHA256 checksum
      run: |
        cd AppImage/dist
        sha256sum *.AppImage > ProxMenux-Monitor.AppImage.sha256
        echo "Generated SHA256:"
        cat ProxMenux-Monitor.AppImage.sha256

    - name: Upload AppImage and checksum to /AppImage folder in main
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"

        git fetch origin main
        git checkout main

        rm -f AppImage/*.AppImage AppImage/*.sha256 || true

        # Copy new files
        cp AppImage/dist/*.AppImage AppImage/
        cp AppImage/dist/ProxMenux-Monitor.AppImage.sha256 AppImage/

        git add AppImage/*.AppImage AppImage/*.sha256
        git commit -m "Update AppImage build ($(date +'%Y-%m-%d %H:%M:%S'))" || echo "No changes to commit"
        git push origin main



================================================
FILE: .github/workflows/build-appimage.yml
================================================
name: Build ProxMenux Monitor AppImage

on:
  push:
    branches: [ main ]
    paths: [ 'AppImage/**' ]
  pull_request:
    branches: [ main ]
    paths: [ 'AppImage/**' ]
  workflow_dispatch:  

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Install dependencies
      working-directory: AppImage
      run: npm install --legacy-peer-deps
      
    - name: Build Next.js app
      working-directory: AppImage
      run: npm run build
      
    - name: Install Python dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip python3-venv
        
    - name: Make build script executable
      working-directory: AppImage
      run: chmod +x scripts/build_appimage.sh
      
    - name: Build AppImage
      working-directory: AppImage
      run: ./scripts/build_appimage.sh
      
    - name: Get version from package.json
      id: version
      working-directory: AppImage
      run: echo "VERSION=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
      
    - name: Upload AppImage artifact
      uses: actions/upload-artifact@v4
      with:
        name: ProxMenux-${{ steps.version.outputs.VERSION }}-AppImage
        path: AppImage/dist/*.AppImage
        retention-days: 30



================================================
FILE: .github/workflows/deploy.yml
================================================
name: Deploy to GitHub Pages

on:
  push:
    branches:
      - "main"
    paths:
      - "web/**"
      - "guides/**"
      - "CHANGELOG.md"
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: 'npm'
          cache-dependency-path: 'web/package.json'

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Install dependencies and generate lock file
        run: |
          cd web
          npm install

      - name: Build with Next.js
        run: |
          cd web
          npm run build

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: web/out

  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4



================================================
FILE: .github/workflows/update-helpers-cache.yml
================================================
name: Update Helper Scripts Cache

on:
  # Manual trigger from GitHub Actions UI
  workflow_dispatch:

  # Automatic run every 6 hours
  schedule:
    - cron: "0 */6 * * *"

jobs:
  update-cache:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to push changes to the repository

    steps:
      - name: â¬‡ï¸ Checkout the repository
        uses: actions/checkout@v3

      - name: ğŸ Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: ğŸ“¦ Install Python dependencies
        run: pip install requests

      - name: âš™ï¸ Generate json/helpers_cache.json
        run: python .github/scripts/generate_helpers_cache.py

      - name: ğŸ“¤ Commit and push if updated
        run: |
          git config user.name "ProxMenuxBot"
          git config user.email "bot@proxmenux.local"
          git add json/helpers_cache.json
          git diff --cached --quiet || git commit -m "Update helpers_cache.json"
          git push


